<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › dlm › lock.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lock.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">**</span>
<span class="cm">**  Copyright (C) 2005-2010 Red Hat, Inc.  All rights reserved.</span>
<span class="cm">**</span>
<span class="cm">**  This copyrighted material is made available to anyone wishing to use,</span>
<span class="cm">**  modify, copy, or redistribute it subject to the terms and conditions</span>
<span class="cm">**  of the GNU General Public License v.2.</span>
<span class="cm">**</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">******************************************************************************/</span>

<span class="cm">/* Central locking logic has four stages:</span>

<span class="cm">   dlm_lock()</span>
<span class="cm">   dlm_unlock()</span>

<span class="cm">   request_lock(ls, lkb)</span>
<span class="cm">   convert_lock(ls, lkb)</span>
<span class="cm">   unlock_lock(ls, lkb)</span>
<span class="cm">   cancel_lock(ls, lkb)</span>

<span class="cm">   _request_lock(r, lkb)</span>
<span class="cm">   _convert_lock(r, lkb)</span>
<span class="cm">   _unlock_lock(r, lkb)</span>
<span class="cm">   _cancel_lock(r, lkb)</span>

<span class="cm">   do_request(r, lkb)</span>
<span class="cm">   do_convert(r, lkb)</span>
<span class="cm">   do_unlock(r, lkb)</span>
<span class="cm">   do_cancel(r, lkb)</span>

<span class="cm">   Stage 1 (lock, unlock) is mainly about checking input args and</span>
<span class="cm">   splitting into one of the four main operations:</span>

<span class="cm">       dlm_lock          = request_lock</span>
<span class="cm">       dlm_lock+CONVERT  = convert_lock</span>
<span class="cm">       dlm_unlock        = unlock_lock</span>
<span class="cm">       dlm_unlock+CANCEL = cancel_lock</span>

<span class="cm">   Stage 2, xxxx_lock(), just finds and locks the relevant rsb which is</span>
<span class="cm">   provided to the next stage.</span>

<span class="cm">   Stage 3, _xxxx_lock(), determines if the operation is local or remote.</span>
<span class="cm">   When remote, it calls send_xxxx(), when local it calls do_xxxx().</span>

<span class="cm">   Stage 4, do_xxxx(), is the guts of the operation.  It manipulates the</span>
<span class="cm">   given rsb and lkb and queues callbacks.</span>

<span class="cm">   For remote operations, send_xxxx() results in the corresponding do_xxxx()</span>
<span class="cm">   function being executed on the remote node.  The connecting send/receive</span>
<span class="cm">   calls on local (L) and remote (R) nodes:</span>

<span class="cm">   L: send_xxxx()              -&gt;  R: receive_xxxx()</span>
<span class="cm">                                   R: do_xxxx()</span>
<span class="cm">   L: receive_xxxx_reply()     &lt;-  R: send_xxxx_reply()</span>
<span class="cm">*/</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;dlm_internal.h&quot;</span>
<span class="cp">#include &lt;linux/dlm_device.h&gt;</span>
<span class="cp">#include &quot;memory.h&quot;</span>
<span class="cp">#include &quot;lowcomms.h&quot;</span>
<span class="cp">#include &quot;requestqueue.h&quot;</span>
<span class="cp">#include &quot;util.h&quot;</span>
<span class="cp">#include &quot;dir.h&quot;</span>
<span class="cp">#include &quot;member.h&quot;</span>
<span class="cp">#include &quot;lockspace.h&quot;</span>
<span class="cp">#include &quot;ast.h&quot;</span>
<span class="cp">#include &quot;lock.h&quot;</span>
<span class="cp">#include &quot;rcom.h&quot;</span>
<span class="cp">#include &quot;recover.h&quot;</span>
<span class="cp">#include &quot;lvb_table.h&quot;</span>
<span class="cp">#include &quot;user.h&quot;</span>
<span class="cp">#include &quot;config.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">send_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">send_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">send_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">send_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">send_grant</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">send_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">send_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">send_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">_request_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">_cancel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__receive_convert_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">receive_extralen</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">do_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">del_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Lock compatibilty matrix - thanks Steve</span>
<span class="cm"> * UN = Unlocked state. Not really a state, used as a flag</span>
<span class="cm"> * PD = Padding. Used to make the matrix a nice power of two in size</span>
<span class="cm"> * Other states are the same as the VMS DLM.</span>
<span class="cm"> * Usage: matrix[grmode+1][rqmode+1]  (although m[rq+1][gr+1] is the same)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">__dlm_compat_matrix</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="cm">/* UN NL CR CW PR PW EX PD */</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* UN */</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* NL */</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* CR */</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* CW */</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* PR */</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* PW */</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* EX */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>        <span class="cm">/* PD */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This defines the direction of transfer of LVB data.</span>
<span class="cm"> * Granted mode is the row; requested mode is the column.</span>
<span class="cm"> * Usage: matrix[grmode+1][rqmode+1]</span>
<span class="cm"> * 1 = LVB is returned to the caller</span>
<span class="cm"> * 0 = LVB is written to the resource</span>
<span class="cm"> * -1 = nothing happens to the LVB</span>
<span class="cm"> */</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">dlm_lvb_operations</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="cm">/* UN   NL  CR  CW  PR  PW  EX  PD*/</span>
        <span class="p">{</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span> <span class="cm">/* UN */</span>
        <span class="p">{</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span> <span class="cm">/* NL */</span>
        <span class="p">{</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span> <span class="cm">/* CR */</span>
        <span class="p">{</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span> <span class="cm">/* CW */</span>
        <span class="p">{</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span> <span class="cm">/* PR */</span>
        <span class="p">{</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span> <span class="cm">/* PW */</span>
        <span class="p">{</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">},</span> <span class="cm">/* EX */</span>
        <span class="p">{</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">}</span>  <span class="cm">/* PD */</span>
<span class="p">};</span>

<span class="cp">#define modes_compat(gr, rq) \</span>
<span class="cp">	__dlm_compat_matrix[(gr)-&gt;lkb_grmode + 1][(rq)-&gt;lkb_rqmode + 1]</span>

<span class="kt">int</span> <span class="nf">dlm_modes_compat</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__dlm_compat_matrix</span><span class="p">[</span><span class="n">mode1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">mode2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compatibility matrix for conversions with QUECVT set.</span>
<span class="cm"> * Granted mode is the row; requested mode is the column.</span>
<span class="cm"> * Usage: matrix[grmode+1][rqmode+1]</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">__quecvt_compat_matrix</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="cm">/* UN NL CR CW PR PW EX PD */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* UN */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* NL */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* CR */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* CW */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* PR */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* PW */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>       <span class="cm">/* EX */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>        <span class="cm">/* PD */</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">dlm_print_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;lkb: nodeid %d id %x remid %x exflags %x flags %x &quot;</span>
	       <span class="s">&quot;sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span><span class="p">,</span>
	       <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">,</span>
	       <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_nodeid</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_recover_seq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_print_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rsb: nodeid %d flags %lx first %x rlc %d name %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_flags</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span><span class="p">,</span>
	       <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_recover_locks_count</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_dump_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>

	<span class="n">dlm_print_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rsb: root_list empty %d recover_list empty %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_root_list</span><span class="p">),</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_recover_list</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rsb lookup list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lookup</span><span class="p">,</span> <span class="n">lkb_rsb_lookup</span><span class="p">)</span>
		<span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rsb grant queue:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span>
		<span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rsb convert queue:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span>
		<span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;rsb wait queue:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span>
		<span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Threads cannot use the lockspace while it&#39;s being recovered */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_lock_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_in_recovery</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_unlock_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_in_recovery</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_lock_recovery_try</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_in_recovery</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">can_be_queued</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_NOQUEUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">force_blocking_asts</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_NOQUEUEBAST</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_demoted</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">&amp;</span> <span class="n">DLM_SBF_DEMOTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_altmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">&amp;</span> <span class="n">DLM_SBF_ALTMODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_granted</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span> <span class="o">==</span> <span class="n">DLM_LKSTS_GRANTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dlm_print_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
	<span class="k">return</span> <span class="o">!!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_process_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_MSTCPY</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_master_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_MSTCPY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">middle_conversion</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="o">==</span><span class="n">DLM_LOCK_PR</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="o">==</span><span class="n">DLM_LOCK_CW</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="o">==</span><span class="n">DLM_LOCK_PR</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="o">==</span><span class="n">DLM_LOCK_CW</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">down_conversion</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">middle_conversion</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">&lt;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_overlap_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_overlap_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DLM_IFL_OVERLAP_UNLOCK</span> <span class="o">|</span>
				  <span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_cast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_master_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">del_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lksb</span><span class="p">,</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">););</span>

	<span class="cm">/* if the operation was a cancel, then return -DLM_ECANCEL, if a</span>
<span class="cm">	   timeout caused the cancel then return -ETIMEDOUT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_TIMEOUT_CANCEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_TIMEOUT_CANCEL</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_DEADLOCK_CANCEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_DEADLOCK_CANCEL</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dlm_add_cb</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_CB_CAST</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="p">,</span> <span class="n">rv</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_cast_overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span>
		   <span class="n">is_overlap_unlock</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span> <span class="o">:</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rqmode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_master_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">send_bast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">rqmode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dlm_add_cb</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_CB_BAST</span><span class="p">,</span> <span class="n">rqmode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Basic operations on rsb&#39;s and lkb&#39;s</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pre_rsb_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r1</span><span class="p">,</span> <span class="o">*</span><span class="n">r2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_spin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_count</span> <span class="o">&gt;</span> <span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_new_rsb_count</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_spin</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_spin</span><span class="p">);</span>

	<span class="n">r1</span> <span class="o">=</span> <span class="n">dlm_allocate_rsb</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="n">r2</span> <span class="o">=</span> <span class="n">dlm_allocate_rsb</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_spin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="o">-&gt;</span><span class="n">res_hashchain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb</span><span class="p">);</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r2</span><span class="o">-&gt;</span><span class="n">res_hashchain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb</span><span class="p">);</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_count</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_spin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If ls-&gt;ls_new_rsb is empty, return -EAGAIN, so the caller can</span>
<span class="cm">   unlock any spinlocks, go back and call pre_rsb_struct again.</span>
<span class="cm">   Otherwise, take an rsb off the list and return it. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_rsb_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">**</span><span class="n">r_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_spin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_count</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_spin</span><span class="p">);</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;find_rsb retry %d %d %s&quot;</span><span class="p">,</span>
			  <span class="n">count</span><span class="p">,</span> <span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_new_rsb_count</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">,</span> <span class="n">res_hashchain</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hashchain</span><span class="p">);</span>
	<span class="cm">/* Convert the empty list_head to a NULL rb_node for tree usage: */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hashnode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_node</span><span class="p">));</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_new_rsb_spin</span><span class="p">);</span>

	<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span> <span class="o">=</span> <span class="n">ls</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_mutex</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lookup</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_root_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_recover_list</span><span class="p">);</span>

	<span class="o">*</span><span class="n">r_ret</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rsb_cmp</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">maxname</span><span class="p">[</span><span class="n">DLM_RESNAME_MAXLEN</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">maxname</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DLM_RESNAME_MAXLEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">maxname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">nlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">,</span> <span class="n">maxname</span><span class="p">,</span> <span class="n">DLM_RESNAME_MAXLEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_search_rsb_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">**</span><span class="n">r_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">,</span> <span class="n">res_hashnode</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">rsb_cmp</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">r_ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>

 <span class="nl">found:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">R_MASTER</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTBLK</span><span class="p">;</span>
	<span class="o">*</span><span class="n">r_ret</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rsb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">rsb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">newn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">newn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">newn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">,</span>
					       <span class="n">res_hashnode</span><span class="p">);</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">newn</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">rsb_cmp</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">rsb</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">,</span> <span class="n">rsb</span><span class="o">-&gt;</span><span class="n">res_length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">newn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">newn</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;rsb_insert match&quot;</span><span class="p">);</span>
			<span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">rsb</span><span class="p">);</span>
			<span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsb</span><span class="o">-&gt;</span><span class="n">res_hashnode</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">newn</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsb</span><span class="o">-&gt;</span><span class="n">res_hashnode</span><span class="p">,</span> <span class="n">tree</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_search_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">**</span><span class="n">r_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_search_rsb_tree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">keep</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTBLK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_search_rsb_tree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">toss</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hashnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">toss</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">rsb_insert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">keep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_no_directory</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsb_clear_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_MASTER_UNCERTAIN</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsb_set_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_MASTER_UNCERTAIN</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dlm_print_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
		<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">rsb_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_MASTER_UNCERTAIN</span><span class="p">),);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="o">*</span><span class="n">r_ret</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find rsb in rsbtbl and potentially create/add one</span>
<span class="cm"> *</span>
<span class="cm"> * Delaying the release of rsb&#39;s has a similar benefit to applications keeping</span>
<span class="cm"> * NL locks on an rsb, but without the guarantee that the cached master value</span>
<span class="cm"> * will still be valid when the rsb is reused.  Apps aren&#39;t always smart enough</span>
<span class="cm"> * to keep NL locks on an rsb that they may lock again shortly; this can lead</span>
<span class="cm"> * to excessive master lookups and removals if we don&#39;t delay the release.</span>
<span class="cm"> *</span>
<span class="cm"> * Searching for an rsb means looking through both the normal list and toss</span>
<span class="cm"> * list.  When found on the toss list the rsb is moved to the normal list with</span>
<span class="cm"> * ref count of 1; when found on normal list the ref count is incremented.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">**</span><span class="n">r_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">,</span> <span class="n">bucket</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">DLM_RESNAME_MAXLEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_no_directory</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">R_CREATE</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">jhash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bucket</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

 <span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">R_CREATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">pre_rsb_struct</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_search_rsb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBADR</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">R_CREATE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* the rsb was found but wasn&#39;t a master copy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTBLK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">get_rsb_struct</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_bucket</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ref</span><span class="p">);</span>

	<span class="cm">/* With no directory, the master can be set immediately */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_no_directory</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nodeid</span> <span class="o">=</span> <span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">dlm_our_nodeid</span><span class="p">())</span>
			<span class="n">nodeid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">=</span> <span class="n">nodeid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">rsb_insert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">keep</span><span class="p">);</span>
 <span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="o">*</span><span class="n">r_ret</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_dump_rsb_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">keep</span><span class="p">);</span> <span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">,</span> <span class="n">res_hashnode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hash</span> <span class="o">==</span> <span class="n">hash</span><span class="p">)</span>
				<span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This is only called to add a reference when the code already holds</span>
<span class="cm">   a valid reference to the rsb, so there&#39;s no need for locking. */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hold_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_hold_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">toss_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">,</span> <span class="n">res_ref</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_root_list</span><span class="p">),</span> <span class="n">dlm_print_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ref</span><span class="p">);</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hashnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_bucket</span><span class="p">].</span><span class="n">keep</span><span class="p">);</span>
	<span class="n">rsb_insert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_bucket</span><span class="p">].</span><span class="n">toss</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_toss_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dlm_free_lvb</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* When all references to the rsb are gone it&#39;s transferred to</span>
<span class="cm">   the tossed list for later disposal. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bucket</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_bucket</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ref</span><span class="p">,</span> <span class="n">toss_rsb</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_put_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* See comment for unhold_lkb */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unhold_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ref</span><span class="p">,</span> <span class="n">toss_rsb</span><span class="p">);</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">,</span> <span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kill_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">,</span> <span class="n">res_ref</span><span class="p">);</span>

	<span class="cm">/* All work is done after the return from kref_put() so we</span>
<span class="cm">	   can release the write_lock before the remove and free. */</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lookup</span><span class="p">),</span> <span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">),</span> <span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">),</span> <span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">),</span> <span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_root_list</span><span class="p">),</span> <span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_recover_list</span><span class="p">),</span> <span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>
<span class="p">}</span>

<span class="cm">/* Attaching/detaching lkb&#39;s from rsb&#39;s is for rsb reference counting.</span>
<span class="cm">   The rsb must exist as long as any lkb&#39;s for it do. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_rsb</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">**</span><span class="n">lkb_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">lkb</span> <span class="o">=</span> <span class="n">dlm_allocate_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ref</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rsb_lookup</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_time_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_cb_list</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_cb_mutex</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_cb_work</span><span class="p">,</span> <span class="n">dlm_callback_work</span><span class="p">);</span>

 <span class="nl">retry:</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr_spin</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr_spin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;create_lkb idr error %d&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">lkb_ret</span> <span class="o">=</span> <span class="n">lkb</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">lkid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">**</span><span class="n">lkb_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr_spin</span><span class="p">);</span>
	<span class="n">lkb</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr</span><span class="p">,</span> <span class="n">lkid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ref</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr_spin</span><span class="p">);</span>

	<span class="o">*</span><span class="n">lkb_ret</span> <span class="o">=</span> <span class="n">lkb</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lkb</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kill_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span><span class="p">,</span> <span class="n">lkb_ref</span><span class="p">);</span>

	<span class="cm">/* All work is done after the return from kref_put() so we</span>
<span class="cm">	   can release the write_lock before the detach_lkb */</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span><span class="p">,</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">););</span>
<span class="p">}</span>

<span class="cm">/* __put_lkb() is used when an lkb may not have an rsb attached to</span>
<span class="cm">   it so we need to provide the lockspace explicitly */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__put_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">lkid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr_spin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ref</span><span class="p">,</span> <span class="n">kill_lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr</span><span class="p">,</span> <span class="n">lkid</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr_spin</span><span class="p">);</span>

		<span class="n">detach_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>

		<span class="cm">/* for local/process lkbs, lvbptr points to caller&#39;s lksb */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span> <span class="o">&amp;&amp;</span> <span class="n">is_master_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="n">dlm_free_lvb</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">);</span>
		<span class="n">dlm_free_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lkbidr_spin</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_put_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">;</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">,</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">););</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">,</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">););</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__put_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is only called to add a reference when the code already holds</span>
<span class="cm">   a valid reference to the lkb, so there&#39;s no need for locking. */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hold_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is called when we need to remove a reference and are certain</span>
<span class="cm">   it&#39;s not the last ref.  e.g. del_lkb is always called between a</span>
<span class="cm">   find_lkb/put_lkb and is always the inverse of a previous add_lkb.</span>
<span class="cm">   put_lkb would work fine, but would involve unnecessary locking */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unhold_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ref</span><span class="p">,</span> <span class="n">kill_lkb</span><span class="p">);</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">,</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">););</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lkb_add_ordered</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">&lt;</span> <span class="n">mode</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="n">__list_add</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_statequeue</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_statequeue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* add/remove lkb to rsb&#39;s grant/convert/wait queue */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ref</span><span class="p">);</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span><span class="p">,</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">););</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_timestamp</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLM_LKSTS_WAITING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_HEADQUE</span><span class="p">)</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_statequeue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_statequeue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_LKSTS_GRANTED</span>:
		<span class="cm">/* convention says granted locks kept in order of grmode */</span>
		<span class="n">lkb_add_ordered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_statequeue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">,</span>
				<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_LKSTS_CONVERT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_HEADQUE</span><span class="p">)</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_statequeue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_statequeue</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sts=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">););</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">del_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_statequeue</span><span class="p">);</span>
	<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="n">del_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">add_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">sts</span><span class="p">);</span>
	<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msg_reply_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">mstype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mstype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
		<span class="k">return</span> <span class="n">DLM_MSG_REQUEST_REPLY</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT</span>:
		<span class="k">return</span> <span class="n">DLM_MSG_CONVERT_REPLY</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
		<span class="k">return</span> <span class="n">DLM_MSG_UNLOCK_REPLY</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_MSG_CANCEL</span>:
		<span class="k">return</span> <span class="n">DLM_MSG_CANCEL_REPLY</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP</span>:
		<span class="k">return</span> <span class="n">DLM_MSG_LOOKUP_REPLY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nodeid_warned</span><span class="p">(</span><span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">warned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warned</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">warned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeid</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">warned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nodeid</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_scan_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">s64</span> <span class="n">us</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">debug_maxus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">debug_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">debug_expired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">warned</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_waitwarn_us</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters</span><span class="p">,</span> <span class="n">lkb_wait_reply</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ktime_equal</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_time</span><span class="p">,</span> <span class="n">zero</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">debug_scanned</span><span class="o">++</span><span class="p">;</span>

		<span class="n">us</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_time</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">us</span> <span class="o">&lt;</span> <span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_waitwarn_us</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_time</span> <span class="o">=</span> <span class="n">zero</span><span class="p">;</span>

		<span class="n">debug_expired</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">us</span> <span class="o">&gt;</span> <span class="n">debug_maxus</span><span class="p">)</span>
			<span class="n">debug_maxus</span> <span class="o">=</span> <span class="n">us</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_nodes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_nodes</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_num_nodes</span><span class="p">;</span>
			<span class="n">warned</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">num_nodes</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warned</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodeid_warned</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_nodeid</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="n">warned</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;waitwarn %x %lld %d us check connection to &quot;</span>
			  <span class="s">&quot;node %d&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">us</span><span class="p">,</span>
			  <span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_waitwarn_us</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_nodeid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">warned</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_expired</span><span class="p">)</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;scan_waiters %u warn %u over %d us max %lld us&quot;</span><span class="p">,</span>
			  <span class="n">debug_scanned</span><span class="p">,</span> <span class="n">debug_expired</span><span class="p">,</span>
			  <span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_waitwarn_us</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">debug_maxus</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* add/remove lkb from global waiters list of lkb&#39;s waiting for</span>
<span class="cm">   a reply from a remote node */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_to_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mstype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap_unlock</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">is_overlap_cancel</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mstype</span> <span class="o">==</span> <span class="n">DLM_MSG_CANCEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">||</span> <span class="n">is_overlap_cancel</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">mstype</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLM_MSG_CANCEL</span>:
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>

		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;addwait %x cur %d overlap %d count %d f %x&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="p">,</span>
		   <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		   <span class="n">printk</span><span class="p">(</span><span class="s">&quot;wait_count %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="p">););</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">=</span> <span class="n">mstype</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_time</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_nodeid</span> <span class="o">=</span> <span class="n">to_nodeid</span><span class="p">;</span> <span class="cm">/* for debugging */</span>
	<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_reply</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;addwait error %x %d flags %x %d %d %s&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We clear the RESEND flag because we might be taking an lkb off the waiters</span>
<span class="cm">   list as part of process_requestqueue (e.g. a lookup that has an optimized</span>
<span class="cm">   request reply on the requestqueue) between dlm_recover_waiters_pre() which</span>
<span class="cm">   set RESEND and dlm_recover_waiters_post() */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_remove_from_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mstype</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">overlap_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap_unlock</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mstype</span> <span class="o">==</span> <span class="n">DLM_MSG_UNLOCK_REPLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remwait %x unlock_reply overlap&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
		<span class="n">overlap_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_del</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap_cancel</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mstype</span> <span class="o">==</span> <span class="n">DLM_MSG_CANCEL_REPLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remwait %x cancel_reply overlap&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
		<span class="n">overlap_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_del</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Cancel state was preemptively cleared by a successful convert,</span>
<span class="cm">	   see next comment, nothing to do. */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mstype</span> <span class="o">==</span> <span class="n">DLM_MSG_CANCEL_REPLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">!=</span> <span class="n">DLM_MSG_CANCEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remwait %x cancel_reply wait_type %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove for the convert reply, and premptively remove for the</span>
<span class="cm">	   cancel reply.  A convert has been granted while there&#39;s still</span>
<span class="cm">	   an outstanding cancel on it (the cancel is moot and the result</span>
<span class="cm">	   in the cancel reply should be 0).  We preempt the cancel reply</span>
<span class="cm">	   because the app gets the convert result and then can follow up</span>
<span class="cm">	   with another op, like convert.  This subsequent op would see the</span>
<span class="cm">	   lingering state of the cancel and fail with -EBUSY. */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mstype</span> <span class="o">==</span> <span class="n">DLM_MSG_CONVERT_REPLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">==</span> <span class="n">DLM_MSG_CONVERT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">is_overlap_cancel</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ms</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remwait %x convert_reply zap overlap_cancel&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_del</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* N.B. type of reply may not always correspond to type of original</span>
<span class="cm">	   msg due to lookup-&gt;request optimization, verify others? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_del</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remwait error %x remote %d %x msg %d flags %x no wait&quot;</span><span class="p">,</span>
		  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">ms</span> <span class="o">?</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span><span class="p">,</span>
		  <span class="n">mstype</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

 <span class="nl">out_del:</span>
	<span class="cm">/* the force-unlock/cancel has completed and we haven&#39;t recvd a reply</span>
<span class="cm">	   to the op that was in progress prior to the unlock/cancel; we</span>
<span class="cm">	   give up on any reply to the earlier op.  FIXME: not sure when/how</span>
<span class="cm">	   this would happen */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">overlap_done</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remwait error %x reply %d wait_type %d overlap&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="p">,</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">););</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_RESEND</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="p">)</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_reply</span><span class="p">);</span>
	<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_from_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mstype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">_remove_from_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handles situations where we might be processing a &quot;fake&quot; or &quot;stub&quot; reply in</span>
<span class="cm">   which we can&#39;t try to take waiters_mutex again. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_from_waiters_ms</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">!=</span> <span class="n">DLM_IFL_STUB_MS</span><span class="p">)</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">_remove_from_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">!=</span> <span class="n">DLM_IFL_STUB_MS</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dir_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_no_directory</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">to_nodeid</span> <span class="o">=</span> <span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_nodeid</span> <span class="o">!=</span> <span class="n">dlm_our_nodeid</span><span class="p">())</span>
		<span class="n">send_remove</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dlm_dir_remove_entry</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">,</span>
				     <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* FIXME: make this more efficient */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">shrink_bucket</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">found</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">toss</span><span class="p">);</span> <span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">,</span> <span class="n">res_hashnode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_toss_time</span> <span class="o">+</span>
					   <span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_toss_secs</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ref</span><span class="p">,</span> <span class="n">kill_rsb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hashnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">toss</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">is_master</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
				<span class="n">dir_remove</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="n">dlm_free_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;tossed rsb in use %s&quot;</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_scan_rsbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shrink_bucket</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_locking_stopped</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_master_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">LSFL_TIMEWARN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_NODLCKWT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_WATCH_TIMEWARN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">add_it</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_TIMEOUT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">add_it</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">add_it:</span>
	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_time_list</span><span class="p">),</span> <span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">););</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout_mutex</span><span class="p">);</span>
	<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_time_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">del_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_time_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_time_list</span><span class="p">);</span>
		<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* FIXME: is it safe to look at lkb_exflags, lkb_flags, lkb_timestamp, and</span>
<span class="cm">   lkb_lksb_timeout without lock_rsb?  Note: we can&#39;t lock timeout_mutex</span>
<span class="cm">   and then lock rsb because of lock ordering in add_timeout.  We may need</span>
<span class="cm">   to specify some special timeout-related bits in the lkb that are just to</span>
<span class="cm">   be accessed under the timeout_mutex. */</span>

<span class="kt">void</span> <span class="nf">dlm_scan_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_cancel</span><span class="p">,</span> <span class="n">do_warn</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">wait_us</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_locking_stopped</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">do_cancel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">do_warn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout_mutex</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout</span><span class="p">,</span> <span class="n">lkb_time_list</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">wait_us</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span>
					      		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_timestamp</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_TIMEOUT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">wait_us</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_timeout_cs</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">))</span>
				<span class="n">do_cancel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_WATCH_TIMEWARN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">wait_us</span> <span class="o">&gt;=</span> <span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_timewarn_cs</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>
				<span class="n">do_warn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_cancel</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">do_warn</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_cancel</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">do_warn</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
		<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_warn</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* clear flag so we only warn once */</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_WATCH_TIMEWARN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_TIMEOUT</span><span class="p">))</span>
				<span class="n">del_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
			<span class="n">dlm_timeout_warn</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_cancel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;timeout cancel %x node %d %s&quot;</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_WATCH_TIMEWARN</span><span class="p">;</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_TIMEOUT_CANCEL</span><span class="p">;</span>
			<span class="n">del_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
			<span class="n">_cancel_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">unhold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This is only called by dlm_recoverd, and we rely on dlm_ls_stop() stopping</span>
<span class="cm">   dlm_recoverd before checking/setting ls_recover_begin. */</span>

<span class="kt">void</span> <span class="nf">dlm_adjust_timeouts</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">adj_us</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_begin</span><span class="p">);</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_begin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout</span><span class="p">,</span> <span class="n">lkb_time_list</span><span class="p">)</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_timestamp</span> <span class="o">=</span> <span class="n">ktime_add_us</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_timestamp</span><span class="p">,</span> <span class="n">adj_us</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_timeout_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_waitwarn_us</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters</span><span class="p">,</span> <span class="n">lkb_wait_reply</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ktime_to_us</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_time</span><span class="p">))</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_time</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* lkb is master or local copy */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_lvb_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="o">-&gt;</span><span class="n">ls_lvblen</span><span class="p">;</span>

	<span class="cm">/* b=1 lvb returned to caller</span>
<span class="cm">	   b=0 lvb written to rsb or invalidated</span>
<span class="cm">	   b=-1 do nothing */</span>

	<span class="n">b</span> <span class="o">=</span>  <span class="n">dlm_lvb_operations</span><span class="p">[</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbseq</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbseq</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_IVVALBLK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rsb_set_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_VALNOTVALID</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">)</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span> <span class="o">=</span> <span class="n">dlm_allocate_lvb</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbseq</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbseq</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbseq</span><span class="p">;</span>
		<span class="n">rsb_clear_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_VALNOTVALID</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rsb_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_VALNOTVALID</span><span class="p">))</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">|=</span> <span class="n">DLM_SBF_VALNOTVALID</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_lvb_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">&lt;</span> <span class="n">DLM_LOCK_PW</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_IVVALBLK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsb_set_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_VALNOTVALID</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">)</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span> <span class="o">=</span> <span class="n">dlm_allocate_lvb</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbptr</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="o">-&gt;</span><span class="n">ls_lvblen</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lvbseq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rsb_clear_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_VALNOTVALID</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* lkb is process copy (pc) */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_lvb_lock_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">dlm_lvb_operations</span><span class="p">[</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">receive_extralen</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">DLM_RESNAME_MAXLEN</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">DLM_RESNAME_MAXLEN</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_extra</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbseq</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lvbseq</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Manipulate lkb&#39;s on rsb&#39;s convert/granted/waiting queues</span>
<span class="cm">   remove_lock -- used for unlock, removes lkb from granted</span>
<span class="cm">   revert_lock -- used for cancel, moves lkb from convert to granted</span>
<span class="cm">   grant_lock  -- used for request and convert, adds lkb to granted or</span>
<span class="cm">                  moves lkb from convert or waiting to granted</span>

<span class="cm">   Each of these is used for master or local copy lkb&#39;s.  There is</span>
<span class="cm">   also a _pc() variation used to make the corresponding change on</span>
<span class="cm">   a process copy (pc) lkb. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_remove_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>
	<span class="cm">/* this unhold undoes the original ref from create_lkb()</span>
<span class="cm">	   so this leads to the lkb being freed */</span>
	<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_lvb_unlock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">_remove_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_lock_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_remove_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns: 0 did nothing</span>
<span class="cm">	    1 moved lock to granted</span>
<span class="cm">	   -1 removed lock */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">revert_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLM_LKSTS_GRANTED</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_LKSTS_CONVERT</span>:
		<span class="n">move_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_LKSTS_GRANTED</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_LKSTS_WAITING</span>:
		<span class="n">del_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>
		<span class="cm">/* this unhold undoes the original ref from create_lkb()</span>
<span class="cm">		   so this leads to the lkb being freed */</span>
		<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;invalid status for revert %d&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">revert_lock_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">revert_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_grant_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">!=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span><span class="p">)</span>
			<span class="n">move_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_LKSTS_GRANTED</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">add_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_LKSTS_GRANTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_highbast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">grant_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_lvb_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">_grant_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">grant_lock_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_lvb_lock_pc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">_grant_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called by grant_pending_locks() which means an async grant message must</span>
<span class="cm">   be sent to the requesting node in addition to granting the lock if the</span>
<span class="cm">   lkb belongs to a remote node. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">grant_lock_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">grant_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_master_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
		<span class="n">send_grant</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The special CONVDEADLK, ALTPR and ALTCW flags allow the master to</span>
<span class="cm">   change the granted/requested modes.  We&#39;re munging things accordingly in</span>
<span class="cm">   the process copy.</span>
<span class="cm">   CONVDEADLK: our grmode may have been forced down to NL to resolve a</span>
<span class="cm">   conversion deadlock</span>
<span class="cm">   ALTPR/ALTCW: our rqmode may have been changed to PR or CW to become</span>
<span class="cm">   compatible with other granted locks */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">munge_demoted</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_IV</span> <span class="o">||</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_IV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;munge_demoted %x invalid modes gr %d rq %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_NL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">munge_altmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">!=</span> <span class="n">DLM_MSG_REQUEST_REPLY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">!=</span> <span class="n">DLM_MSG_GRANT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;munge_altmode %x invalid reply type %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_ALTPR</span><span class="p">)</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_PR</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_ALTCW</span><span class="p">)</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_CW</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;munge_altmode invalid exflags %x&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span><span class="p">);</span>
		<span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">first_in_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span><span class="p">,</span>
					   <span class="n">lkb_statequeue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span> <span class="o">==</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check if the given lkb conflicts with another lkb on the queue. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">queue_conflict</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span> <span class="o">==</span> <span class="n">lkb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modes_compat</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">lkb</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;A conversion deadlock arises with a pair of lock requests in the converting</span>
<span class="cm"> * queue for one resource.  The granted mode of each lock blocks the requested</span>
<span class="cm"> * mode of the other lock.&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * Part 2: if the granted mode of lkb is preventing an earlier lkb in the</span>
<span class="cm"> * convert queue from being granted, then deadlk/demote lkb.</span>
<span class="cm"> *</span>
<span class="cm"> * Example:</span>
<span class="cm"> * Granted Queue: empty</span>
<span class="cm"> * Convert Queue: NL-&gt;EX (first lock)</span>
<span class="cm"> *                PR-&gt;EX (second lock)</span>
<span class="cm"> *</span>
<span class="cm"> * The first lock can&#39;t be granted because of the granted mode of the second</span>
<span class="cm"> * lock and the second lock can&#39;t be granted because it&#39;s not first in the</span>
<span class="cm"> * list.  We either cancel lkb&#39;s conversion (PR-&gt;EX) and return EDEADLK, or we</span>
<span class="cm"> * demote the granted mode of lkb (from PR to NL) if it has the CONVDEADLK</span>
<span class="cm"> * flag set and return DEMOTED in the lksb flags.</span>
<span class="cm"> *</span>
<span class="cm"> * Originally, this function detected conv-deadlk in a more limited scope:</span>
<span class="cm"> * - if !modes_compat(lkb1, lkb2) &amp;&amp; !modes_compat(lkb2, lkb1), or</span>
<span class="cm"> * - if lkb1 was the first entry in the queue (not just earlier), and was</span>
<span class="cm"> *   blocked by the granted mode of lkb2, and there was nothing on the</span>
<span class="cm"> *   granted queue preventing lkb1 from being granted immediately, i.e.</span>
<span class="cm"> *   lkb2 was the only thing preventing lkb1 from being granted.</span>
<span class="cm"> *</span>
<span class="cm"> * That second condition meant we&#39;d only say there was conv-deadlk if</span>
<span class="cm"> * resolving it (by demotion) would lead to the first lock on the convert</span>
<span class="cm"> * queue being granted right away.  It allowed conversion deadlocks to exist</span>
<span class="cm"> * between locks on the convert queue while they couldn&#39;t be granted anyway.</span>
<span class="cm"> *</span>
<span class="cm"> * Now, we detect and take action on conversion deadlocks immediately when</span>
<span class="cm"> * they&#39;re created, even if they may not be immediately consequential.  If</span>
<span class="cm"> * lkb1 exists anywhere in the convert queue and lkb2 comes in with a granted</span>
<span class="cm"> * mode that would prevent lkb1&#39;s conversion from being granted, we do a</span>
<span class="cm"> * deadlk/demote on lkb2 right away and don&#39;t let it onto the convert queue.</span>
<span class="cm"> * I think this means that the lkb_is_ahead condition below should always</span>
<span class="cm"> * be zero, i.e. there will never be conv-deadlk between two locks that are</span>
<span class="cm"> * both already on the convert queue.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">conversion_deadlock_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lkb_is_ahead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb1</span> <span class="o">==</span> <span class="n">lkb2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lkb_is_ahead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb_is_ahead</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modes_compat</span><span class="p">(</span><span class="n">lkb2</span><span class="p">,</span> <span class="n">lkb1</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modes_compat</span><span class="p">(</span><span class="n">lkb2</span><span class="p">,</span> <span class="n">lkb1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">modes_compat</span><span class="p">(</span><span class="n">lkb1</span><span class="p">,</span> <span class="n">lkb2</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return 1 if the lock can be granted, 0 otherwise.</span>
<span class="cm"> * Also detect and resolve conversion deadlocks.</span>
<span class="cm"> *</span>
<span class="cm"> * lkb is the lock to be granted</span>
<span class="cm"> *</span>
<span class="cm"> * now is 1 if the function is being called in the context of the</span>
<span class="cm"> * immediate request, it is 0 if called later, after the lock has been</span>
<span class="cm"> * queued.</span>
<span class="cm"> *</span>
<span class="cm"> * References are from chapter 6 of &quot;VAXcluster Principles&quot; by Roy Davis</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_can_be_granted</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int8_t</span> <span class="n">conv</span> <span class="o">=</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">!=</span> <span class="n">DLM_LOCK_IV</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * 6-10: Version 5.4 introduced an option to address the phenomenon of</span>
<span class="cm">	 * a new request for a NL mode lock being blocked.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 6-11: If the optional EXPEDITE flag is used with the new NL mode</span>
<span class="cm">	 * request, then it would be granted.  In essence, the use of this flag</span>
<span class="cm">	 * tells the Lock Manager to expedite theis request by not considering</span>
<span class="cm">	 * what may be in the CONVERTING or WAITING queues...  As of this</span>
<span class="cm">	 * writing, the EXPEDITE flag can be used only with new requests for NL</span>
<span class="cm">	 * mode locks.  This flag is not valid for conversion requests.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A shortcut.  Earlier checks return an error if EXPEDITE is used in a</span>
<span class="cm">	 * conversion or used with a non-NL requested mode.  We also know an</span>
<span class="cm">	 * EXPEDITE request is always granted immediately, so now must always</span>
<span class="cm">	 * be 1.  The full condition to grant an expedite request: (now &amp;&amp;</span>
<span class="cm">	 * !conv &amp;&amp; lkb-&gt;rqmode == DLM_LOCK_NL &amp;&amp; (flags &amp; EXPEDITE)) can</span>
<span class="cm">	 * therefore be shortened to just checking the flag.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_EXPEDITE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A shortcut. Without this, !queue_conflict(grantqueue, lkb) would be</span>
<span class="cm">	 * added to the remaining conditions.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue_conflict</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">,</span> <span class="n">lkb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 6-3: By default, a conversion request is immediately granted if the</span>
<span class="cm">	 * requested mode is compatible with the modes of all other granted</span>
<span class="cm">	 * locks</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue_conflict</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">,</span> <span class="n">lkb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 6-5: But the default algorithm for deciding whether to grant or</span>
<span class="cm">	 * queue conversion requests does not by itself guarantee that such</span>
<span class="cm">	 * requests are serviced on a &quot;first come first serve&quot; basis.  This, in</span>
<span class="cm">	 * turn, can lead to a phenomenon known as &quot;indefinate postponement&quot;.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 6-7: This issue is dealt with by using the optional QUECVT flag with</span>
<span class="cm">	 * the system service employed to request a lock conversion.  This flag</span>
<span class="cm">	 * forces certain conversion requests to be queued, even if they are</span>
<span class="cm">	 * compatible with the granted modes of other locks on the same</span>
<span class="cm">	 * resource.  Thus, the use of this flag results in conversion requests</span>
<span class="cm">	 * being ordered on a &quot;first come first servce&quot; basis.</span>
<span class="cm">	 *</span>
<span class="cm">	 * DCT: This condition is all about new conversions being able to occur</span>
<span class="cm">	 * &quot;in place&quot; while the lock remains on the granted queue (assuming</span>
<span class="cm">	 * nothing else conflicts.)  IOW if QUECVT isn&#39;t set, a conversion</span>
<span class="cm">	 * doesn&#39;t _have_ to go onto the convert queue where it&#39;s processed in</span>
<span class="cm">	 * order.  The &quot;now&quot; variable is necessary to distinguish converts</span>
<span class="cm">	 * being received and processed for the first time now, because once a</span>
<span class="cm">	 * convert is moved to the conversion queue the condition below applies</span>
<span class="cm">	 * requiring fifo granting.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&amp;&amp;</span> <span class="n">conv</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_QUECVT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even if the convert is compat with all granted locks,</span>
<span class="cm">	 * QUECVT forces it behind other locks on the convert queue.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&amp;&amp;</span> <span class="n">conv</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_QUECVT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The NOORDER flag is set to avoid the standard vms rules on grant</span>
<span class="cm">	 * order.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_NOORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 6-3: Once in that queue [CONVERTING], a conversion request cannot be</span>
<span class="cm">	 * granted until all other conversion requests ahead of it are granted</span>
<span class="cm">	 * and/or canceled.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">now</span> <span class="o">&amp;&amp;</span> <span class="n">conv</span> <span class="o">&amp;&amp;</span> <span class="n">first_in_list</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 6-4: By default, a new request is immediately granted only if all</span>
<span class="cm">	 * three of the following conditions are satisfied when the request is</span>
<span class="cm">	 * issued:</span>
<span class="cm">	 * - The queue of ungranted conversion requests for the resource is</span>
<span class="cm">	 *   empty.</span>
<span class="cm">	 * - The queue of ungranted new requests for the resource is empty.</span>
<span class="cm">	 * - The mode of the new request is compatible with the most</span>
<span class="cm">	 *   restrictive mode of all granted locks on the resource.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">conv</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 6-4: Once a lock request is in the queue of ungranted new requests,</span>
<span class="cm">	 * it cannot be granted until the queue of ungranted conversion</span>
<span class="cm">	 * requests is empty, all ungranted new requests ahead of it are</span>
<span class="cm">	 * granted and/or canceled, and it is compatible with the granted mode</span>
<span class="cm">	 * of the most restrictive lock granted on the resource.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">now</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">conv</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">first_in_list</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">can_be_granted</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">now</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">int8_t</span> <span class="n">alt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rqmode</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">;</span>
	<span class="kt">int8_t</span> <span class="n">is_convert</span> <span class="o">=</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">!=</span> <span class="n">DLM_LOCK_IV</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">_can_be_granted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The CONVDEADLK flag is non-standard and tells the dlm to resolve</span>
<span class="cm">	 * conversion deadlocks by demoting grmode to NL, otherwise the dlm</span>
<span class="cm">	 * cancels one of the locks.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_convert</span> <span class="o">&amp;&amp;</span> <span class="n">can_be_queued</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">conversion_deadlock_detect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVDEADLK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_NL</span><span class="p">;</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">|=</span> <span class="n">DLM_SBF_DEMOTED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_NODLCKWT</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;can_be_granted deadlock %x now %d&quot;</span><span class="p">,</span>
					  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
				<span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ALTPR and ALTCW flags are non-standard and tell the dlm to try</span>
<span class="cm">	 * to grant a request in a mode other than the normal rqmode.  It&#39;s a</span>
<span class="cm">	 * simple way to provide a big optimization to applications that can</span>
<span class="cm">	 * use them.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rqmode</span> <span class="o">!=</span> <span class="n">DLM_LOCK_PR</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_ALTPR</span><span class="p">))</span>
		<span class="n">alt</span> <span class="o">=</span> <span class="n">DLM_LOCK_PR</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rqmode</span> <span class="o">!=</span> <span class="n">DLM_LOCK_CW</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_ALTCW</span><span class="p">))</span>
		<span class="n">alt</span> <span class="o">=</span> <span class="n">DLM_LOCK_CW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">alt</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">_can_be_granted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">|=</span> <span class="n">DLM_SBF_ALTMODE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">rqmode</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* FIXME: I don&#39;t think that can_be_granted() can/will demote or find deadlock</span>
<span class="cm">   for locks pending on the convert list.  Once verified (watch for these</span>
<span class="cm">   log_prints), we should be able to just call _can_be_granted() and not</span>
<span class="cm">   bother with the demote/deadlk cases here (and there&#39;s no easy way to deal</span>
<span class="cm">   with a deadlk here, we&#39;d have to generate something like grant_lock with</span>
<span class="cm">   the deadlk error.) */</span>

<span class="cm">/* Returns the highest requested mode of all blocked conversions; sets</span>
<span class="cm">   cw if there&#39;s a blocked conversion to DLM_LOCK_CW. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">grant_pending_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cw</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hi</span><span class="p">,</span> <span class="n">demoted</span><span class="p">,</span> <span class="n">quit</span><span class="p">,</span> <span class="n">grant_restart</span><span class="p">,</span> <span class="n">demote_restart</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">deadlk</span><span class="p">;</span>

	<span class="n">quit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">restart:</span>
	<span class="n">grant_restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">demote_restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hi</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">demoted</span> <span class="o">=</span> <span class="n">is_demoted</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="n">deadlk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">can_be_granted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deadlk</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">grant_lock_pending</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
			<span class="n">grant_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
				<span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">demoted</span> <span class="o">&amp;&amp;</span> <span class="n">is_demoted</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;WARN: pending demoted %x node %d %s&quot;</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
			<span class="n">demote_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">deadlk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;WARN: pending deadlock %x node %d %s&quot;</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
			<span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hi</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cw</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_CW</span><span class="p">)</span>
			<span class="o">*</span><span class="n">cw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">grant_restart</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">demote_restart</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">quit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">grant_pending_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cw</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_be_granted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">grant_lock_pending</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
				<span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_CW</span><span class="p">)</span>
				<span class="o">*</span><span class="n">cw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">high</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* cw of 1 means there&#39;s a lock with a rqmode of DLM_LOCK_CW that&#39;s blocked</span>
<span class="cm">   on either the convert or waiting queue.</span>
<span class="cm">   high is the largest rqmode of all locks blocked on the convert or</span>
<span class="cm">   waiting queue. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lock_requires_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">gr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_PR</span> <span class="o">&amp;&amp;</span> <span class="n">cw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_highbast</span> <span class="o">&lt;</span> <span class="n">DLM_LOCK_EX</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_highbast</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">__dlm_compat_matrix</span><span class="p">[</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">grant_pending_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_master</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;grant_pending_locks r nodeid %d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">);</span>
		<span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">high</span> <span class="o">=</span> <span class="n">grant_pending_convert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cw</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">high</span> <span class="o">=</span> <span class="n">grant_pending_wait</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cw</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">high</span> <span class="o">==</span> <span class="n">DLM_LOCK_IV</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are locks left on the wait/convert queue then send blocking</span>
<span class="cm">	 * ASTs to granted locks based on the largest requested mode (high)</span>
<span class="cm">	 * found above.</span>
<span class="cm">	 */</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_bastfn</span> <span class="o">&amp;&amp;</span> <span class="n">lock_requires_bast</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">cw</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cw</span> <span class="o">&amp;&amp;</span> <span class="n">high</span> <span class="o">==</span> <span class="n">DLM_LOCK_PR</span> <span class="o">&amp;&amp;</span>
			    <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_PR</span><span class="p">)</span>
				<span class="n">queue_bast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_LOCK_CW</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">queue_bast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_highbast</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">modes_require_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">gr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_PR</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_CW</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_CW</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_PR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_highbast</span> <span class="o">&lt;</span> <span class="n">DLM_LOCK_EX</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_highbast</span> <span class="o">&lt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">modes_compat</span><span class="p">(</span><span class="n">gr</span><span class="p">,</span> <span class="n">rq</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_bast_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">gr</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">gr</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* skip self when sending basts to convertqueue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gr</span> <span class="o">==</span> <span class="n">lkb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_bastfn</span> <span class="o">&amp;&amp;</span> <span class="n">modes_require_bast</span><span class="p">(</span><span class="n">gr</span><span class="p">,</span> <span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">queue_bast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">gr</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">);</span>
			<span class="n">gr</span><span class="o">-&gt;</span><span class="n">lkb_highbast</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_blocking_asts</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">send_bast_queue</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_blocking_asts_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">send_bast_queue</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">send_bast_queue</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* set_master(r, lkb) -- set the master nodeid of a resource</span>

<span class="cm">   The purpose of this function is to set the nodeid field in the given</span>
<span class="cm">   lkb using the nodeid field in the given rsb.  If the rsb&#39;s nodeid is</span>
<span class="cm">   known, it can just be copied to the lkb and the function will return</span>
<span class="cm">   0.  If the rsb&#39;s nodeid is _not_ known, it needs to be looked up</span>
<span class="cm">   before it can be copied to the lkb.</span>

<span class="cm">   When the rsb nodeid is being looked up remotely, the initial lkb</span>
<span class="cm">   causing the lookup is kept on the ls_waiters list waiting for the</span>
<span class="cm">   lookup reply.  Other lkb&#39;s waiting for the same rsb lookup are kept</span>
<span class="cm">   on the rsb&#39;s res_lookup list until the master is verified.</span>

<span class="cm">   Return values:</span>
<span class="cm">   0: nodeid is set in rsb/lkb and the caller should go ahead and use it</span>
<span class="cm">   1: the rsb master is not available and the lkb has been placed on</span>
<span class="cm">      a wait queue</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">dir_nodeid</span><span class="p">,</span> <span class="n">ret_nodeid</span><span class="p">,</span> <span class="n">our_nodeid</span> <span class="o">=</span> <span class="n">dlm_our_nodeid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rsb_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_MASTER_UNCERTAIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rsb_clear_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_MASTER_UNCERTAIN</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">!=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rsb_lookup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lookup</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">););</span>

	<span class="n">dir_nodeid</span> <span class="o">=</span> <span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir_nodeid</span> <span class="o">!=</span> <span class="n">our_nodeid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">;</span>
		<span class="n">send_lookup</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* It&#39;s possible for dlm_scand to remove an old rsb for</span>
<span class="cm">		   this same resource from the toss list, us to create</span>
<span class="cm">		   a new one, look up the master locally, and find it</span>
<span class="cm">		   already exists just before dlm_scand does the</span>
<span class="cm">		   dir_remove() on the previous rsb. */</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_dir_lookup</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">our_nodeid</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">,</span>
				       <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret_nodeid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dir_lookup error %d %s&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_nodeid</span> <span class="o">==</span> <span class="n">our_nodeid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">=</span> <span class="n">ret_nodeid</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="n">ret_nodeid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_lookup_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lookup</span><span class="p">,</span> <span class="n">lkb_rsb_lookup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rsb_lookup</span><span class="p">);</span>
		<span class="n">_request_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* confirm_master -- confirm (or deny) an rsb&#39;s master nodeid */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">confirm_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">process_lookup_list</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EBADR</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTBLK</span>:
		<span class="cm">/* the remote request failed and won&#39;t be retried (it was</span>
<span class="cm">		   a NOQUEUE, or has been canceled/unlocked); make a waiting</span>
<span class="cm">		   lkb the first_lkid */</span>

		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lookup</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lkb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_lookup</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span><span class="p">,</span>
					 <span class="n">lkb_rsb_lookup</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rsb_lookup</span><span class="p">);</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">;</span>
			<span class="n">_request_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">,</span> <span class="s">&quot;confirm_master unknown error %d&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_lock_args</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout_cs</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ast</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">),</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bast</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">),</span>
			 <span class="k">struct</span> <span class="n">dlm_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check for invalid arg usage */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">&gt;</span> <span class="n">DLM_LOCK_EX</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">DLM_RESNAME_MAXLEN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CANCEL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_QUECVT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVDEADLK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVDEADLK</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_NOQUEUE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_EXPEDITE</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_EXPEDITE</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_QUECVT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_EXPEDITE</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_NOQUEUE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_EXPEDITE</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">DLM_LOCK_NL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ast</span> <span class="o">||</span> <span class="o">!</span><span class="n">lksb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lvbptr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVERT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lkid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* these args will be copied to the lkb in validate_lock_args,</span>
<span class="cm">	   it cannot be done now because when converting locks, fields in</span>
<span class="cm">	   an active lkb cannot be modified before locking the rsb */</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">astfn</span> <span class="o">=</span> <span class="n">ast</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">astparam</span> <span class="o">=</span> <span class="n">astparam</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">bastfn</span> <span class="o">=</span> <span class="n">bast</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout_cs</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">lksb</span> <span class="o">=</span> <span class="n">lksb</span><span class="p">;</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_unlock_args</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">DLM_LKF_CANCEL</span> <span class="o">|</span> <span class="n">DLM_LKF_VALBLK</span> <span class="o">|</span> <span class="n">DLM_LKF_IVVALBLK</span> <span class="o">|</span>
 		      <span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CANCEL</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">astparam</span> <span class="o">=</span> <span class="n">astarg</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_lock_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dlm_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_MSTCPY</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_QUECVT</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">__quecvt_compat_matrix</span><span class="p">[</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mode</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span> <span class="o">!=</span> <span class="n">DLM_LKSTS_GRANTED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_astfn</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">astfn</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_astparam</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">astparam</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_bastfn</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">bastfn</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lksb</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lvbptr</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownpid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_timeout_cs</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;validate_lock_args %d %x %x %x %d %d %s&quot;</span><span class="p">,</span>
			  <span class="n">rv</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* when dlm_unlock() sees -EBUSY with CANCEL/FORCEUNLOCK it returns 0</span>
<span class="cm">   for success */</span>

<span class="cm">/* note: it&#39;s valid for lkb_nodeid/res_nodeid to be -1 when we get here</span>
<span class="cm">   because there may be a lookup in progress and it&#39;s valid to do</span>
<span class="cm">   cancel/unlockf on it */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_unlock_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_MSTCPY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;unlock on MSTCPY %x&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">);</span>
		<span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* an lkb may still exist even though the lock is EOL&#39;ed due to a</span>
<span class="cm">	   cancel, unlock or failed noqueue request; an app can&#39;t use these</span>
<span class="cm">	   locks; return same error as if the lkid had not been found at all */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_ENDOFLIFE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;unlock on ENDOFLIFE %x&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* an lkb may be waiting for an rsb lookup to complete where the</span>
<span class="cm">	   lookup was initiated by another lock */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rsb_lookup</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DLM_LKF_CANCEL</span> <span class="o">|</span> <span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;unlock on rsb_lookup %x&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rsb_lookup</span><span class="p">);</span>
			<span class="n">queue_cast</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span>
				   <span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CANCEL</span> <span class="o">?</span>
				   <span class="o">-</span><span class="n">DLM_ECANCEL</span> <span class="o">:</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span><span class="p">);</span>
			<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span> <span class="cm">/* undoes create_lkb() */</span>
		<span class="p">}</span>
		<span class="cm">/* caller changes -EBUSY to 0 for CANCEL and FORCEUNLOCK */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* cancel not allowed with another cancel/unlock in progress */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CANCEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CANCEL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* don&#39;t let scand try to do a cancel */</span>
		<span class="n">del_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_RESEND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* there&#39;s nothing to cancel */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span> <span class="o">==</span> <span class="n">DLM_LKSTS_GRANTED</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP</span>:
		<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
		<span class="k">case</span> <span class="n">DLM_MSG_CANCEL</span>:
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* add_to_waiters() will set OVERLAP_CANCEL */</span>
		<span class="k">goto</span> <span class="n">out_ok</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do we need to allow a force-unlock if there&#39;s a normal unlock</span>
<span class="cm">	   already in progress?  in what conditions could the normal unlock</span>
<span class="cm">	   fail such that we&#39;d want to send a force-unlock to be sure? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap_unlock</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* don&#39;t let scand try to do a cancel */</span>
		<span class="n">del_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_RESEND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP</span>:
		<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* add_to_waiters() will set OVERLAP_UNLOCK */</span>
		<span class="k">goto</span> <span class="n">out_ok</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* normal unlock not allowed if there&#39;s any op in progress */</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">||</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

 <span class="nl">out_ok:</span>
	<span class="cm">/* an overlapping op shouldn&#39;t blow away exflags from other op */</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">|=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_astparam</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">astparam</span><span class="p">;</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;validate_unlock_args %d %x %x %x %x %d %s&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span><span class="p">,</span>
			  <span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Four stage 4 varieties:</span>
<span class="cm"> * do_request(), do_convert(), do_unlock(), do_cancel()</span>
<span class="cm"> * These are called on the master node for the given lock and</span>
<span class="cm"> * from the central locking logic.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_be_granted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">grant_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_be_queued</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
		<span class="n">add_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_LKSTS_WAITING</span><span class="p">);</span>
		<span class="n">add_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_request_effects</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">force_blocking_asts</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="n">send_blocking_asts_all</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
		<span class="n">send_blocking_asts</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">deadlk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* changing an existing lock may allow others to be granted */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_be_granted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deadlk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">grant_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* can_be_granted() detected that this lock would block in a conversion</span>
<span class="cm">	   deadlock, so we leave it on the granted queue and return EDEADLK in</span>
<span class="cm">	   the ast for the convert. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">deadlk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* it&#39;s left on the granted queue */</span>
		<span class="n">revert_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* is_demoted() means the can_be_granted() above set the grmode</span>
<span class="cm">	   to NL, and left us on the granted queue.  This auto-demotion</span>
<span class="cm">	   (due to CONVDEADLK) might mean other locks, and/or this lock, are</span>
<span class="cm">	   now grantable.  We have to try to grant other converting locks</span>
<span class="cm">	   before we try again to grant this one. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_demoted</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">grant_pending_convert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">DLM_LOCK_IV</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_can_be_granted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">grant_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
			<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* else fall through and move to convert queue */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_be_queued</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
		<span class="n">del_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">add_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_LKSTS_CONVERT</span><span class="p">);</span>
		<span class="n">add_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_convert_effects</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">grant_pending_locks</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* grant_pending_locks also sends basts */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">force_blocking_asts</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="n">send_blocking_asts_all</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
		<span class="n">send_blocking_asts</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_unlock_effects</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">grant_pending_locks</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns: 0 did nothing, -DLM_ECANCEL canceled lock */</span>
 
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">revert_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_cancel_effects</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">grant_pending_locks</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Four stage 3 varieties:</span>
<span class="cm"> * _request_lock(), _convert_lock(), _unlock_lock(), _cancel_lock()</span>
<span class="cm"> */</span>

<span class="cm">/* add a new lkb to a possibly new rsb, called by requesting process */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_request_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* set_master: sets lkb nodeid from r */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_master</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_remote</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* receive_request() calls do_request() on remote node */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">send_request</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">do_request</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="cm">/* for remote locks the request_reply is sent</span>
<span class="cm">		   between do_request and do_request_effects */</span>
		<span class="n">do_request_effects</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* change some property of an existing lkb, e.g. mode */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_convert_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_remote</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* receive_convert() calls do_convert() on remote node */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">send_convert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">do_convert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="cm">/* for remote locks the convert_reply is sent</span>
<span class="cm">		   between do_convert and do_convert_effects */</span>
		<span class="n">do_convert_effects</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* remove an existing lkb from the granted queue */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_unlock_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_remote</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* receive_unlock() calls do_unlock() on remote node */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">send_unlock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">do_unlock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="cm">/* for remote locks the unlock_reply is sent</span>
<span class="cm">		   between do_unlock and do_unlock_effects */</span>
		<span class="n">do_unlock_effects</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* remove an existing lkb from the convert or wait queue */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_cancel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_remote</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* receive_cancel() calls do_cancel() on remote node */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">send_cancel</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">do_cancel</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="cm">/* for remote locks the cancel_reply is sent</span>
<span class="cm">		   between do_cancel and do_cancel_effects */</span>
		<span class="n">do_cancel_effects</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Four stage 2 varieties:</span>
<span class="cm"> * request_lock(), convert_lock(), unlock_lock(), cancel_lock()</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">request_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_lock_args</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_rsb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">R_CREATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">attach_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lksb</span><span class="o">-&gt;</span><span class="n">sb_lkid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_request_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>

	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dlm_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_lock_args</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_convert_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlock_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dlm_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_unlock_args</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_unlock_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cancel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dlm_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_unlock_args</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_cancel_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Two stage 1 varieties:  dlm_lock() and dlm_unlock()</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">dlm_lock</span><span class="p">(</span><span class="n">dlm_lockspace_t</span> <span class="o">*</span><span class="n">lockspace</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
	     <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
	     <span class="kt">uint32_t</span> <span class="n">parent_lkid</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ast</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">),</span>
	     <span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bast</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">convert</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">;</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">dlm_find_lockspace_local</span><span class="p">(</span><span class="n">lockspace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">convert</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lkid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">create_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_lock_args</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">lksb</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ast</span><span class="p">,</span>
			      <span class="n">astarg</span><span class="p">,</span> <span class="n">bast</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">convert</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">convert_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">request_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_put:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">convert</span> <span class="o">||</span> <span class="n">error</span><span class="p">)</span>
		<span class="n">__put_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="n">dlm_put_lockspace</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_unlock</span><span class="p">(</span><span class="n">dlm_lockspace_t</span> <span class="o">*</span><span class="n">lockspace</span><span class="p">,</span>
	       <span class="kt">uint32_t</span> <span class="n">lkid</span><span class="p">,</span>
	       <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">dlm_find_lockspace_local</span><span class="p">(</span><span class="n">lockspace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_unlock_args</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">astarg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_CANCEL</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">cancel_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">unlock_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span> <span class="o">||</span> <span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DLM_LKF_CANCEL</span> <span class="o">|</span> <span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">)))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_put:</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="n">dlm_put_lockspace</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * send/receive routines for remote operations and replies</span>
<span class="cm"> *</span>
<span class="cm"> * send_args</span>
<span class="cm"> * send_common</span>
<span class="cm"> * send_request			receive_request</span>
<span class="cm"> * send_convert			receive_convert</span>
<span class="cm"> * send_unlock			receive_unlock</span>
<span class="cm"> * send_cancel			receive_cancel</span>
<span class="cm"> * send_grant			receive_grant</span>
<span class="cm"> * send_bast			receive_bast</span>
<span class="cm"> * send_lookup			receive_lookup</span>
<span class="cm"> * send_remove			receive_remove</span>
<span class="cm"> *</span>
<span class="cm"> * 				send_common_reply</span>
<span class="cm"> * receive_request_reply	send_request_reply</span>
<span class="cm"> * receive_convert_reply	send_convert_reply</span>
<span class="cm"> * receive_unlock_reply		send_unlock_reply</span>
<span class="cm"> * receive_cancel_reply		send_cancel_reply</span>
<span class="cm"> * receive_lookup_reply		send_lookup_reply</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_create_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mb_len</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mstype</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">**</span><span class="n">ms_ret</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">**</span><span class="n">mh_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>

	<span class="cm">/* get_buffer gives us a message handle (mh) that we need to</span>
<span class="cm">	   pass into lowcomms_commit and a message buffer (mb) that we</span>
<span class="cm">	   write our data into */</span>

	<span class="n">mh</span> <span class="o">=</span> <span class="n">dlm_lowcomms_get_buffer</span><span class="p">(</span><span class="n">to_nodeid</span><span class="p">,</span> <span class="n">mb_len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mb_len</span><span class="p">);</span>

	<span class="n">ms</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="p">;</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">DLM_HEADER_MAJOR</span> <span class="o">|</span> <span class="n">DLM_HEADER_MINOR</span><span class="p">);</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_lockspace</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_global_id</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span> <span class="o">=</span> <span class="n">dlm_our_nodeid</span><span class="p">();</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_length</span> <span class="o">=</span> <span class="n">mb_len</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_cmd</span> <span class="o">=</span> <span class="n">DLM_MSG</span><span class="p">;</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">=</span> <span class="n">mstype</span><span class="p">;</span>

	<span class="o">*</span><span class="n">mh_ret</span> <span class="o">=</span> <span class="n">mh</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ms_ret</span> <span class="o">=</span> <span class="n">ms</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mstype</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">**</span><span class="n">ms_ret</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">**</span><span class="n">mh_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mb_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mstype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_REMOVE</span>:
		<span class="n">mb_len</span> <span class="o">+=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_length</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_REQUEST_REPLY</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT_REPLY</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_GRANT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
			<span class="n">mb_len</span> <span class="o">+=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="o">-&gt;</span><span class="n">ls_lvblen</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">_create_message</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">,</span> <span class="n">mb_len</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span>
			       <span class="n">ms_ret</span><span class="p">,</span> <span class="n">mh_ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* further lowcomms enhancements or alternate implementations may make</span>
<span class="cm">   the return value from this function useful at some point */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dlm_message_out</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
	<span class="n">dlm_lowcomms_commit_buffer</span><span class="p">(</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_nodeid</span>   <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_pid</span>      <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownpid</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span>     <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span>    <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_exflags</span>  <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_sbflags</span>  <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_flags</span>    <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lvbseq</span>   <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbseq</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_status</span>   <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_grmode</span>   <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_rqmode</span>   <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_hash</span>     <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hash</span><span class="p">;</span>

	<span class="cm">/* m_result and m_bastmode are set from function args,</span>
<span class="cm">	   not from lkb fields */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_bastfn</span><span class="p">)</span>
		<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_asts</span> <span class="o">|=</span> <span class="n">DLM_CB_BAST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_astfn</span><span class="p">)</span>
		<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_asts</span> <span class="o">|=</span> <span class="n">DLM_CB_CAST</span><span class="p">;</span>

	<span class="cm">/* compare with switch in create_message; send_remove() doesn&#39;t</span>
<span class="cm">	   use send_args() */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_extra</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_length</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_REQUEST_REPLY</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT_REPLY</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_GRANT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_extra</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="o">-&gt;</span><span class="n">ls_lvblen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mstype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">to_nodeid</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">add_to_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_message</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">send_args</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">send_message</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">remove_from_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">msg_reply_type</span><span class="p">(</span><span class="n">mstype</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_common</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_REQUEST</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">send_common</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_CONVERT</span><span class="p">);</span>

	<span class="cm">/* down conversions go without a reply from the master */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">down_conversion</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">remove_from_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_CONVERT_REPLY</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="o">-&gt;</span><span class="n">ls_stub_ms</span><span class="p">.</span><span class="n">m_flags</span> <span class="o">=</span> <span class="n">DLM_IFL_STUB_MS</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="o">-&gt;</span><span class="n">ls_stub_ms</span><span class="p">.</span><span class="n">m_type</span> <span class="o">=</span> <span class="n">DLM_MSG_CONVERT_REPLY</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="o">-&gt;</span><span class="n">ls_stub_ms</span><span class="p">.</span><span class="n">m_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__receive_convert_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="o">-&gt;</span><span class="n">ls_stub_ms</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* FIXME: if this lkb is the only lock we hold on the rsb, then set</span>
<span class="cm">   MASTER_UNCERTAIN to force the next request on the rsb to confirm</span>
<span class="cm">   that the master is still correct. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_common</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_UNLOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_common</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_CANCEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_grant</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">to_nodeid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_message</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">DLM_MSG_GRANT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">send_args</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">send_message</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">to_nodeid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_message</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">DLM_MSG_BAST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">send_args</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_bastmode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">send_message</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">to_nodeid</span> <span class="o">=</span> <span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">add_to_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_LOOKUP</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_message</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">DLM_MSG_LOOKUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">send_args</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">send_message</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">remove_from_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_LOOKUP_REPLY</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">to_nodeid</span> <span class="o">=</span> <span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_message</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">DLM_MSG_REMOVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_extra</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_name</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_length</span><span class="p">);</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_hash</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_hash</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">send_message</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_common_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">mstype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">to_nodeid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_message</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">to_nodeid</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">send_args</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span> <span class="o">=</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">send_message</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_request_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_common_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_REQUEST_REPLY</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_convert_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_common_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_CONVERT_REPLY</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_unlock_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_common_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_UNLOCK_REPLY</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_cancel_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_common_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_CANCEL_REPLY</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_lookup_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms_in</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">ret_nodeid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_rsb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">nodeid</span> <span class="o">=</span> <span class="n">ms_in</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_message</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">DLM_MSG_LOOKUP_REPLY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span> <span class="o">=</span> <span class="n">ms_in</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span> <span class="o">=</span> <span class="n">rv</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_nodeid</span> <span class="o">=</span> <span class="n">ret_nodeid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">send_message</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* which args we save from a received message depends heavily on the type</span>
<span class="cm">   of message, unlike the send side where we can safely send everything about</span>
<span class="cm">   the lkb for any type of message */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">receive_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_exflags</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_sbflags</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">)</span> <span class="o">|</span>
		         <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="mh">0x0000FFFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">receive_flags_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">==</span> <span class="n">DLM_IFL_STUB_MS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_sbflags</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_sbflags</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">)</span> <span class="o">|</span>
		         <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="mh">0x0000FFFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_extralen</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_length</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_lvb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span> <span class="o">=</span> <span class="n">dlm_allocate_lvb</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">receive_extralen</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">DLM_RESNAME_MAXLEN</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">DLM_RESNAME_MAXLEN</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_extra</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fake_bastfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;fake_bastfn should not be called&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fake_astfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;fake_astfn should not be called&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_request_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownpid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_pid</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_rqmode</span><span class="p">;</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_bastfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_asts</span> <span class="o">&amp;</span> <span class="n">DLM_CB_BAST</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">fake_bastfn</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_astfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_asts</span> <span class="o">&amp;</span> <span class="n">DLM_CB_CAST</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">fake_astfn</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* lkb was just created so there won&#39;t be an lvb yet */</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span> <span class="o">=</span> <span class="n">dlm_allocate_lvb</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_convert_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_status</span> <span class="o">!=</span> <span class="n">DLM_LKSTS_GRANTED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">receive_lvb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_rqmode</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbseq</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lvbseq</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_unlock_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">receive_lvb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We fill in the stub-lkb fields with the info that send_xxxx_reply()</span>
<span class="cm">   uses to send a reply and that the remote end uses to process the reply. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_stub_lkb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_lkb</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is called after the rsb is locked so that we can safely inspect</span>
<span class="cm">   fields in the lkb. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_CANCEL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_master_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">||</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">!=</span> <span class="n">from</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT_REPLY</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK_REPLY</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_CANCEL_REPLY</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_GRANT</span>:
	<span class="k">case</span> <span class="n">DLM_MSG_BAST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_process_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">||</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">!=</span> <span class="n">from</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_REQUEST_REPLY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_process_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">!=</span> <span class="n">from</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">,</span>
			  <span class="s">&quot;ignore invalid message %d from %d %x %x %x %d&quot;</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">receive_flags</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_MSTCPY</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">receive_request_args</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__put_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">namelen</span> <span class="o">=</span> <span class="n">receive_extralen</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_rsb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_extra</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">R_MASTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__put_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">attach_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">do_request</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">send_request_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">do_request_effects</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">setup_stub_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">send_request_reply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_rsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">reply</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span> <span class="o">!=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_convert %x remid %x recover_seq %llu &quot;</span>
			  <span class="s">&quot;remote %d %x&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_recover_seq</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">receive_flags</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">receive_convert_args</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_convert_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reply</span> <span class="o">=</span> <span class="o">!</span><span class="n">down_conversion</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_convert</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span>
		<span class="n">send_convert_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">do_convert_effects</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">setup_stub_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">send_convert_reply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_rsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span> <span class="o">!=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_unlock %x remid %x remote %d %x&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">receive_flags</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">receive_unlock_args</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_unlock_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_unlock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">send_unlock_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">do_unlock_effects</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">setup_stub_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">send_unlock_reply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_rsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">receive_flags</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_cancel</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">send_cancel_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">do_cancel_effects</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">setup_stub_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">send_cancel_reply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_rsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_stub_lkb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_grant</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">receive_flags_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_altmode</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
		<span class="n">munge_altmode</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">grant_lock_pc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">queue_bast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_bastmode</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_highbast</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_bastmode</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">receive_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">ret_nodeid</span><span class="p">,</span> <span class="n">dir_nodeid</span><span class="p">,</span> <span class="n">from_nodeid</span><span class="p">,</span> <span class="n">our_nodeid</span><span class="p">;</span>

	<span class="n">from_nodeid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">;</span>
	<span class="n">our_nodeid</span> <span class="o">=</span> <span class="n">dlm_our_nodeid</span><span class="p">();</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">receive_extralen</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>

	<span class="n">dir_nodeid</span> <span class="o">=</span> <span class="n">dlm_hash2nodeid</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir_nodeid</span> <span class="o">!=</span> <span class="n">our_nodeid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;lookup dir_nodeid %d from %d&quot;</span><span class="p">,</span>
			  <span class="n">dir_nodeid</span><span class="p">,</span> <span class="n">from_nodeid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ret_nodeid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_dir_lookup</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">from_nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_extra</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret_nodeid</span><span class="p">);</span>

	<span class="cm">/* Optimization: we&#39;re master so treat lookup as a request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">ret_nodeid</span> <span class="o">==</span> <span class="n">our_nodeid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">receive_request</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">send_lookup_reply</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">ret_nodeid</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">receive_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">dir_nodeid</span><span class="p">,</span> <span class="n">from_nodeid</span><span class="p">;</span>

	<span class="n">from_nodeid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">receive_extralen</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>

	<span class="n">dir_nodeid</span> <span class="o">=</span> <span class="n">dlm_hash2nodeid</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir_nodeid</span> <span class="o">!=</span> <span class="n">dlm_our_nodeid</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remove dir entry dir_nodeid %d from %d&quot;</span><span class="p">,</span>
			  <span class="n">dir_nodeid</span><span class="p">,</span> <span class="n">from_nodeid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dlm_dir_remove_entry</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">from_nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_extra</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">receive_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">do_purge</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_request_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mstype</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">remove_from_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_REQUEST_REPLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_request_reply %x remote %d %x result %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">);</span>
		<span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Optimization: the dir node was also the master, so it took our</span>
<span class="cm">	   lookup as a request and sent request reply instead of lookup reply */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mstype</span> <span class="o">==</span> <span class="n">DLM_MSG_LOOKUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this is the value returned from do_request() on the master */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="cm">/* request would block (be queued) on remote master */</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
		<span class="n">confirm_master</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
		<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span> <span class="cm">/* undoes create_lkb() */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* request was queued or granted on remote master */</span>
		<span class="n">receive_flags_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_altmode</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="n">munge_altmode</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">add_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_LKSTS_WAITING</span><span class="p">);</span>
			<span class="n">add_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">grant_lock_pc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
			<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">confirm_master</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">EBADR</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOTBLK</span>:
		<span class="cm">/* find_rsb failed to find rsb or rsb wasn&#39;t master */</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_request_reply %x %x master diff %d %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* we&#39;ll ignore error in cancel/unlock reply */</span>
			<span class="n">queue_cast_overlap</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
			<span class="n">confirm_master</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span> <span class="cm">/* undoes create_lkb() */</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">_request_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_request_reply %x error %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap_unlock</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_request_reply %x result %d unlock&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
		<span class="n">send_unlock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_overlap_cancel</span><span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_request_reply %x cancel&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
		<span class="n">send_cancel</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__receive_convert_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* this is the value returned from do_convert() on the master */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="cm">/* convert would block (be queued) on remote master */</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">EDEADLK</span>:
		<span class="n">receive_flags_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="n">revert_lock_pc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
		<span class="cm">/* convert was queued on remote master */</span>
		<span class="n">receive_flags_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_demoted</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="n">munge_demoted</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="n">del_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">add_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_LKSTS_CONVERT</span><span class="p">);</span>
		<span class="n">add_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* convert was granted on remote master */</span>
		<span class="n">receive_flags_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_demoted</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="n">munge_demoted</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="n">grant_lock_pc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">,</span> <span class="s">&quot;receive_convert_reply %x remote %d %x %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">);</span>
		<span class="n">dlm_print_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">dlm_print_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_receive_convert_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* stub reply can happen with waiters_mutex held */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">remove_from_waiters_ms</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">__receive_convert_reply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_convert_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">_receive_convert_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_receive_unlock_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* stub reply can happen with waiters_mutex held */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">remove_from_waiters_ms</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* this is the value returned from do_unlock() on the master */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span>:
		<span class="n">receive_flags_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="n">remove_lock_pc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">,</span> <span class="s">&quot;receive_unlock_reply %x error %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_unlock_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">_receive_unlock_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_receive_cancel_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_message</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* stub reply can happen with waiters_mutex held */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">remove_from_waiters_ms</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* this is the value returned from do_cancel() on the master */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span>:
		<span class="n">receive_flags_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="n">revert_lock_pc</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">,</span> <span class="s">&quot;receive_cancel_reply %x error %d&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_cancel_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">_receive_cancel_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">receive_lookup_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">ret_nodeid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_lookup_reply no lkid %x&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ms-&gt;m_result is the value returned by dlm_dir_lookup on dir node</span>
<span class="cm">	   FIXME: will a non-zero error ever be returned? */</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">remove_from_waiters</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">DLM_MSG_LOOKUP_REPLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret_nodeid</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_nodeid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_nodeid</span> <span class="o">==</span> <span class="n">dlm_our_nodeid</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret_nodeid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_first_lkid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* set_master() will copy res_nodeid to lkb_nodeid */</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span> <span class="o">=</span> <span class="n">ret_nodeid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive_lookup_reply %x unlock %x&quot;</span><span class="p">,</span>
			  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">);</span>
		<span class="n">queue_cast_overlap</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span> <span class="cm">/* undoes create_lkb() */</span>
		<span class="k">goto</span> <span class="n">out_list</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_request_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>

 <span class="nl">out_list:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_nodeid</span><span class="p">)</span>
		<span class="n">process_lookup_list</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_receive_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span>
			     <span class="kt">uint32_t</span> <span class="n">saved_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">noent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_member</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;ignore non-member message %d from %d %x %x %d&quot;</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_result</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">)</span> <span class="p">{</span>

	<span class="cm">/* messages sent to a master node */</span>

	<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_request</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_convert</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_unlock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_CANCEL</span>:
		<span class="n">noent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_cancel</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* messages sent from a master node (replies to above) */</span>

	<span class="k">case</span> <span class="n">DLM_MSG_REQUEST_REPLY</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_request_reply</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_CONVERT_REPLY</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_convert_reply</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK_REPLY</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_unlock_reply</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_CANCEL_REPLY</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_cancel_reply</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* messages sent from a master node (only two types of async msg) */</span>

	<span class="k">case</span> <span class="n">DLM_MSG_GRANT</span>:
		<span class="n">noent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_grant</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_BAST</span>:
		<span class="n">noent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">receive_bast</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* messages sent to a dir node */</span>

	<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP</span>:
		<span class="n">receive_lookup</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DLM_MSG_REMOVE</span>:
		<span class="n">receive_remove</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* messages sent from a dir node (remove has no reply) */</span>

	<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP_REPLY</span>:
		<span class="n">receive_lookup_reply</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* other messages */</span>

	<span class="k">case</span> <span class="n">DLM_MSG_PURGE</span>:
		<span class="n">receive_purge</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;unknown message type %d&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When checking for ENOENT, we&#39;re checking the result of</span>
<span class="cm">	 * find_lkb(m_remid):</span>
<span class="cm">	 *</span>
<span class="cm">	 * The lock id referenced in the message wasn&#39;t found.  This may</span>
<span class="cm">	 * happen in normal usage for the async messages and cancel, so</span>
<span class="cm">	 * only use log_debug for them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some errors are expected and normal.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">&amp;&amp;</span> <span class="n">noent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive %d no %x remote %d %x saved_seq %u&quot;</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">,</span> <span class="n">saved_seq</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive %d no %x remote %d %x saved_seq %u&quot;</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">,</span> <span class="n">saved_seq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">==</span> <span class="n">DLM_MSG_CONVERT</span><span class="p">)</span>
			<span class="n">dlm_dump_rsb_hash</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_hash</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;receive %d inval from %d lkid %x remid %x &quot;</span>
			  <span class="s">&quot;saved_seq %u&quot;</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_type</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span>
			  <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_lkid</span><span class="p">,</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_remid</span><span class="p">,</span> <span class="n">saved_seq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* If the lockspace is in recovery mode (locking stopped), then normal</span>
<span class="cm">   messages are saved on the requestqueue for processing after recovery is</span>
<span class="cm">   done.  When not in recovery mode, we wait for dlm_recoverd to drain saved</span>
<span class="cm">   messages off the requestqueue before we process new ones. This occurs right</span>
<span class="cm">   after recovery completes when we transition from saving all messages on</span>
<span class="cm">   requestqueue, to processing all the saved messages, to processing new</span>
<span class="cm">   messages as they arrive. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_receive_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_locking_stopped</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dlm_add_requestqueue</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dlm_wait_requestqueue</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="n">_receive_message</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This is called by dlm_recoverd to process messages that were saved on</span>
<span class="cm">   the requestqueue. */</span>

<span class="kt">void</span> <span class="nf">dlm_receive_message_saved</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span>
			       <span class="kt">uint32_t</span> <span class="n">saved_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_receive_message</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">saved_seq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is called by the midcomms layer when something is received for</span>
<span class="cm">   the lockspace.  It could be either a MSG (normal message sent as part of</span>
<span class="cm">   standard locking activity) or an RCOM (recovery message sent as part of</span>
<span class="cm">   lockspace recovery). */</span>

<span class="kt">void</span> <span class="nf">dlm_receive_buffer</span><span class="p">(</span><span class="k">union</span> <span class="n">dlm_packet</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_header</span> <span class="o">*</span><span class="n">hd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLM_MSG</span>:
		<span class="n">dlm_message_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">);</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">.</span><span class="n">m_type</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_RCOM</span>:
		<span class="n">dlm_rcom_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rcom</span><span class="p">);</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rcom</span><span class="p">.</span><span class="n">rc_type</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;invalid h_cmd %d from %u&quot;</span><span class="p">,</span> <span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_cmd</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_nodeid</span> <span class="o">!=</span> <span class="n">nodeid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_print</span><span class="p">(</span><span class="s">&quot;invalid h_nodeid %d from %d lockspace %x&quot;</span><span class="p">,</span>
			  <span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_lockspace</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ls</span> <span class="o">=</span> <span class="n">dlm_find_lockspace_global</span><span class="p">(</span><span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_lockspace</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_log_debug</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;dlm: invalid lockspace &quot;</span>
				<span class="s">&quot;%u from %d cmd %d type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_lockspace</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_cmd</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_cmd</span> <span class="o">==</span> <span class="n">DLM_RCOM</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">DLM_RCOM_STATUS</span><span class="p">)</span>
			<span class="n">dlm_send_ls_not_ready</span><span class="p">(</span><span class="n">nodeid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rcom</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this rwsem allows dlm_ls_stop() to wait for all dlm_recv threads to</span>
<span class="cm">	   be inactive (in this ls) before transitioning to recovery mode */</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recv_active</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hd</span><span class="o">-&gt;</span><span class="n">h_cmd</span> <span class="o">==</span> <span class="n">DLM_MSG</span><span class="p">)</span>
		<span class="n">dlm_receive_message</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dlm_receive_rcom</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rcom</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recv_active</span><span class="p">);</span>

	<span class="n">dlm_put_lockspace</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">recover_convert_waiter</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms_stub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">middle_conversion</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ms_stub</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span><span class="p">));</span>
		<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">=</span> <span class="n">DLM_IFL_STUB_MS</span><span class="p">;</span>
		<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">=</span> <span class="n">DLM_MSG_CONVERT_REPLY</span><span class="p">;</span>
		<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
		<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">;</span>
		<span class="n">_receive_convert_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms_stub</span><span class="p">);</span>

		<span class="cm">/* Same special case as in receive_rcom_lock_args() */</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>
		<span class="n">rsb_set_flag</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">,</span> <span class="n">RSB_RECOVER_CONVERT</span><span class="p">);</span>
		<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">&gt;=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_RESEND</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* lkb-&gt;lkb_rqmode &lt; lkb-&gt;lkb_grmode shouldn&#39;t happen since down</span>
<span class="cm">	   conversions are async; there&#39;s no reply from the remote master */</span>
<span class="p">}</span>

<span class="cm">/* A waiting lkb needs recovery if the master node has failed, or</span>
<span class="cm">   the master node is changing (only when no directory is used) */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">waiter_needs_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">dir_nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_no_directory</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_removed</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_nodeid</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Recovery for locks that are waiting for replies from nodes that are now</span>
<span class="cm">   gone.  We can just complete unlocks and cancels by faking a reply from the</span>
<span class="cm">   dead node.  Requests and up-conversions we flag to be resent after</span>
<span class="cm">   recovery.  Down-conversions can just be completed with a fake reply like</span>
<span class="cm">   unlocks.  Conversions between PR and CW need special attention. */</span>

<span class="kt">void</span> <span class="nf">dlm_recover_waiters_pre</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms_stub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait_type</span><span class="p">,</span> <span class="n">stub_unlock_result</span><span class="p">,</span> <span class="n">stub_cancel_result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dir_nodeid</span><span class="p">;</span>

	<span class="n">ms_stub</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms_stub</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_waiters_pre no mem&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters</span><span class="p">,</span> <span class="n">lkb_wait_reply</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">dir_nodeid</span> <span class="o">=</span> <span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">);</span>

		<span class="cm">/* exclude debug messages about unlocks because there can be so</span>
<span class="cm">		   many and they aren&#39;t very interesting */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">!=</span> <span class="n">DLM_MSG_UNLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;waiter %x remote %x msg %d r_nodeid %d &quot;</span>
				  <span class="s">&quot;lkb_nodeid %d wait_nodeid %d dir_nodeid %d&quot;</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_nodeid</span><span class="p">,</span>
				  <span class="n">dir_nodeid</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* all outstanding lookups, regardless of destination  will be</span>
<span class="cm">		   resent after recovery is done */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">==</span> <span class="n">DLM_MSG_LOOKUP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_RESEND</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waiter_needs_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">dir_nodeid</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">wait_type</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">;</span>
		<span class="n">stub_unlock_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span><span class="p">;</span>
		<span class="n">stub_cancel_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">;</span>

		<span class="cm">/* Main reply may have been received leaving a zero wait_type,</span>
<span class="cm">		   but a reply for the overlapping op may not have been</span>
<span class="cm">		   received.  In that case we need to fake the appropriate</span>
<span class="cm">		   reply for the overlap op. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap_cancel</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wait_type</span> <span class="o">=</span> <span class="n">DLM_MSG_CANCEL</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_IV</span><span class="p">)</span>
					<span class="n">stub_cancel_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_overlap_unlock</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wait_type</span> <span class="o">=</span> <span class="n">DLM_MSG_UNLOCK</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">==</span> <span class="n">DLM_LOCK_IV</span><span class="p">)</span>
					<span class="n">stub_unlock_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;rwpre overlap %x %x %d %d %d&quot;</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span><span class="p">,</span> <span class="n">wait_type</span><span class="p">,</span>
				  <span class="n">stub_cancel_result</span><span class="p">,</span> <span class="n">stub_unlock_result</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">wait_type</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
			<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_RESEND</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DLM_MSG_CONVERT</span>:
			<span class="n">recover_convert_waiter</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ms_stub</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DLM_MSG_UNLOCK</span>:
			<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">ms_stub</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span><span class="p">));</span>
			<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">=</span> <span class="n">DLM_IFL_STUB_MS</span><span class="p">;</span>
			<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">=</span> <span class="n">DLM_MSG_UNLOCK_REPLY</span><span class="p">;</span>
			<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_result</span> <span class="o">=</span> <span class="n">stub_unlock_result</span><span class="p">;</span>
			<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">;</span>
			<span class="n">_receive_unlock_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms_stub</span><span class="p">);</span>
			<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DLM_MSG_CANCEL</span>:
			<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">ms_stub</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span><span class="p">));</span>
			<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">=</span> <span class="n">DLM_IFL_STUB_MS</span><span class="p">;</span>
			<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_type</span> <span class="o">=</span> <span class="n">DLM_MSG_CANCEL_REPLY</span><span class="p">;</span>
			<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_result</span> <span class="o">=</span> <span class="n">stub_cancel_result</span><span class="p">;</span>
			<span class="n">ms_stub</span><span class="o">-&gt;</span><span class="n">m_header</span><span class="p">.</span><span class="n">h_nodeid</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">;</span>
			<span class="n">_receive_cancel_reply</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">ms_stub</span><span class="p">);</span>
			<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;invalid lkb wait_type %d %d&quot;</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">,</span> <span class="n">wait_type</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ms_stub</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="nf">find_resend_waiter</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters</span><span class="p">,</span> <span class="n">lkb_wait_reply</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_IFL_RESEND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="n">lkb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lkb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Deal with lookups and lkb&#39;s marked RESEND from _pre.  We may now be the</span>
<span class="cm">   master or dir-node for r.  Processing the lkb may result in it being placed</span>
<span class="cm">   back on waiters. */</span>

<span class="cm">/* We do this after normal locking has been enabled and any saved messages</span>
<span class="cm">   (in requestqueue) have been processed.  We should be confident that at</span>
<span class="cm">   this point we won&#39;t get or process a reply to any of these waiting</span>
<span class="cm">   operations.  But, new ops may be coming in on the rsbs/locks here from</span>
<span class="cm">   userspace or remotely. */</span>

<span class="cm">/* there may have been an overlap unlock/cancel prior to recovery or after</span>
<span class="cm">   recovery.  if before, the lkb may still have a pos wait_count; if after, the</span>
<span class="cm">   overlap flag would just have been set and nothing new sent.  we can be</span>
<span class="cm">   confident here than any replies to either the initial op or overlap ops</span>
<span class="cm">   prior to recovery have been received. */</span>

<span class="kt">int</span> <span class="nf">dlm_recover_waiters_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">oc</span><span class="p">,</span> <span class="n">ou</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_locking_stopped</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;recover_waiters_post aborted&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lkb</span> <span class="o">=</span> <span class="n">find_resend_waiter</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
		<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

		<span class="n">mstype</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span><span class="p">;</span>
		<span class="n">oc</span> <span class="o">=</span> <span class="n">is_overlap_cancel</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="n">ou</span> <span class="o">=</span> <span class="n">is_overlap_unlock</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;waiter %x remote %x msg %d r_nodeid %d &quot;</span>
			  <span class="s">&quot;lkb_nodeid %d wait_nodeid %d dir_nodeid %d &quot;</span>
			  <span class="s">&quot;overlap %d %d&quot;</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span>
			  <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_nodeid</span><span class="p">,</span>
			  <span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">oc</span><span class="p">,</span> <span class="n">ou</span><span class="p">);</span>

		<span class="cm">/* At this point we assume that we won&#39;t get a reply to any</span>
<span class="cm">		   previous op or overlap op on this lock.  First, do a big</span>
<span class="cm">		   remove_from_waiters() for all previous ops. */</span>

		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_RESEND</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_UNLOCK</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_IFL_OVERLAP_CANCEL</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_wait_reply</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_waiters_mutex</span><span class="p">);</span>
		<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span> <span class="cm">/* for waiters list */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">oc</span> <span class="o">||</span> <span class="n">ou</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* do an unlock or cancel instead of resending */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">mstype</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP</span>:
			<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
				<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">ou</span> <span class="o">?</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span> <span class="o">:</span>
							<span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">);</span>
				<span class="n">unhold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span> <span class="cm">/* undoes create_lkb() */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_MSG_CONVERT</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">oc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">queue_cast</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">|=</span> <span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">;</span>
					<span class="n">_unlock_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">mstype</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">DLM_MSG_LOOKUP</span>:
			<span class="k">case</span> <span class="n">DLM_MSG_REQUEST</span>:
				<span class="n">_request_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_master</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
					<span class="n">confirm_master</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_MSG_CONVERT</span>:
				<span class="n">_convert_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;waiter %x msg %d r_nodeid %d &quot;</span>
				  <span class="s">&quot;dir_nodeid %d overlap %d %d&quot;</span><span class="p">,</span>
				  <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">,</span> <span class="n">mstype</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_nodeid</span><span class="p">,</span>
				  <span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">oc</span><span class="p">,</span> <span class="n">ou</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">purge_mstcpy_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_master_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* don&#39;t purge lkbs we&#39;ve added in recover_master_copy for</span>
<span class="cm">		   the current recovery seq */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_recover_seq</span> <span class="o">==</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_seq</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">del_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>

		<span class="cm">/* this put should free the lkb */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;purged mstcpy lkb not released&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_purge_mstcpy_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">res_ls</span><span class="p">;</span>

	<span class="n">purge_mstcpy_list</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">);</span>
	<span class="n">purge_mstcpy_list</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">);</span>
	<span class="n">purge_mstcpy_list</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">purge_dead_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">nodeid_gone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_master_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">==</span> <span class="n">nodeid_gone</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">dlm_is_removed</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">del_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>

			<span class="cm">/* this put should free the lkb */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span>
				<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;purged dead lkb not released&quot;</span><span class="p">);</span>

			<span class="n">rsb_set_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_RECOVER_GRANT</span><span class="p">);</span>

			<span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Get rid of locks held by nodes that are gone. */</span>

<span class="kt">void</span> <span class="nf">dlm_recover_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodes_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodeid_gone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lkb_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* cache one removed nodeid to optimize the common</span>
<span class="cm">	   case of a single node removed */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes_gone</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nodes_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nodeid_gone</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_root_sem</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_root_list</span><span class="p">,</span> <span class="n">res_root_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_master</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">purge_dead_list</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">,</span>
					<span class="n">nodeid_gone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb_count</span><span class="p">);</span>
			<span class="n">purge_dead_list</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">,</span>
					<span class="n">nodeid_gone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb_count</span><span class="p">);</span>
			<span class="n">purge_dead_list</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">,</span>
					<span class="n">nodeid_gone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb_count</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">unhold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_root_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb_count</span><span class="p">)</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_purge %u locks for %u nodes&quot;</span><span class="p">,</span>
			  <span class="n">lkb_count</span><span class="p">,</span> <span class="n">nodes_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="nf">find_grant_rsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bucket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">keep</span><span class="p">);</span> <span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">,</span> <span class="n">res_hashnode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsb_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_RECOVER_GRANT</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rsb_clear_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_RECOVER_GRANT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_master</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to grant locks on resources that we are the master of.</span>
<span class="cm"> * Locks may have become grantable during recovery because locks</span>
<span class="cm"> * from departed nodes have been purged (or not rebuilt), allowing</span>
<span class="cm"> * previously blocked locks to now be granted.  The subset of rsb&#39;s</span>
<span class="cm"> * we are interested in are those with lkb&#39;s on either the convert or</span>
<span class="cm"> * waiting queues.</span>
<span class="cm"> *</span>
<span class="cm"> * Simplest would be to go through each master rsb and check for non-empty</span>
<span class="cm"> * convert or waiting queues, and attempt to grant on those rsbs.</span>
<span class="cm"> * Checking the queues requires lock_rsb, though, for which we&#39;d need</span>
<span class="cm"> * to release the rsbtbl lock.  This would make iterating through all</span>
<span class="cm"> * rsb&#39;s very inefficient.  So, we rely on earlier recovery routines</span>
<span class="cm"> * to set RECOVER_GRANT on any rsb&#39;s that we should attempt to grant</span>
<span class="cm"> * locks for.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">dlm_recover_grant</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bucket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsb_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lkb_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">find_grant_rsb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">bucket</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bucket</span> <span class="o">==</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_rsbtbl_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">bucket</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rsb_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">grant_pending_locks</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">lkb_count</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">confirm_master</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb_count</span><span class="p">)</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_grant %u locks on %u resources&quot;</span><span class="p">,</span>
			  <span class="n">lkb_count</span><span class="p">,</span> <span class="n">rsb_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="nf">search_remid_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span>
					 <span class="kt">uint32_t</span> <span class="n">remid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">lkb_statequeue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">==</span> <span class="n">nodeid</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span> <span class="o">==</span> <span class="n">remid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lkb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="nf">search_remid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span>
				    <span class="kt">uint32_t</span> <span class="n">remid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>

	<span class="n">lkb</span> <span class="o">=</span> <span class="n">search_remid_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_grantqueue</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lkb</span><span class="p">;</span>
	<span class="n">lkb</span> <span class="o">=</span> <span class="n">search_remid_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lkb</span><span class="p">;</span>
	<span class="n">lkb</span> <span class="o">=</span> <span class="n">search_remid_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lkb</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* needs at least dlm_rcom + rcom_lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_rcom_lock_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rcom</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcom_lock</span> <span class="o">*</span><span class="n">rl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rcom_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_buf</span><span class="p">;</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_nodeid</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownpid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_ownpid</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_lkid</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_exflags</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0000FFFF</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_MSTCPY</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbseq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_lvbseq</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_rqmode</span> <span class="o">=</span> <span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_rqmode</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_grmode</span><span class="p">;</span>
	<span class="cm">/* don&#39;t set lkb_status because add_lkb wants to itself */</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_bastfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_asts</span> <span class="o">&amp;</span> <span class="n">DLM_CB_BAST</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">fake_bastfn</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_astfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_asts</span> <span class="o">&amp;</span> <span class="n">DLM_CB_CAST</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">fake_astfn</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lvblen</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_length</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rcom</span><span class="p">)</span> <span class="o">-</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcom_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lvblen</span> <span class="o">&gt;</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_lvblen</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span> <span class="o">=</span> <span class="n">dlm_allocate_lvb</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_lvbptr</span><span class="p">,</span> <span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_lvb</span><span class="p">,</span> <span class="n">lvblen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Conversions between PR and CW (middle modes) need special handling.</span>
<span class="cm">	   The real granted mode of these converting locks cannot be determined</span>
<span class="cm">	   until all locks have been rebuilt on the rsb (recover_conversion) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_wait_type</span> <span class="o">==</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">DLM_MSG_CONVERT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">middle_conversion</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_status</span> <span class="o">=</span> <span class="n">DLM_LKSTS_CONVERT</span><span class="p">;</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_grmode</span> <span class="o">=</span> <span class="n">DLM_LOCK_IV</span><span class="p">;</span>
		<span class="n">rsb_set_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_RECOVER_CONVERT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This lkb may have been recovered in a previous aborted recovery so we need</span>
<span class="cm">   to check if the rsb already has an lkb with the given remote nodeid/lkid.</span>
<span class="cm">   If so we just send back a standard reply.  If not, we create a new lkb with</span>
<span class="cm">   the given values and send back our lkid.  We send back our lkid by sending</span>
<span class="cm">   back the rcom_lock struct we got but with the remid field filled in. */</span>

<span class="cm">/* needs at least dlm_rcom + rcom_lock */</span>
<span class="kt">int</span> <span class="nf">dlm_recover_master_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rcom</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcom_lock</span> <span class="o">*</span><span class="n">rl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rcom_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">remid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_parent_lkid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">remid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_lkid</span><span class="p">);</span>

	<span class="cm">/* In general we expect the rsb returned to be R_MASTER, but we don&#39;t</span>
<span class="cm">	   have to require it.  Recovery of masters on one node can overlap</span>
<span class="cm">	   recovery of locks on another node, so one node can send us MSTCPY</span>
<span class="cm">	   locks before we&#39;ve made ourselves master of this rsb.  We can still</span>
<span class="cm">	   add new MSTCPY locks that we receive here without any harm; when</span>
<span class="cm">	   we make ourselves master, dlm_recover_masters() won&#39;t touch the</span>
<span class="cm">	   MSTCPY locks we&#39;ve received early. */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_rsb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_name</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_namelen</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_no_directory</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dlm_dir_nodeid</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dlm_our_nodeid</span><span class="p">()))</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_master_copy remote %d %x not dir&quot;</span><span class="p">,</span>
			  <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
		<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">lkb</span> <span class="o">=</span> <span class="n">search_remid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_remid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">receive_rcom_lock_args</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__put_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">attach_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
	<span class="n">add_lkb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_status</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_locks_in</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_waitqueue</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_convertqueue</span><span class="p">))</span>
		<span class="n">rsb_set_flag</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RSB_RECOVER_GRANT</span><span class="p">);</span>

 <span class="nl">out_remid:</span>
	<span class="cm">/* this is the new value returned to the lock holder for</span>
<span class="cm">	   saving in its process-copy lkb */</span>
	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_remid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_id</span><span class="p">);</span>

	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_recover_seq</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_seq</span><span class="p">;</span>

 <span class="nl">out_unlock:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_master_copy remote %d %x error %d&quot;</span><span class="p">,</span>
			  <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_result</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* needs at least dlm_rcom + rcom_lock */</span>
<span class="kt">int</span> <span class="nf">dlm_recover_process_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rcom</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcom_lock</span> <span class="o">*</span><span class="n">rl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rcom_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">lkid</span><span class="p">,</span> <span class="n">remid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">lkid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_lkid</span><span class="p">);</span>
	<span class="n">remid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_remid</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">rl_result</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_process_copy no %x remote %d %x %d&quot;</span><span class="p">,</span>
			  <span class="n">lkid</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_process_copy</span><span class="p">(</span><span class="n">lkb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_process_copy bad %x remote %d %x %d&quot;</span><span class="p">,</span>
			  <span class="n">lkid</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">dlm_dump_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EBADR</span>:
		<span class="cm">/* There&#39;s a chance the new master received our lock before</span>
<span class="cm">		   dlm_recover_master_reply(), this wouldn&#39;t happen if we did</span>
<span class="cm">		   a barrier between recover_masters and recover_locks. */</span>

		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_process_copy %x remote %d %x %d&quot;</span><span class="p">,</span>
			  <span class="n">lkid</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	
		<span class="n">dlm_send_rcom_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EEXIST</span>:
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_remid</span> <span class="o">=</span> <span class="n">remid</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_process_copy %x remote %d %x %d unk&quot;</span><span class="p">,</span>
			  <span class="n">lkid</span><span class="p">,</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">.</span><span class="n">h_nodeid</span><span class="p">,</span> <span class="n">remid</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* an ack for dlm_recover_locks() which waits for replies from</span>
<span class="cm">	   all the locks it sends to new masters */</span>
	<span class="n">dlm_recovered_lock</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_user_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="o">*</span><span class="n">ua</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout_cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ua</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">DLM_USER_LVB_LEN</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ua</span><span class="p">);</span>
			<span class="n">__put_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* After ua is attached to lkb it will be freed by dlm_free_lkb().</span>
<span class="cm">	   When DLM_IFL_USER is set, the dlm knows that this is a userspace</span>
<span class="cm">	   lock and that lkb_astparam is the dlm_user_args structure. */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_lock_args</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">timeout_cs</span><span class="p">,</span>
			      <span class="n">fake_astfn</span><span class="p">,</span> <span class="n">ua</span><span class="p">,</span> <span class="n">fake_bastfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_USER</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__put_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">request_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="nl">default:</span>
		<span class="n">__put_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* add this new lkb to the per-process list of locks */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks_spin</span><span class="p">);</span>
	<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks_spin</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_user_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="o">*</span><span class="n">ua_tmp</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">lkid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lvb_in</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout_cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="o">*</span><span class="n">ua</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* user can change the params on its lock when it converts it, or</span>
<span class="cm">	   add an lvb that didn&#39;t exist before */</span>

	<span class="n">ua</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ua</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_VALBLK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">DLM_USER_LVB_LEN</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lvb_in</span> <span class="o">&amp;&amp;</span> <span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span><span class="p">,</span> <span class="n">lvb_in</span><span class="p">,</span> <span class="n">DLM_USER_LVB_LEN</span><span class="p">);</span>

	<span class="n">ua</span><span class="o">-&gt;</span><span class="n">xid</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">xid</span><span class="p">;</span>
	<span class="n">ua</span><span class="o">-&gt;</span><span class="n">castparam</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">castparam</span><span class="p">;</span>
	<span class="n">ua</span><span class="o">-&gt;</span><span class="n">castaddr</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">castaddr</span><span class="p">;</span>
	<span class="n">ua</span><span class="o">-&gt;</span><span class="n">bastparam</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">bastparam</span><span class="p">;</span>
	<span class="n">ua</span><span class="o">-&gt;</span><span class="n">bastaddr</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">bastaddr</span><span class="p">;</span>
	<span class="n">ua</span><span class="o">-&gt;</span><span class="n">user_lksb</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">user_lksb</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_lock_args</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">timeout_cs</span><span class="p">,</span>
			      <span class="n">fake_astfn</span><span class="p">,</span> <span class="n">ua</span><span class="p">,</span> <span class="n">fake_bastfn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">convert_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span> <span class="o">||</span> <span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_put:</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ua_tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_user_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="o">*</span><span class="n">ua_tmp</span><span class="p">,</span>
		    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">lkid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lvb_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="o">*</span><span class="n">ua</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ua</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ua</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lvb_in</span> <span class="o">&amp;&amp;</span> <span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span><span class="p">,</span> <span class="n">lvb_in</span><span class="p">,</span> <span class="n">DLM_USER_LVB_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">castparam</span><span class="p">)</span>
		<span class="n">ua</span><span class="o">-&gt;</span><span class="n">castparam</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">castparam</span><span class="p">;</span>
	<span class="n">ua</span><span class="o">-&gt;</span><span class="n">user_lksb</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">user_lksb</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_unlock_args</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">ua</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">unlock_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* from validate_unlock_args() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks_spin</span><span class="p">);</span>
	<span class="cm">/* dlm_user_add_cb() may have already taken lkb off the proc list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">))</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">unlocking</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ua</span><span class="o">-&gt;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks_spin</span><span class="p">);</span>
 <span class="nl">out_put:</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ua_tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_user_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="o">*</span><span class="n">ua_tmp</span><span class="p">,</span>
		    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">lkid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="o">*</span><span class="n">ua</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ua</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ua</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">castparam</span><span class="p">)</span>
		<span class="n">ua</span><span class="o">-&gt;</span><span class="n">castparam</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">castparam</span><span class="p">;</span>
	<span class="n">ua</span><span class="o">-&gt;</span><span class="n">user_lksb</span> <span class="o">=</span> <span class="n">ua_tmp</span><span class="o">-&gt;</span><span class="n">user_lksb</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_unlock_args</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">ua</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">cancel_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* from validate_unlock_args() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_put:</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ua_tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_user_deadlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">lkid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="o">*</span><span class="n">ua</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">find_lkb</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ua</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ua</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_unlock_args</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">ua</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="cm">/* same as cancel_lock(), but set DEADLOCK_CANCEL after lock_rsb */</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_resource</span><span class="p">;</span>
	<span class="n">hold_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">lock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">validate_unlock_args</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_r</span><span class="p">;</span>
	<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_DEADLOCK_CANCEL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_cancel_lock</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out_r:</span>
	<span class="n">unlock_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="n">put_rsb</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* from validate_unlock_args() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_put:</span>
	<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lkb&#39;s that are removed from the waiters list by revert are just left on the</span>
<span class="cm">   orphans list with the granted orphan locks, to be freed by purge */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">orphan_proc_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">hold_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_orphans_mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_orphans</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_orphans_mutex</span><span class="p">);</span>

	<span class="n">set_unlock_args</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ua</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">cancel_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The force flag allows the unlock to go ahead even if the lkb isn&#39;t granted.</span>
<span class="cm">   Regardless of what rsb queue the lock is on, it&#39;s removed and freed. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlock_proc_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">set_unlock_args</span><span class="p">(</span><span class="n">DLM_LKF_FORCEUNLOCK</span><span class="p">,</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ua</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">unlock_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We have to release clear_proc_locks mutex before calling unlock_proc_lock()</span>
<span class="cm">   (which does lock_rsb) due to deadlock with receiving a message that does</span>
<span class="cm">   lock_rsb followed by dlm_user_add_cb() */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="nf">del_proc_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_user_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_clear_proc_locks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">lkb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span><span class="p">,</span> <span class="n">lkb_ownqueue</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_PERSISTENT</span><span class="p">)</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_ORPHAN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_DEAD</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_clear_proc_locks</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lkb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The ls_clear_proc_locks mutex protects against dlm_user_add_cb() which</span>
<span class="cm">   1) references lkb-&gt;ua which we free here and 2) adds lkbs to proc-&gt;asts,</span>
<span class="cm">   which we clear here. */</span>

<span class="cm">/* proc CLOSING flag is set so no more device_reads should look at proc-&gt;asts</span>
<span class="cm">   list, and no more device_writes should add lkb&#39;s to proc-&gt;locks list; so we</span>
<span class="cm">   shouldn&#39;t need to take asts_spin or locks_spin here.  this assumes that</span>
<span class="cm">   device reads/writes/closes are serialized -- FIXME: we may need to serialize</span>
<span class="cm">   them ourself. */</span>

<span class="kt">void</span> <span class="nf">dlm_clear_proc_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_user_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>

	<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkb</span> <span class="o">=</span> <span class="n">del_proc_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">proc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">del_timeout</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_exflags</span> <span class="o">&amp;</span> <span class="n">DLM_LKF_PERSISTENT</span><span class="p">)</span>
			<span class="n">orphan_proc_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">unlock_proc_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>

		<span class="cm">/* this removes the reference for the proc-&gt;locks list</span>
<span class="cm">		   added by dlm_user_request, it may result in the lkb</span>
<span class="cm">		   being freed */</span>

		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_clear_proc_locks</span><span class="p">);</span>

	<span class="cm">/* in-progress unlocks */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">unlocking</span><span class="p">,</span> <span class="n">lkb_ownqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_DEAD</span><span class="p">;</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">asts</span><span class="p">,</span> <span class="n">lkb_cb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_callbacks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_callback</span><span class="p">)</span> <span class="o">*</span> <span class="n">DLM_CALLBACKS_SIZE</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_cb_list</span><span class="p">);</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_clear_proc_locks</span><span class="p">);</span>
	<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">purge_proc_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_user_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks_spin</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lkb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lkb</span><span class="p">,</span>
					 <span class="n">lkb_ownqueue</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks_spin</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lkb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_DEAD</span><span class="p">;</span>
		<span class="n">unlock_proc_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span> <span class="cm">/* ref from proc-&gt;locks list */</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks_spin</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">unlocking</span><span class="p">,</span> <span class="n">lkb_ownqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">);</span>
		<span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_flags</span> <span class="o">|=</span> <span class="n">DLM_IFL_DEAD</span><span class="p">;</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">locks_spin</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">asts_spin</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">asts</span><span class="p">,</span> <span class="n">lkb_cb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_callbacks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_callback</span><span class="p">)</span> <span class="o">*</span> <span class="n">DLM_CALLBACKS_SIZE</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_cb_list</span><span class="p">);</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">asts_spin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* pid of 0 means purge all orphans */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_orphans_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lkb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_orphans</span><span class="p">,</span> <span class="n">lkb_ownqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&amp;&amp;</span> <span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownpid</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">unlock_proc_lock</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">lkb</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkb</span><span class="o">-&gt;</span><span class="n">lkb_ownqueue</span><span class="p">);</span>
		<span class="n">dlm_put_lkb</span><span class="p">(</span><span class="n">lkb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_orphans_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_message</span> <span class="o">*</span><span class="n">ms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_mhandle</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_create_message</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_message</span><span class="p">),</span> <span class="n">nodeid</span><span class="p">,</span>
				<span class="n">DLM_MSG_PURGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_nodeid</span> <span class="o">=</span> <span class="n">nodeid</span><span class="p">;</span>
	<span class="n">ms</span><span class="o">-&gt;</span><span class="n">m_pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">send_message</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_user_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_user_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nodeid</span> <span class="o">!=</span> <span class="n">dlm_our_nodeid</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">send_purge</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dlm_lock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
			<span class="n">purge_proc_locks</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">proc</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">do_purge</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
		<span class="n">dlm_unlock_recovery</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
