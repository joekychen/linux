<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › fix_node.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fix_node.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> ** old_item_num</span>
<span class="cm"> ** old_entry_num</span>
<span class="cm"> ** set_entry_sizes</span>
<span class="cm"> ** create_virtual_node</span>
<span class="cm"> ** check_left</span>
<span class="cm"> ** check_right</span>
<span class="cm"> ** directory_part_size</span>
<span class="cm"> ** get_num_ver</span>
<span class="cm"> ** set_parameters</span>
<span class="cm"> ** is_leaf_removable</span>
<span class="cm"> ** are_leaves_removable</span>
<span class="cm"> ** get_empty_nodes</span>
<span class="cm"> ** get_lfree</span>
<span class="cm"> ** get_rfree</span>
<span class="cm"> ** is_left_neighbor_in_cache</span>
<span class="cm"> ** decrement_key</span>
<span class="cm"> ** get_far_parent</span>
<span class="cm"> ** get_parents</span>
<span class="cm"> ** can_node_be_removed</span>
<span class="cm"> ** ip_check_balance</span>
<span class="cm"> ** dc_check_balance_internal</span>
<span class="cm"> ** dc_check_balance_leaf</span>
<span class="cm"> ** dc_check_balance</span>
<span class="cm"> ** check_balance</span>
<span class="cm"> ** get_direct_parent</span>
<span class="cm"> ** get_neighbors</span>
<span class="cm"> ** fix_nodes</span>
<span class="cm"> **</span>
<span class="cm"> **</span>
<span class="cm"> **/</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>

<span class="cm">/* To make any changes in the tree we find a node, that contains item</span>
<span class="cm">   to be changed/deleted or position in the node we insert a new item</span>
<span class="cm">   to. We call this node S. To do balancing we need to decide what we</span>
<span class="cm">   will shift to left/right neighbor, or to a new node, where new item</span>
<span class="cm">   will be etc. To make this analysis simpler we build virtual</span>
<span class="cm">   node. Virtual node is an array of items, that will replace items of</span>
<span class="cm">   node S. (For instance if we are going to delete an item, virtual</span>
<span class="cm">   node does not contain it). Virtual node keeps information about</span>
<span class="cm">   item sizes and types, mergeability of first and last items, sizes</span>
<span class="cm">   of all entries in directory item. We use this array of items when</span>
<span class="cm">   calculating what we can shift to neighbors and how many nodes we</span>
<span class="cm">   have to have if we do not any shiftings, if we shift to left/right</span>
<span class="cm">   neighbor or to both. */</span>

<span class="cm">/* taking item number in virtual node, returns number of item, that it has in source buffer */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">old_item_num</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">affected_item_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_PASTE</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">M_CUT</span> <span class="o">||</span> <span class="n">new_num</span> <span class="o">&lt;</span> <span class="n">affected_item_num</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">new_num</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_INSERT</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">new_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="s">&quot;vs-8005: for INSERT mode and item number of inserted item&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">new_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">M_DELETE</span><span class="p">,</span>
	       <span class="s">&quot;vs-8010: old_item_num: mode must be M_DELETE (mode = </span><span class="se">\&#39;</span><span class="s">%c</span><span class="se">\&#39;</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">mode</span><span class="p">);</span>
	<span class="cm">/* delete mode */</span>
	<span class="k">return</span> <span class="n">new_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">create_virtual_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">Sh</span><span class="p">;</span>	<span class="cm">/* this comes from tb-&gt;S[h] */</span>

	<span class="n">Sh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/* size of changed node */</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_size</span> <span class="o">=</span>
	    <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">-</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>

	<span class="cm">/* for internal nodes array if virtual items is not created */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">=</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_size</span> <span class="o">-</span> <span class="n">DC_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* number of items in virtual node  */</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">=</span>
	    <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_INSERT</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span>
	    <span class="p">((</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_DELETE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* first virtual item */</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span><span class="p">)(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span><span class="p">));</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_free_ptr</span> <span class="o">+=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span><span class="p">);</span>

	<span class="cm">/* first item in the node */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">Sh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* define the mergeability for 0-th item (if it is not being deleted) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">Sh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">!=</span> <span class="n">M_DELETE</span> <span class="o">||</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_affected_item_num</span><span class="p">))</span>
		<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vi_type</span> <span class="o">|=</span> <span class="n">VI_TYPE_LEFT_MERGEABLE</span><span class="p">;</span>

	<span class="cm">/* go through all items those remain in the virtual node (except for the new (inserted) one) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">new_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">new_num</span> <span class="o">&lt;</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">;</span> <span class="n">new_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span> <span class="o">+</span> <span class="n">new_num</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">is_affected</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">new_num</span> <span class="o">!=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_affected_item_num</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_affected</span> <span class="o">&amp;&amp;</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_INSERT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* get item number in source node */</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">old_item_num</span><span class="p">(</span><span class="n">new_num</span><span class="p">,</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_affected_item_num</span><span class="p">,</span>
				 <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">);</span>

		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_item_len</span> <span class="o">+=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="n">IH_SIZE</span><span class="p">;</span>
		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_ih</span> <span class="o">=</span> <span class="n">ih</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_item</span> <span class="o">=</span> <span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">Sh</span><span class="p">,</span> <span class="n">ih</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_uarea</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_free_ptr</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>FIXME: there is no check, that item operation did not
consume too much memory</p></td><td class="code"><div class="highlight"><pre>		<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_free_ptr</span> <span class="o">+=</span>
		    <span class="n">op_create_vi</span><span class="p">(</span><span class="n">vn</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">is_affected</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf_size</span> <span class="o">&lt;</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_free_ptr</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-8030&quot;</span><span class="p">,</span>
				       <span class="s">&quot;virtual node space consumed&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_affected</span><span class="p">)</span>
			<span class="cm">/* this is not being changed */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_PASTE</span> <span class="o">||</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_CUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="n">new_num</span><span class="p">].</span><span class="n">vi_item_len</span> <span class="o">+=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_new_data</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_data</span><span class="p">;</span>	<span class="c1">// pointer to data which is going to be pasted</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* virtual inserted item is not defined yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_INSERT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span> <span class="o">+</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_affected_item_num</span><span class="p">;</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_ins_ih</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
		       <span class="s">&quot;vs-8040: item header of inserted item is not specified&quot;</span><span class="p">);</span>
		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_item_len</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_ih</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_ins_ih</span><span class="p">;</span>
		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_item</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_data</span><span class="p">;</span>
		<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_uarea</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_free_ptr</span><span class="p">;</span>

		<span class="n">op_create_vi</span><span class="p">(</span><span class="n">vn</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/*not pasted or cut */</span> <span class="p">,</span>
			     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* set right merge flag we take right delimiting key and check whether it is a mergeable item */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

		<span class="n">key</span> <span class="o">=</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Sh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">!=</span> <span class="n">M_DELETE</span>
			<span class="o">||</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_affected_item_num</span> <span class="o">!=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">vi_type</span> <span class="o">|=</span>
			    <span class="n">VI_TYPE_RIGHT_MERGEABLE</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Sh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">!=</span> <span class="n">M_DELETE</span>
		      <span class="o">||</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_affected_item_num</span> <span class="o">!=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* we delete last item and it could be merged with right neighbor&#39;s first item */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span>
			    <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
			     <span class="o">&amp;&amp;</span> <span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">Sh</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			     <span class="o">&amp;&amp;</span> <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">Sh</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* node contains more than 1 item, or item is not directory item, or this item contains more than 1 entry */</span>
				<span class="n">print_block</span><span class="p">(</span><span class="n">Sh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-8045&quot;</span><span class="p">,</span>
					       <span class="s">&quot;rdkey %k, affected item==%d &quot;</span>
					       <span class="s">&quot;(mode==%c) Must be %c&quot;</span><span class="p">,</span>
					       <span class="n">key</span><span class="p">,</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_affected_item_num</span><span class="p">,</span>
					       <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">M_DELETE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* using virtual node check, how many items can be shifted to left</span>
<span class="cm">   neighbor */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cur_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">d_size</span><span class="p">,</span> <span class="n">ih_size</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">cur_free</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;vs-8050: cur_free (%d) &lt; 0&quot;</span><span class="p">,</span> <span class="n">cur_free</span><span class="p">);</span>

	<span class="cm">/* internal level */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_free</span> <span class="o">/</span> <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* leaf level */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur_free</span> <span class="o">||</span> <span class="o">!</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no free space or nothing to move */</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	       <span class="s">&quot;vs-8055: parent does not exist or invalid&quot;</span><span class="p">);</span>

	<span class="n">vi</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">cur_free</span> <span class="o">&gt;=</span>
	    <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_size</span> <span class="o">-</span>
	     <span class="p">((</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_type</span> <span class="o">&amp;</span> <span class="n">VI_TYPE_LEFT_MERGEABLE</span><span class="p">)</span> <span class="o">?</span> <span class="n">IH_SIZE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* all contents of S[0] fits into L[0] */</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_INSERT</span> <span class="o">||</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_PASTE</span><span class="p">,</span>
		       <span class="s">&quot;vs-8055: invalid mode or balance condition failed&quot;</span><span class="p">);</span>

		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ih_size</span> <span class="o">=</span> <span class="n">IH_SIZE</span><span class="p">;</span>

	<span class="cm">/* first item may be merge with last item in left neighbor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_type</span> <span class="o">&amp;</span> <span class="n">VI_TYPE_LEFT_MERGEABLE</span><span class="p">)</span>
		<span class="n">d_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">IH_SIZE</span><span class="p">),</span> <span class="n">ih_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">;</span>
	     <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ih_size</span> <span class="o">=</span> <span class="n">IH_SIZE</span><span class="p">,</span> <span class="n">d_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d_size</span> <span class="o">+=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_item_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_free</span> <span class="o">&gt;=</span> <span class="n">d_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* the item can be shifted entirely */</span>
			<span class="n">cur_free</span> <span class="o">-=</span> <span class="n">d_size</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* the item cannot be shifted entirely, try to split it */</span>
		<span class="cm">/* check whether L[0] can hold ih and at least one byte of the item body */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_free</span> <span class="o">&lt;=</span> <span class="n">ih_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* cannot shift even a part of the current item */</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur_free</span> <span class="o">-=</span> <span class="n">ih_size</span><span class="p">;</span>

		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">=</span> <span class="n">op_check_left</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">cur_free</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* count partially shifted item */</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* using virtual node check, how many items can be shifted to right</span>
<span class="cm">   neighbor */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cur_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">d_size</span><span class="p">,</span> <span class="n">ih_size</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">cur_free</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;vs-8070: cur_free &lt; 0&quot;</span><span class="p">);</span>

	<span class="cm">/* internal level */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_free</span> <span class="o">/</span> <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* leaf level */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur_free</span> <span class="o">||</span> <span class="o">!</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no free space  */</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	       <span class="s">&quot;vs-8075: parent does not exist or invalid&quot;</span><span class="p">);</span>

	<span class="n">vi</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span> <span class="o">+</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">cur_free</span> <span class="o">&gt;=</span>
	    <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_size</span> <span class="o">-</span>
	     <span class="p">((</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_type</span> <span class="o">&amp;</span> <span class="n">VI_TYPE_RIGHT_MERGEABLE</span><span class="p">)</span> <span class="o">?</span> <span class="n">IH_SIZE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* all contents of S[0] fits into R[0] */</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_INSERT</span> <span class="o">||</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">==</span> <span class="n">M_PASTE</span><span class="p">,</span>
		       <span class="s">&quot;vs-8080: invalid mode or balance condition failed&quot;</span><span class="p">);</span>

		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ih_size</span> <span class="o">=</span> <span class="n">IH_SIZE</span><span class="p">;</span>

	<span class="cm">/* last item may be merge with first item in right neighbor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_type</span> <span class="o">&amp;</span> <span class="n">VI_TYPE_RIGHT_MERGEABLE</span><span class="p">)</span>
		<span class="n">d_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">IH_SIZE</span><span class="p">,</span> <span class="n">ih_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">d_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ih_size</span> <span class="o">=</span> <span class="n">IH_SIZE</span><span class="p">,</span> <span class="n">vi</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d_size</span> <span class="o">+=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_item_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_free</span> <span class="o">&gt;=</span> <span class="n">d_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* the item can be shifted entirely */</span>
			<span class="n">cur_free</span> <span class="o">-=</span> <span class="n">d_size</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* check whether R[0] can hold ih and at least one byte of the item body */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_free</span> <span class="o">&lt;=</span> <span class="n">ih_size</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* cannot shift even a part of the current item */</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* R[0] can hold the header of the item and at least one byte of its body */</span>
		<span class="n">cur_free</span> <span class="o">-=</span> <span class="n">ih_size</span><span class="p">;</span>	<span class="cm">/* cur_free is still &gt; 0 */</span>

		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">=</span> <span class="n">op_check_right</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">cur_free</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* count partially shifted item */</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * from - number of items, which are shifted to left neighbor entirely</span>
<span class="cm"> * to - number of item, which are shifted to right neighbor entirely</span>
<span class="cm"> * from_bytes - number of bytes of boundary item (or directory entries) which are shifted to left neighbor</span>
<span class="cm"> * to_bytes - number of bytes of boundary item (or directory entries) which are shifted to right neighbor */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_num_ver</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from_bytes</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to_bytes</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">snum012</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cur_free</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>int bytes;</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">int</span> <span class="n">units</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>struct virtual_item * vi;</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">int</span> <span class="n">total_node_size</span><span class="p">,</span> <span class="n">max_node_size</span><span class="p">,</span> <span class="n">current_item_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needed_nodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_item</span><span class="p">,</span>		<span class="cm">/* position of item we start filling node from */</span>
	 <span class="n">end_item</span><span class="p">,</span>		<span class="cm">/* position of item we finish filling node by */</span>
	 <span class="n">start_bytes</span><span class="p">,</span>		<span class="cm">/* number of first bytes (entries for directory) of start_item-th item</span>
<span class="cm">				   we do not include into node that is being filled */</span>
	 <span class="n">end_bytes</span><span class="p">;</span>		<span class="cm">/* number of last bytes (entries for directory) of end_item-th item</span>
<span class="cm">				   we do node include into node that is being filled */</span>
	<span class="kt">int</span> <span class="n">split_item_positions</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* these are positions in virtual item of</span>
<span class="cm">					   items, that are split between S[0] and</span>
<span class="cm">					   S1new and S1new and S2new */</span>

	<span class="n">split_item_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">split_item_positions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* We only create additional nodes if we are in insert or paste mode</span>
<span class="cm">	   or we are in replace mode at the internal level. If h is 0 and</span>
<span class="cm">	   the mode is M_REPLACE then in fix_nodes we change the mode to</span>
<span class="cm">	   paste or insert before we get here in the code.  */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">M_INSERT</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">M_PASTE</span><span class="p">),</span>
	       <span class="s">&quot;vs-8100: insert_size &lt; 0 in overflow&quot;</span><span class="p">);</span>

	<span class="n">max_node_size</span> <span class="o">=</span> <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">));</span>

	<span class="cm">/* snum012 [0-2] - number of items, that lay</span>
<span class="cm">	   to S[0], first new node and second new node */</span>
	<span class="n">snum012</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* s1bytes */</span>
	<span class="n">snum012</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* s2bytes */</span>

	<span class="cm">/* internal level */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">((</span><span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="n">DC_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="n">DC_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">max_node_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">max_node_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* leaf level */</span>
	<span class="n">needed_nodes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">total_node_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cur_free</span> <span class="o">=</span> <span class="n">max_node_size</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>start from 'from'-th item</p></td><td class="code"><div class="highlight"><pre>	<span class="n">start_item</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>skip its first 'start_bytes' units</p></td><td class="code"><div class="highlight"><pre>	<span class="n">start_bytes</span> <span class="o">=</span> <span class="p">((</span><span class="n">from_bytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">from_bytes</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>last included item is the 'end_item'-th one</p></td><td class="code"><div class="highlight"><pre>	<span class="n">end_item</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">-</span> <span class="n">to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>do not count last 'end<em>bytes' units of 'end</em>item'-th item</p></td><td class="code"><div class="highlight"><pre>	<span class="n">end_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">to_bytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">to_bytes</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* go through all item beginning from the start_item-th item and ending by</span>
<span class="cm">	   the end_item-th item. Do not count first &#39;start_bytes&#39; units of</span>
<span class="cm">	   &#39;start_item&#39;-th item and last &#39;end_bytes&#39; of &#39;end_item&#39;-th item */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_item</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end_item</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">skip_from_end</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">end_item</span><span class="p">)</span> <span class="o">?</span> <span class="n">end_bytes</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">needed_nodes</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;vs-8105: too many nodes are needed&quot;</span><span class="p">);</span>

		<span class="cm">/* get size of current item */</span>
		<span class="n">current_item_size</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_item_len</span><span class="p">;</span>

		<span class="cm">/* do not take in calculation head part (from_bytes) of from-th item */</span>
		<span class="n">current_item_size</span> <span class="o">-=</span>
		    <span class="n">op_part_size</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/*from start */</span> <span class="p">,</span> <span class="n">start_bytes</span><span class="p">);</span>

		<span class="cm">/* do not take in calculation tail part of last item */</span>
		<span class="n">current_item_size</span> <span class="o">-=</span>
		    <span class="n">op_part_size</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/*from end */</span> <span class="p">,</span> <span class="n">skip_from_end</span><span class="p">);</span>

		<span class="cm">/* if item fits into current node entierly */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_node_size</span> <span class="o">+</span> <span class="n">current_item_size</span> <span class="o">&lt;=</span> <span class="n">max_node_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snum012</span><span class="p">[</span><span class="n">needed_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="n">total_node_size</span> <span class="o">+=</span> <span class="n">current_item_size</span><span class="p">;</span>
			<span class="n">start_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">current_item_size</span> <span class="o">&gt;</span> <span class="n">max_node_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* virtual item length is longer, than max size of item in</span>
<span class="cm">			   a node. It is impossible for direct item */</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">vi_ih</span><span class="p">),</span>
			       <span class="s">&quot;vs-8110: &quot;</span>
			       <span class="s">&quot;direct item length is %d. It can not be longer than %d&quot;</span><span class="p">,</span>
			       <span class="n">current_item_size</span><span class="p">,</span> <span class="n">max_node_size</span><span class="p">);</span>
			<span class="cm">/* we will try to split it */</span>
			<span class="n">flow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flow</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* as we do not split items, take new node and continue */</span>
			<span class="n">needed_nodes</span><span class="o">++</span><span class="p">;</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="n">total_node_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>calculate number of item units which fit into node being
filled</p></td><td class="code"><div class="highlight"><pre>		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">free_space</span><span class="p">;</span>

			<span class="n">free_space</span> <span class="o">=</span> <span class="n">max_node_size</span> <span class="o">-</span> <span class="n">total_node_size</span> <span class="o">-</span> <span class="n">IH_SIZE</span><span class="p">;</span>
			<span class="n">units</span> <span class="o">=</span>
			    <span class="n">op_check_left</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">free_space</span><span class="p">,</span> <span class="n">start_bytes</span><span class="p">,</span>
					  <span class="n">skip_from_end</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">units</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* nothing fits into current node, take new node and continue */</span>
				<span class="n">needed_nodes</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">total_node_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* something fits into the current node */</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>if (snum012[3] != -1 || needed<em>nodes != 1)
 reiserfs</em>panic (tb->tb<em>sb, "vs-8115: get</em>num<em>ver: too many nodes required");
snum012[needed</em>nodes - 1 + 3] = op<em>unit</em>num (vi) - start_bytes - units;</p></td><td class="code"><div class="highlight"><pre>		<span class="n">start_bytes</span> <span class="o">+=</span> <span class="n">units</span><span class="p">;</span>
		<span class="n">snum012</span><span class="p">[</span><span class="n">needed_nodes</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">units</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">needed_nodes</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-8111&quot;</span><span class="p">,</span>
					 <span class="s">&quot;split_item_position is out of range&quot;</span><span class="p">);</span>
		<span class="n">snum012</span><span class="p">[</span><span class="n">needed_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">split_item_positions</span><span class="p">[</span><span class="n">needed_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">needed_nodes</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* continue from the same item with start_bytes != -1 */</span>
		<span class="n">start_item</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="n">total_node_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>sum012[4] (if it is not -1) contains number of units of which
are to be in S1new, snum012[3] - to be in S0. They are supposed
to be S1bytes and S2bytes correspondingly, so recalculate</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">snum012</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">split_item_num</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bytes_to_r</span><span class="p">,</span> <span class="n">bytes_to_l</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bytes_to_S1new</span><span class="p">;</span>

		<span class="n">split_item_num</span> <span class="o">=</span> <span class="n">split_item_positions</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">bytes_to_l</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">from</span> <span class="o">==</span> <span class="n">split_item_num</span>
		      <span class="o">&amp;&amp;</span> <span class="n">from_bytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">from_bytes</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bytes_to_r</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">end_item</span> <span class="o">==</span> <span class="n">split_item_num</span>
		      <span class="o">&amp;&amp;</span> <span class="n">end_bytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">end_bytes</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bytes_to_S1new</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">split_item_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>
		      <span class="n">split_item_positions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">?</span> <span class="n">snum012</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>s2bytes</p></td><td class="code"><div class="highlight"><pre>		<span class="n">snum012</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">op_unit_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="n">split_item_num</span><span class="p">])</span> <span class="o">-</span> <span class="n">snum012</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span>
		    <span class="n">bytes_to_r</span> <span class="o">-</span> <span class="n">bytes_to_l</span> <span class="o">-</span> <span class="n">bytes_to_S1new</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="n">split_item_num</span><span class="p">].</span><span class="n">vi_index</span> <span class="o">!=</span> <span class="n">TYPE_DIRENTRY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="n">split_item_num</span><span class="p">].</span><span class="n">vi_index</span> <span class="o">!=</span> <span class="n">TYPE_INDIRECT</span><span class="p">)</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-8115&quot;</span><span class="p">,</span>
					 <span class="s">&quot;not directory or indirect item&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now we know S2bytes, calculate S1bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snum012</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">split_item_num</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bytes_to_r</span><span class="p">,</span> <span class="n">bytes_to_l</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bytes_to_S2new</span><span class="p">;</span>

		<span class="n">split_item_num</span> <span class="o">=</span> <span class="n">split_item_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">bytes_to_l</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">from</span> <span class="o">==</span> <span class="n">split_item_num</span>
		      <span class="o">&amp;&amp;</span> <span class="n">from_bytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">from_bytes</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bytes_to_r</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">end_item</span> <span class="o">==</span> <span class="n">split_item_num</span>
		      <span class="o">&amp;&amp;</span> <span class="n">end_bytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">end_bytes</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bytes_to_S2new</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">split_item_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">split_item_positions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		      <span class="o">&amp;&amp;</span> <span class="n">snum012</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">snum012</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>s1bytes</p></td><td class="code"><div class="highlight"><pre>		<span class="n">snum012</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">op_unit_num</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="n">split_item_num</span><span class="p">])</span> <span class="o">-</span> <span class="n">snum012</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span>
		    <span class="n">bytes_to_r</span> <span class="o">-</span> <span class="n">bytes_to_l</span> <span class="o">-</span> <span class="n">bytes_to_S2new</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">needed_nodes</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Set parameters for balancing.</span>
<span class="cm"> * Performs write of results of analysis of balancing into structure tb,</span>
<span class="cm"> * where it will later be used by the functions that actually do the balancing.</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	tb	tree_balance structure;</span>
<span class="cm"> *	h	current level of the node;</span>
<span class="cm"> *	lnum	number of items from S[h] that must be shifted to L[h];</span>
<span class="cm"> *	rnum	number of items from S[h] that must be shifted to R[h];</span>
<span class="cm"> *	blk_num	number of blocks that S[h] will be splitted into;</span>
<span class="cm"> *	s012	number of items that fall into splitted nodes.</span>
<span class="cm"> *	lbytes	number of bytes which flow to the left neighbor from the item that is not</span>
<span class="cm"> *		not shifted entirely</span>
<span class="cm"> *	rbytes	number of bytes which flow to the right neighbor from the item that is not</span>
<span class="cm"> *		not shifted entirely</span>
<span class="cm"> *	s1bytes	number of bytes which flow to the first  new node when S[0] splits (this number is contained in s012 array)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">rnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blk_num</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">s012</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rb</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">rnum</span><span class="p">;</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">blk_num</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* only for leaf level */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s012</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">s0num</span> <span class="o">=</span> <span class="o">*</span><span class="n">s012</span><span class="o">++</span><span class="p">,</span>
			    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">s1num</span> <span class="o">=</span> <span class="o">*</span><span class="n">s012</span><span class="o">++</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">s2num</span> <span class="o">=</span> <span class="o">*</span><span class="n">s012</span><span class="o">++</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">s1bytes</span> <span class="o">=</span> <span class="o">*</span><span class="n">s012</span><span class="o">++</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">s2bytes</span> <span class="o">=</span> <span class="o">*</span><span class="n">s012</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">=</span> <span class="n">lb</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">PROC_INFO_ADD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">PROC_INFO_ADD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">rnum</span><span class="p">);</span>

	<span class="n">PROC_INFO_ADD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">lbytes</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">lb</span><span class="p">);</span>
	<span class="n">PROC_INFO_ADD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">rbytes</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">rb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* check, does node disappear if we shift tb-&gt;lnum[0] items to left</span>
<span class="cm">   neighbor and tb-&gt;rnum[0] to the right one. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_leaf_removable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to_left</span><span class="p">,</span> <span class="n">to_right</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remain_items</span><span class="p">;</span>

	<span class="cm">/* number of items, that will be shifted to left (right) neighbor</span>
<span class="cm">	   entirely */</span>
	<span class="n">to_left</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">to_right</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">remain_items</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">;</span>

	<span class="cm">/* how many items remain in S[0] after shiftings to neighbors */</span>
	<span class="n">remain_items</span> <span class="o">-=</span> <span class="p">(</span><span class="n">to_left</span> <span class="o">+</span> <span class="n">to_right</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remain_items</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* all content of node can be shifted to neighbors */</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">to_left</span><span class="p">,</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">-</span> <span class="n">to_left</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			       <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remain_items</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* S[0] is not removable */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check, whether we can divide 1 remaining item between neighbors */</span>

	<span class="cm">/* get size of remaining item (in item units) */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">op_unit_num</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="n">to_left</span><span class="p">]));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">to_left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">to_right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* check whether L, S, R can be joined in one node */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">are_leaves_removable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lfree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rfree</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ih_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">S0</span><span class="p">;</span>

	<span class="n">S0</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ih_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vi_type</span> <span class="o">&amp;</span> <span class="n">VI_TYPE_LEFT_MERGEABLE</span><span class="p">)</span>
			<span class="n">ih_size</span> <span class="o">+=</span> <span class="n">IH_SIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_vi</span><span class="p">[</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span>
		    <span class="n">vi_type</span> <span class="o">&amp;</span> <span class="n">VI_TYPE_RIGHT_MERGEABLE</span><span class="p">)</span>
			<span class="n">ih_size</span> <span class="o">+=</span> <span class="n">IH_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* there was only one item and it will be deleted */</span>
		<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="s">&quot;vs-8125: item number must be 1: it is %d&quot;</span><span class="p">,</span>
		       <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">S0</span><span class="p">));</span>

		<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">comp_short_le_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span>
					   <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							  <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Directory must be in correct state here: that is</span>
<span class="cm">				   somewhere at the left side should exist first directory</span>
<span class="cm">				   item. But the item being deleted can not be that first</span>
<span class="cm">				   one because its right neighbor is item of the same</span>
<span class="cm">				   directory. (But first item always gets deleted in last</span>
<span class="cm">				   turn). So, neighbors of deleted item can be merged, so</span>
<span class="cm">				   we can save ih_size */</span>
				<span class="n">ih_size</span> <span class="o">=</span> <span class="n">IH_SIZE</span><span class="p">;</span>

				<span class="cm">/* we might check that left neighbor exists and is of the</span>
<span class="cm">				   same directory */</span>
				<span class="n">RFALSE</span><span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">==</span> <span class="n">DOT_OFFSET</span><span class="p">,</span>
				       <span class="s">&quot;vs-8130: first directory item can not be removed until directory is not empty&quot;</span><span class="p">);</span>
			<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span> <span class="o">+</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_size</span> <span class="o">&lt;=</span> <span class="n">rfree</span> <span class="o">+</span> <span class="n">lfree</span> <span class="o">+</span> <span class="n">ih_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">leaves_removable</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* when we do not split item, lnum and rnum are numbers of entire items */</span>
<span class="cp">#define SET_PAR_SHIFT_LEFT \</span>
<span class="cp">if (h)\</span>
<span class="cp">{\</span>
<span class="cp">   int to_l;\</span>
<span class="cp">   \</span>
<span class="cp">   to_l = (MAX_NR_KEY(Sh)+1 - lpar + vn-&gt;vn_nr_item + 1) / 2 -\</span>
<span class="cp">	      (MAX_NR_KEY(Sh) + 1 - lpar);\</span>
<span class="cp">	      \</span>
<span class="cp">	      set_parameters (tb, h, to_l, 0, lnver, NULL, -1, -1);\</span>
<span class="cp">}\</span>
<span class="cp">else \</span>
<span class="cp">{\</span>
<span class="cp">   if (lset==LEFT_SHIFT_FLOW)\</span>
<span class="cp">     set_parameters (tb, h, lpar, 0, lnver, snum012+lset,\</span>
<span class="cp">		     tb-&gt;lbytes, -1);\</span>
<span class="cp">   else\</span>
<span class="cp">     set_parameters (tb, h, lpar - (tb-&gt;lbytes!=-1), 0, lnver, snum012+lset,\</span>
<span class="cp">		     -1, -1);\</span>
<span class="cp">}</span>

<span class="cp">#define SET_PAR_SHIFT_RIGHT \</span>
<span class="cp">if (h)\</span>
<span class="cp">{\</span>
<span class="cp">   int to_r;\</span>
<span class="cp">   \</span>
<span class="cp">   to_r = (MAX_NR_KEY(Sh)+1 - rpar + vn-&gt;vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 - rpar);\</span>
<span class="cp">   \</span>
<span class="cp">   set_parameters (tb, h, 0, to_r, rnver, NULL, -1, -1);\</span>
<span class="cp">}\</span>
<span class="cp">else \</span>
<span class="cp">{\</span>
<span class="cp">   if (rset==RIGHT_SHIFT_FLOW)\</span>
<span class="cp">     set_parameters (tb, h, 0, rpar, rnver, snum012+rset,\</span>
<span class="cp">		  -1, tb-&gt;rbytes);\</span>
<span class="cp">   else\</span>
<span class="cp">     set_parameters (tb, h, 0, rpar - (tb-&gt;rbytes!=-1), rnver, snum012+rset,\</span>
<span class="cp">		  -1, -1);\</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_buffers_in_tb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pathrelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Get new buffers for storing new nodes that are created while balancing.</span>
<span class="cm"> * Returns:	SCHEDULE_OCCURRED - schedule occurred while the function worked;</span>
<span class="cm"> *	        CARRY_ON - schedule didn&#39;t occur while the function worked;</span>
<span class="cm"> *	        NO_DISK_SPACE - no disk space.</span>
<span class="cm"> */</span>
<span class="cm">/* The function is NOT SCHEDULE-SAFE! */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_empty_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">new_bh</span><span class="p">,</span>
	    <span class="o">*</span><span class="n">Sh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="n">b_blocknr_t</span> <span class="o">*</span><span class="n">blocknr</span><span class="p">,</span> <span class="n">blocknrs</span><span class="p">[</span><span class="n">MAX_AMOUNT_NEEDED</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">counter</span><span class="p">,</span> <span class="n">number_of_freeblk</span><span class="p">,</span> <span class="n">amount_needed</span><span class="p">,</span>	<span class="cm">/* number of needed empty blocks */</span>
	 <span class="n">retval</span> <span class="o">=</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">;</span>

	<span class="cm">/* number_of_freeblk is the number of empty blocks which have been</span>
<span class="cm">	   acquired for use by the balancing algorithm minus the number of</span>
<span class="cm">	   empty blocks used in the previous levels of the analysis,</span>
<span class="cm">	   number_of_freeblk = tb-&gt;cur_blknum can be non-zero if a schedule occurs</span>
<span class="cm">	   after empty blocks are acquired, and the balancing analysis is</span>
<span class="cm">	   then restarted, amount_needed is the number needed by this level</span>
<span class="cm">	   (h) of the balancing analysis.</span>

<span class="cm">	   Note that for systems with many processes writing, it would be</span>
<span class="cm">	   more layout optimal to calculate the total number needed by all</span>
<span class="cm">	   levels and then to run reiserfs_new_blocks to get all of them at once.  */</span>

	<span class="cm">/* Initiate number_of_freeblk to the amount acquired prior to the restart of</span>
<span class="cm">	   the analysis or 0 if not restarted, then subtract the amount needed</span>
<span class="cm">	   by all of the levels of the tree below h. */</span>
	<span class="cm">/* blknum includes S[h], so we subtract 1 in this calculation */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">number_of_freeblk</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">cur_blknum</span><span class="p">;</span>
	     <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span>
		<span class="n">number_of_freeblk</span> <span class="o">-=</span>
		    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">counter</span><span class="p">])</span> <span class="o">?</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">-</span>
						   <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Allocate missing empty blocks. */</span>
	<span class="cm">/* if Sh == 0  then we are getting a new root */</span>
	<span class="n">amount_needed</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*  Amount_needed = the amount that we need more than the amount that we have. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amount_needed</span> <span class="o">&gt;</span> <span class="n">number_of_freeblk</span><span class="p">)</span>
		<span class="n">amount_needed</span> <span class="o">-=</span> <span class="n">number_of_freeblk</span><span class="p">;</span>
	<span class="k">else</span>			<span class="cm">/* If we have enough already then there is nothing to do. */</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>

	<span class="cm">/* No need to check quota - is not allocated for blocks used for formatted nodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_new_form_blocknrs</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">blocknrs</span><span class="p">,</span>
				       <span class="n">amount_needed</span><span class="p">)</span> <span class="o">==</span> <span class="n">NO_DISK_SPACE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NO_DISK_SPACE</span><span class="p">;</span>

	<span class="cm">/* for each blocknumber we just got, get a buffer and stick it on FEB */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blocknr</span> <span class="o">=</span> <span class="n">blocknrs</span><span class="p">,</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">amount_needed</span><span class="p">;</span> <span class="n">blocknr</span><span class="o">++</span><span class="p">,</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!*</span><span class="n">blocknr</span><span class="p">,</span>
		       <span class="s">&quot;PAP-8135: reiserfs_new_blocknrs failed when got new blocks&quot;</span><span class="p">);</span>

		<span class="n">new_bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">*</span><span class="n">blocknr</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">new_bh</span><span class="p">)</span> <span class="o">||</span>
		       <span class="n">buffer_journaled</span><span class="p">(</span><span class="n">new_bh</span><span class="p">)</span> <span class="o">||</span>
		       <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">new_bh</span><span class="p">),</span>
		       <span class="s">&quot;PAP-8140: journaled or dirty buffer %b for the new block&quot;</span><span class="p">,</span>
		       <span class="n">new_bh</span><span class="p">);</span>

		<span class="cm">/* Put empty buffers into the array. */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cur_blknum</span><span class="p">],</span>
		       <span class="s">&quot;PAP-8141: busy slot for new buffer&quot;</span><span class="p">);</span>

		<span class="n">set_buffer_journal_new</span><span class="p">(</span><span class="n">new_bh</span><span class="p">);</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">cur_blknum</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_bh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">CARRY_ON</span> <span class="o">&amp;&amp;</span> <span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get free space of the left neighbor, which is stored in the parent</span>
<span class="cm"> * node of the left neighbor.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_lfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span>
		<span class="n">order</span> <span class="o">=</span> <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">order</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">order</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/* Get free space of the right neighbor,</span>
<span class="cm"> * which is stored in the parent node of the right neighbor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_rfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span>
		<span class="n">order</span> <span class="o">=</span> <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">order</span><span class="p">)));</span>

<span class="p">}</span>

<span class="cm">/* Check whether left neighbor is in memory. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_left_neighbor_in_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">father</span><span class="p">,</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">left_neighbor_blocknr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left_neighbor_position</span><span class="p">;</span>

	<span class="cm">/* Father of the left neighbor does not exist. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Calculate father of the node to be balanced. */</span>
	<span class="n">father</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">father</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">father</span><span class="p">)</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">father</span><span class="p">)</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]),</span>
	       <span class="s">&quot;vs-8165: F[h] (%b) or FL[h] (%b) is invalid&quot;</span><span class="p">,</span>
	       <span class="n">father</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

	<span class="cm">/* Get position of the pointer to the left neighbor into the left father. */</span>
	<span class="n">left_neighbor_position</span> <span class="o">=</span> <span class="p">(</span><span class="n">father</span> <span class="o">==</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">?</span>
	    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">:</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
	<span class="cm">/* Get left neighbor block number. */</span>
	<span class="n">left_neighbor_blocknr</span> <span class="o">=</span>
	    <span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">left_neighbor_position</span><span class="p">);</span>
	<span class="cm">/* Look for the left neighbor in the cache. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">left</span> <span class="o">=</span> <span class="n">sb_find_get_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">left_neighbor_blocknr</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">left</span><span class="p">),</span>
		       <span class="s">&quot;vs-8170: left neighbor (%b %z) is not in the tree&quot;</span><span class="p">,</span>
		       <span class="n">left</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define LEFT_PARENTS  &#39;l&#39;</span>
<span class="cp">#define RIGHT_PARENTS &#39;r&#39;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">decrement_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>call item specific function for this key</p></td><td class="code"><div class="highlight"><pre>	<span class="n">item_ops</span><span class="p">[</span><span class="n">cpu_key_k_type</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span><span class="o">-&gt;</span><span class="n">decrement_key</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Calculate far left/right parent of the left/right neighbor of the current node, that</span>
<span class="cm"> * is calculate the left/right (FL[h]/FR[h]) neighbor of the parent F[h].</span>
<span class="cm"> * Calculate left/right common parent of the current node and L[h]/R[h].</span>
<span class="cm"> * Calculate left/right delimiting key position.</span>
<span class="cm"> * Returns:	PATH_INCORRECT   - path in the tree is not correct;</span>
<span class="cm"> 		SCHEDULE_OCCURRED - schedule occurred while the function worked;</span>
<span class="cm"> *	        CARRY_ON         - schedule didn&#39;t occur while the function worked;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_far_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">h</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">pfather</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">pcom_father</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c_lr_par</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">s_path_to_neighbor_father</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">s_lr_father_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">counter</span><span class="p">,</span>
	    <span class="n">position</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span>
	    <span class="n">first_last_position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	    <span class="n">path_offset</span> <span class="o">=</span> <span class="n">PATH_H_PATH_OFFSET</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/* Starting from F[h] go upwards in the tree, and look for the common</span>
<span class="cm">	   ancestor of F[h], and its neighbor l/r, that should be obtained. */</span>

	<span class="n">counter</span> <span class="o">=</span> <span class="n">path_offset</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">,</span>
	       <span class="s">&quot;PAP-8180: invalid path length&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">;</span> <span class="n">counter</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check whether parent of the current buffer in the path is really parent in the tree. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span>
		    <span class="p">(</span><span class="n">parent</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
		<span class="cm">/* Check whether position in the parent is correct. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">position</span> <span class="o">=</span>
		     <span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
					  <span class="n">counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span>
		    <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
		<span class="cm">/* Check whether parent at the path really points to the child. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
		<span class="cm">/* Return delimiting key if position in the parent is not equal to first/last one. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c_lr_par</span> <span class="o">==</span> <span class="n">RIGHT_PARENTS</span><span class="p">)</span>
			<span class="n">first_last_position</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">!=</span> <span class="n">first_last_position</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">pcom_father</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="o">*</span><span class="n">pcom_father</span><span class="p">);</span>
			<span class="cm">/*(*pcom_father = parent)-&gt;b_count++; */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* if we are in the root of the tree, then there is no common father */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check whether first buffer in the path is the root of the tree. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PATH_OFFSET_PBUFFER</span>
		    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
		     <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span>
		    <span class="n">SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">pfather</span> <span class="o">=</span> <span class="o">*</span><span class="n">pcom_father</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_LEVEL</span><span class="p">(</span><span class="o">*</span><span class="n">pcom_father</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">DISK_LEAF_NODE_LEVEL</span><span class="p">,</span>
	       <span class="s">&quot;PAP-8185: (%b %z) level too small&quot;</span><span class="p">,</span>
	       <span class="o">*</span><span class="n">pcom_father</span><span class="p">,</span> <span class="o">*</span><span class="n">pcom_father</span><span class="p">);</span>

	<span class="cm">/* Check whether the common parent is locked. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="o">*</span><span class="n">pcom_father</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Release the write lock while the buffer is busy */</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>
		<span class="n">__wait_on_buffer</span><span class="p">(</span><span class="o">*</span><span class="n">pcom_father</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="o">*</span><span class="n">pcom_father</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* So, we got common parent of the current node and its left/right neighbor.</span>
<span class="cm">	   Now we are geting the parent of the left/right neighbor. */</span>

	<span class="cm">/* Form key to get parent of the left/right neighbor. */</span>
	<span class="n">le_key2cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_lr_father_key</span><span class="p">,</span>
		       <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="o">*</span><span class="n">pcom_father</span><span class="p">,</span>
				      <span class="p">(</span><span class="n">c_lr_par</span> <span class="o">==</span>
				       <span class="n">LEFT_PARENTS</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
							<span class="n">position</span> <span class="o">-</span>
							<span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span>
									   <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
							      <span class="n">position</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c_lr_par</span> <span class="o">==</span> <span class="n">LEFT_PARENTS</span><span class="p">)</span>
		<span class="n">decrement_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_lr_father_key</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">search_by_key</span>
	    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_lr_father_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_path_to_neighbor_father</span><span class="p">,</span>
	     <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>path is released</p></td><td class="code"><div class="highlight"><pre>		<span class="k">return</span> <span class="n">IO_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_path_to_neighbor_father</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="o">*</span><span class="n">pcom_father</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pfather</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_path_to_neighbor_father</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_LEVEL</span><span class="p">(</span><span class="o">*</span><span class="n">pfather</span><span class="p">)</span> <span class="o">!=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	       <span class="s">&quot;PAP-8190: (%b %z) level too small&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pfather</span><span class="p">,</span> <span class="o">*</span><span class="n">pfather</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">s_path_to_neighbor_father</span><span class="p">.</span><span class="n">path_length</span> <span class="o">&lt;</span>
	       <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">,</span> <span class="s">&quot;PAP-8192: path length is too small&quot;</span><span class="p">);</span>

	<span class="n">s_path_to_neighbor_father</span><span class="p">.</span><span class="n">path_length</span><span class="o">--</span><span class="p">;</span>
	<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_path_to_neighbor_father</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get parents of neighbors of node in the path(S[path_offset]) and common parents of</span>
<span class="cm"> * S[path_offset] and L[path_offset]/R[path_offset]: F[path_offset], FL[path_offset],</span>
<span class="cm"> * FR[path_offset], CFL[path_offset], CFR[path_offset].</span>
<span class="cm"> * Calculate numbers of left and right delimiting keys position: lkey[path_offset], rkey[path_offset].</span>
<span class="cm"> * Returns:	SCHEDULE_OCCURRED - schedule occurred while the function worked;</span>
<span class="cm"> *	        CARRY_ON - schedule didn&#39;t occur while the function worked;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_parents</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">position</span><span class="p">,</span>
	    <span class="n">ret</span><span class="p">,</span>
	    <span class="n">path_offset</span> <span class="o">=</span> <span class="n">PATH_H_PATH_OFFSET</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">curf</span><span class="p">,</span> <span class="o">*</span><span class="n">curcf</span><span class="p">;</span>

	<span class="cm">/* Current node is the root of the tree or will be root of the tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path_offset</span> <span class="o">&lt;=</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The root can not have parents.</span>
<span class="cm">		   Release nodes which previously were obtained as parents of the current node neighbors. */</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get parent FL[path_offset] of L[path_offset]. */</span>
	<span class="n">position</span> <span class="o">=</span> <span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Current node is not the first child of its parent. */</span>
		<span class="n">curf</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">curcf</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">curf</span><span class="p">);</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">curf</span><span class="p">);</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Calculate current parent of L[path_offset], which is the left neighbor of the current node.</span>
<span class="cm">		   Calculate current common parent of L[path_offset] and the current node. Note that</span>
<span class="cm">		   CFL[path_offset] not equal FL[path_offset] and CFL[path_offset] not equal F[path_offset].</span>
<span class="cm">		   Calculate lkey[path_offset]. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_far_parent</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curf</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">curcf</span><span class="p">,</span>
						  <span class="n">LEFT_PARENTS</span><span class="p">))</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">curf</span><span class="p">;</span>	<span class="cm">/* New initialization of FL[h]. */</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">curcf</span><span class="p">;</span>	<span class="cm">/* New initialization of CFL[h]. */</span>

	<span class="n">RFALSE</span><span class="p">((</span><span class="n">curf</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">curf</span><span class="p">))</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">curcf</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">curcf</span><span class="p">)),</span>
	       <span class="s">&quot;PAP-8195: FL (%b) or CFL (%b) is invalid&quot;</span><span class="p">,</span> <span class="n">curf</span><span class="p">,</span> <span class="n">curcf</span><span class="p">);</span>

<span class="cm">/* Get parent FR[h] of R[h]. */</span>

<span class="cm">/* Current node is the last child of F[h]. FR[h] != F[h]. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">==</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
<span class="cm">/* Calculate current parent of R[h], which is the right neighbor of F[h].</span>
<span class="cm">   Calculate current common parent of R[h] and current node. Note that CFR[h]</span>
<span class="cm">   not equal FR[path_offset] and CFR[h] not equal F[h]. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span>
		     <span class="n">get_far_parent</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curcf</span><span class="p">,</span>
				    <span class="n">RIGHT_PARENTS</span><span class="p">))</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cm">/* Current node is not the last child of its parent F[h]. */</span>
		<span class="n">curf</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">curcf</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">curf</span><span class="p">);</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">curf</span><span class="p">);</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
	<span class="cm">/* New initialization of FR[path_offset]. */</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">curf</span><span class="p">;</span>

	<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
	<span class="cm">/* New initialization of CFR[path_offset]. */</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">curcf</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">((</span><span class="n">curf</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">curf</span><span class="p">))</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">curcf</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">curcf</span><span class="p">)),</span>
	       <span class="s">&quot;PAP-8205: FR (%b) or CFR (%b) is invalid&quot;</span><span class="p">,</span> <span class="n">curf</span><span class="p">,</span> <span class="n">curcf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* it is possible to remove node as result of shiftings to</span>
<span class="cm">   neighbors even when we insert or paste item. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">can_node_be_removed</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lfree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sfree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rfree</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">Sh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">levbytes</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">r_key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">Sh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">])</span>
		<span class="n">r_key</span> <span class="o">=</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lfree</span> <span class="o">+</span> <span class="n">rfree</span> <span class="o">+</span> <span class="n">sfree</span> <span class="o">&lt;</span> <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span> <span class="n">levbytes</span>
	    <span class="cm">/* shifting may merge items which might save space */</span>
	    <span class="o">-</span>
	    <span class="p">((</span><span class="o">!</span><span class="n">h</span>
	      <span class="o">&amp;&amp;</span> <span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">Sh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">))</span> <span class="o">?</span> <span class="n">IH_SIZE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="o">-</span>
	    <span class="p">((</span><span class="o">!</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">r_key</span>
	      <span class="o">&amp;&amp;</span> <span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="n">r_key</span><span class="p">,</span> <span class="n">Sh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">))</span> <span class="o">?</span> <span class="n">IH_SIZE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="o">+</span> <span class="p">((</span><span class="n">h</span><span class="p">)</span> <span class="o">?</span> <span class="n">KEY_SIZE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* node can not be removed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sfree</span> <span class="o">&gt;=</span> <span class="n">levbytes</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* new item fits into node S[h] without any shifting */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">s0num</span> <span class="o">=</span>
				    <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span>
				    <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_INSERT</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">can_node_be_removed</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether current node S[h] is balanced when increasing its size by</span>
<span class="cm"> * Inserting or Pasting.</span>
<span class="cm"> * Calculate parameters for balancing for current level h.</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	tb	tree_balance structure;</span>
<span class="cm"> *	h	current level of the node;</span>
<span class="cm"> *	inum	item number in S[h];</span>
<span class="cm"> *	mode	i - insert, p - paste;</span>
<span class="cm"> * Returns:	1 - schedule occurred;</span>
<span class="cm"> *	        0 - balancing for higher levels needed;</span>
<span class="cm"> *	       -1 - no balancing for higher levels needed;</span>
<span class="cm"> *	       -2 - no disk space.</span>
<span class="cm"> */</span>
<span class="cm">/* ip means Inserting or Pasting */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ip_check_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">levbytes</span><span class="p">,</span>		<span class="cm">/* Number of bytes that must be inserted into (value</span>
<span class="cm">				   is negative if bytes are deleted) buffer which</span>
<span class="cm">				   contains node being balanced.  The mnemonic is</span>
<span class="cm">				   that the attempted change in node space used level</span>
<span class="cm">				   is levbytes bytes. */</span>
	 <span class="n">ret</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">lfree</span><span class="p">,</span> <span class="n">sfree</span><span class="p">,</span> <span class="n">rfree</span> <span class="cm">/* free space in L, S and R */</span> <span class="p">;</span>

	<span class="cm">/* nver is short for number of vertixes, and lnver is the number if</span>
<span class="cm">	   we shift to the left, rnver is the number if we shift to the</span>
<span class="cm">	   right, and lrnver is the number if we shift in both directions.</span>
<span class="cm">	   The goal is to minimize first the number of vertixes, and second,</span>
<span class="cm">	   the number of vertixes whose contents are changed by shifting,</span>
<span class="cm">	   and third the number of uncached vertixes whose contents are</span>
<span class="cm">	   changed by shifting and must be read from disk.  */</span>
	<span class="kt">int</span> <span class="n">nver</span><span class="p">,</span> <span class="n">lnver</span><span class="p">,</span> <span class="n">rnver</span><span class="p">,</span> <span class="n">lrnver</span><span class="p">;</span>

	<span class="cm">/* used at leaf level only, S0 = S[0] is the node being balanced,</span>
<span class="cm">	   sInum [ I = 0,1,2 ] is the number of items that will</span>
<span class="cm">	   remain in node SI after balancing.  S1 and S2 are new</span>
<span class="cm">	   nodes that might be created. */</span>

	<span class="cm">/* we perform 8 calls to get_num_ver().  For each call we calculate five parameters.</span>
<span class="cm">	   where 4th parameter is s1bytes and 5th - s2bytes</span>
<span class="cm">	 */</span>
	<span class="kt">short</span> <span class="n">snum012</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>	<span class="cm">/* s0num, s1num, s2num for 8 cases</span>
<span class="cm">					   0,1 - do not shift and do not shift but bottle</span>
<span class="cm">					   2 - shift only whole item to left</span>
<span class="cm">					   3 - shift to left and bottle as much as possible</span>
<span class="cm">					   4,5 - shift to right (whole items and as much as possible</span>
<span class="cm">					   6,7 - shift to both directions (whole items and as much as possible)</span>
<span class="cm">					 */</span>

	<span class="cm">/* Sh is the node whose balance is currently being checked */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">Sh</span><span class="p">;</span>

	<span class="n">Sh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="n">levbytes</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>

	<span class="cm">/* Calculate balance parameters for creating new root. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Sh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-8210&quot;</span><span class="p">,</span>
				       <span class="s">&quot;S[0] can not be 0&quot;</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_empty_nodes</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CARRY_ON</span>:
			<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>	<span class="cm">/* no balancing for higher levels needed */</span>

		<span class="k">case</span> <span class="n">NO_DISK_SPACE</span>:
		<span class="k">case</span> <span class="n">REPEAT_SEARCH</span>:
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-8215&quot;</span><span class="p">,</span> <span class="s">&quot;incorrect &quot;</span>
				       <span class="s">&quot;return value of get_empty_nodes&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_parents</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>	<span class="cm">/* get parents of S[h] neighbors. */</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">sfree</span> <span class="o">=</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">Sh</span><span class="p">);</span>

	<span class="cm">/* get free space of neighbors */</span>
	<span class="n">rfree</span> <span class="o">=</span> <span class="n">get_rfree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="n">lfree</span> <span class="o">=</span> <span class="n">get_lfree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_node_be_removed</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">lfree</span><span class="p">,</span> <span class="n">sfree</span><span class="p">,</span> <span class="n">rfree</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">NO_BALANCING_NEEDED</span><span class="p">)</span>
		<span class="cm">/* and new item fits into node S[h] without any shifting */</span>
		<span class="k">return</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>

	<span class="n">create_virtual_node</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	   determine maximal number of items we can shift to the left neighbor (in tb structure)</span>
<span class="cm">	   and the maximal number of bytes that can flow to the left neighbor</span>
<span class="cm">	   from the left most liquid item that cannot be shifted from S[0] entirely (returned value)</span>
<span class="cm">	 */</span>
	<span class="n">check_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">lfree</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	   determine maximal number of items we can shift to the right neighbor (in tb structure)</span>
<span class="cm">	   and the maximal number of bytes that can flow to the right neighbor</span>
<span class="cm">	   from the right most liquid item that cannot be shifted from S[0] entirely (returned value)</span>
<span class="cm">	 */</span>
	<span class="n">check_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">rfree</span><span class="p">);</span>

	<span class="cm">/* all contents of internal node S[h] can be moved into its</span>
<span class="cm">	   neighbors, S[h] will be removed after balancing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">to_r</span><span class="p">;</span>

		<span class="cm">/* Since we are working on internal nodes, and our internal</span>
<span class="cm">		   nodes have fixed size entries, then we can balance by the</span>
<span class="cm">		   number of items rather than the space they consume.  In this</span>
<span class="cm">		   routine we set the left node equal to the right node,</span>
<span class="cm">		   allowing a difference of less than or equal to 1 child</span>
<span class="cm">		   pointer. */</span>
		<span class="n">to_r</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span>
		     <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span>
						<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">to_r</span><span class="p">,</span> <span class="n">to_r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			       <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this checks balance condition, that any two neighboring nodes can not fit in one node */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">h</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
	       <span class="s">&quot;vs-8220: tree is not balanced on internal level&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">||</span>
		      <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))),</span>
	       <span class="s">&quot;vs-8225: tree is not balanced on leaf level&quot;</span><span class="p">);</span>

	<span class="cm">/* all contents of S[0] can be moved into its neighbors</span>
<span class="cm">	   S[0] will be removed after balancing. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">is_leaf_removable</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>

	<span class="cm">/* why do we perform this check here rather than earlier??</span>
<span class="cm">	   Answer: we can win 1 node in some cases above. Moreover we</span>
<span class="cm">	   checked it above, when we checked, that S[0] is not removable</span>
<span class="cm">	   in principle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sfree</span> <span class="o">&gt;=</span> <span class="n">levbytes</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* new item fits into node S[h] without any shifting */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">s0num</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">;</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">lpar</span><span class="p">,</span> <span class="n">rpar</span><span class="p">,</span> <span class="n">nset</span><span class="p">,</span> <span class="n">lset</span><span class="p">,</span> <span class="n">rset</span><span class="p">,</span> <span class="n">lrset</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * regular overflowing of the node</span>
<span class="cm">		 */</span>

		<span class="cm">/* get_num_ver works in 2 modes (FLOW &amp; NO_FLOW)</span>
<span class="cm">		   lpar, rpar - number of items we can shift to left/right neighbor (including splitting item)</span>
<span class="cm">		   nset, lset, rset, lrset - shows, whether flowing items give better packing</span>
<span class="cm">		 */</span>
<span class="cp">#define FLOW 1</span>
<span class="cp">#define NO_FLOW 0		</span><span class="cm">/* do not any splitting */</span><span class="cp"></span>

		<span class="cm">/* we choose one the following */</span>
<span class="cp">#define NOTHING_SHIFT_NO_FLOW	0</span>
<span class="cp">#define NOTHING_SHIFT_FLOW	5</span>
<span class="cp">#define LEFT_SHIFT_NO_FLOW	10</span>
<span class="cp">#define LEFT_SHIFT_FLOW		15</span>
<span class="cp">#define RIGHT_SHIFT_NO_FLOW	20</span>
<span class="cp">#define RIGHT_SHIFT_FLOW	25</span>
<span class="cp">#define LR_SHIFT_NO_FLOW	30</span>
<span class="cp">#define LR_SHIFT_FLOW		35</span>

		<span class="n">lpar</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">rpar</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>

		<span class="cm">/* calculate number of blocks S[h] must be split into when</span>
<span class="cm">		   nothing is shifted to the neighbors,</span>
<span class="cm">		   as well as number of items in each part of the split node (s012 numbers),</span>
<span class="cm">		   and number of bytes (s1bytes) of the shared drop which flow to S1 if any */</span>
		<span class="n">nset</span> <span class="o">=</span> <span class="n">NOTHING_SHIFT_NO_FLOW</span><span class="p">;</span>
		<span class="n">nver</span> <span class="o">=</span> <span class="n">get_num_ver</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
				   <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">?</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				   <span class="n">snum012</span><span class="p">,</span> <span class="n">NO_FLOW</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nver1</span><span class="p">;</span>

			<span class="cm">/* note, that in this case we try to bottle between S[0] and S1 (S1 - the first new node) */</span>
			<span class="n">nver1</span> <span class="o">=</span> <span class="n">get_num_ver</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					    <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					    <span class="n">snum012</span> <span class="o">+</span> <span class="n">NOTHING_SHIFT_FLOW</span><span class="p">,</span> <span class="n">FLOW</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nver</span> <span class="o">&gt;</span> <span class="n">nver1</span><span class="p">)</span>
				<span class="n">nset</span> <span class="o">=</span> <span class="n">NOTHING_SHIFT_FLOW</span><span class="p">,</span> <span class="n">nver</span> <span class="o">=</span> <span class="n">nver1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* calculate number of blocks S[h] must be split into when</span>
<span class="cm">		   l_shift_num first items and l_shift_bytes of the right most</span>
<span class="cm">		   liquid item to be shifted are shifted to the left neighbor,</span>
<span class="cm">		   as well as number of items in each part of the splitted node (s012 numbers),</span>
<span class="cm">		   and number of bytes (s1bytes) of the shared drop which flow to S1 if any</span>
<span class="cm">		 */</span>
		<span class="n">lset</span> <span class="o">=</span> <span class="n">LEFT_SHIFT_NO_FLOW</span><span class="p">;</span>
		<span class="n">lnver</span> <span class="o">=</span> <span class="n">get_num_ver</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
				    <span class="n">lpar</span> <span class="o">-</span> <span class="p">((</span><span class="n">h</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span>
				    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">?</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				    <span class="n">snum012</span> <span class="o">+</span> <span class="n">LEFT_SHIFT_NO_FLOW</span><span class="p">,</span> <span class="n">NO_FLOW</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">lnver1</span><span class="p">;</span>

			<span class="n">lnver1</span> <span class="o">=</span> <span class="n">get_num_ver</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					     <span class="n">lpar</span> <span class="o">-</span>
					     <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
					     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					     <span class="n">snum012</span> <span class="o">+</span> <span class="n">LEFT_SHIFT_FLOW</span><span class="p">,</span> <span class="n">FLOW</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lnver</span> <span class="o">&gt;</span> <span class="n">lnver1</span><span class="p">)</span>
				<span class="n">lset</span> <span class="o">=</span> <span class="n">LEFT_SHIFT_FLOW</span><span class="p">,</span> <span class="n">lnver</span> <span class="o">=</span> <span class="n">lnver1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* calculate number of blocks S[h] must be split into when</span>
<span class="cm">		   r_shift_num first items and r_shift_bytes of the left most</span>
<span class="cm">		   liquid item to be shifted are shifted to the right neighbor,</span>
<span class="cm">		   as well as number of items in each part of the splitted node (s012 numbers),</span>
<span class="cm">		   and number of bytes (s1bytes) of the shared drop which flow to S1 if any</span>
<span class="cm">		 */</span>
		<span class="n">rset</span> <span class="o">=</span> <span class="n">RIGHT_SHIFT_NO_FLOW</span><span class="p">;</span>
		<span class="n">rnver</span> <span class="o">=</span> <span class="n">get_num_ver</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
				    <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				    <span class="n">h</span> <span class="o">?</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">-</span> <span class="n">rpar</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">rpar</span> <span class="o">-</span>
								   <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span>
								     <span class="n">rbytes</span> <span class="o">!=</span>
								     <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span>
								    <span class="mi">0</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				    <span class="n">snum012</span> <span class="o">+</span> <span class="n">RIGHT_SHIFT_NO_FLOW</span><span class="p">,</span> <span class="n">NO_FLOW</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">rnver1</span><span class="p">;</span>

			<span class="n">rnver1</span> <span class="o">=</span> <span class="n">get_num_ver</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">rpar</span> <span class="o">-</span>
					      <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)),</span>
					     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">,</span>
					     <span class="n">snum012</span> <span class="o">+</span> <span class="n">RIGHT_SHIFT_FLOW</span><span class="p">,</span> <span class="n">FLOW</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rnver</span> <span class="o">&gt;</span> <span class="n">rnver1</span><span class="p">)</span>
				<span class="n">rset</span> <span class="o">=</span> <span class="n">RIGHT_SHIFT_FLOW</span><span class="p">,</span> <span class="n">rnver</span> <span class="o">=</span> <span class="n">rnver1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* calculate number of blocks S[h] must be split into when</span>
<span class="cm">		   items are shifted in both directions,</span>
<span class="cm">		   as well as number of items in each part of the splitted node (s012 numbers),</span>
<span class="cm">		   and number of bytes (s1bytes) of the shared drop which flow to S1 if any</span>
<span class="cm">		 */</span>
		<span class="n">lrset</span> <span class="o">=</span> <span class="n">LR_SHIFT_NO_FLOW</span><span class="p">;</span>
		<span class="n">lrnver</span> <span class="o">=</span> <span class="n">get_num_ver</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
				     <span class="n">lpar</span> <span class="o">-</span> <span class="p">((</span><span class="n">h</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span>
				     <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">h</span> <span class="o">?</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">-</span> <span class="n">rpar</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">rpar</span> <span class="o">-</span>
								    <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span>
								      <span class="n">rbytes</span> <span class="o">!=</span>
								      <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span>
								     <span class="mi">0</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				     <span class="n">snum012</span> <span class="o">+</span> <span class="n">LR_SHIFT_NO_FLOW</span><span class="p">,</span> <span class="n">NO_FLOW</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">lrnver1</span><span class="p">;</span>

			<span class="n">lrnver1</span> <span class="o">=</span> <span class="n">get_num_ver</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					      <span class="n">lpar</span> <span class="o">-</span>
					      <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
					      <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">rpar</span> <span class="o">-</span>
					       <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)),</span>
					      <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">,</span>
					      <span class="n">snum012</span> <span class="o">+</span> <span class="n">LR_SHIFT_FLOW</span><span class="p">,</span> <span class="n">FLOW</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lrnver</span> <span class="o">&gt;</span> <span class="n">lrnver1</span><span class="p">)</span>
				<span class="n">lrset</span> <span class="o">=</span> <span class="n">LR_SHIFT_FLOW</span><span class="p">,</span> <span class="n">lrnver</span> <span class="o">=</span> <span class="n">lrnver1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Our general shifting strategy is:</span>
<span class="cm">		   1) to minimized number of new nodes;</span>
<span class="cm">		   2) to minimized number of neighbors involved in shifting;</span>
<span class="cm">		   3) to minimized number of disk reads; */</span>

		<span class="cm">/* we can win TWO or ONE nodes by shifting in both directions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lrnver</span> <span class="o">&lt;</span> <span class="n">lnver</span> <span class="o">&amp;&amp;</span> <span class="n">lrnver</span> <span class="o">&lt;</span> <span class="n">rnver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">h</span> <span class="o">&amp;&amp;</span>
			       <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span>
				<span class="n">lrnver</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">rnver</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">lnver</span> <span class="o">!=</span> <span class="mi">2</span>
				<span class="o">||</span> <span class="n">h</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">),</span> <span class="s">&quot;vs-8230: bad h&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lrset</span> <span class="o">==</span> <span class="n">LR_SHIFT_FLOW</span><span class="p">)</span>
				<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">],</span>
					       <span class="n">lrnver</span><span class="p">,</span> <span class="n">snum012</span> <span class="o">+</span> <span class="n">lrset</span><span class="p">,</span>
					       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span>
					       <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span>
					       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span>
					       <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span>
					       <span class="n">lrnver</span><span class="p">,</span> <span class="n">snum012</span> <span class="o">+</span> <span class="n">lrset</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if shifting doesn&#39;t lead to better packing then don&#39;t shift */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nver</span> <span class="o">==</span> <span class="n">lrnver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nver</span><span class="p">,</span> <span class="n">snum012</span> <span class="o">+</span> <span class="n">nset</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				       <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* now we know that for better packing shifting in only one</span>
<span class="cm">		   direction either to the left or to the right is required */</span>

		<span class="cm">/*  if shifting to the left is better than shifting to the right */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnver</span> <span class="o">&lt;</span> <span class="n">rnver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SET_PAR_SHIFT_LEFT</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if shifting to the right is better than shifting to the left */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnver</span> <span class="o">&gt;</span> <span class="n">rnver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SET_PAR_SHIFT_RIGHT</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* now shifting in either direction gives the same number</span>
<span class="cm">		   of nodes and we can make use of the cached neighbors */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_left_neighbor_in_cache</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_PAR_SHIFT_LEFT</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* shift to the right independently on whether the right neighbor in cache or not */</span>
		<span class="n">SET_PAR_SHIFT_RIGHT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Check whether current node S[h] is balanced when Decreasing its size by</span>
<span class="cm"> * Deleting or Cutting for INTERNAL node of S+tree.</span>
<span class="cm"> * Calculate parameters for balancing for current level h.</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	tb	tree_balance structure;</span>
<span class="cm"> *	h	current level of the node;</span>
<span class="cm"> *	inum	item number in S[h];</span>
<span class="cm"> *	mode	i - insert, p - paste;</span>
<span class="cm"> * Returns:	1 - schedule occurred;</span>
<span class="cm"> *	        0 - balancing for higher levels needed;</span>
<span class="cm"> *	       -1 - no balancing for higher levels needed;</span>
<span class="cm"> *	       -2 - no disk space.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Items of internal nodes have fixed size, so the balance condition for</span>
<span class="cm"> * the internal part of S+tree is as for the B-trees.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dc_check_balance_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span>

	<span class="cm">/* Sh is the node whose balance is currently being checked,</span>
<span class="cm">	   and Fh is its father.  */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">Sh</span><span class="p">,</span> <span class="o">*</span><span class="n">Fh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lfree</span><span class="p">,</span> <span class="n">rfree</span> <span class="cm">/* free space in L and R */</span> <span class="p">;</span>

	<span class="n">Sh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="n">Fh</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="n">maxsize</span> <span class="o">=</span> <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">Sh</span><span class="p">);</span>

<span class="cm">/*   using tb-&gt;insert_size[h], which is negative in this case, create_virtual_node calculates: */</span>
<span class="cm">/*   new_nr_item = number of items node would have if operation is */</span>
<span class="cm">/* 	performed without balancing (new_nr_item); */</span>
	<span class="n">create_virtual_node</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Fh</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* S[h] is the root. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>	<span class="cm">/* no balancing for higher levels needed */</span>
		<span class="p">}</span>
		<span class="cm">/* new_nr_item == 0.</span>
<span class="cm">		 * Current root will be deleted resulting in</span>
<span class="cm">		 * decrementing the tree height. */</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_parents</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* get free space of neighbors */</span>
	<span class="n">rfree</span> <span class="o">=</span> <span class="n">get_rfree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="n">lfree</span> <span class="o">=</span> <span class="n">get_lfree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/* determine maximal number of items we can fit into neighbors */</span>
	<span class="n">check_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">lfree</span><span class="p">);</span>
	<span class="n">check_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">rfree</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">&gt;=</span> <span class="n">MIN_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* Balance condition for the internal node is valid.</span>
<span class="cm">						 * In this case we balance only if it leads to better packing. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">==</span> <span class="n">MIN_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* Here we join S[h] with one of its neighbors,</span>
<span class="cm">							 * which is impossible with greater values of new_nr_item. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* All contents of S[h] can be moved to L[h]. */</span>
				<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">order_L</span><span class="p">;</span>

				<span class="n">order_L</span> <span class="o">=</span>
				    <span class="p">((</span><span class="n">n</span> <span class="o">=</span>
				      <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
							  <span class="n">h</span><span class="p">))</span> <span class="o">==</span>
				     <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">:</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">order_L</span><span class="p">))</span> <span class="o">/</span>
				    <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
				<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					       <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* All contents of S[h] can be moved to R[h]. */</span>
				<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">order_R</span><span class="p">;</span>

				<span class="n">order_R</span> <span class="o">=</span>
				    <span class="p">((</span><span class="n">n</span> <span class="o">=</span>
				      <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
							  <span class="n">h</span><span class="p">))</span> <span class="o">==</span>
				     <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">Fh</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">order_R</span><span class="p">))</span> <span class="o">/</span>
				    <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
				<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					       <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* All contents of S[h] can be moved to the neighbors (L[h] &amp; R[h]). */</span>
			<span class="kt">int</span> <span class="n">to_r</span><span class="p">;</span>

			<span class="n">to_r</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span>
			     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span>
			    <span class="p">(</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
			<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">to_r</span><span class="p">,</span> <span class="n">to_r</span><span class="p">,</span>
				       <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Balancing does not lead to better packing. */</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Current node contain insufficient number of items. Balancing is required. */</span>
	<span class="cm">/* Check whether we can merge S[h] with left neighbor. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_left_neighbor_in_cache</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">order_L</span><span class="p">;</span>

			<span class="n">order_L</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">n</span> <span class="o">=</span>
			      <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
						  <span class="n">h</span><span class="p">))</span> <span class="o">==</span>
			     <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">:</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">order_L</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span>
								      <span class="n">KEY_SIZE</span><span class="p">);</span>
			<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Check whether we can merge S[h] with right neighbor. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">order_R</span><span class="p">;</span>

		<span class="n">order_R</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">n</span> <span class="o">=</span>
		      <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
					  <span class="n">h</span><span class="p">))</span> <span class="o">==</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">Fh</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">order_R</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span>
							      <span class="n">KEY_SIZE</span><span class="p">);</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All contents of S[h] can be moved to the neighbors (L[h] &amp; R[h]). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">to_r</span><span class="p">;</span>

		<span class="n">to_r</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span>
		     <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span>
						<span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">to_r</span><span class="p">,</span> <span class="n">to_r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			       <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For internal nodes try to borrow item from a neighbor */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="s">&quot;vs-8235: trying to borrow for root&quot;</span><span class="p">);</span>

	<span class="cm">/* Borrow one or two items from caching neighbor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_left_neighbor_in_cache</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">from_l</span><span class="p">;</span>

		<span class="n">from_l</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span>
		     <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="n">from_l</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="o">-</span><span class="p">((</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">Sh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span>
			  <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether current node S[h] is balanced when Decreasing its size by</span>
<span class="cm"> * Deleting or Truncating for LEAF node of S+tree.</span>
<span class="cm"> * Calculate parameters for balancing for current level h.</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	tb	tree_balance structure;</span>
<span class="cm"> *	h	current level of the node;</span>
<span class="cm"> *	inum	item number in S[h];</span>
<span class="cm"> *	mode	i - insert, p - paste;</span>
<span class="cm"> * Returns:	1 - schedule occurred;</span>
<span class="cm"> *	        0 - balancing for higher levels needed;</span>
<span class="cm"> *	       -1 - no balancing for higher levels needed;</span>
<span class="cm"> *	       -2 - no disk space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dc_check_balance_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span><span class="p">;</span>

	<span class="cm">/* Number of bytes that must be deleted from</span>
<span class="cm">	   (value is negative if bytes are deleted) buffer which</span>
<span class="cm">	   contains node being balanced.  The mnemonic is that the</span>
<span class="cm">	   attempted change in node space used level is levbytes bytes. */</span>
	<span class="kt">int</span> <span class="n">levbytes</span><span class="p">;</span>
	<span class="cm">/* the maximal item size */</span>
	<span class="kt">int</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* S0 is the node whose balance is currently being checked,</span>
<span class="cm">	   and F0 is its father.  */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">S0</span><span class="p">,</span> <span class="o">*</span><span class="n">F0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lfree</span><span class="p">,</span> <span class="n">rfree</span> <span class="cm">/* free space in L and R */</span> <span class="p">;</span>

	<span class="n">S0</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">F0</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">levbytes</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>

	<span class="n">maxsize</span> <span class="o">=</span> <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">S0</span><span class="p">);</span>	<span class="cm">/* maximal possible size of an item */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">F0</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* S[0] is the root now. */</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">-</span><span class="n">levbytes</span> <span class="o">&gt;=</span> <span class="n">maxsize</span> <span class="o">-</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">S0</span><span class="p">),</span>
		       <span class="s">&quot;vs-8240: attempt to create empty buffer tree&quot;</span><span class="p">);</span>

		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_parents</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* get free space of neighbors */</span>
	<span class="n">rfree</span> <span class="o">=</span> <span class="n">get_rfree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="n">lfree</span> <span class="o">=</span> <span class="n">get_lfree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="n">create_virtual_node</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/* if 3 leaves can be merge to one, set parameters and return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">are_leaves_removable</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">lfree</span><span class="p">,</span> <span class="n">rfree</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>

	<span class="cm">/* determine maximal number of items we can shift to the left/right  neighbor</span>
<span class="cm">	   and the maximal number of bytes that can flow to the left/right neighbor</span>
<span class="cm">	   from the left/right most liquid item that cannot be shifted from S[0] entirely</span>
<span class="cm">	 */</span>
	<span class="n">check_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">lfree</span><span class="p">);</span>
	<span class="n">check_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">rfree</span><span class="p">);</span>

	<span class="cm">/* check whether we can merge S with left neighbor. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_left_neighbor_in_cache</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">)</span> <span class="o">||</span>	<span class="cm">/* S can not be merged with R */</span>
		    <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="p">{</span>

			<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span>
			       <span class="s">&quot;vs-8245: dc_check_balance_leaf: FL[h] must exist&quot;</span><span class="p">);</span>

			<span class="cm">/* set parameter to merge S[0] with its left neighbor */</span>
			<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* check whether we can merge S[0] with right neighbor. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All contents of S[0] can be moved to the neighbors (L[0] &amp; R[0]). Set parameters and return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_leaf_removable</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>

	<span class="cm">/* Balancing is not required. */</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">s0num</span> <span class="o">=</span> <span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_nr_item</span><span class="p">;</span>
	<span class="n">set_parameters</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether current node S[h] is balanced when Decreasing its size by</span>
<span class="cm"> * Deleting or Cutting.</span>
<span class="cm"> * Calculate parameters for balancing for current level h.</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	tb	tree_balance structure;</span>
<span class="cm"> *	h	current level of the node;</span>
<span class="cm"> *	inum	item number in S[h];</span>
<span class="cm"> *	mode	d - delete, c - cut.</span>
<span class="cm"> * Returns:	1 - schedule occurred;</span>
<span class="cm"> *	        0 - balancing for higher levels needed;</span>
<span class="cm"> *	       -1 - no balancing for higher levels needed;</span>
<span class="cm"> *	       -2 - no disk space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dc_check_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">)),</span>
	       <span class="s">&quot;vs-8250: S is not initialized&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dc_check_balance_internal</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">dc_check_balance_leaf</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check whether current node S[h] is balanced.</span>
<span class="cm"> * Calculate parameters for balancing for current level h.</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *</span>
<span class="cm"> *	tb	tree_balance structure:</span>
<span class="cm"> *</span>
<span class="cm"> *              tb is a large structure that must be read about in the header file</span>
<span class="cm"> *              at the same time as this procedure if the reader is to successfully</span>
<span class="cm"> *              understand this procedure</span>
<span class="cm"> *</span>
<span class="cm"> *	h	current level of the node;</span>
<span class="cm"> *	inum	item number in S[h];</span>
<span class="cm"> *	mode	i - insert, p - paste, d - delete, c - cut.</span>
<span class="cm"> * Returns:	1 - schedule occurred;</span>
<span class="cm"> *	        0 - balancing for higher levels needed;</span>
<span class="cm"> *	       -1 - no balancing for higher levels needed;</span>
<span class="cm"> *	       -2 - no disk space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_balance</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">h</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">inum</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ins_ih</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">vn</span><span class="p">;</span>

	<span class="n">vn</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="p">)(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf</span><span class="p">);</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_free_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_vn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_affected_item_num</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_pos_in_item</span> <span class="o">=</span> <span class="n">pos_in_item</span><span class="p">;</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_ins_ih</span> <span class="o">=</span> <span class="n">ins_ih</span><span class="p">;</span>
	<span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_INSERT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">vn_ins_ih</span><span class="p">,</span>
	       <span class="s">&quot;vs-8255: ins_ih can not be 0 in insert mode&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Calculate balance parameters when size of node is increasing. */</span>
		<span class="k">return</span> <span class="n">ip_check_balance</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/* Calculate balance parameters when  size of node is decreasing. */</span>
	<span class="k">return</span> <span class="n">dc_check_balance</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check whether parent at the path is the really parent of the current node.*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_direct_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">position</span><span class="p">,</span>
	    <span class="n">path_offset</span> <span class="o">=</span> <span class="n">PATH_H_PATH_OFFSET</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/* We are in the root or in the new root. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path_offset</span> <span class="o">&lt;=</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">path_offset</span> <span class="o">&lt;</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="s">&quot;PAP-8260: invalid offset in the path&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span><span class="o">-&gt;</span>
		    <span class="n">b_blocknr</span> <span class="o">==</span> <span class="n">SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Root is not changed. */</span>
			<span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>	<span class="cm">/* Root is changed and we must recalculate the path. */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span>
	    <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>	<span class="cm">/* Parent in the path is not in the tree. */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">position</span> <span class="o">=</span>
	     <span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
				  <span class="n">path_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path_offset</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">)</span>
		<span class="cm">/* Parent in the path is not parent of the current node in the tree. */</span>
		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>
		<span class="n">__wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>	<span class="cm">/* Parent in the path is unlocked and really parent of the current node.  */</span>
<span class="p">}</span>

<span class="cm">/* Using lnum[h] and rnum[h] we should determine what neighbors</span>
<span class="cm"> * of S[h] we</span>
<span class="cm"> * need in order to balance S[h], and get them if necessary.</span>
<span class="cm"> * Returns:	SCHEDULE_OCCURRED - schedule occurred while the function worked;</span>
<span class="cm"> *	        CARRY_ON - schedule didn&#39;t occur while the function worked;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">child_position</span><span class="p">,</span>
	    <span class="n">path_offset</span> <span class="o">=</span> <span class="n">PATH_H_PATH_OFFSET</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">son_number</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">get_neighbors</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/* We need left neighbor to balance S[h]. */</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">need_l_neighbor</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="p">);</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="p">),</span>
		       <span class="s">&quot;PAP-8270: invalid position in the parent&quot;</span><span class="p">);</span>

		<span class="n">child_position</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">bh</span> <span class="o">==</span>
		     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">?</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">:</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
								       <span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">son_number</span> <span class="o">=</span> <span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">child_position</span><span class="p">);</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">son_number</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">IO_ERROR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">get_neighbors_restart</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">||</span>
		       <span class="n">child_position</span> <span class="o">&gt;</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">||</span>
		       <span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">child_position</span><span class="p">)</span> <span class="o">!=</span>
		       <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span> <span class="s">&quot;PAP-8275: invalid parent&quot;</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span> <span class="s">&quot;PAP-8280: invalid child&quot;</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">h</span> <span class="o">&amp;&amp;</span>
		       <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">!=</span>
		       <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">-</span>
		       <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">child_position</span><span class="p">)),</span>
		       <span class="s">&quot;PAP-8290: invalid child size of left neighbor&quot;</span><span class="p">);</span>

		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need right neighbor to balance S[path_offset]. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="p">{</span>	<span class="cm">/* We need right neighbor to balance S[path_offset]. */</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">need_r_neighbor</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="p">);</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		       <span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
					    <span class="n">path_offset</span><span class="p">)</span> <span class="o">&gt;=</span>
		       <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
		       <span class="s">&quot;PAP-8295: invalid position in the parent&quot;</span><span class="p">);</span>

		<span class="n">child_position</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">?</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">son_number</span> <span class="o">=</span> <span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">child_position</span><span class="p">);</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">son_number</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">IO_ERROR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">get_neighbors_restart</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">h</span>
		       <span class="o">&amp;&amp;</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">!=</span>
		       <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">-</span>
		       <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">child_position</span><span class="p">)),</span>
		       <span class="s">&quot;PAP-8300: invalid child size of right neighbor (%d != %d - %d)&quot;</span><span class="p">,</span>
		       <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span> <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
		       <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">child_position</span><span class="p">)));</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_virtual_node_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max_num_of_items</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_num_of_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>

<span class="cp">#define MIN_NAME_LEN 1</span>

	<span class="n">max_num_of_items</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">BLKH_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">MIN_ITEM_LEN</span><span class="p">);</span>
	<span class="n">max_num_of_entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">BLKH_SIZE</span> <span class="o">-</span> <span class="n">IH_SIZE</span><span class="p">)</span> <span class="o">/</span>
	    <span class="p">(</span><span class="n">DEH_SIZE</span> <span class="o">+</span> <span class="n">MIN_NAME_LEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtual_node</span><span class="p">)</span> <span class="o">+</span>
	    <span class="n">max</span><span class="p">(</span><span class="n">max_num_of_items</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">direntry_uarea</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">max_num_of_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u16</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* maybe we should fail balancing we are going to perform when kmalloc</span>
<span class="cm">   fails several times. But now it will loop until kmalloc gets</span>
<span class="cm">   required memory */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_mem_for_virtual_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">check_fs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">get_virtual_node_size</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we have to allocate more memory for virtual node */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* free memory allocated before */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf</span><span class="p">);</span>
			<span class="cm">/* this is not needed if kfree is atomic */</span>
			<span class="n">check_fs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* virtual node requires now more memory */</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="cm">/* get memory for virtual item */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* getting memory with GFP_KERNEL priority may involve</span>
<span class="cm">			   balancing now (due to indirect_to_direct conversion on</span>
<span class="cm">			   dcache shrinking). So, release path and collected</span>
<span class="cm">			   resources here */</span>
			<span class="n">free_buffers_in_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_fs</span> <span class="o">&amp;&amp;</span> <span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tb_buffer_sanity_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>

			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;jmacd-1&quot;</span><span class="p">,</span> <span class="s">&quot;negative or zero &quot;</span>
				       <span class="s">&quot;reference counter for buffer %s[%d] &quot;</span>
				       <span class="s">&quot;(%b)&quot;</span><span class="p">,</span> <span class="n">descr</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;jmacd-2&quot;</span><span class="p">,</span> <span class="s">&quot;buffer is not up &quot;</span>
				       <span class="s">&quot;to date %s[%d] (%b)&quot;</span><span class="p">,</span>
				       <span class="n">descr</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;jmacd-3&quot;</span><span class="p">,</span> <span class="s">&quot;buffer is not &quot;</span>
				       <span class="s">&quot;in tree %s[%d] (%b)&quot;</span><span class="p">,</span>
				       <span class="n">descr</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">!=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;jmacd-4&quot;</span><span class="p">,</span> <span class="s">&quot;buffer has wrong &quot;</span>
				       <span class="s">&quot;device %s[%d] (%b)&quot;</span><span class="p">,</span>
				       <span class="n">descr</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">!=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;jmacd-5&quot;</span><span class="p">,</span> <span class="s">&quot;buffer has wrong &quot;</span>
				       <span class="s">&quot;blocksize %s[%d] (%b)&quot;</span><span class="p">,</span>
				       <span class="n">descr</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">&gt;</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;jmacd-6&quot;</span><span class="p">,</span> <span class="s">&quot;buffer block &quot;</span>
				       <span class="s">&quot;number too high %s[%d] (%b)&quot;</span><span class="p">,</span>
				       <span class="n">descr</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tb_buffer_sanity_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clear_all_dirty_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_tb_buffers_until_unlocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">locked</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="kt">int</span> <span class="n">repeat_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>

		<span class="n">locked</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="o">-&gt;</span><span class="n">path_length</span><span class="p">;</span>
		     <span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* if I understand correctly, we can only be sure the last buffer</span>
<span class="cm">				 ** in the path is in the tree --clm</span>
<span class="cm">				 */</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">)</span> <span class="o">==</span>
				    <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
					<span class="n">tb_buffer_sanity_check</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							       <span class="n">PATH_OFFSET_PBUFFER</span>
							       <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
								<span class="n">i</span><span class="p">),</span> <span class="s">&quot;S&quot;</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="o">-&gt;</span>
							       <span class="n">path_length</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_all_dirty_bits</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							  <span class="n">PATH_OFFSET_PBUFFER</span>
							  <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
							   <span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">locked</span> <span class="o">=</span>
					    <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
								<span class="n">i</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		     <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">tb_buffer_sanity_check</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							       <span class="s">&quot;L&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_all_dirty_bits</span>
					    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
						<span class="n">locked</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">tb_buffer_sanity_check</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							       <span class="s">&quot;FL&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_all_dirty_bits</span>
					    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
						<span class="n">locked</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">tb_buffer_sanity_check</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							       <span class="s">&quot;CFL&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_all_dirty_bits</span>
					    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
						<span class="n">locked</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>

			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">tb_buffer_sanity_check</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							       <span class="s">&quot;R&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_all_dirty_bits</span>
					    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
						<span class="n">locked</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">tb_buffer_sanity_check</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							       <span class="s">&quot;FR&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_all_dirty_bits</span>
					    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
						<span class="n">locked</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">tb_buffer_sanity_check</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							       <span class="s">&quot;CFR&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_all_dirty_bits</span>
					    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
						<span class="n">locked</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* as far as I can tell, this is not required.  The FEB list seems</span>
<span class="cm">		 ** to be full of newly allocated nodes, which will never be locked,</span>
<span class="cm">		 ** dirty, or anything else.</span>
<span class="cm">		 ** To be safe, I&#39;m putting in the checks and waits in.  For the moment,</span>
<span class="cm">		 ** they are needed to keep the code in journal.c from complaining</span>
<span class="cm">		 ** about the buffer.  That code is inside CONFIG_REISERFS_CHECK as well.</span>
<span class="cm">		 ** --clm</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_FEB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_all_dirty_bits</span>
				    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
					<span class="n">locked</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
			<span class="n">repeat_counter</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">repeat_counter</span> <span class="o">%</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-8200&quot;</span><span class="p">,</span>
						 <span class="s">&quot;too many iterations waiting &quot;</span>
						 <span class="s">&quot;for buffer to unlock &quot;</span>
						 <span class="s">&quot;(%b)&quot;</span><span class="p">,</span> <span class="n">locked</span><span class="p">);</span>

				<span class="cm">/* Don&#39;t loop forever.  Try to recover from possible error. */</span>

				<span class="k">return</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span> <span class="o">?</span>
				    <span class="n">REPEAT_SEARCH</span> <span class="o">:</span> <span class="n">CARRY_ON</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>
			<span class="n">__wait_on_buffer</span><span class="p">(</span><span class="n">locked</span><span class="p">);</span>
			<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">locked</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Prepare for balancing, that is</span>
<span class="cm"> *	get all necessary parents, and neighbors;</span>
<span class="cm"> *	analyze what and where should be moved;</span>
<span class="cm"> *	get sufficient number of new nodes;</span>
<span class="cm"> * Balancing will start only after all resources will be collected at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * When ported to SMP kernels, only at the last moment after all needed nodes</span>
<span class="cm"> * are collected in cache, will the resources be locked using the usual</span>
<span class="cm"> * textbook ordered lock acquisition algorithms.  Note that ensuring that</span>
<span class="cm"> * this code neither write locks what it does not need to write lock nor locks out of order</span>
<span class="cm"> * will be a pain in the butt that could have been avoided.  Grumble grumble. -Hans</span>
<span class="cm"> *</span>
<span class="cm"> * fix is meant in the sense of render unchanging</span>
<span class="cm"> *</span>
<span class="cm"> * Latency might be improved by first gathering a list of what buffers are needed</span>
<span class="cm"> * and then getting as many of them in parallel as possible? -Hans</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> *	op_mode	i - insert, d - delete, c - cut (truncate), p - paste (append)</span>
<span class="cm"> *	tb	tree_balance structure;</span>
<span class="cm"> *	inum	item number in S[h];</span>
<span class="cm"> *      pos_in_item - comment this if you can</span>
<span class="cm"> *      ins_ih	item head of item being inserted</span>
<span class="cm"> *	data	inserted item or data to be pasted</span>
<span class="cm"> * Returns:	1 - schedule occurred while the function worked;</span>
<span class="cm"> *	        0 - schedule didn&#39;t occur while the function worked;</span>
<span class="cm"> *             -1 - if no_disk_space</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">fix_nodes</span><span class="p">(</span><span class="kt">int</span> <span class="n">op_mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ins_ih</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">item_num</span> <span class="o">=</span> <span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">;</span>

	<span class="cm">/* we set wait_tb_buffers_run when we have to restore any dirty bits cleared</span>
<span class="cm">	 ** during wait_tb_buffers_run</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">wait_tb_buffers_run</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbS0</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>

	<span class="o">++</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_fix_nodes</span><span class="p">;</span>

	<span class="n">pos_in_item</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="o">-&gt;</span><span class="n">pos_in_item</span><span class="p">;</span>

	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">fs_gen</span> <span class="o">=</span> <span class="n">get_generation</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>

	<span class="cm">/* we prepare and log the super here so it will already be in the</span>
<span class="cm">	 ** transaction when do_balance needs to change it.</span>
<span class="cm">	 ** This way do_balance won&#39;t have to schedule when trying to prepare</span>
<span class="cm">	 ** the super for logging</span>
<span class="cm">	 */</span>
	<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
				     <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">transaction_handle</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
			   <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>

	<span class="cm">/* if it possible in indirect_to_direct conversion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">tbS0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>
		<span class="n">__wait_on_buffer</span><span class="p">(</span><span class="n">tbS0</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_tb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;fix_nodes&quot;</span><span class="p">);</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-8305&quot;</span><span class="p">,</span>
			       <span class="s">&quot;there is pending do_balance&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">tbS0</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">tbS0</span><span class="p">))</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-8320&quot;</span><span class="p">,</span> <span class="s">&quot;S[0] (%b %z) is &quot;</span>
			       <span class="s">&quot;not uptodate at the beginning of fix_nodes &quot;</span>
			       <span class="s">&quot;or not in tree (mode %c)&quot;</span><span class="p">,</span>
			       <span class="n">tbS0</span><span class="p">,</span> <span class="n">tbS0</span><span class="p">,</span> <span class="n">op_mode</span><span class="p">);</span>

	<span class="cm">/* Check parameters. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">op_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">M_INSERT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">item_num</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">item_num</span> <span class="o">&gt;</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbS0</span><span class="p">))</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-8330&quot;</span><span class="p">,</span> <span class="s">&quot;Incorrect &quot;</span>
				       <span class="s">&quot;item number %d (in S0 - %d) in case &quot;</span>
				       <span class="s">&quot;of insert&quot;</span><span class="p">,</span> <span class="n">item_num</span><span class="p">,</span>
				       <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbS0</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">M_PASTE</span>:
	<span class="k">case</span> <span class="n">M_DELETE</span>:
	<span class="k">case</span> <span class="n">M_CUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">item_num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">item_num</span> <span class="o">&gt;=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbS0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">print_block</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-8335&quot;</span><span class="p">,</span> <span class="s">&quot;Incorrect &quot;</span>
				       <span class="s">&quot;item number(%d); mode = %c &quot;</span>
				       <span class="s">&quot;insert_size = %d&quot;</span><span class="p">,</span>
				       <span class="n">item_num</span><span class="p">,</span> <span class="n">op_mode</span><span class="p">,</span>
				       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-8340&quot;</span><span class="p">,</span> <span class="s">&quot;Incorrect mode &quot;</span>
			       <span class="s">&quot;of operation&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_mem_for_virtual_node</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span> <span class="o">==</span> <span class="n">REPEAT_SEARCH</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>FIXME: maybe -ENOMEM when tb->vn_buf == 0? Now just repeat</p></td><td class="code"><div class="highlight"><pre>		<span class="k">return</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>

	<span class="cm">/* Starting from the leaf level; for all levels h of the tree. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">];</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_direct_parent</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">check_balance</span><span class="p">(</span><span class="n">op_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">item_num</span><span class="p">,</span>
				    <span class="n">pos_in_item</span><span class="p">,</span> <span class="n">ins_ih</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NO_BALANCING_NEEDED</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* No balancing for higher levels needed. */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="n">MAX_HEIGHT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/* ok, analysis and resource gathering are complete */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

		<span class="cm">/* No disk space, or schedule occurred and analysis may be</span>
<span class="cm">		 * invalid and needs to be redone. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_empty_nodes</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* We have a positive insert size but no nodes exist on this</span>
<span class="cm">			   level, this means that we are creating a new root. */</span>

			<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="s">&quot;PAP-8350: creating new empty root&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* The tree needs to be grown, so this node S[h]</span>
<span class="cm">				   which is the root node is split into two nodes,</span>
<span class="cm">				   and a new node (S[h+1]) will be created to</span>
<span class="cm">				   become the root node.  */</span>

				<span class="n">RFALSE</span><span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">MAX_HEIGHT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				       <span class="s">&quot;PAP-8355: attempt to create too high of a tree&quot;</span><span class="p">);</span>

				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span>
				     <span class="n">KEY_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">DC_SIZE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_tb_buffers_until_unlocked</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">CARRY_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wait_tb_buffers_run</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">REPEAT_SEARCH</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wait_tb_buffers_run</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="nl">repeat:</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>fix_nodes was unable to perform its calculation due to
filesystem got changed under us, lack of free disk space or i/o
failure. If the first is the case - the search will be
repeated. For now - free all resources acquired so far except
for the new allocated nodes</p></td><td class="code"><div class="highlight"><pre>	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* Release path buffers. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_tb_buffers_run</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pathrelse_and_restore</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* brelse all resources collected for balancing */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wait_tb_buffers_run</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
								 <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
								 <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
								 <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
								 <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
								 <span class="n">tb</span><span class="o">-&gt;</span>
								 <span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
								 <span class="n">tb</span><span class="o">-&gt;</span>
								 <span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait_tb_buffers_run</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_FEB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="n">reiserfs_restore_prepared_buffer</span>
					    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/* Anatoly will probably forgive me renaming tb to tb. I just</span>
<span class="cm">   wanted to make lines shorter */</span>
<span class="kt">void</span> <span class="nf">unfix_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Release path buffers. */</span>
	<span class="n">pathrelse_and_restore</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>

	<span class="cm">/* brelse all resources collected for balancing */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* deal with list of allocated (used and unused) nodes */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_FEB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">b_blocknr_t</span> <span class="n">blocknr</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
			<span class="cm">/* de-allocated block which was not used by balancing and</span>
<span class="cm">			   bforget about buffer for it */</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">transaction_handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					    <span class="n">blocknr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* release used as new nodes including a new root */</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">vn_buf</span><span class="p">);</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
