<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › bitmap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>bitmap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>
<span class="cm">/* Reiserfs block (de)allocator, bitmap-based. */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#define PREALLOCATION_SIZE 9</span>

<span class="cm">/* different reiserfs block allocator options */</span>

<span class="cp">#define SB_ALLOC_OPTS(s) (REISERFS_SB(s)-&gt;s_alloc_options.bits)</span>

<span class="cp">#define  _ALLOC_concentrating_formatted_nodes 0</span>
<span class="cp">#define  _ALLOC_displacing_large_files 1</span>
<span class="cp">#define  _ALLOC_displacing_new_packing_localities 2</span>
<span class="cp">#define  _ALLOC_old_hashed_relocation 3</span>
<span class="cp">#define  _ALLOC_new_hashed_relocation 4</span>
<span class="cp">#define  _ALLOC_skip_busy 5</span>
<span class="cp">#define  _ALLOC_displace_based_on_dirid 6</span>
<span class="cp">#define  _ALLOC_hashed_formatted_nodes 7</span>
<span class="cp">#define  _ALLOC_old_way 8</span>
<span class="cp">#define  _ALLOC_hundredth_slices 9</span>
<span class="cp">#define  _ALLOC_dirid_groups 10</span>
<span class="cp">#define  _ALLOC_oid_groups 11</span>
<span class="cp">#define  _ALLOC_packing_groups 12</span>

<span class="cp">#define  concentrating_formatted_nodes(s)	test_bit(_ALLOC_concentrating_formatted_nodes, &amp;SB_ALLOC_OPTS(s))</span>
<span class="cp">#define  displacing_large_files(s)		test_bit(_ALLOC_displacing_large_files, &amp;SB_ALLOC_OPTS(s))</span>
<span class="cp">#define  displacing_new_packing_localities(s)	test_bit(_ALLOC_displacing_new_packing_localities, &amp;SB_ALLOC_OPTS(s))</span>

<span class="cp">#define SET_OPTION(optname) \</span>
<span class="cp">   do { \</span>
<span class="cp">	reiserfs_info(s, &quot;block allocator option \&quot;%s\&quot; is set&quot;, #optname); \</span>
<span class="cp">	set_bit(_ALLOC_ ## optname , &amp;SB_ALLOC_OPTS(s)); \</span>
<span class="cp">    } while(0)</span>
<span class="cp">#define TEST_OPTION(optname, s) \</span>
<span class="cp">    test_bit(_ALLOC_ ## optname , &amp;SB_ALLOC_OPTS(s))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_bit_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				   <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bmap_nr</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* It is in the bitmap block number equal to the block</span>
<span class="cm">	 * number divided by the number of bits in a block. */</span>
	<span class="o">*</span><span class="n">bmap_nr</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="cm">/* Within that bitmap block it is located at bit offset *offset. */</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_reusable</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap_count</span> <span class="o">=</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">block</span> <span class="o">&gt;=</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-4010&quot;</span><span class="p">,</span>
			       <span class="s">&quot;block number is out of range %lu (%u)&quot;</span><span class="p">,</span>
			       <span class="n">block</span><span class="p">,</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_bit_address</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/* Old format filesystem? Unlikely, but the bitmaps are all up front so</span>
<span class="cm">	 * we need to account for it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REISERFS_OLD_FORMAT</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_properties</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">b_blocknr_t</span> <span class="n">bmap1</span> <span class="o">=</span> <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">bmap1</span> <span class="o">&amp;&amp;</span>
		    <span class="n">block</span> <span class="o">&lt;=</span> <span class="n">bmap1</span> <span class="o">+</span> <span class="n">bmap_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-4019&quot;</span><span class="p">,</span> <span class="s">&quot;bitmap block %lu(%u) &quot;</span>
				       <span class="s">&quot;can&#39;t be freed or reused&quot;</span><span class="p">,</span>
				       <span class="n">block</span><span class="p">,</span> <span class="n">bmap_count</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-4020&quot;</span><span class="p">,</span> <span class="s">&quot;bitmap block %lu(%u) &quot;</span>
				       <span class="s">&quot;can&#39;t be freed or reused&quot;</span><span class="p">,</span>
				       <span class="n">block</span><span class="p">,</span> <span class="n">bmap_count</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmap</span> <span class="o">&gt;=</span> <span class="n">bmap_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-4030&quot;</span><span class="p">,</span> <span class="s">&quot;bitmap for requested block &quot;</span>
			       <span class="s">&quot;is out of range: block=%lu, bitmap_nr=%u&quot;</span><span class="p">,</span>
			       <span class="n">block</span><span class="p">,</span> <span class="n">bmap</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bit_value</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">==</span> <span class="n">SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-4050&quot;</span><span class="p">,</span> <span class="s">&quot;this is root block (%u), &quot;</span>
			       <span class="s">&quot;it must be busy&quot;</span><span class="p">,</span> <span class="n">SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* searches in journal structures for a given block number (bmap, off). If block</span>
<span class="cm">   is found in reiserfs journal it suggests next free block candidate to test. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_block_in_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">b_blocknr_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_in_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bmap</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* hint supplied */</span>
			<span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scan_bitmap</span><span class="p">.</span><span class="n">in_journal_hint</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="n">off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* inc offset to avoid looping. */</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scan_bitmap</span><span class="p">.</span><span class="n">in_journal_nohint</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scan_bitmap</span><span class="p">.</span><span class="n">retry</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* it searches for a window of zero bits with given minimum and maximum lengths in one bitmap</span>
<span class="cm"> * block; */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_bitmap_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap_n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">beg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">boundary</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unfm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">bmap_n</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">org</span> <span class="o">=</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">bmap_n</span> <span class="o">&gt;=</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s">&quot;Bitmap %u is out of &quot;</span>
	       <span class="s">&quot;range (0..%u)&quot;</span><span class="p">,</span> <span class="n">bmap_n</span><span class="p">,</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scan_bitmap</span><span class="p">.</span><span class="n">bmap</span><span class="p">);</span>
<span class="cm">/* this is unclear and lacks comments, explain how journal bitmaps</span>
<span class="cm">   work here for the reader.  Convey a sense of the design here. What</span>
<span class="cm">   is a window? */</span>
<span class="cm">/* - I mean `a window of zero bits&#39; as in description of this function - Zam. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;jdm-4055&quot;</span><span class="p">,</span> <span class="s">&quot;NULL bitmap info pointer &quot;</span>
			       <span class="s">&quot;for bitmap %d&quot;</span><span class="p">,</span> <span class="n">bmap_n</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">reiserfs_read_bitmap_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bmap_n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	      <span class="nl">cont:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// No free blocks in this bitmap</span>
		<span class="p">}</span>

		<span class="cm">/* search for a first zero bit -- beginning of a window */</span>
		<span class="o">*</span><span class="n">beg</span> <span class="o">=</span> <span class="n">reiserfs_find_next_zero_le_bit</span>
		    <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">),</span> <span class="n">boundary</span><span class="p">,</span> <span class="o">*</span><span class="n">beg</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">beg</span> <span class="o">+</span> <span class="n">min</span> <span class="o">&gt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* search for a zero bit fails or the rest of bitmap block</span>
<span class="cm">						 * cannot contain a zero window of minimum size */</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unfm</span> <span class="o">&amp;&amp;</span> <span class="n">is_block_in_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bmap_n</span><span class="p">,</span> <span class="o">*</span><span class="n">beg</span><span class="p">,</span> <span class="n">beg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* first zero bit found; we check next bits */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">end</span> <span class="o">=</span> <span class="o">*</span><span class="n">beg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="n">end</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="o">*</span><span class="n">beg</span> <span class="o">+</span> <span class="n">max</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">boundary</span>
			    <span class="o">||</span> <span class="n">reiserfs_test_le_bit</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* finding the other end of zero bit window requires looking into journal structures (in</span>
<span class="cm">			 * case of searching for free blocks for unformatted nodes) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unfm</span> <span class="o">&amp;&amp;</span> <span class="n">is_block_in_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bmap_n</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* now (*beg) points to beginning of zero bits window,</span>
<span class="cm">		 * (end) points to one bit after the window end */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="o">*</span><span class="n">beg</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* it seems we have found window of proper size */</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/* try to set all blocks used checking are they still free */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* It seems that we should not check in journal again. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_test_and_set_le_bit</span>
				    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* bit was set by another process</span>
<span class="cm">					 * while we slept in prepare_for_journal() */</span>
					<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scan_bitmap</span><span class="p">.</span><span class="n">stolen</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="o">*</span><span class="n">beg</span> <span class="o">+</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* we can continue with smaller set of allocated blocks,</span>
<span class="cm">								 * if length of this set is more or equal to `min&#39; */</span>
						<span class="n">end</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/* otherwise we clear all bit were set ... */</span>
					<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="o">*</span><span class="n">beg</span><span class="p">)</span>
						<span class="n">reiserfs_clear_le_bit</span>
						    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
					<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
					<span class="o">*</span><span class="n">beg</span> <span class="o">=</span> <span class="n">org</span><span class="p">;</span>
					<span class="cm">/* ... and search again in current block from beginning */</span>
					<span class="k">goto</span> <span class="n">cont</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">bi</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">-=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="o">*</span><span class="n">beg</span><span class="p">);</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

			<span class="cm">/* free block count calculation */</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
						     <span class="mi">1</span><span class="p">);</span>
			<span class="n">PUT_SB_FREE_BLOCKS</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SB_FREE_BLOCKS</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="o">*</span><span class="n">beg</span><span class="p">));</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>

			<span class="k">return</span> <span class="n">end</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">beg</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bmap_hash_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">hash_in</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hash_in</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">keyed_hash</span><span class="p">(</span><span class="n">hash_in</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bm</span><span class="p">)</span>
			<span class="n">bm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* this can only be true when SB_BMAP_NR = 1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bm</span> <span class="o">&gt;=</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hashes the id and then returns &gt; 0 if the block group for the</span>
<span class="cm"> * corresponding hash is full</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">block_group_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bm</span> <span class="o">=</span> <span class="n">bmap_hash_id</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">bm</span><span class="p">];</span>

	<span class="cm">/* If we don&#39;t have cached information on this bitmap block, we&#39;re</span>
<span class="cm">	 * going to have to load it later anyway. Loading it here allows us</span>
<span class="cm">	 * to make a better decision. This favors long-term performance gain</span>
<span class="cm">	 * with a better on-disk layout vs. a short term gain of skipping the</span>
<span class="cm">	 * read and potentially having a bad placement. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">==</span> <span class="n">UINT_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">reiserfs_read_bitmap_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bm</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">/</span> <span class="mi">100</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * the packing is returned in disk byte order</span>
<span class="cm"> */</span>
<span class="n">__le32</span> <span class="nf">reiserfs_choose_packing</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="n">packing</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">packing_groups</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">parent_dir</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * some versions of reiserfsck expect packing locality 1 to be</span>
<span class="cm">		 * special</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent_dir</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">block_group_used</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">parent_dir</span><span class="p">))</span>
			<span class="n">packing</span> <span class="o">=</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">packing</span> <span class="o">=</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">packing</span> <span class="o">=</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">packing</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Tries to find contiguous zero bit window (given size) in given region of</span>
<span class="cm"> * bitmap and place new blocks there. Returns number of allocated blocks. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		       <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">finish</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unfm</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">file_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="cm">/* find every bm and bmap and bmap_nr in this file, and change them all to bitmap_blocknr</span>
<span class="cm">	 * - Hans, it is not a block number - Zam. */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bm</span><span class="p">,</span> <span class="n">off</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end_bm</span><span class="p">,</span> <span class="n">end_off</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off_max</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">scan_bitmap</span><span class="p">.</span><span class="n">call</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SB_FREE_BLOCKS</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// No point in looking for more free blocks</span>

	<span class="n">get_bit_address</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">);</span>
	<span class="n">get_bit_address</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_bm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_off</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bm</span> <span class="o">&gt;</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_bm</span> <span class="o">&gt;</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="n">end_bm</span> <span class="o">=</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/* When the bitmap is more than 10% free, anyone can allocate.</span>
<span class="cm">	 * When it&#39;s less than 10% free, only files that already use the</span>
<span class="cm">	 * bitmap are allowed. Once we pass 80% full, this restriction</span>
<span class="cm">	 * is lifted.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do this so that files that grow later still have space close to</span>
<span class="cm">	 * their original allocation. This improves locality, and presumably</span>
<span class="cm">	 * performance as a result.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is only an allocation policy and does not make up for getting a</span>
<span class="cm">	 * bad hint. Decent hinting must be implemented for this to work well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">skip_busy</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">SB_FREE_BLOCKS</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">bm</span> <span class="o">&lt;</span> <span class="n">end_bm</span><span class="p">;</span> <span class="n">bm</span><span class="o">++</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">off</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">unfm</span> <span class="o">||</span> <span class="p">(</span><span class="n">file_block</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span>
			    <span class="o">||</span> <span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">bm</span><span class="p">].</span><span class="n">free_count</span> <span class="o">&gt;</span>
			    <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
				<span class="n">nr_allocated</span> <span class="o">=</span>
				    <span class="n">scan_bitmap_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">,</span> <span class="n">off_max</span><span class="p">,</span>
						      <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">unfm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr_allocated</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* we know from above that start is a reasonable number */</span>
		<span class="n">get_bit_address</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">bm</span> <span class="o">&lt;</span> <span class="n">end_bm</span><span class="p">;</span> <span class="n">bm</span><span class="o">++</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_allocated</span> <span class="o">=</span>
		    <span class="n">scan_bitmap_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">,</span> <span class="n">off_max</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">unfm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_allocated</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nr_allocated</span> <span class="o">=</span>
	    <span class="n">scan_bitmap_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">off</span><span class="p">,</span> <span class="n">end_off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">unfm</span><span class="p">);</span>

      <span class="nl">ret:</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">bm</span> <span class="o">*</span> <span class="n">off_max</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nr_allocated</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_reiserfs_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">for_unformatted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">rs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">sbh</span><span class="p">,</span> <span class="o">*</span><span class="n">bmbh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="o">*</span><span class="n">apbi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">free_block</span><span class="p">);</span>

	<span class="n">rs</span> <span class="o">=</span> <span class="n">SB_DISK_SUPER_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">sbh</span> <span class="o">=</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">apbi</span> <span class="o">=</span> <span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">get_bit_address</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-4075&quot;</span><span class="p">,</span> <span class="s">&quot;block %lu is out of range&quot;</span><span class="p">,</span>
			       <span class="n">block</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bmbh</span> <span class="o">=</span> <span class="n">reiserfs_read_bitmap_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bmbh</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bmbh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* clear bit for the given block in bit map */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reiserfs_test_and_clear_le_bit</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">bmbh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-4080&quot;</span><span class="p">,</span>
			       <span class="s">&quot;block %lu: bit already cleared&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">apbi</span><span class="p">[</span><span class="n">nr</span><span class="p">].</span><span class="n">free_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bmbh</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bmbh</span><span class="p">);</span>

	<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sbh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* update super block */</span>
	<span class="n">set_sb_free_blocks</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">sb_free_blocks</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">sbh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">for_unformatted</span><span class="p">)</span>
		<span class="n">dquot_free_block_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">for_unformatted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-4061: trying to free block on nonexistent device&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_reusable</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;</span> <span class="n">sb_block_count</span><span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;bitmap-4072&quot;</span><span class="p">,</span>
			       <span class="s">&quot;Trying to free block outside file system &quot;</span>
			       <span class="s">&quot;boundaries (%lu &gt; %lu)&quot;</span><span class="p">,</span>
			       <span class="n">block</span><span class="p">,</span> <span class="n">sb_block_count</span><span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rs</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* mark it before we clear it, just in case */</span>
	<span class="n">journal_mark_freed</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">_reiserfs_free_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">for_unformatted</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* preallocated blocks don&#39;t need to be run through journal_mark_freed */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reiserfs_free_prealloc_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span>
	       <span class="s">&quot;vs-4060: trying to free block on nonexistent device&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_reusable</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">_reiserfs_free_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__discard_prealloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">reiserfs_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">save</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;zam-4001&quot;</span><span class="p">,</span>
			       <span class="s">&quot;inode has negative prealloc blocks count.&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_free_prealloc_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span><span class="p">);</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span>
		<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span> <span class="o">=</span> <span class="n">save</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_list</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* FIXME: It should be inline function */</span>
<span class="kt">void</span> <span class="nf">reiserfs_discard_prealloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span><span class="p">)</span>
		<span class="n">__discard_prealloc</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_discard_all_prealloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">plist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_prealloc_list</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">plist</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
		<span class="n">ei</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">plist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_inode_info</span><span class="p">,</span>
				<span class="n">i_prealloc_list</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;zam-4001&quot;</span><span class="p">,</span>
				       <span class="s">&quot;inode is in prealloc list but has &quot;</span>
				       <span class="s">&quot;no preallocated blocks.&quot;</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">__discard_prealloc</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_init_alloc_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">_ALLOC_skip_busy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SB_ALLOC_OPTS</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">_ALLOC_dirid_groups</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SB_ALLOC_OPTS</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">_ALLOC_packing_groups</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SB_ALLOC_OPTS</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* block allocator related options are parsed here */</span>
<span class="kt">int</span> <span class="nf">reiserfs_parse_alloc_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">this_char</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>

	<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* clear default settings */</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">this_char</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">value</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">value</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;concentrating_formatted_nodes&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">concentrating_formatted_nodes</span><span class="p">);</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span>
				<span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="o">?</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span>
							    <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="mi">10</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">temp</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">border</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">border</span> <span class="o">=</span>
				    <span class="mi">100</span> <span class="o">/</span> <span class="n">temp</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;displacing_large_files&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">displacing_large_files</span><span class="p">);</span>
			<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">large_file_size</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">value</span>
			     <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="o">?</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;displacing_new_packing_localities&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">displacing_new_packing_localities</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;old_hashed_relocation&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">old_hashed_relocation</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;new_hashed_relocation&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">new_hashed_relocation</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;dirid_groups&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">dirid_groups</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;oid_groups&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">oid_groups</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;packing_groups&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">packing_groups</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;hashed_formatted_nodes&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">hashed_formatted_nodes</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;skip_busy&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">skip_busy</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;hundredth_slices&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">hundredth_slices</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;old_way&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">old_way</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;displace_based_on_dirid&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SET_OPTION</span><span class="p">(</span><span class="n">displace_based_on_dirid</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;preallocmin&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">preallocmin</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">value</span>
			     <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="o">?</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">this_char</span><span class="p">,</span> <span class="s">&quot;preallocsize&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">preallocsize</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">value</span>
			     <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="o">?</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span>
							 <span class="mi">0</span><span class="p">)</span> <span class="o">:</span>
			    <span class="n">PREALLOCATION_SIZE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;zam-4001&quot;</span><span class="p">,</span> <span class="s">&quot;unknown option - %s&quot;</span><span class="p">,</span>
				 <span class="n">this_char</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reiserfs_info</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;allocator options = [%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SB_ALLOC_OPTS</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_sep</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">first</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">first</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">show_alloc_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SB_ALLOC_OPTS</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">_ALLOC_skip_busy</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">_ALLOC_dirid_groups</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">_ALLOC_packing_groups</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,alloc=&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">concentrating_formatted_nodes</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">border</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;concentrating_formatted_nodes=%d&quot;</span><span class="p">,</span>
				<span class="mi">100</span> <span class="o">/</span> <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">border</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;concentrating_formatted_nodes&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">displacing_large_files</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">large_file_size</span> <span class="o">!=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;displacing_large_files=%lu&quot;</span><span class="p">,</span>
			    <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">large_file_size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;displacing_large_files&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">displacing_new_packing_localities</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;displacing_new_packing_localities&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">old_hashed_relocation</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;old_hashed_relocation&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">new_hashed_relocation</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;new_hashed_relocation&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">dirid_groups</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;dirid_groups&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">oid_groups</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;oid_groups&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">packing_groups</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;packing_groups&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">hashed_formatted_nodes</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;hashed_formatted_nodes&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">skip_busy</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;skip_busy&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">hundredth_slices</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;hundredth_slices&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">old_way</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;old_way&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">displace_based_on_dirid</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;displace_based_on_dirid&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">preallocmin</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;preallocmin=%d&quot;</span><span class="p">,</span>
				<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">preallocmin</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">preallocsize</span> <span class="o">!=</span> <span class="mi">17</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">print_sep</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;preallocsize=%d&quot;</span><span class="p">,</span>
				<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">preallocsize</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">new_hashed_relocation</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">hash_in</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash_in</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>hint->search_start = hint->beg;</p></td><td class="code"><div class="highlight"><pre>			<span class="n">hash_in</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">displace_based_on_dirid</span><span class="p">,</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">))</span>
			<span class="n">hash_in</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">hash_in</span> <span class="o">=</span>
			    <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span>
	    <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span> <span class="n">keyed_hash</span><span class="p">(</span><span class="n">hash_in</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Relocation based on dirid, hashing them into a given bitmap block</span>
<span class="cm"> * files. Formatted nodes are unaffected, a separate policy covers them</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dirid_groups</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">dirid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">dirid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">)</span>
		<span class="n">dirid</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dirid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="n">bmap_hash_id</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">dirid</span><span class="p">);</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">bm</span> <span class="o">*</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="cm">/* give a portion of the block group to metadata */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
			<span class="n">hash</span> <span class="o">+=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Relocation based on oid, hashing them into a given bitmap block</span>
<span class="cm"> * files. Formatted nodes are unaffected, a separate policy covers them</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">oid_groups</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">oid</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">dirid</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bm</span><span class="p">;</span>

		<span class="n">dirid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>

		<span class="cm">/* keep the root dir and it&#39;s first set of subdirs close to</span>
<span class="cm">		 * the start of the disk</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirid</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">oid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">);</span>
			<span class="n">bm</span> <span class="o">=</span> <span class="n">bmap_hash_id</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">oid</span><span class="p">);</span>
			<span class="n">hash</span> <span class="o">=</span> <span class="n">bm</span> <span class="o">*</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* returns 1 if it finds an indirect item and gets valid hint info</span>
<span class="cm"> * from it, otherwise 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_left_neighbor</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">)</span>	<span class="cm">/* reiserfs code can call this function w/o pointer to path</span>
<span class="cm">				 * structure supplied; then we rely on supplied search_start */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">get_last_bh</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;green-4002: Illegal path specified to get_left_neighbor&quot;</span><span class="p">);</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">pos_in_item</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pos_in_item</span><span class="p">;</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">get_item</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span> <span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* for indirect item: go to left and look for the first non-hole entry</span>
<span class="cm">		   in the indirect item */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_item</span> <span class="o">==</span> <span class="n">I_UNFM_NUM</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
			<span class="n">pos_in_item</span><span class="o">--</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><pre><code>     pos_in_item = I_UNFM_NUM (ih) - 1;
</code></pre></td><td class="code"><div class="highlight"><pre>		<span class="k">while</span> <span class="p">(</span><span class="n">pos_in_item</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">get_block_num</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pos_in_item</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* does result value fit into specified region? */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* should be, if formatted node, then try to put on first part of the device</span>
<span class="cm">   specified as number of percent with mount option device, else try to put</span>
<span class="cm">   on last of device.  This is not to say it is good code to do so,</span>
<span class="cm">   but the effect should be measured.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_border_in_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				      <span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">b_blocknr_t</span> <span class="n">border</span> <span class="o">=</span>
	    <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">border</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">)</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">border</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">=</span> <span class="n">border</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">displace_large_file</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">displace_based_on_dirid</span><span class="p">,</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">))</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span>
		    <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span>
		    <span class="n">keyed_hash</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">),</span>
			       <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span>
		    <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span>
		    <span class="n">keyed_hash</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">),</span>
			       <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hash_formatted_node</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">hash_in</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">hash_in</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">displace_based_on_dirid</span><span class="p">,</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">))</span>
		<span class="n">hash_in</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hash_in</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">);</span>

	<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span>
	    <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span> <span class="n">keyed_hash</span><span class="p">(</span><span class="n">hash_in</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">this_blocknr_allocation_would_make_it_a_large_file</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span>
						   <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">==</span>
	    <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span><span class="n">large_file_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DISPLACE_NEW_PACKING_LOCALITIES</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">displace_new_packing_locality</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_core_key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>

	<span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">displace_new_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span>
	    <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span> <span class="n">keyed_hash</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">),</span>
				   <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">old_hashed_relocation</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">b_blocknr_t</span> <span class="n">border</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_in</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">||</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hash_in</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">((</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
	<span class="n">border</span> <span class="o">=</span>
	    <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">keyed_hash</span><span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">hash_in</span><span class="p">)),</span>
					 <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">border</span> <span class="o">&gt;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span><span class="p">)</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span> <span class="n">border</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">old_way</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">b_blocknr_t</span> <span class="n">border</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">||</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">border</span> <span class="o">=</span>
	    <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span>
							      <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">border</span> <span class="o">&gt;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span><span class="p">)</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span> <span class="n">border</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hundredth_slices</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_core_key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">slice_start</span><span class="p">;</span>

	<span class="n">slice_start</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">keyed_hash</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slice_start</span> <span class="o">&gt;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span>
	    <span class="o">||</span> <span class="n">slice_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span> <span class="n">slice_start</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">determine_search_start</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">amount_needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unfm_hint</span><span class="p">;</span>

	<span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hint</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* This is former border algorithm. Now with tunable border offset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">concentrating_formatted_nodes</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="n">set_border_in_hint</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">hint</span><span class="p">);</span>

<span class="cp">#ifdef DISPLACE_NEW_PACKING_LOCALITIES</span>
	<span class="cm">/* whenever we create a new directory, we displace it.  At first we will</span>
<span class="cm">	   hash for location, later we might look for a moderately empty place for</span>
<span class="cm">	   it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">displacing_new_packing_localities</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">displace_new_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">displace_new_packing_locality</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>

		<span class="cm">/* we do not continue determine_search_start,</span>
<span class="cm">		 * if new packing locality is being displaced */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* all persons should feel encouraged to add more special cases here and</span>
<span class="cm">	 * test them */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">displacing_large_files</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span>
	    <span class="o">&amp;&amp;</span> <span class="n">this_blocknr_allocation_would_make_it_a_large_file</span><span class="p">(</span><span class="n">hint</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">displace_large_file</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if none of our special cases is relevant, use the left neighbor in the</span>
<span class="cm">	   tree order of the new node we are allocating for */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span> <span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">hashed_formatted_nodes</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hash_formatted_node</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unfm_hint</span> <span class="o">=</span> <span class="n">get_left_neighbor</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>

	<span class="cm">/* Mimic old block allocator behaviour, that is if VFS allowed for preallocation,</span>
<span class="cm">	   new blocks are displaced based on directory ID. Also, if suggested search_start</span>
<span class="cm">	   is less than last preallocated block, we start searching from it, assuming that</span>
<span class="cm">	   HDD dataflow is faster in forward direction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">old_way</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reiserfs_hashed_relocation</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
				<span class="n">old_way</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reiserfs_no_unhashed_relocation</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
				<span class="n">old_hashed_relocation</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span>
			    <span class="o">&amp;&amp;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">&lt;</span>
			    <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span><span class="p">)</span>
				<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span>
				    <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This is an approach proposed by Hans */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">hundredth_slices</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">displacing_large_files</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hundredth_slices</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* old_hashed_relocation only works on unformatted */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unfm_hint</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span>
	    <span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">old_hashed_relocation</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">old_hashed_relocation</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* new_hashed_relocation works with both formatted/unformatted nodes */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">unfm_hint</span> <span class="o">||</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">new_hashed_relocation</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_hashed_relocation</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* dirid grouping works only on unformatted nodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unfm_hint</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span> <span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">dirid_groups</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dirid_groups</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef DISPLACE_NEW_PACKING_LOCALITIES</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span> <span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">dirid_groups</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dirid_groups</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* oid grouping works only on unformatted nodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unfm_hint</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span> <span class="n">TEST_OPTION</span><span class="p">(</span><span class="n">oid_groups</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">oid_groups</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">determine_prealloc_size</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* make minimum size a mount option and benchmark both ways */</span>
	<span class="cm">/* we preallocate blocks only for regular files, specific size */</span>
	<span class="cm">/* benchmark preallocating always and see what happens */</span>

	<span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">preallocate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;=</span>
		    <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span>
		    <span class="n">preallocmin</span> <span class="o">*</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span>
			<span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span> <span class="o">=</span>
			    <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_options</span><span class="p">.</span>
			    <span class="n">preallocsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* XXX I know it could be merged with upper-level function;</span>
<span class="cm">   but may be result function would be too complex. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">allocate_without_wrapping_disk</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">,</span>
						 <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">new_blocknrs</span><span class="p">,</span>
						 <span class="n">b_blocknr_t</span> <span class="n">start</span><span class="p">,</span>
						 <span class="n">b_blocknr_t</span> <span class="n">finish</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">amount_needed</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">prealloc_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">amount_needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_allocated</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rest</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">finish</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_allocated</span> <span class="o">=</span> <span class="n">scan_bitmap</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span>
					   <span class="n">rest</span> <span class="o">+</span> <span class="n">prealloc_size</span><span class="p">,</span>
					   <span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">,</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_allocated</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* no new blocks allocated, return */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* fill free_blocknrs array first */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">rest</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nr_allocated</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">new_blocknrs</span><span class="o">++</span> <span class="o">=</span> <span class="n">start</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rest</span><span class="o">--</span><span class="p">;</span>
			<span class="n">nr_allocated</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* do we have something to fill prealloc. array also ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_allocated</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* it means prealloc_size was greater that 0 and we do preallocation */</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_list</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">)</span><span class="o">-&gt;</span>
				 <span class="n">j_prealloc_list</span><span class="p">);</span>
			<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">=</span>
			    <span class="n">nr_allocated</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">amount_needed</span> <span class="o">-</span> <span class="n">rest</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">blocknrs_and_prealloc_arrays_from_search_start</span>
    <span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">new_blocknrs</span><span class="p">,</span>
     <span class="kt">int</span> <span class="n">amount_needed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">passno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">determine_prealloc_size</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">quota_ret</span><span class="p">;</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
			       <span class="s">&quot;reiserquota: allocating %d blocks id=%u&quot;</span><span class="p">,</span>
			       <span class="n">amount_needed</span><span class="p">,</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">quota_ret</span> <span class="o">=</span>
		    <span class="n">dquot_alloc_block_nodirty</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">amount_needed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">quota_ret</span><span class="p">)</span>	<span class="cm">/* Quota exceeded? */</span>
			<span class="k">return</span> <span class="n">QUOTA_EXCEEDED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">preallocate</span> <span class="o">&amp;&amp;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
			<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
				       <span class="s">&quot;reiserquota: allocating (prealloc) %d blocks id=%u&quot;</span><span class="p">,</span>
				       <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span><span class="p">,</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">quota_ret</span> <span class="o">=</span> <span class="n">dquot_prealloc_block_nodirty</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
							 <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">quota_ret</span><span class="p">)</span>
				<span class="n">hint</span><span class="o">-&gt;</span><span class="n">preallocate</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* for unformatted nodes, force large allocations */</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">passno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* Search from hint-&gt;search_start to end of disk */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span><span class="p">;</span>
			<span class="n">finish</span> <span class="o">=</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:	<span class="cm">/* Search from hint-&gt;beg to hint-&gt;search_start */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">;</span>
			<span class="n">finish</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:	<span class="cm">/* Last chance: Search from 0 to hint-&gt;beg */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">finish</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>	<span class="cm">/* We&#39;ve tried searching everywhere, not enough space */</span>
			<span class="cm">/* Free the blocks */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
				<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
					       <span class="s">&quot;reiserquota: freeing (nospace) %d blocks id=%u&quot;</span><span class="p">,</span>
					       <span class="n">amount_needed</span> <span class="o">+</span>
					       <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span> <span class="o">-</span>
					       <span class="n">nr_allocated</span><span class="p">,</span>
					       <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="cm">/* Free not allocated blocks */</span>
				<span class="n">dquot_free_block_nodirty</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
					<span class="n">amount_needed</span> <span class="o">+</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span> <span class="o">-</span>
					<span class="n">nr_allocated</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">nr_allocated</span><span class="o">--</span><span class="p">)</span>
				<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="p">,</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
						    <span class="n">new_blocknrs</span><span class="p">[</span><span class="n">nr_allocated</span><span class="p">],</span>
						    <span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">NO_DISK_SPACE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">nr_allocated</span> <span class="o">+=</span> <span class="n">allocate_without_wrapping_disk</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span>
								 <span class="n">new_blocknrs</span> <span class="o">+</span>
								 <span class="n">nr_allocated</span><span class="p">,</span>
								 <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span>
								 <span class="mi">1</span><span class="p">,</span>
								 <span class="n">amount_needed</span> <span class="o">-</span>
								 <span class="n">nr_allocated</span><span class="p">,</span>
								 <span class="n">hint</span><span class="o">-&gt;</span>
								 <span class="n">prealloc_size</span><span class="p">))</span>
		 <span class="o">&lt;</span> <span class="n">amount_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span>
	    <span class="n">amount_needed</span> <span class="o">+</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span> <span class="o">&gt;</span>
	    <span class="n">nr_allocated</span> <span class="o">+</span> <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Some of preallocation blocks were not allocated */</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
			       <span class="s">&quot;reiserquota: freeing (failed prealloc) %d blocks id=%u&quot;</span><span class="p">,</span>
			       <span class="n">amount_needed</span> <span class="o">+</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span> <span class="o">-</span>
			       <span class="n">nr_allocated</span> <span class="o">-</span>
			       <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span><span class="p">,</span>
			       <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">dquot_free_block_nodirty</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">amount_needed</span> <span class="o">+</span>
					 <span class="n">hint</span><span class="o">-&gt;</span><span class="n">prealloc_size</span> <span class="o">-</span> <span class="n">nr_allocated</span> <span class="o">-</span>
					 <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span>
					 <span class="n">i_prealloc_count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* grab new blocknrs from preallocated list */</span>
<span class="cm">/* return amount still needed after using them */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">use_preallocated_list_if_available</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">,</span>
					      <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">new_blocknrs</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">amount_needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">amount_needed</span><span class="p">)</span> <span class="p">{</span>

			<span class="o">*</span><span class="n">new_blocknrs</span><span class="o">++</span> <span class="o">=</span> <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span><span class="o">++</span><span class="p">;</span>
			<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span><span class="o">--</span><span class="p">;</span>

			<span class="n">amount_needed</span><span class="o">--</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_list</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* return amount still needed after using preallocated blocks */</span>
	<span class="k">return</span> <span class="n">amount_needed</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_allocate_blocknrs</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span> <span class="n">hint</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">new_blocknrs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount_needed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved_by_us</span>	<span class="cm">/* Amount of blocks we have</span>
<span class="cm">																	   already reserved */</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">initial_amount_needed</span> <span class="o">=</span> <span class="n">amount_needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>

	<span class="cm">/* Check if there is enough space, taking into account reserved space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SB_FREE_BLOCKS</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reserved_blocks</span> <span class="o">&lt;</span>
	    <span class="n">amount_needed</span> <span class="o">-</span> <span class="n">reserved_by_us</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NO_DISK_SPACE</span><span class="p">;</span>
	<span class="cm">/* should this be if !hint-&gt;inode &amp;&amp;  hint-&gt;preallocate? */</span>
	<span class="cm">/* do you mean hint-&gt;formatted_node can be removed ? - Zam */</span>
	<span class="cm">/* hint-&gt;formatted_node cannot be removed because we try to access</span>
<span class="cm">	   inode information here, and there is often no inode assotiated with</span>
<span class="cm">	   metadata allocations - green */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">formatted_node</span> <span class="o">&amp;&amp;</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">preallocate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">amount_needed</span> <span class="o">=</span> <span class="n">use_preallocated_list_if_available</span>
		    <span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="n">new_blocknrs</span><span class="p">,</span> <span class="n">amount_needed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amount_needed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* all blocknrs we need we got from</span>
<span class="cm">					   prealloc. list */</span>
			<span class="k">return</span> <span class="n">CARRY_ON</span><span class="p">;</span>
		<span class="n">new_blocknrs</span> <span class="o">+=</span> <span class="p">(</span><span class="n">initial_amount_needed</span> <span class="o">-</span> <span class="n">amount_needed</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* find search start and save it in hint structure */</span>
	<span class="n">determine_search_start</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="n">amount_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">&gt;=</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="n">hint</span><span class="o">-&gt;</span><span class="n">search_start</span> <span class="o">=</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* allocation itself; fill new_blocknrs and preallocation arrays */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">blocknrs_and_prealloc_arrays_from_search_start</span>
	    <span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="n">new_blocknrs</span><span class="p">,</span> <span class="n">amount_needed</span><span class="p">);</span>

	<span class="cm">/* we used prealloc. list to fill (partially) new_blocknrs array. If final allocation fails we</span>
<span class="cm">	 * need to return blocks back to prealloc. list or just free them. -- Zam (I chose second</span>
<span class="cm">	 * variant) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">amount_needed</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">initial_amount_needed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">th</span><span class="p">,</span> <span class="n">hint</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
					    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">new_blocknrs</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_cache_bitmap_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>

	<span class="cm">/* The first bit must ALWAYS be 1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reiserfs_test_le_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-2025&quot;</span><span class="p">,</span> <span class="s">&quot;bitmap block %lu is &quot;</span>
			       <span class="s">&quot;corrupted: first bit must be 1&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 0 and ~0 are special, we can optimize for them */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">+=</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0L</span><span class="p">)</span>	<span class="cm">/* A mix, investigate */</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">+=</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">hweight_long</span><span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">reiserfs_read_bitmap_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
                                               <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">b_blocknr_t</span> <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span> <span class="n">bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="cm">/* Way old format filesystems had the bitmaps packed up front.</span>
<span class="cm">	 * I doubt there are any of these left, but just in case... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">REISERFS_OLD_FORMAT</span><span class="p">,</span>
	                      <span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_properties</span><span class="p">))))</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">bitmap</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">REISERFS_DISK_OFFSET_IN_BYTES</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;sh-2029: %s: bitmap block (#%u) &quot;</span>
		                 <span class="s">&quot;reading failed&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">scan_bitmap</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="n">__wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">free_count</span> <span class="o">==</span> <span class="n">UINT_MAX</span><span class="p">)</span>
			<span class="n">reiserfs_cache_bitmap_metadata</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_init_bitmap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap_nr</span> <span class="o">=</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bitmap</span><span class="p">)</span> <span class="o">*</span> <span class="n">bmap_nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bitmap</span><span class="p">)</span> <span class="o">*</span> <span class="n">bmap_nr</span><span class="p">);</span>

	<span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_free_bitmap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
		<span class="n">SB_AP_BITMAP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
