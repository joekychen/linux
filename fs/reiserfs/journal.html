<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › journal.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>journal.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">** Write ahead logging implementation copyright Chris Mason 2000</span>
<span class="cm">**</span>
<span class="cm">** The background commits make this code very interrelated, and</span>
<span class="cm">** overly complex.  I need to rethink things a bit....The major players:</span>
<span class="cm">**</span>
<span class="cm">** journal_begin -- call with the number of blocks you expect to log.</span>
<span class="cm">**                  If the current transaction is too</span>
<span class="cm">** 		    old, it will block until the current transaction is</span>
<span class="cm">** 		    finished, and then start a new one.</span>
<span class="cm">**		    Usually, your transaction will get joined in with</span>
<span class="cm">**                  previous ones for speed.</span>
<span class="cm">**</span>
<span class="cm">** journal_join  -- same as journal_begin, but won&#39;t block on the current</span>
<span class="cm">**                  transaction regardless of age.  Don&#39;t ever call</span>
<span class="cm">**                  this.  Ever.  There are only two places it should be</span>
<span class="cm">**                  called from, and they are both inside this file.</span>
<span class="cm">**</span>
<span class="cm">** journal_mark_dirty -- adds blocks into this transaction.  clears any flags</span>
<span class="cm">**                       that might make them get sent to disk</span>
<span class="cm">**                       and then marks them BH_JDirty.  Puts the buffer head</span>
<span class="cm">**                       into the current transaction hash.</span>
<span class="cm">**</span>
<span class="cm">** journal_end -- if the current transaction is batchable, it does nothing</span>
<span class="cm">**                   otherwise, it could do an async/synchronous commit, or</span>
<span class="cm">**                   a full flush of all log and real blocks in the</span>
<span class="cm">**                   transaction.</span>
<span class="cm">**</span>
<span class="cm">** flush_old_commits -- if the current transaction is too old, it is ended and</span>
<span class="cm">**                      commit blocks are sent to disk.  Forces commit blocks</span>
<span class="cm">**                      to disk for all backgrounded commits that have been</span>
<span class="cm">**                      around too long.</span>
<span class="cm">**		     -- Note, if you call this as an immediate flush from</span>
<span class="cm">**		        from within kupdate, it will ignore the immediate flag</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/semaphore.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>


<span class="cm">/* gets a struct reiserfs_journal_list * from a list head */</span>
<span class="cp">#define JOURNAL_LIST_ENTRY(h) (list_entry((h), struct reiserfs_journal_list, \</span>
<span class="cp">                               j_list))</span>
<span class="cp">#define JOURNAL_WORK_ENTRY(h) (list_entry((h), struct reiserfs_journal_list, \</span>
<span class="cp">                               j_working_list))</span>

<span class="cm">/* the number of mounted filesystems.  This is used to decide when to</span>
<span class="cm">** start and kill the commit workqueue</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">reiserfs_mounted_fs_count</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">commit_wq</span><span class="p">;</span>

<span class="cp">#define JOURNAL_TRANS_HALF 1018	</span><span class="cm">/* must be correct to keep the desc and commit</span>
<span class="cm">				   structs at 4k */</span><span class="cp"></span>
<span class="cp">#define BUFNR 64		</span><span class="cm">/*read ahead */</span><span class="cp"></span>

<span class="cm">/* cnode stat bits.  Move these into reiserfs_fs.h */</span>

<span class="cp">#define BLOCK_FREED 2		</span><span class="cm">/* this block was freed, and can&#39;t be written.  */</span><span class="cp"></span>
<span class="cp">#define BLOCK_FREED_HOLDER 3	</span><span class="cm">/* this block was freed during this transaction, and can&#39;t be written */</span><span class="cp"></span>

<span class="cp">#define BLOCK_NEEDS_FLUSH 4	</span><span class="cm">/* used in flush_journal_list */</span><span class="cp"></span>
<span class="cp">#define BLOCK_DIRTIED 5</span>

<span class="cm">/* journal list state bits */</span>
<span class="cp">#define LIST_TOUCHED 1</span>
<span class="cp">#define LIST_DIRTY   2</span>
<span class="cp">#define LIST_COMMIT_PENDING  4	</span><span class="cm">/* someone will commit this list */</span><span class="cp"></span>

<span class="cm">/* flags for do_journal_end */</span>
<span class="cp">#define FLUSH_ALL   1		</span><span class="cm">/* flush commit and real blocks */</span><span class="cp"></span>
<span class="cp">#define COMMIT_NOW  2		</span><span class="cm">/* end and commit this transaction */</span><span class="cp"></span>
<span class="cp">#define WAIT        4		</span><span class="cm">/* wait for the log blocks to hit the disk */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">do_journal_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">flush_journal_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flushall</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">flush_commit_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flushall</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">can_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">journal_join</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">release_journal_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">super</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dirty_one_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">flush_async_commits</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">queue_log_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="cm">/* values for join in do_journal_begin_r */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">JBEGIN_REG</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* regular journal begin */</span>
	<span class="n">JBEGIN_JOIN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* join the running transaction if at all possible */</span>
	<span class="n">JBEGIN_ABORT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* called from cleanup code, ignores aborted flag */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">do_journal_begin_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">join</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_journal_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_hash_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">JOURNAL_HASH_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** clears BH_Dirty and sticks the buffer on the clean list.  Called because I can&#39;t allow refile_buffer to</span>
<span class="cm">** make schedule happen after I&#39;ve freed a block.  Look at remove_from_transaction and journal_mark_freed for</span>
<span class="cm">** more details.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_clean_and_file_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">clear_buffer_journal_test</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">*</span><span class="nf">allocate_bitmap_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span>
							 <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">*</span><span class="n">bn</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">bn</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bn</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bn</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bn</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">++</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">*</span><span class="nf">get_bitmap_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">*</span><span class="n">bn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bitmap_nodes</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_used_bitmap_nodes</span><span class="o">++</span><span class="p">;</span>
      <span class="nl">repeat:</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bitmap_nodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free_bitmap_nodes</span><span class="o">--</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">bn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bn</span> <span class="o">=</span> <span class="n">allocate_bitmap_node</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">yield</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bn</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_bitmap_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">*</span><span class="n">bn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_used_bitmap_nodes</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free_bitmap_nodes</span> <span class="o">&gt;</span> <span class="n">REISERFS_MAX_BITMAP_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bn</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bitmap_nodes</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free_bitmap_nodes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">allocate_bitmap_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">*</span><span class="n">bn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">REISERFS_MIN_BITMAP_NODES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">allocate_bitmap_node</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bitmap_nodes</span><span class="p">);</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free_bitmap_nodes</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* this is ok, we&#39;ll try again when more are needed */</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_bit_in_list_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				  <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap_nr</span> <span class="o">=</span> <span class="n">block</span> <span class="o">/</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit_nr</span> <span class="o">=</span> <span class="n">block</span> <span class="o">%</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">bmap_nr</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">bmap_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_bitmap_node</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">bit_nr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">bmap_nr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_bitmap_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">free_bitmap_node</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** only call this on FS unmount.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">free_list_bitmaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb_array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">JOURNAL_NUM_BITMAPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jb</span> <span class="o">=</span> <span class="n">jb_array</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">jb</span><span class="o">-&gt;</span><span class="n">journal_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cleanup_bitmap_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jb</span><span class="p">);</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">);</span>
		<span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">free_bitmap_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bitmap_nodes</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">*</span><span class="n">bn</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bitmap_nodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bn</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bitmap_nodes</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free_bitmap_nodes</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** get memory for JOURNAL_NUM_BITMAPS worth of bitmaps.</span>
<span class="cm">** jb_array is the array to be filled in.</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">reiserfs_allocate_list_bitmaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb_array</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">bmap_nr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">JOURNAL_NUM_BITMAPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jb</span> <span class="o">=</span> <span class="n">jb_array</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">jb</span><span class="o">-&gt;</span><span class="n">journal_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;clm-2000&quot;</span><span class="p">,</span> <span class="s">&quot;unable to &quot;</span>
					 <span class="s">&quot;allocate bitmaps for journal lists&quot;</span><span class="p">);</span>
			<span class="n">failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_list_bitmaps</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jb_array</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** find an available list bitmap.  If you can&#39;t find one, flush a commit list</span>
<span class="cm">** and try again</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="nf">get_list_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">reiserfs_journal_list</span>
						    <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">JOURNAL_NUM_BITMAPS</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap_index</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">JOURNAL_NUM_BITMAPS</span><span class="p">;</span>
		<span class="n">jb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">journal_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
					  <span class="n">journal_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">journal_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">journal_list</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* double check to make sure if flushed correctly */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jb</span><span class="o">-&gt;</span><span class="n">journal_list</span> <span class="o">=</span> <span class="n">jl</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">jb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** allocates a new chunk of X nodes, and links them all together as a list.</span>
<span class="cm">** Uses the cnode-&gt;next and cnode-&gt;prev pointers</span>
<span class="cm">** returns NULL on failure</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="nf">allocate_cnodes</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_cnodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_cnodes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">num_cnodes</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_cnodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">head</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* if last one, overwrite it after the if */</span>
	<span class="p">}</span>
	<span class="n">head</span><span class="p">[</span><span class="n">num_cnodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** pulls a cnode off the free list, or returns NULL on failure</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="nf">get_cnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">reiserfs_check_lock_depth</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;get_cnode&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_used</span><span class="o">++</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free</span><span class="o">--</span><span class="p">;</span>
	<span class="n">cn</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">cn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">cn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** returns a cnode to the free list</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_cnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">reiserfs_check_lock_depth</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;free_cnode&quot;</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_used</span><span class="o">--</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* not needed with the memset, but I might kill the memset, and forget to do this */</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_prepared_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_buffer_journal_prepared</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_journal_restore_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* return a cnode with same dev, block number and size in table, or null if not found */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="nf">get_journal_hash_dev</span><span class="p">(</span><span class="k">struct</span>
								  <span class="n">super_block</span>
								  <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
								  <span class="k">struct</span>
								  <span class="n">reiserfs_journal_cnode</span>
								  <span class="o">**</span><span class="n">table</span><span class="p">,</span>
								  <span class="kt">long</span> <span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="n">cn</span> <span class="o">=</span> <span class="n">journal_hash</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">bl</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="n">bl</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">==</span> <span class="n">sb</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cn</span><span class="p">;</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** this actually means &#39;can this block be reallocated yet?&#39;.  If you set search_all, a block can only be allocated</span>
<span class="cm">** if it is not in the current transaction, was not freed by the current transaction, and has no chance of ever</span>
<span class="cm">** being overwritten by a replay after crashing.</span>
<span class="cm">**</span>
<span class="cm">** If you don&#39;t set search_all, a block can only be allocated if it is not in the current transaction.  Since deleting</span>
<span class="cm">** a block removes it from the current transaction, this case should never happen.  If you don&#39;t set search_all, make</span>
<span class="cm">** sure you never write the block without logging it.</span>
<span class="cm">**</span>
<span class="cm">** next_zero_bit is a suggestion about the next block to try for find_forward.</span>
<span class="cm">** when bl is rejected because it is set in a journal list bitmap, we search</span>
<span class="cm">** for the next zero bit in the bitmap that rejected bl.  Then, we return that</span>
<span class="cm">** through next_zero_bit for find_forward to try.</span>
<span class="cm">**</span>
<span class="cm">** Just because we return something in next_zero_bit does not mean we won&#39;t</span>
<span class="cm">** reject it on the next call to reiserfs_in_journal</span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">reiserfs_in_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap_nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">search_all</span><span class="p">,</span>
			<span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">next_zero_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bl</span><span class="p">;</span>

	<span class="o">*</span><span class="n">next_zero_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* always start this at zero. */</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">in_journal</span><span class="p">);</span>
	<span class="cm">/* If we aren&#39;t doing a search_all, this is a metablock, and it will be logged before use.</span>
<span class="cm">	 ** if we crash before the transaction that freed it commits,  this transaction won&#39;t</span>
<span class="cm">	 ** have committed either, and the block will never be written</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">search_all</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">JOURNAL_NUM_BITMAPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">in_journal_bitmap</span><span class="p">);</span>
			<span class="n">jb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">journal_list</span> <span class="o">&amp;&amp;</span> <span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">bmap_nr</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			    <span class="n">test_bit</span><span class="p">(</span><span class="n">bit_nr</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">bmap_nr</span><span class="p">]</span><span class="o">-&gt;</span>
				     <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">next_zero_bit</span> <span class="o">=</span>
				    <span class="n">find_next_zero_bit</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
						       <span class="p">(</span><span class="n">jb</span><span class="o">-&gt;</span><span class="n">bitmaps</span><span class="p">[</span><span class="n">bmap_nr</span><span class="p">]</span><span class="o">-&gt;</span>
							<span class="n">data</span><span class="p">),</span>
						       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
						       <span class="n">bit_nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bl</span> <span class="o">=</span> <span class="n">bmap_nr</span> <span class="o">*</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">bit_nr</span><span class="p">;</span>
	<span class="cm">/* is it in any old transactions? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">search_all</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cn</span> <span class="o">=</span>
		<span class="n">get_journal_hash_dev</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_hash_table</span><span class="p">,</span> <span class="n">bl</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* is it in the current transaction.  This should never happen */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cn</span> <span class="o">=</span> <span class="n">get_journal_hash_dev</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_hash_table</span><span class="p">,</span> <span class="n">bl</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">in_journal_reusable</span><span class="p">);</span>
	<span class="cm">/* safe for reuse */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* insert cn into table</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">insert_journal_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">**</span><span class="n">table</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn_orig</span><span class="p">;</span>

	<span class="n">cn_orig</span> <span class="o">=</span> <span class="n">journal_hash</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">);</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">hnext</span> <span class="o">=</span> <span class="n">cn_orig</span><span class="p">;</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">hprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cn_orig</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cn_orig</span><span class="o">-&gt;</span><span class="n">hprev</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">journal_hash</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">)</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lock the current transaction */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">lock_journal</span><span class="p">);</span>

	<span class="n">reiserfs_mutex_lock_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_mutex</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* unlock the current transaction */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_journal_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_refcount</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_journal_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_refcount</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-2&quot;</span><span class="p">,</span> <span class="s">&quot;trans id %u, refcount at %d&quot;</span><span class="p">,</span>
			       <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">,</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_refcount</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_refcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">jl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** this used to be much more involved, and I&#39;m keeping it just in case things get ugly again.</span>
<span class="cm">** it gets called by flush_commit_list, and cleans up any data stored about blocks freed during a</span>
<span class="cm">** transaction.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_freed_for_journal_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cleanup_bitmap_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="o">-&gt;</span><span class="n">journal_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_list_still_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">&lt;=</span> <span class="n">trans_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If page-&gt;mapping was null, we failed to truncate this page for</span>
<span class="cm"> * some reason.  Most likely because it was truncated after being</span>
<span class="cm"> * logged via data=journal.</span>
<span class="cm"> *</span>
<span class="cm"> * This does a check to see if the buffer belongs to one of these</span>
<span class="cm"> * lost pages before doing the final put_bh.  If page-&gt;mapping was</span>
<span class="cm"> * null, it tries to free buffers on the page, which should make the</span>
<span class="cm"> * final page_cache_release drop the page from the lru.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_buffer_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
			<span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reiserfs_end_buffer_io_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;clm-2084&quot;</span><span class="p">,</span>
				 <span class="s">&quot;pinned buffer %lu:%s sent to disk&quot;</span><span class="p">,</span>
				 <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">release_buffer_page</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reiserfs_end_ordered_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">submit_logged_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">reiserfs_end_buffer_io_sync</span><span class="p">;</span>
	<span class="n">clear_buffer_journal_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_clear_buffer_journal_test</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">submit_bh</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">submit_ordered_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">reiserfs_end_ordered_io</span><span class="p">;</span>
	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">submit_bh</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define CHUNK_SIZE 32</span>
<span class="k">struct</span> <span class="n">buffer_chunk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">[</span><span class="n">CHUNK_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">submit_logged_buffer</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_ordered_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">submit_ordered_buffer</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_to_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			<span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_chunk</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">CHUNK_SIZE</span><span class="p">);</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">[</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">nr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">CHUNK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">fn</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">nr_reiserfs_jh</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">reiserfs_jh</span> <span class="o">*</span><span class="nf">alloc_jh</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_jh</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_reiserfs_jh</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">jh</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">yield</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * we want to free the jh when the buffer has been written</span>
<span class="cm"> * and waited on</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">reiserfs_free_jh</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_jh</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>

	<span class="n">jh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_reiserfs_jh</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_reiserfs_jh</span><span class="p">);</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__add_jh</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_jh</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_jh</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	      <span class="nl">no_jh:</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">alloc_jh</span><span class="p">();</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
		<span class="cm">/* buffer must be locked for __add_jh, should be able to have</span>
<span class="cm">		 * two adds at the same time</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">);</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">jl</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_tail_bh_list</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_bh_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_add_tail_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__add_jh</span><span class="p">(</span><span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">reiserfs_add_ordered_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__add_jh</span><span class="p">(</span><span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define JH_ENTRY(l) list_entry((l), struct reiserfs_jh, list)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_ordered_buffers</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_jh</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_chunk</span> <span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">chunk</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">JH_ENTRY</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">loop_next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span>
				<span class="n">write_ordered_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="p">);</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop_next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* in theory, dirty non-uptodate buffers should never get here,</span>
<span class="cm">		 * but the upper layer io error paths still have a few quirks.</span>
<span class="cm">		 * Handle them here as gracefully as we can</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">add_to_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">write_ordered_chunk</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">reiserfs_free_jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	      <span class="nl">loop_next:</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">cond_resched_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">write_ordered_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">JH_ENTRY</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">reiserfs_free_jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* ugly interaction with invalidatepage here.</span>
<span class="cm">		 * reiserfs_invalidate_page will pin any buffer that has a valid</span>
<span class="cm">		 * journal head from an older transaction.  If someone else sets</span>
<span class="cm">		 * our buffer dirty after we write it in the first loop, and</span>
<span class="cm">		 * then someone truncates the page away, nobody will ever write</span>
<span class="cm">		 * the buffer. We&#39;re safe if we write the page one last time</span>
<span class="cm">		 * after freeing the journal header.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">cond_resched_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush_older_commits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">other_jl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">first_jl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">other_trans_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_trans_id</span><span class="p">;</span>

      <span class="nl">find_first:</span>
	<span class="cm">/*</span>
<span class="cm">	 * first we walk backwards to find the oldest uncommitted transation</span>
<span class="cm">	 */</span>
	<span class="n">first_jl</span> <span class="o">=</span> <span class="n">jl</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">other_jl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span> <span class="o">||</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other_jl</span><span class="o">-&gt;</span><span class="n">j_older_commits_done</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">first_jl</span> <span class="o">=</span> <span class="n">other_jl</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">other_jl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if we didn&#39;t find any older uncommitted transactions, return now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_jl</span> <span class="o">==</span> <span class="n">jl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">first_trans_id</span> <span class="o">=</span> <span class="n">first_jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">first_jl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">other_jl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">other_trans_id</span> <span class="o">=</span> <span class="n">other_jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">other_trans_id</span> <span class="o">&lt;</span> <span class="n">trans_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other_jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">other_jl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

				<span class="cm">/* list we were called with is gone, return */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_list_still_alive</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">trans_id</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

				<span class="cm">/* the one we just flushed is gone, this means all</span>
<span class="cm">				 * older lists are also gone, so first_jl is no longer</span>
<span class="cm">				 * valid either.  Go back to the beginning.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_list_still_alive</span>
				    <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">other_trans_id</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">goto</span> <span class="n">find_first</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_async_progress_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_async_throttle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** if this journal list still has commit blocks unflushed, send them to disk.</span>
<span class="cm">**</span>
<span class="cm">** log areas must be flushed in order (transaction 2 can&#39;t commit before transaction 1)</span>
<span class="cm">** Before the commit block can by written, every other log block must be safely on disk</span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush_commit_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flushall</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">bn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_len</span><span class="p">;</span>

	<span class="n">reiserfs_check_lock_depth</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;flush_commit_list&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_older_commits_done</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* before we can put our commit blocks on disk, we have to make sure everyone older than</span>
<span class="cm">	 ** us is on disk too</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">trans_id</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>

	<span class="n">get_journal_list</span><span class="p">(</span><span class="n">jl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flushall</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flush_older_commits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* list disappeared during flush_older_commits.  return */</span>
			<span class="k">goto</span> <span class="n">put_jl</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* make sure nobody is trying to flush this one at the same time */</span>
	<span class="n">reiserfs_mutex_lock_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_mutex</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_list_still_alive</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">trans_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">put_jl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* this commit is done, exit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flushall</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_older_commits_done</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">put_jl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_bh_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We might sleep in numerous places inside</span>
<span class="cm">		 * write_ordered_buffers. Relax the write lock.</span>
<span class="cm">		 */</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">write_ordered_buffers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">,</span>
					    <span class="n">journal</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_bh_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_bh_list</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * for the description block and all the log blocks, submit any buffers</span>
<span class="cm">	 * that haven&#39;t already reached the disk.  Try to write at least 256</span>
<span class="cm">	 * log blocks. later on, we will only wait on blocks that correspond</span>
<span class="cm">	 * to this transaction, but while we&#39;re unplugging we might as well</span>
<span class="cm">	 * get a chunk of data on there.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_async_throttle</span><span class="p">);</span>
	<span class="n">write_len</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_len</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span>
		<span class="n">write_len</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">write_len</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span>
		    <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">tbh</span> <span class="o">=</span> <span class="n">journal_find_get_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tbh</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">tbh</span><span class="p">))</span> <span class="p">{</span>
		            <span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			    <span class="n">ll_rw_block</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tbh</span><span class="p">);</span>
			    <span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">put_bh</span><span class="p">(</span><span class="n">tbh</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_async_throttle</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">tbh</span> <span class="o">=</span> <span class="n">journal_find_get_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bn</span><span class="p">);</span>

		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>since we're using ll<em>rw</em>blk above, it might have skipped over
a locked buffer.  Double check here</p></td><td class="code"><div class="highlight"><pre>		<span class="cm">/* redundant, sync_dirty_buffer() checks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">tbh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>
			<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">tbh</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-601&quot;</span><span class="p">,</span>
					 <span class="s">&quot;buffer write failed&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>	<span class="cm">/* once for journal_find_get_block */</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>	<span class="cm">/* once due to original getblk in do_journal_end */</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* If there was a write error in the journal - we can&#39;t commit</span>
<span class="cm">	 * this transaction - it will be invalid and, if successful,</span>
<span class="cm">	 * will just end up propagating the write error out to</span>
<span class="cm">	 * the file system. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reiserfs_is_journal_aborted</span> <span class="p">(</span><span class="n">journal</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_bh</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_bh</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_barrier_flush</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
			<span class="n">__sync_dirty_buffer</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_bh</span><span class="p">,</span> <span class="n">WRITE_FLUSH_FUA</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_bh</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If there was a write error in the journal - we can&#39;t commit this</span>
<span class="cm">	 * transaction - it will be invalid and, if successful, will just end</span>
<span class="cm">	 * up propagating the write error out to the filesystem. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_bh</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-615&quot;</span><span class="p">,</span> <span class="s">&quot;buffer write failed&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bforget</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_commit_id</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_commit_id</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;clm-2200&quot;</span><span class="p">,</span> <span class="s">&quot;last commit %lu, current %lu&quot;</span><span class="p">,</span>
				 <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_commit_id</span><span class="p">,</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_commit_id</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>

	<span class="cm">/* now, every commit block is on the disk.  It is safe to allow blocks freed during this transaction to be reallocated */</span>
	<span class="n">cleanup_freed_for_journal_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">retval</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">;</span>

	<span class="cm">/* mark the metadata dirty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">dirty_one_transaction</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flushall</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_older_commits_done</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_mutex</span><span class="p">);</span>
      <span class="nl">put_jl:</span>
	<span class="n">put_journal_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">reiserfs_abort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="s">&quot;Journal write error in %s&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** flush_journal_list frequently needs to find a newer transaction for a given block.  This does that, or</span>
<span class="cm">** returns NULL if it can&#39;t find anything</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="nf">find_newer_jl_for_cn</span><span class="p">(</span><span class="k">struct</span>
							  <span class="n">reiserfs_journal_cnode</span>
							  <span class="o">*</span><span class="n">cn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">blocknr</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">;</span>

	<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">==</span> <span class="n">sb</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="n">blocknr</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">newer_jl_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">blocknr</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">;</span>

	<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">==</span> <span class="n">sb</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="n">blocknr</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">jlist</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">remove_journal_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">**</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
				<span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">** once all the real blocks have been flushed, it is safe to remove them from the</span>
<span class="cm">** journal list for this transaction.  Aside from freeing the cnode, this also allows the</span>
<span class="cm">** block to be reallocated for data blocks if it had been deleted.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_all_from_journal_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">debug</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="n">cn</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">;</span>

	<span class="cm">/* which is better, to lock once around the whole loop, or</span>
<span class="cm">	 ** to lock for each call to remove_journal_hash?</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-2201&quot;</span><span class="p">,</span>
						 <span class="s">&quot;block %u, bh is %d, state %ld&quot;</span><span class="p">,</span>
						 <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
						 <span class="n">cn</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">cn</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">remove_journal_hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_hash_table</span><span class="p">,</span>
					    <span class="n">jl</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">free_cnode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** if this timestamp is greater than the timestamp we wrote last to the header block, write it to the header block.</span>
<span class="cm">** once this is done, I can safely say the log area for this transaction won&#39;t ever be replayed, and I can start</span>
<span class="cm">** releasing blocks in this transaction for reuse as data blocks.</span>
<span class="cm">** called by flush_journal_list, before it calls remove_all_from_journal_list</span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_update_journal_header_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_header</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans_id</span> <span class="o">&gt;=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">((</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="n">wait_on_buffer</span><span class="p">((</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">));</span>
			<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
				<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-699&quot;</span><span class="p">,</span>
						 <span class="s">&quot;buffer write failed&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span> <span class="o">=</span> <span class="n">trans_id</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first_unflushed_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="o">-&gt;</span>
							<span class="n">b_data</span><span class="p">);</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">trans_id</span><span class="p">);</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_first_unflushed_offset</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_mount_id</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_mount_id</span><span class="p">);</span>

		<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">);</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_barrier_flush</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
			<span class="n">__sync_dirty_buffer</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">,</span> <span class="n">WRITE_FLUSH_FUA</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">);</span>

		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-837&quot;</span><span class="p">,</span>
					 <span class="s">&quot;IO error during journal replay&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_journal_header_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_update_journal_header_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">trans_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** flush any and all journal lists older than you are</span>
<span class="cm">** can only be called from flush_journal_list</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush_older_journal_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">other_jl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>

	<span class="cm">/* we know we are the only ones flushing things, no extra race</span>
<span class="cm">	 * protection is required.</span>
<span class="cm">	 */</span>
      <span class="nl">restart:</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="cm">/* Did we wrap? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">other_jl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other_jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">&lt;</span> <span class="n">trans_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">other_jl</span><span class="o">-&gt;</span><span class="n">j_refcount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* do not flush all */</span>
		<span class="n">flush_journal_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">other_jl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* other_jl is now deleted from the list */</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">del_from_work_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_working_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_working_list</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_num_work_lists</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* flush a journal list, both commit and real blocks</span>
<span class="cm">**</span>
<span class="cm">** always set flushall to 1, unless you are calling from inside</span>
<span class="cm">** flush_journal_list</span>
<span class="cm">**</span>
<span class="cm">** IMPORTANT.  This can only be called while there are no journal writers,</span>
<span class="cm">** and the journal is locked.  That means it can only be called from</span>
<span class="cm">** do_journal_end, or by journal_release</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush_journal_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flushall</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">pjl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_jwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">saved_bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_len_saved</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">j_len_saved</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;clm-2048&quot;</span><span class="p">,</span> <span class="s">&quot;called with wcount %d&quot;</span><span class="p">,</span>
				 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* if flushall == 0, the lock is already held */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flushall</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_mutex_lock_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flush_mutex</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flush_mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j_len_saved</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-715&quot;</span><span class="p">,</span> <span class="s">&quot;length is %lu, trans id %lu&quot;</span><span class="p">,</span>
			       <span class="n">j_len_saved</span><span class="p">,</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if all the work is already done, get out of here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_nonzerolen</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">flush_older_and_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* start by putting the commit list on disk.  This will also flush</span>
<span class="cm">	 ** the commit lists of any olders transactions</span>
<span class="cm">	 */</span>
	<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">&amp;</span> <span class="n">LIST_DIRTY</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reiserfs_is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="cm">/* are we done now? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_nonzerolen</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">flush_older_and_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* loop through each cnode, see if we need to write it,</span>
<span class="cm">	 ** or wait on a more recent transaction, or just ignore it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-844&quot;</span><span class="p">,</span> <span class="s">&quot;journal list is flushing, &quot;</span>
			       <span class="s">&quot;wcount is not 0&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cn</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">was_jwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">was_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">saved_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* blocknr of 0 is no longer in the hash, ignore it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">free_cnode</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* This transaction failed commit. Don&#39;t write out to the disk */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">&amp;</span> <span class="n">LIST_DIRTY</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_cnode</span><span class="p">;</span>

		<span class="n">pjl</span> <span class="o">=</span> <span class="n">find_newer_jl_for_cn</span><span class="p">(</span><span class="n">cn</span><span class="p">);</span>
		<span class="cm">/* the order is important here.  We check pjl to make sure we</span>
<span class="cm">		 ** don&#39;t clear BH_JDirty_wait if we aren&#39;t the one writing this</span>
<span class="cm">		 ** block to disk</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pjl</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">saved_bh</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>

			<span class="cm">/* we do this to make sure nobody releases the buffer while</span>
<span class="cm">			 ** we are working with it</span>
<span class="cm">			 */</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">can_dirty</span><span class="p">(</span><span class="n">cn</span><span class="p">));</span>
				<span class="n">was_jwait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">was_dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">can_dirty</span><span class="p">(</span><span class="n">cn</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* everything with !pjl &amp;&amp; jwait should be writable */</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* if someone has this block in a newer transaction, just make</span>
<span class="cm">		 ** sure they are committed, and don&#39;t try writing it to disk</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pjl</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pjl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">))</span>
				<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pjl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_cnode</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* bh == NULL when the block got to disk on its own, OR,</span>
<span class="cm">		 ** the block got freed in a future transaction</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">saved_bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">free_cnode</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* this should never happen.  kupdate_one_transaction has this list</span>
<span class="cm">		 ** locked while it works, so we should never see a buffer here that</span>
<span class="cm">		 ** is not marked JDirty_wait</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">was_jwait</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-813&quot;</span><span class="p">,</span>
					 <span class="s">&quot;BAD! buffer %llu %cdirty %cjwait, &quot;</span>
					 <span class="s">&quot;not in a newer tranasction&quot;</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">saved_bh</span><span class="o">-&gt;</span>
					 <span class="n">b_blocknr</span><span class="p">,</span> <span class="n">was_dirty</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;!&#39;</span><span class="p">,</span>
					 <span class="n">was_jwait</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;!&#39;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">was_dirty</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we inc again because saved_bh gets decremented at free_cnode */</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">BLOCK_NEEDS_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">!=</span> <span class="n">saved_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">))</span>
				<span class="n">submit_logged_buffer</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;clm-2082&quot;</span><span class="p">,</span>
					 <span class="s">&quot;Unable to flush buffer %llu in %s&quot;</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">saved_bh</span><span class="o">-&gt;</span>
					 <span class="n">b_blocknr</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
	      <span class="nl">free_cnode:</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">saved_bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we incremented this to keep others from taking the buffer head away */</span>
			<span class="n">put_bh</span><span class="p">(</span><span class="n">saved_bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">saved_bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-945&quot;</span><span class="p">,</span>
						 <span class="s">&quot;saved_bh-&gt;b_count &lt; 0&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BLOCK_NEEDS_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-1011&quot;</span><span class="p">,</span>
						       <span class="s">&quot;cn-&gt;bh is NULL&quot;</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-1012&quot;</span><span class="p">,</span>
						       <span class="s">&quot;cn-&gt;bh is NULL&quot;</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
					<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;journal-949&quot;</span><span class="p">,</span>
							 <span class="s">&quot;buffer write failed&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* note, we must clear the JDirty_wait bit after the up to date</span>
<span class="cm">				 ** check, otherwise we race against our flushpage routine</span>
<span class="cm">				 */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">test_clear_buffer_journal_dirty</span>
				       <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">));</span>

				<span class="cm">/* drop one ref for us */</span>
				<span class="n">put_bh</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
				<span class="cm">/* drop one ref for journal_mark_dirty */</span>
				<span class="n">release_buffer_page</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">reiserfs_abort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">,</span>
			       <span class="s">&quot;Write error while pushing transaction to disk in %s&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">);</span>
      <span class="nl">flush_older_and_return:</span>

	<span class="cm">/* before we can update the journal header block, we _must_ flush all</span>
<span class="cm">	 ** real blocks from all older transactions to disk.  This is because</span>
<span class="cm">	 ** once the header block is updated, this transaction will not be</span>
<span class="cm">	 ** replayed after a crash</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flushall</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_older_journal_lists</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">;</span>
	<span class="cm">/* before we can remove everything from the hash tables for this</span>
<span class="cm">	 ** transaction, we must make sure it can never be replayed</span>
<span class="cm">	 **</span>
<span class="cm">	 ** since we are only called from do_journal_end, we know for sure there</span>
<span class="cm">	 ** are no allocations going on while we are flushing journal lists.  So,</span>
<span class="cm">	 ** we only need to update the journal header block for the last list</span>
<span class="cm">	 ** being flushed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">flushall</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span>
		    <span class="n">update_journal_header_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
						<span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">+</span>
						 <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
						<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">reiserfs_abort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">,</span>
				       <span class="s">&quot;Write error while updating journal header in %s&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">remove_all_from_journal_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_num_lists</span><span class="o">--</span><span class="p">;</span>
	<span class="n">del_from_work_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_id</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_id</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;clm-2201&quot;</span><span class="p">,</span> <span class="s">&quot;last flush %lu, current %lu&quot;</span><span class="p">,</span>
				 <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_id</span><span class="p">,</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_id</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>

	<span class="cm">/* not strictly required since we are freeing the list, but it should</span>
<span class="cm">	 * help find code using dead lists later on</span>
<span class="cm">	 */</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_nonzerolen</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">put_journal_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flushall</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flush_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_nonzerolen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cn</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if the blocknr == 0, this has been cleared from the hash,</span>
<span class="cm">		 ** skip it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">newer_jl_done</span><span class="p">(</span><span class="n">cn</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	      <span class="nl">next:</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_one_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">buffer_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">|=</span> <span class="n">LIST_TOUCHED</span><span class="p">;</span>
	<span class="n">del_from_work_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_nonzerolen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cn</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if the blocknr == 0, this has been cleared from the hash,</span>
<span class="cm">		 ** skip it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="n">can_dirty</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tmp_bh</span><span class="p">;</span>
			<span class="cm">/* we can race against journal_mark_freed when we try</span>
<span class="cm">			 * to lock_buffer(cn-&gt;bh), so we have to inc the buffer</span>
<span class="cm">			 * count, and recheck things after locking</span>
<span class="cm">			 */</span>
			<span class="n">tmp_bh</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">);</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="n">can_dirty</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">)</span> <span class="o">||</span>
				    <span class="n">buffer_journal_prepared</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">))</span>
					<span class="n">BUG</span><span class="p">();</span>
				<span class="n">add_to_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">tmp_bh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">write_chunk</span><span class="p">);</span>
				<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* note, cn-&gt;bh might be null now */</span>
				<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">put_bh</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">);</span>
		<span class="p">}</span>
	      <span class="nl">next:</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* used by flush_commit_list */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dirty_one_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">pjl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">|=</span> <span class="n">LIST_DIRTY</span><span class="p">;</span>
	<span class="n">cn</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* look for a more recent transaction that logged this</span>
<span class="cm">		 ** buffer.  Only the most recent transaction with a buffer in</span>
<span class="cm">		 ** it is allowed to send that buffer to disk</span>
<span class="cm">		 */</span>
		<span class="n">pjl</span> <span class="o">=</span> <span class="n">find_newer_jl_for_cn</span><span class="p">(</span><span class="n">cn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pjl</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span>
		    <span class="o">&amp;&amp;</span> <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">can_dirty</span><span class="p">(</span><span class="n">cn</span><span class="p">));</span>
			<span class="cm">/* if the buffer is prepared, it will either be logged</span>
<span class="cm">			 * or restored.  If restored, we need to make sure</span>
<span class="cm">			 * it actually gets marked dirty</span>
<span class="cm">			 */</span>
			<span class="n">clear_buffer_journal_new</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journal_prepared</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">set_buffer_journal_restore_dirty</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">set_buffer_journal_test</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kupdate_transactions</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">**</span><span class="n">next_jl</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">next_trans_id</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">num_blocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">transactions_flushed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">orig_trans_id</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_chunk</span> <span class="n">chunk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">chunk</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reiserfs_mutex_lock_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flush_mutex</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_list_still_alive</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">orig_trans_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;ve got j_flush_mutex held, nobody is going to delete any</span>
<span class="cm">	 * of these lists out from underneath us</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">num_trans</span> <span class="o">&amp;&amp;</span> <span class="n">transactions_flushed</span> <span class="o">&lt;</span> <span class="n">num_trans</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="o">!</span><span class="n">num_trans</span> <span class="o">&amp;&amp;</span> <span class="n">written</span> <span class="o">&lt;</span> <span class="n">num_blocks</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">&amp;</span> <span class="n">LIST_TOUCHED</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">)</span>
		    <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">&amp;</span> <span class="n">LIST_DIRTY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">del_from_work_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">write_one_transaction</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">transactions_flushed</span><span class="o">++</span><span class="p">;</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

		<span class="cm">/* did we wrap? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

		<span class="cm">/* don&#39;t bother with older transactions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">&lt;=</span> <span class="n">orig_trans_id</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

      <span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flush_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* for o_sync and fsync heavy applications, they tend to use</span>
<span class="cm">** all the journa list slots with tiny transactions.  These</span>
<span class="cm">** trigger lots and lots of calls to update the header block, which</span>
<span class="cm">** adds seeks and slows things down.</span>
<span class="cm">**</span>
<span class="cm">** This function tries to clear out a large chunk of the journal lists</span>
<span class="cm">** at once, which makes everything faster since only the newest journal</span>
<span class="cm">** list updates the header block</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush_used_journal_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cur_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">tjl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">flush_jl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">flush_jl</span> <span class="o">=</span> <span class="n">tjl</span> <span class="o">=</span> <span class="n">jl</span><span class="p">;</span>

	<span class="cm">/* in data logging mode, try harder to flush a lot of blocks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_data_log</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="cm">/* flush for 256 transactions or limit blocks, whichever comes first */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tjl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">tjl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">&lt;</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur_len</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tjl</span><span class="o">-&gt;</span><span class="n">j_nonzerolen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tjl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LIST_TOUCHED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">cur_len</span><span class="p">;</span>
		<span class="n">flush_jl</span> <span class="o">=</span> <span class="n">tjl</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tjl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">tjl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">tjl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* try to find a group of blocks we can flush across all the</span>
<span class="cm">	 ** transactions, but only bother if we&#39;ve actually spanned</span>
<span class="cm">	 ** across multiple lists</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush_jl</span> <span class="o">!=</span> <span class="n">jl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kupdate_transactions</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tjl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans_id</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">flush_journal_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flush_jl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** removes any nodes in table with name block and dev as bh.</span>
<span class="cm">** only touchs the hnext and hprev pointers.</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">remove_journal_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">**</span><span class="n">table</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">remove_freed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">**</span><span class="n">head</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">journal_hash</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="n">block</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">==</span> <span class="n">sb</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">jl</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">jl</span> <span class="o">==</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BLOCK_FREED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">||</span> <span class="n">remove_freed</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cur</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="o">-&gt;</span><span class="n">hprev</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cur</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="o">-&gt;</span><span class="n">hnext</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="p">)</span>	<span class="cm">/* anybody who clears the cur-&gt;bh will also dec the nonzerolen */</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="o">-&gt;</span><span class="n">j_nonzerolen</span><span class="p">));</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">jlist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_journal_ram</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_num_lists</span><span class="o">--</span><span class="p">;</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_orig</span><span class="p">);</span>
	<span class="n">free_list_bitmaps</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">);</span>
	<span class="n">free_bitmap_nodes</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>	<span class="cm">/* must be after free_list_bitmaps */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* j_header_bh is on the journal dev, make sure not to release the journal</span>
<span class="cm">	 * dev until we brelse j_header_bh</span>
<span class="cm">	 */</span>
	<span class="n">release_journal_dev</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** call on unmount.  Only set error to 1 if you haven&#39;t made your way out</span>
<span class="cm">** of read_super() yet.  Any other caller must keep error at 0.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_journal_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">myth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flushed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* we only want to flush out transactions if we were called with error == 0</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* end the current trans */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
		<span class="n">do_journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">FLUSH_ALL</span><span class="p">);</span>

		<span class="cm">/* make sure something gets logged to force our way into the flush code */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
						     <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
						     <span class="mi">1</span><span class="p">);</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
					   <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
			<span class="n">do_journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FLUSH_ALL</span><span class="p">);</span>
			<span class="n">flushed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* this also catches errors during the do_journal_end above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">reiserfs_is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">myth</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_join_abort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
						     <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
						     <span class="mi">1</span><span class="p">);</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
					   <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
			<span class="n">do_journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FLUSH_ALL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">reiserfs_mounted_fs_count</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/* wait for all commits to finish */</span>
	<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_work</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must release the write lock here because</span>
<span class="cm">	 * the workqueue job (flush_async_commit) needs this lock</span>
<span class="cm">	 */</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">old_work</span><span class="p">);</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">commit_wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reiserfs_mounted_fs_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">commit_wq</span><span class="p">);</span>
		<span class="n">commit_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_journal_ram</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** call on unmount.  flush all journal trans, release all alloc&#39;d ram</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">journal_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_journal_release</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** only call from an error condition inside reiserfs_read_super!</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">journal_release_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_journal_release</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* compares description block with commit block.  returns 1 if they differ, 0 if they are the same */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_compare_desc_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">reiserfs_journal_commit</span> <span class="o">*</span><span class="n">commit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_commit_trans_id</span><span class="p">(</span><span class="n">commit</span><span class="p">)</span> <span class="o">!=</span> <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">get_commit_trans_len</span><span class="p">(</span><span class="n">commit</span><span class="p">)</span> <span class="o">!=</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">get_commit_trans_len</span><span class="p">(</span><span class="n">commit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">||</span>
	    <span class="n">get_commit_trans_len</span><span class="p">(</span><span class="n">commit</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns 0 if it did not find a description block</span>
<span class="cm">** returns -1 if it found a corrupt commit block</span>
<span class="cm">** returns 1 if both desc and commit were valid</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_transaction_is_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">d_bh</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">oldest_invalid_trans_id</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">newest_mount_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_commit</span> <span class="o">*</span><span class="n">commit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">c_bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">get_journal_desc_magic</span><span class="p">(</span><span class="n">d_bh</span><span class="p">),</span> <span class="n">JOURNAL_DESC_MAGIC</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldest_invalid_trans_id</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">oldest_invalid_trans_id</span>
		    <span class="o">&amp;&amp;</span> <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">oldest_invalid_trans_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
				       <span class="s">&quot;journal-986: transaction &quot;</span>
				       <span class="s">&quot;is valid returning because trans_id %d is greater than &quot;</span>
				       <span class="s">&quot;oldest_invalid %lu&quot;</span><span class="p">,</span>
				       <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
				       <span class="o">*</span><span class="n">oldest_invalid_trans_id</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newest_mount_id</span>
		    <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">newest_mount_id</span> <span class="o">&gt;</span> <span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
				       <span class="s">&quot;journal-1087: transaction &quot;</span>
				       <span class="s">&quot;is valid returning because mount_id %d is less than &quot;</span>
				       <span class="s">&quot;newest_mount_id %lu&quot;</span><span class="p">,</span>
				       <span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
				       <span class="o">*</span><span class="n">newest_mount_id</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_trans_max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-2018&quot;</span><span class="p">,</span>
					 <span class="s">&quot;Bad transaction length %d &quot;</span>
					 <span class="s">&quot;encountered, ignoring transaction&quot;</span><span class="p">,</span>
					 <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">-</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="cm">/* ok, we have a journal description block, lets see if the transaction was valid */</span>
		<span class="n">c_bh</span> <span class="o">=</span>
		    <span class="n">journal_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				  <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
				  <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">+</span>
				    <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c_bh</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">commit</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_commit</span> <span class="o">*</span><span class="p">)</span><span class="n">c_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal_compare_desc_commit</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">commit</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
				       <span class="s">&quot;journal_transaction_is_valid, commit offset %ld had bad &quot;</span>
				       <span class="s">&quot;time %d or length %d&quot;</span><span class="p">,</span>
				       <span class="n">c_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">-</span>
				       <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
				       <span class="n">get_commit_trans_id</span><span class="p">(</span><span class="n">commit</span><span class="p">),</span>
				       <span class="n">get_commit_trans_len</span><span class="p">(</span><span class="n">commit</span><span class="p">));</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oldest_invalid_trans_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">oldest_invalid_trans_id</span> <span class="o">=</span>
				    <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
				<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
					       <span class="s">&quot;journal-1004: &quot;</span>
					       <span class="s">&quot;transaction_is_valid setting oldest invalid trans_id &quot;</span>
					       <span class="s">&quot;to %d&quot;</span><span class="p">,</span>
					       <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
			       <span class="s">&quot;journal-1006: found valid &quot;</span>
			       <span class="s">&quot;transaction start offset %llu, len %d id %d&quot;</span><span class="p">,</span>
			       <span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">-</span>
			       <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
			       <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
			       <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">brelse_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">heads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">heads</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** given the start, and values for the oldest acceptable transactions,</span>
<span class="cm">** this either reads in a replays a transaction, or returns because the transaction</span>
<span class="cm">** is invalid, or too old.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_read_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cur_dblock</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">oldest_start</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldest_trans_id</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newest_mount_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_commit</span> <span class="o">*</span><span class="n">commit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">c_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">d_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">log_blocks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">real_blocks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trans_half</span><span class="p">;</span>

	<span class="n">d_bh</span> <span class="o">=</span> <span class="n">journal_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">cur_dblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">trans_offset</span> <span class="o">=</span> <span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">-</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span> <span class="s">&quot;journal-1037: &quot;</span>
		       <span class="s">&quot;journal_read_transaction, offset %llu, len %d mount_id %d&quot;</span><span class="p">,</span>
		       <span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">-</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
		       <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">oldest_trans_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span> <span class="s">&quot;journal-1039: &quot;</span>
			       <span class="s">&quot;journal_read_trans skipping because %lu is too old&quot;</span><span class="p">,</span>
			       <span class="n">cur_dblock</span> <span class="o">-</span>
			       <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">newest_mount_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span> <span class="s">&quot;journal-1146: &quot;</span>
			       <span class="s">&quot;journal_read_trans skipping because %d is != &quot;</span>
			       <span class="s">&quot;newest_mount_id %lu&quot;</span><span class="p">,</span> <span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
			       <span class="n">newest_mount_id</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c_bh</span> <span class="o">=</span> <span class="n">journal_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
			     <span class="p">((</span><span class="n">trans_offset</span> <span class="o">+</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
			      <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">commit</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_commit</span> <span class="o">*</span><span class="p">)</span><span class="n">c_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal_compare_desc_commit</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">commit</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
			       <span class="s">&quot;journal_read_transaction, &quot;</span>
			       <span class="s">&quot;commit offset %llu had bad time %d or length %d&quot;</span><span class="p">,</span>
			       <span class="n">c_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">-</span>
			       <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
			       <span class="n">get_commit_trans_id</span><span class="p">(</span><span class="n">commit</span><span class="p">),</span>
			       <span class="n">get_commit_trans_len</span><span class="p">(</span><span class="n">commit</span><span class="p">));</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdev_read_only</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;clm-2076&quot;</span><span class="p">,</span>
				 <span class="s">&quot;device is readonly, unable to replay log&quot;</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trans_id</span> <span class="o">=</span> <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="cm">/* now we know we&#39;ve got a good transaction, and it was inside the valid time ranges */</span>
	<span class="n">log_blocks</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">*</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">real_blocks</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">*</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">log_blocks</span> <span class="o">||</span> <span class="o">!</span><span class="n">real_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">);</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1169&quot;</span><span class="p">,</span>
				 <span class="s">&quot;kmalloc failed, unable to mount FS&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* get all the buffer heads */</span>
	<span class="n">trans_half</span> <span class="o">=</span> <span class="n">journal_trans_half</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">journal_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				   <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
				   <span class="p">(</span><span class="n">trans_offset</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
				    <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">trans_half</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">commit</span><span class="o">-&gt;</span>
						  <span class="n">j_realblock</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">trans_half</span><span class="p">]));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">&gt;</span> <span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1207&quot;</span><span class="p">,</span>
					 <span class="s">&quot;REPLAY FAILURE fsck required! &quot;</span>
					 <span class="s">&quot;Block to replay is outside of &quot;</span>
					 <span class="s">&quot;filesystem&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">abort_replay</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* make sure we don&#39;t try to replay onto log or reserved area */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_block_in_log_or_reserved_area</span>
		    <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1204&quot;</span><span class="p">,</span>
					 <span class="s">&quot;REPLAY FAILURE fsck required! &quot;</span>
					 <span class="s">&quot;Trying to replay onto a log block&quot;</span><span class="p">);</span>
		      <span class="nl">abort_replay:</span>
			<span class="n">brelse_array</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">brelse_array</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* read in the log blocks, memcpy to the corresponding real block */</span>
	<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="n">log_blocks</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1212&quot;</span><span class="p">,</span>
					 <span class="s">&quot;REPLAY FAILURE fsck required! &quot;</span>
					 <span class="s">&quot;buffer write failed&quot;</span><span class="p">);</span>
			<span class="n">brelse_array</span><span class="p">(</span><span class="n">log_blocks</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				     <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">brelse_array</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">,</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">log_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
		       <span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="cm">/* flush out the real blocks */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">write_dirty_buffer</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">WRITE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1226&quot;</span><span class="p">,</span>
					 <span class="s">&quot;REPLAY FAILURE, fsck required! &quot;</span>
					 <span class="s">&quot;buffer write failed&quot;</span><span class="p">);</span>
			<span class="n">brelse_array</span><span class="p">(</span><span class="n">real_blocks</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				     <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">cur_dblock</span> <span class="o">=</span>
	    <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
	    <span class="p">((</span><span class="n">trans_offset</span> <span class="o">+</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">+</span>
	      <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
		       <span class="s">&quot;journal-1095: setting journal &quot;</span> <span class="s">&quot;start to offset %ld&quot;</span><span class="p">,</span>
		       <span class="n">cur_dblock</span> <span class="o">-</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>

	<span class="cm">/* init starting values for the first transaction, in case this is the last transaction to be replayed. */</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">=</span> <span class="n">cur_dblock</span> <span class="o">-</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span> <span class="o">=</span> <span class="n">trans_id</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="n">trans_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* check for trans_id overflow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">log_blocks</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">real_blocks</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function reads blocks starting from block and to max_block of bufsize</span>
<span class="cm">   size (but no more than BUFNR blocks at a time). This proved to improve</span>
<span class="cm">   mounting speed on self-rebuilding raid5 arrays at least.</span>
<span class="cm">   Right now it is only used from journal code. But later we might use it</span>
<span class="cm">   from other places.</span>
<span class="cm">   Note: Do not use journal_getblk/sb_getblk functions here! */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">reiserfs_breada</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">,</span>
					   <span class="n">b_blocknr_t</span> <span class="n">max_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bhlist</span><span class="p">[</span><span class="n">BUFNR</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocks</span> <span class="o">=</span> <span class="n">BUFNR</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">+</span> <span class="n">BUFNR</span> <span class="o">&gt;</span> <span class="n">max_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blocks</span> <span class="o">=</span> <span class="n">max_block</span> <span class="o">-</span> <span class="n">block</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bhlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">bhlist</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">bhlist</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bhlist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">bhlist</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** read and replay the log</span>
<span class="cm">** on a clean unmount, the journal header&#39;s next unflushed pointer will be to an invalid</span>
<span class="cm">** transaction.  This tests that before finding all the transactions in the log, which makes normal mount times fast.</span>
<span class="cm">**</span>
<span class="cm">** After a crash, this starts with the next unflushed transaction, and replays until it finds one too old, or invalid.</span>
<span class="cm">**</span>
<span class="cm">** On exit, it sets things up so the first transaction will work correctly.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldest_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldest_invalid_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">oldest_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cur_dblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newest_mount_id</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">d_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_header</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">valid_journal_header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">replay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">continue_replay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="n">cur_dblock</span> <span class="o">=</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">reiserfs_info</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;checking transaction log (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">bdevname</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="cm">/* step 1, read in the journal header block.  Check the transaction it says</span>
<span class="cm">	 ** is the first unflushed, and if that transaction is not valid,</span>
<span class="cm">	 ** replay is done</span>
<span class="cm">	 */</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span> <span class="o">=</span> <span class="n">journal_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					     <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span>
					     <span class="o">+</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_header_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_first_unflushed_offset</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oldest_start</span> <span class="o">=</span>
		    <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_first_unflushed_offset</span><span class="p">);</span>
		<span class="n">oldest_trans_id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">newest_mount_id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_mount_id</span><span class="p">);</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
			       <span class="s">&quot;journal-1153: found in &quot;</span>
			       <span class="s">&quot;header: first_unflushed_offset %d, last_flushed_trans_id &quot;</span>
			       <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_first_unflushed_offset</span><span class="p">),</span>
			       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span><span class="p">));</span>
		<span class="n">valid_journal_header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* now, we try to read the first unflushed offset.  If it is not valid,</span>
<span class="cm">		 ** there is nothing more we can do, and it makes no sense to read</span>
<span class="cm">		 ** through the whole log.</span>
<span class="cm">		 */</span>
		<span class="n">d_bh</span> <span class="o">=</span>
		    <span class="n">journal_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				  <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
				  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_first_unflushed_offset</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_transaction_is_valid</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">d_bh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">continue_replay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">start_log_replay</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ok, there are transactions that need to be replayed.  start with the first log block, find</span>
<span class="cm">	 ** all the valid transactions, and pick out the oldest.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">continue_replay</span>
	       <span class="o">&amp;&amp;</span> <span class="n">cur_dblock</span> <span class="o">&lt;</span>
	       <span class="p">(</span><span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Note that it is required for blocksize of primary fs device and journal</span>
<span class="cm">		   device to be the same */</span>
		<span class="n">d_bh</span> <span class="o">=</span>
		    <span class="n">reiserfs_breada</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">,</span> <span class="n">cur_dblock</span><span class="p">,</span>
				    <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">,</span>
				    <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span>
		    <span class="n">journal_transaction_is_valid</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">d_bh</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">oldest_invalid_trans_id</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">newest_mount_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oldest_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* init all oldest_ values */</span>
				<span class="n">oldest_trans_id</span> <span class="o">=</span> <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
				<span class="n">oldest_start</span> <span class="o">=</span> <span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
				<span class="n">newest_mount_id</span> <span class="o">=</span> <span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
				<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
					       <span class="s">&quot;journal-1179: Setting &quot;</span>
					       <span class="s">&quot;oldest_start to offset %llu, trans_id %lu&quot;</span><span class="p">,</span>
					       <span class="n">oldest_start</span> <span class="o">-</span>
					       <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span>
					       <span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">oldest_trans_id</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oldest_trans_id</span> <span class="o">&gt;</span> <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* one we just read was older */</span>
				<span class="n">oldest_trans_id</span> <span class="o">=</span> <span class="n">get_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
				<span class="n">oldest_start</span> <span class="o">=</span> <span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
				<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
					       <span class="s">&quot;journal-1180: Resetting &quot;</span>
					       <span class="s">&quot;oldest_start to offset %lu, trans_id %lu&quot;</span><span class="p">,</span>
					       <span class="n">oldest_start</span> <span class="o">-</span>
					       <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span>
					       <span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">oldest_trans_id</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newest_mount_id</span> <span class="o">&lt;</span> <span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">newest_mount_id</span> <span class="o">=</span> <span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
				<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
					       <span class="s">&quot;journal-1299: Setting &quot;</span>
					       <span class="s">&quot;newest_mount_id to %d&quot;</span><span class="p">,</span>
					       <span class="n">get_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">cur_dblock</span> <span class="o">+=</span> <span class="n">get_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cur_dblock</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
	<span class="p">}</span>

      <span class="nl">start_log_replay:</span>
	<span class="n">cur_dblock</span> <span class="o">=</span> <span class="n">oldest_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldest_trans_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
			       <span class="s">&quot;journal-1206: Starting replay &quot;</span>
			       <span class="s">&quot;from offset %llu, trans_id %lu&quot;</span><span class="p">,</span>
			       <span class="n">cur_dblock</span> <span class="o">-</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
			       <span class="n">oldest_trans_id</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="n">replay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">continue_replay</span> <span class="o">&amp;&amp;</span> <span class="n">oldest_trans_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span>
		    <span class="n">journal_read_transaction</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">cur_dblock</span><span class="p">,</span> <span class="n">oldest_start</span><span class="p">,</span>
					     <span class="n">oldest_trans_id</span><span class="p">,</span> <span class="n">newest_mount_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur_dblock</span> <span class="o">=</span>
		    <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">;</span>
		<span class="n">replay_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_dblock</span> <span class="o">==</span> <span class="n">oldest_start</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oldest_trans_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
			       <span class="s">&quot;journal-1225: No valid &quot;</span> <span class="s">&quot;transactions found&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* j_start does not get set correctly if we don&#39;t replay any transactions.</span>
<span class="cm">	 ** if we had a valid journal_header, set j_start to the first unflushed transaction value,</span>
<span class="cm">	 ** copy the trans_id from the header</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">valid_journal_header</span> <span class="o">&amp;&amp;</span> <span class="n">replay_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_first_unflushed_offset</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* check for trans_id overflow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span> <span class="o">=</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_mount_id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">j_mount_id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_mount_id</span> <span class="o">=</span> <span class="n">newest_mount_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span> <span class="s">&quot;journal-1299: Setting &quot;</span>
		       <span class="s">&quot;newest_mount_id to %lu&quot;</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_mount_id</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first_unflushed_offset</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">replay_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_info</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
			      <span class="s">&quot;replayed %d transactions in %lu seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">replay_count</span><span class="p">,</span> <span class="n">get_seconds</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdev_read_only</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">_update_journal_header_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">,</span>
					 <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_flush_trans_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* replay failed, caller must call free_journal_ram and abort</span>
<span class="cm">		 ** the mount</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="nf">alloc_journal_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">;</span>
	<span class="n">jl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_list</span><span class="p">),</span>
		     <span class="n">GFP_NOFS</span> <span class="o">|</span> <span class="n">__GFP_NOFAIL</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_working_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_tail_bh_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_bh_list</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_mutex</span><span class="p">);</span>
	<span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_num_lists</span><span class="o">++</span><span class="p">;</span>
	<span class="n">get_journal_list</span><span class="p">(</span><span class="n">jl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">jl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">journal_list_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_current_jl</span> <span class="o">=</span> <span class="n">alloc_journal_list</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">release_journal_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">super</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">blkdev_put</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_mode</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">super</span><span class="p">,</span> <span class="s">&quot;sh-457&quot;</span><span class="p">,</span>
				 <span class="s">&quot;Cannot release journal device: %i&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_init_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">super</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">jdev_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">jdev</span><span class="p">;</span>
	<span class="n">fmode_t</span> <span class="n">blkdev_mode</span> <span class="o">=</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">jdev</span> <span class="o">=</span> <span class="n">SB_ONDISK_JOURNAL_DEVICE</span><span class="p">(</span><span class="n">super</span><span class="p">)</span> <span class="o">?</span>
	    <span class="n">new_decode_dev</span><span class="p">(</span><span class="n">SB_ONDISK_JOURNAL_DEVICE</span><span class="p">(</span><span class="n">super</span><span class="p">))</span> <span class="o">:</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdev_read_only</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">))</span>
		<span class="n">blkdev_mode</span> <span class="o">=</span> <span class="n">FMODE_READ</span><span class="p">;</span>

	<span class="cm">/* there is no &quot;jdev&quot; option and journal is on separate device */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">jdev_name</span> <span class="o">||</span> <span class="o">!</span><span class="n">jdev_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jdev</span> <span class="o">==</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">)</span>
			<span class="n">blkdev_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FMODE_EXCL</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span> <span class="o">=</span> <span class="n">blkdev_get_by_dev</span><span class="p">(</span><span class="n">jdev</span><span class="p">,</span> <span class="n">blkdev_mode</span><span class="p">,</span>
						      <span class="n">journal</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_mode</span> <span class="o">=</span> <span class="n">blkdev_mode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">);</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">super</span><span class="p">,</span> <span class="s">&quot;sh-458&quot;</span><span class="p">,</span>
					 <span class="s">&quot;cannot init journal device &#39;%s&#39;: %i&quot;</span><span class="p">,</span>
					 <span class="n">__bdevname</span><span class="p">(</span><span class="n">jdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jdev</span> <span class="o">!=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">)</span>
			<span class="n">set_blocksize</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_mode</span> <span class="o">=</span> <span class="n">blkdev_mode</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span> <span class="o">=</span> <span class="n">blkdev_get_by_path</span><span class="p">(</span><span class="n">jdev_name</span><span class="p">,</span> <span class="n">blkdev_mode</span><span class="p">,</span> <span class="n">journal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">super</span><span class="p">,</span>
				 <span class="s">&quot;journal_init_dev: Cannot open &#39;%s&#39;: %i&quot;</span><span class="p">,</span>
				 <span class="n">jdev_name</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_blocksize</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="n">reiserfs_info</span><span class="p">(</span><span class="n">super</span><span class="p">,</span>
		      <span class="s">&quot;journal_init_dev: journal device: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">bdevname</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * When creating/tuning a file system user can assign some</span>
<span class="cm"> * journal params within boundaries which depend on the ratio</span>
<span class="cm"> * blocksize/standard_blocksize.</span>
<span class="cm"> *</span>
<span class="cm"> * For blocks &gt;= standard_blocksize transaction size should</span>
<span class="cm"> * be not less then JOURNAL_TRANS_MIN_DEFAULT, and not more</span>
<span class="cm"> * then JOURNAL_TRANS_MAX_DEFAULT.</span>
<span class="cm"> *</span>
<span class="cm"> * For blocks &lt; standard_blocksize these boundaries should be</span>
<span class="cm"> * decreased proportionally.</span>
<span class="cm"> */</span>
<span class="cp">#define REISERFS_STANDARD_BLKSIZE (4096)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_advise_trans_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span><span class="p">)</span> <span class="p">{</span>
	        <span class="cm">/* Non-default journal params.</span>
<span class="cm">		   Do sanity check for them. */</span>
	        <span class="kt">int</span> <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;</span> <span class="n">REISERFS_STANDARD_BLKSIZE</span><span class="p">)</span>
		        <span class="n">ratio</span> <span class="o">=</span> <span class="n">REISERFS_STANDARD_BLKSIZE</span> <span class="o">/</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">&gt;</span> <span class="n">JOURNAL_TRANS_MAX_DEFAULT</span> <span class="o">/</span> <span class="n">ratio</span> <span class="o">||</span>
		    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">&lt;</span> <span class="n">JOURNAL_TRANS_MIN_DEFAULT</span> <span class="o">/</span> <span class="n">ratio</span> <span class="o">||</span>
		    <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">/</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">&lt;</span>
		    <span class="n">JOURNAL_MIN_RATIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;sh-462&quot;</span><span class="p">,</span>
					 <span class="s">&quot;bad transaction max size (%u). &quot;</span>
					 <span class="s">&quot;FSCK?&quot;</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span> <span class="o">!=</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span><span class="p">)</span> <span class="o">*</span>
		        <span class="n">JOURNAL_MAX_BATCH_DEFAULT</span><span class="o">/</span><span class="n">JOURNAL_TRANS_MAX_DEFAULT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;sh-463&quot;</span><span class="p">,</span>
					 <span class="s">&quot;bad transaction max batch (%u). &quot;</span>
					 <span class="s">&quot;FSCK?&quot;</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Default journal params.</span>
<span class="cm">                   The file system was created by old version</span>
<span class="cm">		   of mkreiserfs, so some fields contain zeros,</span>
<span class="cm">		   and we need to advise proper values for them */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">!=</span> <span class="n">REISERFS_STANDARD_BLKSIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;sh-464&quot;</span><span class="p">,</span> <span class="s">&quot;bad blocksize (%u)&quot;</span><span class="p">,</span>
					 <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">=</span> <span class="n">JOURNAL_TRANS_MAX_DEFAULT</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span> <span class="o">=</span> <span class="n">JOURNAL_MAX_BATCH_DEFAULT</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_commit_age</span> <span class="o">=</span> <span class="n">JOURNAL_MAX_COMMIT_AGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** must be called once on fs mount.  calls journal_read for you</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">journal_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">j_dev_name</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">old_format</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">commit_max_age</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_cnodes</span> <span class="o">=</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bhjh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">rs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_header</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1256&quot;</span><span class="p">,</span>
				 <span class="s">&quot;unable to get memory for journal structure&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bitmap_nodes</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_prealloc_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_working_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_persistent_trans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_allocate_list_bitmaps</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">,</span>
					   <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">sb</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>

	<span class="n">allocate_bitmap_nodes</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* reserved for journal area support */</span>
	<span class="n">SB_JOURNAL_1st_RESERVED_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_format</span> <span class="o">?</span>
						 <span class="n">REISERFS_OLD_DISK_OFFSET_IN_BYTES</span>
						 <span class="o">/</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">+</span>
						 <span class="n">reiserfs_bmap_count</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
						 <span class="mi">1</span> <span class="o">:</span>
						 <span class="n">REISERFS_DISK_OFFSET_IN_BYTES</span> <span class="o">/</span>
						 <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Sanity check to see is the standard journal fitting within first bitmap</span>
<span class="cm">	   (actual for small blocksizes) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SB_ONDISK_JOURNAL_DEVICE</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">SB_JOURNAL_1st_RESERVED_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
	     <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1393&quot;</span><span class="p">,</span>
				 <span class="s">&quot;journal does not fit for area addressed &quot;</span>
				 <span class="s">&quot;by first of bitmap blocks. It starts at &quot;</span>
				 <span class="s">&quot;%u and its size is %u. Block size %ld&quot;</span><span class="p">,</span>
				 <span class="n">SB_JOURNAL_1st_RESERVED_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
				 <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
				 <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal_init_dev</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">,</span> <span class="n">j_dev_name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;sh-462&quot;</span><span class="p">,</span>
				 <span class="s">&quot;unable to initialize jornal device&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rs</span> <span class="o">=</span> <span class="n">SB_DISK_SUPER_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* read journal header */</span>
	<span class="n">bhjh</span> <span class="o">=</span> <span class="n">journal_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
			     <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
			     <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bhjh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;sh-459&quot;</span><span class="p">,</span>
				 <span class="s">&quot;unable to read journal header&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">bhjh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>

	<span class="cm">/* make sure that journal matches to the super block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_reiserfs_jr</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">jh_journal</span><span class="p">.</span><span class="n">jp_journal_magic</span><span class="p">)</span> <span class="o">!=</span>
		<span class="n">sb_jp_journal_magic</span><span class="p">(</span><span class="n">rs</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;sh-460&quot;</span><span class="p">,</span>
				 <span class="s">&quot;journal header magic %x (device %s) does &quot;</span>
				 <span class="s">&quot;not match to magic found in super block %x&quot;</span><span class="p">,</span>
				 <span class="n">jh</span><span class="o">-&gt;</span><span class="n">jh_journal</span><span class="p">.</span><span class="n">jp_journal_magic</span><span class="p">,</span>
				 <span class="n">bdevname</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
				 <span class="n">sb_jp_journal_magic</span><span class="p">(</span><span class="n">rs</span><span class="p">));</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bhjh</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">jh_journal</span><span class="p">.</span><span class="n">jp_journal_trans_max</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">jh_journal</span><span class="p">.</span><span class="n">jp_journal_max_batch</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_commit_age</span> <span class="o">=</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">jh_journal</span><span class="p">.</span><span class="n">jp_journal_max_commit_age</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_trans_age</span> <span class="o">=</span> <span class="n">JOURNAL_MAX_TRANS_AGE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_advise_trans_params</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	        <span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_default_max_commit_age</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_commit_age</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">commit_max_age</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_commit_age</span> <span class="o">=</span> <span class="n">commit_max_age</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_trans_age</span> <span class="o">=</span> <span class="n">commit_max_age</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reiserfs_info</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal params: device %s, size %u, &quot;</span>
		      <span class="s">&quot;journal first block %u, max trans len %u, max batch %u, &quot;</span>
		      <span class="s">&quot;max commit age %u, max trans age %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">bdevname</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev_bd</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
		      <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
		      <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
		      <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span><span class="p">,</span>
		      <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span><span class="p">,</span>
		      <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_commit_age</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_trans_age</span><span class="p">);</span>

	<span class="n">brelse</span><span class="p">(</span><span class="n">bhjh</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_bitmap_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal_list_init</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_hash_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">JOURNAL_HASH_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="p">));</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_async_throttle</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_join_wait</span><span class="p">));</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flush_mutex</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_mount_id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span> <span class="o">=</span> <span class="n">allocate_cnodes</span><span class="p">(</span><span class="n">num_cnodes</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_orig</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free_list</span> <span class="o">?</span> <span class="n">num_cnodes</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_must_wait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-2004&quot;</span><span class="p">,</span> <span class="s">&quot;Journal cnode memory &quot;</span>
		                 <span class="s">&quot;allocation failed (%ld bytes). Journal is &quot;</span>
		                 <span class="s">&quot;too large for available memory. Usually &quot;</span>
		                 <span class="s">&quot;this is due to a journal that is too large.&quot;</span><span class="p">,</span>
		                 <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_cnodes</span><span class="p">);</span>
        	<span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_journal_hash</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">jl</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * get_list_bitmap() may call flush_commit_list() which</span>
<span class="cm">	 * requires the lock. Calling flush_commit_list() shouldn&#39;t happen</span>
<span class="cm">	 * this early but I like to be paranoid.</span>
<span class="cm">	 */</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span> <span class="o">=</span> <span class="n">get_list_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-2005&quot;</span><span class="p">,</span>
				 <span class="s">&quot;get_list_bitmap failed for journal list 0&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal_read needs to be inspected in order to push down</span>
<span class="cm">	 * the lock further inside (or even remove it).</span>
<span class="cm">	 */</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_read</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-2006&quot;</span><span class="p">,</span>
				 <span class="s">&quot;Replay Failure, unable to mount&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_and_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reiserfs_mounted_fs_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_mounted_fs_count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">commit_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;reiserfs&quot;</span><span class="p">,</span> <span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_work</span><span class="p">,</span> <span class="n">flush_async_commits</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_work_sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nl">free_and_return:</span>
	<span class="n">free_journal_ram</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** test for a polite end of the current transaction.  Used by file_write, and should</span>
<span class="cm">** be used by delete to make sure they don&#39;t write more than can fit inside a single</span>
<span class="cm">** transaction</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">journal_transaction_should_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">new_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">);</span>
	<span class="kt">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="cm">/* cannot restart while nested */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_must_wait</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">+</span> <span class="n">new_alloc</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span> <span class="o">||</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_trans_age</span> <span class="o">||</span>
	    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">+=</span> <span class="n">new_alloc</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span> <span class="o">+=</span> <span class="n">new_alloc</span> <span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this must be called inside a transaction</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">reiserfs_block_writes</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_must_wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">J_WRITERS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this must be called without a transaction started</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">reiserfs_allow_writes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">J_WRITERS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_join_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* this must be called without a transaction started</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">reiserfs_wait_on_write_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_join_wait</span><span class="p">,</span>
		   <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">J_WRITERS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_log_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">J_WRITERS_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t want to use wait_event here because</span>
<span class="cm">	 * we only want to wait once.</span>
<span class="cm">	 */</span>
	<span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_join_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">J_WRITERS_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_join_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake_queued_writers</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">J_WRITERS_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_join_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">let_transaction_grow</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trans_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bcount</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bcount</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">|=</span> <span class="n">LIST_COMMIT_PENDING</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		       <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="n">trans_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">queue_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">!=</span> <span class="n">trans_id</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcount</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bcount</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">bcount</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bcount</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* join == true if you must join an existing transaction.</span>
<span class="cm">** join == false if you can deal with waiting for others to finish</span>
<span class="cm">**</span>
<span class="cm">** this will block until the transaction is joinable.  send the number of blocks you</span>
<span class="cm">** expect to use in nblocks.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_journal_begin_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">join</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_trans_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">myth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sched_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">reiserfs_check_lock_depth</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal_begin&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nblocks</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span><span class="p">);</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">journal_being</span><span class="p">);</span>
	<span class="cm">/* set here for journal_join */</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>

      <span class="nl">relock:</span>
	<span class="n">lock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">join</span> <span class="o">!=</span> <span class="n">JBEGIN_ABORT</span> <span class="o">&amp;&amp;</span> <span class="n">reiserfs_is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bcount</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">J_WRITERS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">reiserfs_wait_on_write_block</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">journal_relock_writers</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="cm">/* if there is no room in the journal OR</span>
<span class="cm">	 ** if this transaction is too old, and we weren&#39;t called joinable, wait for it to finish before beginning</span>
<span class="cm">	 ** we don&#39;t sleep if there aren&#39;t other writers</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">join</span> <span class="o">&amp;&amp;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_must_wait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">join</span>
	     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">join</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
		<span class="o">&amp;&amp;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span> <span class="o">&gt;</span> <span class="mi">0</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span><span class="p">)</span> <span class="o">&gt;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_trans_age</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">join</span>
					      <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">join</span> <span class="o">&amp;&amp;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">old_trans_id</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
		<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>	<span class="cm">/* allow others to finish this transaction */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">join</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span>
		    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span>
		    <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">*</span> <span class="mi">75</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sched_count</span><span class="o">++</span><span class="p">;</span>
				<span class="n">queue_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* don&#39;t mess with joining the transaction if all we have to do is</span>
<span class="cm">		 * wait for someone else to do a commit</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="n">old_trans_id</span> <span class="o">&amp;&amp;</span>
			       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">queue_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">journal_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

		<span class="cm">/* someone might have ended the transaction while we joined */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_trans_id</span> <span class="o">!=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">do_journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">do_journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">COMMIT_NOW</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">journal_relock_wcount</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* we are the first writer, set trans_id */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">));</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">+=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_logged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
	<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

      <span class="nl">out_fail:</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">));</span>
	<span class="cm">/* Re-set th-&gt;t_super, so we can properly keep track of how many</span>
<span class="cm">	 * persistent transactions there are. We need to do this so if this</span>
<span class="cm">	 * call is part of a failed restart_transaction, we can free it later */</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="nf">reiserfs_persistent_transaction</span><span class="p">(</span><span class="k">struct</span>
								    <span class="n">super_block</span>
								    <span class="o">*</span><span class="n">s</span><span class="p">,</span>
								    <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>

	<span class="cm">/* if we&#39;re nesting into an existing transaction.  It will be</span>
<span class="cm">	 ** persistent on its own</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_transaction_running</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">++</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>
		
		<span class="k">return</span> <span class="n">th</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_persistent_trans</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">th</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_persistent_trans</span><span class="o">--</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_join</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">cur_th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>

	<span class="cm">/* this keeps do_journal_end from NULLing out the current-&gt;journal_info</span>
<span class="cm">	 ** pointer</span>
<span class="cm">	 */</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_handle_save</span> <span class="o">=</span> <span class="n">cur_th</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cur_th</span> <span class="o">&amp;&amp;</span> <span class="n">cur_th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_journal_begin_r</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">JBEGIN_JOIN</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">journal_join_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">cur_th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>

	<span class="cm">/* this keeps do_journal_end from NULLing out the current-&gt;journal_info</span>
<span class="cm">	 ** pointer</span>
<span class="cm">	 */</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_handle_save</span> <span class="o">=</span> <span class="n">cur_th</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cur_th</span> <span class="o">&amp;&amp;</span> <span class="n">cur_th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_journal_begin_r</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">JBEGIN_ABORT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">journal_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">cur_th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_handle_save</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_th</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we are nesting into the current transaction */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_th</span><span class="o">-&gt;</span><span class="n">t_super</span> <span class="o">==</span> <span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cur_th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">);</span>
			<span class="n">cur_th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">++</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">cur_th</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-2005&quot;</span><span class="p">,</span>
						 <span class="s">&quot;BAD: refcount &lt;= 1, but &quot;</span>
						 <span class="s">&quot;journal_info != 0&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* we&#39;ve ended up with a handle from a different filesystem.</span>
<span class="cm">			 ** save it and restore on journal_end.  This should never</span>
<span class="cm">			 ** really happen...</span>
<span class="cm">			 */</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;clm-2100&quot;</span><span class="p">,</span>
					 <span class="s">&quot;nesting info a different FS&quot;</span><span class="p">);</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_handle_save</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">th</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">th</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_journal_begin_r</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">JBEGIN_REG</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">!=</span> <span class="n">th</span><span class="p">);</span>

	<span class="cm">/* I guess this boils down to being the reciprocal of clm-2100 above.</span>
<span class="cm">	 * If do_journal_begin_r fails, we need to put it back, since journal_end</span>
<span class="cm">	 * won&#39;t be called to do it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_handle_save</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** puts bh into the current transaction.  If it was already there, reorders removes the</span>
<span class="cm">** old pointers from the hash, and puts new ones in (to make sure replay happen in the right order).</span>
<span class="cm">**</span>
<span class="cm">** if it was dirty, cleans and files onto the clean list.  I can&#39;t let it be dirty again until the</span>
<span class="cm">** transaction is committed.</span>
<span class="cm">**</span>
<span class="cm">** if j_len, is bigger than j_len_alloc, it pushes j_len_alloc to 10 + j_len.</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">journal_mark_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count_already_incd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prepared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">mark_dirty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span> <span class="o">!=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;journal-1577&quot;</span><span class="p">,</span>
			       <span class="s">&quot;handle trans id %ld != current trans id %ld&quot;</span><span class="p">,</span>
			       <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">prepared</span> <span class="o">=</span> <span class="n">test_clear_buffer_journal_prepared</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_journal_restore_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="cm">/* already in this transaction, we are done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">mark_dirty_already</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this must be turned into a panic instead of a warning.  We can&#39;t allow</span>
<span class="cm">	 ** a dirty or journal_dirty or locked buffer to be logged, as some changes</span>
<span class="cm">	 ** could get to disk too early.  NOT GOOD.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prepared</span> <span class="o">||</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1777&quot;</span><span class="p">,</span>
				 <span class="s">&quot;buffer %llu bad state &quot;</span>
				 <span class="s">&quot;%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span>
				 <span class="n">prepared</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;!&#39;</span><span class="p">,</span>
				 <span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;!&#39;</span><span class="p">,</span>
				 <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;!&#39;</span><span class="p">,</span>
				 <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;!&#39;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1409&quot;</span><span class="p">,</span>
				 <span class="s">&quot;returning because j_wcount was %d&quot;</span><span class="p">,</span>
				 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">)));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* this error means I&#39;ve screwed up, and we&#39;ve overflowed the transaction.</span>
<span class="cm">	 ** Nothing can be done here, except make the FS readonly or panic.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">&gt;=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;journal-1413&quot;</span><span class="p">,</span>
			       <span class="s">&quot;j_len (%lu) is too big&quot;</span><span class="p">,</span>
			       <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count_already_incd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">mark_dirty_notjournal</span><span class="p">);</span>
		<span class="n">clear_buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">+</span> <span class="n">JOURNAL_PER_BALANCE_CNT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_buffer_journaled</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/* now put this guy on the end */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">get_cnode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-4&quot;</span><span class="p">,</span> <span class="s">&quot;get_cnode failed!&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_logged</span> <span class="o">==</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span> <span class="o">+=</span> <span class="n">JOURNAL_PER_BALANCE_CNT</span><span class="p">;</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">+=</span> <span class="n">JOURNAL_PER_BALANCE_CNT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_logged</span><span class="o">++</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span><span class="o">++</span><span class="p">;</span>

		<span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
		<span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
		<span class="n">cn</span><span class="o">-&gt;</span><span class="n">jlist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">insert_journal_hash</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_hash_table</span><span class="p">,</span> <span class="n">cn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count_already_incd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span><span class="p">;</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reiserfs_schedule_old_flush</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">journal_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;REISER-NESTING&quot;</span><span class="p">,</span>
				 <span class="s">&quot;th NULL, refcount %d&quot;</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">cur_th</span> <span class="o">=</span>
		    <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>

		<span class="cm">/* we aren&#39;t allowed to close a nested transaction on a different</span>
<span class="cm">		 ** filesystem from the one in the task struct</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cur_th</span><span class="o">-&gt;</span><span class="n">t_super</span> <span class="o">!=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">!=</span> <span class="n">cur_th</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">));</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">do_journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* removes from the current transaction, relsing and descrementing any counters.</span>
<span class="cm">** also files the removed buffer directly onto the clean list</span>
<span class="cm">**</span>
<span class="cm">** called by journal_mark_freed when a block has been deleted</span>
<span class="cm">**</span>
<span class="cm">** returns 1 if it cleaned and relsed the buffer. 0 otherwise</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_from_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="n">b_blocknr_t</span> <span class="n">blocknr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">already_cleaned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cn</span> <span class="o">=</span> <span class="n">get_journal_hash_dev</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_hash_table</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span> <span class="o">||</span> <span class="o">!</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cn</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">remove_journal_hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_hash_table</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">clear_buffer_journaled</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>	<span class="cm">/* don&#39;t log this one */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">already_cleaned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">clear_buffer_journal_test</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1752&quot;</span><span class="p">,</span>
					 <span class="s">&quot;b_count &lt; 0&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span><span class="o">--</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span><span class="o">--</span><span class="p">;</span>
	<span class="n">free_cnode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">cn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** for any cnode in a journal list, it can only be dirtied of all the</span>
<span class="cm">** transactions that include it are committed to disk.</span>
<span class="cm">** this checks through each transaction, and returns 1 if you are allowed to dirty,</span>
<span class="cm">** and 0 if you aren&#39;t</span>
<span class="cm">**</span>
<span class="cm">** it is called by dirty_journal_list, which is called after flush_commit_list has gotten all the log</span>
<span class="cm">** blocks for a given transaction on disk</span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">can_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">blocknr</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* first test hprev.  These are all newer than cn, so any node here</span>
<span class="cm">	 ** with the same block number and dev means this node can&#39;t be sent</span>
<span class="cm">	 ** to disk right now.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">can_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">jlist</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">==</span> <span class="n">sb</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cur</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="n">blocknr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">can_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">hprev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* then test hnext.  These are all older than cn.  As long as they</span>
<span class="cm">	 ** are committed to the log, it is safe to write cn to disk</span>
<span class="cm">	 */</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">can_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">jlist</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cur</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">==</span> <span class="n">sb</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="n">blocknr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">can_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">can_dirty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* syncs the commit blocks, but does not force the real buffers to disk</span>
<span class="cm">** will wait until the current transaction is done/committed before returning</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">journal_end_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="cm">/* you can sync while nested, very, very bad */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
					     <span class="mi">1</span><span class="p">);</span>
		<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">do_journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">COMMIT_NOW</span> <span class="o">|</span> <span class="n">WAIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** writeback the pending async commits to disk</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_async_commits</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_journal</span><span class="p">,</span> <span class="n">j_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_work_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* last entry is the youngest, commit it and you get everything */</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">jl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** flushes any old transactions to disk</span>
<span class="cm">** ends the current transaction if it is too old</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">reiserfs_flush_old_commits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">time_t</span> <span class="n">now</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="cm">/* safety check so we don&#39;t flush while we are replaying the log during</span>
<span class="cm">	 * mount</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* check the current transaction.  If there are no writers, and it is</span>
<span class="cm">	 * too old, finish it, and force the commit blocks to disk</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_trans_age</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
						     <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
						     <span class="mi">1</span><span class="p">);</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
					   <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>

			<span class="cm">/* we&#39;re only being called from kreiserfsd, it makes no sense to do</span>
<span class="cm">			 ** an async commit so that kreiserfsd can do it later</span>
<span class="cm">			 */</span>
			<span class="n">do_journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">COMMIT_NOW</span> <span class="o">|</span> <span class="n">WAIT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** returns 0 if do_journal_end should return right away, returns 1 if do_journal_end should finish the commit</span>
<span class="cm">**</span>
<span class="cm">** if the current transaction is too old, but still has writers, this will wait on j_join_wait until all</span>
<span class="cm">** the writers are done.  By the time it wakes up, the transaction it was called has already ended, so it just</span>
<span class="cm">** flushes the commit list and returns 0.</span>
<span class="cm">**</span>
<span class="cm">** Won&#39;t batch when flush or commit_now is set.  Also won&#39;t batch when others are waiting on j_join_wait.</span>
<span class="cm">**</span>
<span class="cm">** Note, we can&#39;t allow the journal_end to proceed while there are still writers in the log.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_journal_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">time_t</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flush</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLUSH_ALL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">commit_now</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">COMMIT_NOW</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait_on_commit</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WAIT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span> <span class="o">!=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;journal-1577&quot;</span><span class="p">,</span>
			       <span class="s">&quot;handle trans id %ld != current trans id %ld&quot;</span><span class="p">,</span>
			       <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">-=</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span> <span class="o">-</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_logged</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* &lt;= 0 is allowed.  unmounting might not call begin */</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* BUG, deal with case where j_len is 0, but people previously freed blocks need to be released</span>
<span class="cm">	 ** will be dealt with by next transaction that actually writes something, but should be taken</span>
<span class="cm">	 ** care of in this trans</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* if wcount &gt; 0, and we are called to with flush or commit_now,</span>
<span class="cm">	 ** we wait on j_join_wait.  We will wake up when the last writer has</span>
<span class="cm">	 ** finished the transaction, and started it on its way to the disk.</span>
<span class="cm">	 ** Then, we flush the commit or journal list, and just return 0</span>
<span class="cm">	 ** because the rest of journal end was already done for this transaction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">||</span> <span class="n">commit_now</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">trans_id</span><span class="p">;</span>

			<span class="n">jl</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">;</span>
			<span class="n">trans_id</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wait_on_commit</span><span class="p">)</span>
				<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">|=</span> <span class="n">LIST_COMMIT_PENDING</span><span class="p">;</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_next_full_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

			<span class="cm">/* sleep while the current transaction is still j_jlocked */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="n">trans_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">queue_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">lock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="n">trans_id</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">),</span>
							   <span class="mi">1</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="n">trans_id</span><span class="p">);</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">commit_now</span>
			    <span class="o">&amp;&amp;</span> <span class="n">journal_list_still_alive</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">trans_id</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="n">wait_on_commit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* deal with old transactions where we are the last writers */</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">now</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_trans_age</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">commit_now</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_next_async_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* don&#39;t batch when someone is waiting on j_join_wait */</span>
	<span class="cm">/* don&#39;t batch when syncing the commit or flushing the whole trans */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_must_wait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">)))</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">flush</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">commit_now</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">&lt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">&lt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch</span>
	    <span class="o">&amp;&amp;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_cnode_free</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bcount</span><span class="o">++</span><span class="p">;</span>
		<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">&gt;</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-003&quot;</span><span class="p">,</span>
			       <span class="s">&quot;j_start (%ld) is too high&quot;</span><span class="p">,</span>
			       <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** Does all the work that makes deleting blocks safe.</span>
<span class="cm">** when deleting a block mark BH_JNew, just remove it from the current transaction, clean it&#39;s buffer_head and move on.</span>
<span class="cm">**</span>
<span class="cm">** otherwise:</span>
<span class="cm">** set a bit for the block in the journal bitmap.  That will prevent it from being allocated for unformatted nodes</span>
<span class="cm">** before this transaction has finished.</span>
<span class="cm">**</span>
<span class="cm">** mark any cnodes for this block as BLOCK_FREED, and clear their bh pointers.  That will prevent any old transactions with</span>
<span class="cm">** this block from trying to flush to the real location.  Since we aren&#39;t removing the cnode from the journal_list_hash,</span>
<span class="cm">** the block can&#39;t be reallocated yet.</span>
<span class="cm">**</span>
<span class="cm">** Then remove it from the current transaction, decrementing any counters and filing it on the clean list.</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">journal_mark_freed</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">blocknr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">jb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">cn</span> <span class="o">=</span> <span class="n">get_journal_hash_dev</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_hash_table</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cn</span> <span class="o">&amp;&amp;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* if it is journal new, we just remove it from this transaction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_journal_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_buffer_journal_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">clear_prepared_bits</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">reiserfs_clean_and_file_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">cleaned</span> <span class="o">=</span> <span class="n">remove_from_transaction</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">cleaned</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* set the bit for this block in the journal bitmap for this transaction */</span>
		<span class="n">jb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1702&quot;</span><span class="p">,</span>
				       <span class="s">&quot;journal_list_bitmap is NULL&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_bit_in_list_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">jb</span><span class="p">);</span>

		<span class="cm">/* Note, the entire while loop is not allowed to schedule.  */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_prepared_bits</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">reiserfs_clean_and_file_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cleaned</span> <span class="o">=</span> <span class="n">remove_from_transaction</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">cleaned</span><span class="p">);</span>

		<span class="cm">/* find all older transactions with this block, make sure they don&#39;t try to write it out */</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">get_journal_hash_dev</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_hash_table</span><span class="p">,</span>
					  <span class="n">blocknr</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sb</span> <span class="o">==</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">&amp;&amp;</span> <span class="n">blocknr</span> <span class="o">==</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">BLOCK_FREED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cleaned</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* remove_from_transaction will brelse the buffer if it was </span>
<span class="cm">						 ** in the current trans</span>
<span class="cm">						 */</span>
						<span class="n">clear_buffer_journal_dirty</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span>
									   <span class="n">bh</span><span class="p">);</span>
						<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
						<span class="n">clear_buffer_journal_test</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span>
									  <span class="n">bh</span><span class="p">);</span>
						<span class="n">cleaned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="n">put_bh</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span>
						    <span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
								 <span class="s">&quot;journal-2138&quot;</span><span class="p">,</span>
								 <span class="s">&quot;cn-&gt;bh-&gt;b_count &lt; 0&quot;</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* since we are clearing the bh, we MUST dec nonzerolen */</span>
						<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span>
							   <span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">jlist</span><span class="o">-&gt;</span>
							    <span class="n">j_nonzerolen</span><span class="p">));</span>
					<span class="p">}</span>
					<span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">hnext</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">release_buffer_page</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span> <span class="cm">/* get_hash grabs the buffer */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_jl</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_trans_id</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns -1 on error, 0 if no commits/barriers were done and 1</span>
<span class="cm"> * if a transaction was actually committed and the barrier was done</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__commit_trans_jl</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">id</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* is it from the current transaction, or from an unknown transaction? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jl</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">;</span>
		<span class="cm">/* try to let other writers come in and grow this transaction */</span>
		<span class="n">let_transaction_grow</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">!=</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">flush_commit_only</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* someone might have ended this transaction while we joined */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">!=</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
						     <span class="mi">1</span><span class="p">);</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">flush_commit_only</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_end_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* this gets tricky, we have to make sure the journal list in</span>
<span class="cm">		 * the inode still exists.  We know the list is still around</span>
<span class="cm">		 * if we&#39;ve got a larger transaction id than the oldest list</span>
<span class="cm">		 */</span>
	      <span class="nl">flush_commit_only:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal_list_still_alive</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we only set ret to 1 when we know for sure</span>
<span class="cm">			 * the barrier hasn&#39;t been started yet on the commit</span>
<span class="cm">			 * block.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* otherwise the list is gone, and long since committed */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_commit_for_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_trans_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span> <span class="o">=</span> <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_jl</span><span class="p">;</span>

	<span class="cm">/* for the whole inode, assume unset id means it was</span>
<span class="cm">	 * changed in the current transaction.  More conservative</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span> <span class="o">||</span> <span class="o">!</span><span class="n">jl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_trans_id</span><span class="p">;</span>
		<span class="cm">/* jl will be updated in __commit_trans_jl */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">__commit_trans_jl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">restore_prepared</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_clear_buffer_journal_restore_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">get_journal_hash_dev</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_hash_table</span><span class="p">,</span>
					  <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cn</span> <span class="o">&amp;&amp;</span> <span class="n">can_dirty</span><span class="p">(</span><span class="n">cn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_buffer_journal_test</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">clear_buffer_journal_prepared</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">cur_tb</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm">** before we can change a metadata block, we have to make sure it won&#39;t</span>
<span class="cm">** be written to disk while we are altering it.  So, we must:</span>
<span class="cm">** clean it</span>
<span class="cm">** wait on it.</span>
<span class="cm">**</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="p">.</span><span class="n">prepare</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_buffer_journal_prepared</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_buffer_journal_test</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">set_buffer_journal_restore_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_old_journal_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">jl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="cm">/* this check should always be run, to send old lists to disk */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_timestamp</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="p">(</span><span class="n">JOURNAL_MAX_TRANS_AGE</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_transaction</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">flush_used_journal_lists</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">jl</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** long and ugly.  If flush, will not return until all commit</span>
<span class="cm">** blocks and all real buffers in the trans are on disk.</span>
<span class="cm">** If no_async, won&#39;t return until all commit blocks are on disk.</span>
<span class="cm">**</span>
<span class="cm">** keep reading, there are comments as you go along</span>
<span class="cm">**</span>
<span class="cm">** If the journal is aborted, we just clean up. Things like flushing</span>
<span class="cm">** journal lists, etc just won&#39;t happen.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_journal_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">jl_cn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">last_cn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_commit</span> <span class="o">*</span><span class="n">commit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">c_bh</span><span class="p">;</span>	<span class="cm">/* commit bh */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">d_bh</span><span class="p">;</span>	<span class="cm">/* desc bh */</span>
	<span class="kt">int</span> <span class="n">cur_write_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* start index of current log write */</span>
	<span class="kt">int</span> <span class="n">old_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flush</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait_on_commit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">,</span> <span class="o">*</span><span class="n">temp_jl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jindex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">commit_trans_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trans_half</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="cm">/* protect flush_older_commits from doing mistakes if the</span>
<span class="cm">           transaction ID counter gets overflowed.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FLUSH_ALL</span> <span class="o">|</span> <span class="n">COMMIT_NOW</span> <span class="o">|</span> <span class="n">WAIT</span><span class="p">;</span>
	<span class="n">flush</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLUSH_ALL</span><span class="p">;</span>
	<span class="n">wait_on_commit</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WAIT</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_handle_save</span><span class="p">;</span>
	<span class="n">reiserfs_check_lock_depth</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal end&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
					     <span class="mi">1</span><span class="p">);</span>
		<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">lock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_next_full_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FLUSH_ALL</span><span class="p">;</span>
		<span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_next_async_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">COMMIT_NOW</span> <span class="o">|</span> <span class="n">WAIT</span><span class="p">;</span>
		<span class="n">wait_on_commit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check_journal_end locks the journal, and unlocks if it does not return 1</span>
<span class="cm">	 ** it tells us if we should continue with the journal_end, or just return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_schedule_old_flush</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">wake_queued_writers</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">reiserfs_async_progress_wait</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check_journal_end might set these, check again */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_next_full_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 ** j must wait means we have to flush the log blocks, and the real blocks for</span>
<span class="cm">	 ** this transaction</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_must_wait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef REISERFS_PREALLOCATE</span>
	<span class="cm">/* quota ops might need to nest, setup the journal_info pointer for them</span>
<span class="cm">	 * and raise the refcount so that it is &gt; 0. */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">th</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">++</span><span class="p">;</span>
	<span class="n">reiserfs_discard_all_prealloc</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>	<span class="cm">/* it should not involve new blocks into</span>
<span class="cm">						 * the transaction */</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">--</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_handle_save</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* setup description block */</span>
	<span class="n">d_bh</span> <span class="o">=</span>
	    <span class="n">journal_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
			   <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
			   <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="o">*</span><span class="p">)(</span><span class="n">d_bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d_bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">get_journal_desc_magic</span><span class="p">(</span><span class="n">d_bh</span><span class="p">),</span> <span class="n">JOURNAL_DESC_MAGIC</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">set_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>

	<span class="cm">/* setup commit block.  Don&#39;t write (keep it clean too) this one until after everyone else is written */</span>
	<span class="n">c_bh</span> <span class="o">=</span> <span class="n">journal_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
			      <span class="p">((</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">+</span>
				<span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)));</span>
	<span class="n">commit</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal_commit</span> <span class="o">*</span><span class="p">)</span><span class="n">c_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">c_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c_bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="n">set_commit_trans_id</span><span class="p">(</span><span class="n">commit</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">c_bh</span><span class="p">);</span>

	<span class="cm">/* init this journal list */</span>
	<span class="n">jl</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">;</span>

	<span class="cm">/* we lock the commit before doing anything because</span>
<span class="cm">	 * we want to make sure nobody tries to run flush_commit_list until</span>
<span class="cm">	 * the new transaction is fully setup, and we&#39;ve already flushed the</span>
<span class="cm">	 * ordered bh list</span>
<span class="cm">	 */</span>
	<span class="n">reiserfs_mutex_lock_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_mutex</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* save the transaction id in case we need to commit it later */</span>
	<span class="n">commit_trans_id</span> <span class="o">=</span> <span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_older_commits_done</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_timestamp</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_bh</span> <span class="o">=</span> <span class="n">c_bh</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">;</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_nonzerolen</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_left</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* The ENTIRE FOR LOOP MUST not cause schedule to occur.</span>
<span class="cm">	 **  for each real block, add it to the journal list hash,</span>
<span class="cm">	 ** copy into real block index array in the commit or desc block</span>
<span class="cm">	 */</span>
	<span class="n">trans_half</span> <span class="o">=</span> <span class="n">journal_trans_half</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cn</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span><span class="p">;</span> <span class="n">cn</span><span class="p">;</span> <span class="n">cn</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jl_cn</span> <span class="o">=</span> <span class="n">get_cnode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jl_cn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1676&quot;</span><span class="p">,</span>
					       <span class="s">&quot;get_cnode returned NULL&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_realblock</span> <span class="o">=</span> <span class="n">jl_cn</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">jl_cn</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">last_cn</span><span class="p">;</span>
			<span class="n">jl_cn</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_cn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">last_cn</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">jl_cn</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">last_cn</span> <span class="o">=</span> <span class="n">jl_cn</span><span class="p">;</span>
			<span class="cm">/* make sure the block we are trying to log is not a block</span>
<span class="cm">			   of journal or reserved area */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">is_block_in_log_or_reserved_area</span>
			    <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-2332&quot;</span><span class="p">,</span>
					       <span class="s">&quot;Trying to log block %lu, &quot;</span>
					       <span class="s">&quot;which is a log block&quot;</span><span class="p">,</span>
					       <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">jl_cn</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
			<span class="n">jl_cn</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">jl_cn</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
			<span class="n">jl_cn</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>
			<span class="n">jl_cn</span><span class="o">-&gt;</span><span class="n">jlist</span> <span class="o">=</span> <span class="n">jl</span><span class="p">;</span>
			<span class="n">insert_journal_hash</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_hash_table</span><span class="p">,</span> <span class="n">jl_cn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">trans_half</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">commit</span><span class="o">-&gt;</span><span class="n">j_realblock</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">trans_half</span><span class="p">]</span> <span class="o">=</span>
				    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">set_desc_trans_len</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span><span class="p">);</span>
	<span class="n">set_desc_mount_id</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_mount_id</span><span class="p">);</span>
	<span class="n">set_desc_trans_id</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">);</span>
	<span class="n">set_commit_trans_len</span><span class="p">(</span><span class="n">commit</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span><span class="p">);</span>

	<span class="cm">/* special check in case all buffers in the journal were marked for not logging */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* we&#39;re about to dirty all the log blocks, mark the description block</span>
<span class="cm">	 * dirty now too.  Don&#39;t mark the commit block dirty until all the</span>
<span class="cm">	 * others are on disk</span>
<span class="cm">	 */</span>
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">d_bh</span><span class="p">);</span>

	<span class="cm">/* first data block is j_start + 1, so add one to cur_write_start wherever you use it */</span>
	<span class="n">cur_write_start</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">;</span>
	<span class="n">cn</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span><span class="p">;</span>
	<span class="n">jindex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* start at one so we don&#39;t get the desc again */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_buffer_journal_new</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="cm">/* copy all the real blocks into log area.  dirty log blocks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tmp_bh</span><span class="p">;</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
			<span class="n">tmp_bh</span> <span class="o">=</span>
			    <span class="n">journal_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					   <span class="n">SB_ONDISK_JOURNAL_1st_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
					   <span class="p">((</span><span class="n">cur_write_start</span> <span class="o">+</span>
					     <span class="n">jindex</span><span class="p">)</span> <span class="o">%</span>
					    <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)));</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
			       <span class="n">addr</span> <span class="o">+</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">),</span>
			       <span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">tmp_bh</span><span class="p">);</span>
			<span class="n">jindex</span><span class="o">++</span><span class="p">;</span>
			<span class="n">set_buffer_journal_dirty</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_journaled</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* JDirty cleared sometime during transaction.  don&#39;t log this one */</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-2048&quot;</span><span class="p">,</span>
					 <span class="s">&quot;BAD, buffer in journal hash, &quot;</span>
					 <span class="s">&quot;but not JDirty!&quot;</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">free_cnode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">cn</span><span class="p">);</span>
		<span class="n">cn</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* we are done  with both the c_bh and d_bh, but</span>
<span class="cm">	 ** c_bh must be written after all other commit blocks,</span>
<span class="cm">	 ** so we dirty/relse c_bh in flush_commit_list, with commit_left &lt;= 1.</span>
<span class="cm">	 */</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span> <span class="o">=</span> <span class="n">alloc_journal_list</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* now it is safe to insert this transaction on the main list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_working_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_working_list</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_num_work_lists</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* reset journal values for the next transaction */</span>
	<span class="n">old_start</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">+</span>
	     <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wcount</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_bcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_start_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* check for trans_id overflow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_must_wait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_len_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_next_full_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_next_async_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_journal_hash</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>make sure reiserfs<em>add</em>jh sees the new current_jl before we
write out the tails</p></td><td class="code"><div class="highlight"><pre>	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* tail conversion targets have to hit the disk before we end the</span>
<span class="cm">	 * transaction.  Otherwise a later transaction might repack the tail</span>
<span class="cm">	 * before this transaction commits, leaving the data block unflushed and</span>
<span class="cm">	 * clean, if we crash before the later transaction commits, the data block</span>
<span class="cm">	 * is lost.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_tail_bh_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">write_ordered_buffers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">,</span>
				      <span class="n">journal</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_tail_bh_list</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_tail_bh_list</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_commit_mutex</span><span class="p">);</span>

	<span class="cm">/* honor the flush wishes from the caller, simple commits can</span>
<span class="cm">	 ** be done outside the journal lock, they are done below</span>
<span class="cm">	 **</span>
<span class="cm">	 ** if we don&#39;t flush the commit list right now, we put it into</span>
<span class="cm">	 ** the work queue so the people waiting on the async progress work</span>
<span class="cm">	 ** queue don&#39;t wait for this proc to flush journal lists and such.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">flush_journal_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">jl</span><span class="o">-&gt;</span><span class="n">j_state</span> <span class="o">&amp;</span> <span class="n">LIST_COMMIT_PENDING</span><span class="p">))</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">commit_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_work</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* if the next transaction has any chance of wrapping, flush</span>
<span class="cm">	 ** transactions that might get overwritten.  If any journal lists are very</span>
<span class="cm">	 ** old flush them as well.</span>
<span class="cm">	 */</span>
      <span class="nl">first_jl:</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp_jl</span> <span class="o">=</span> <span class="n">JOURNAL_LIST_ENTRY</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">&lt;=</span> <span class="n">temp_jl</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span>
			    <span class="n">temp_jl</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flush_used_journal_lists</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">temp_jl</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">first_jl</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span>
				    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span>
				   <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* if we don&#39;t cross into the next transaction and we don&#39;t</span>
<span class="cm">				 * wrap, there is no way we can overlap any later transactions</span>
<span class="cm">				 * break now</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span>
			    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span>
			   <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_start</span> <span class="o">+</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
			     <span class="n">SB_ONDISK_JOURNAL_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="o">&gt;=</span>
			    <span class="n">temp_jl</span><span class="o">-&gt;</span><span class="n">j_start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flush_used_journal_lists</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">temp_jl</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">first_jl</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* we don&#39;t overlap anything from out start to the end of the</span>
<span class="cm">				 * log, and our wrapped portion doesn&#39;t overlap anything at</span>
<span class="cm">				 * the start of the log.  We can break</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">flush_old_journal_lists</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span> <span class="o">=</span>
	    <span class="n">get_list_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="o">-&gt;</span><span class="n">j_list_bitmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal-1996&quot;</span><span class="p">,</span>
			       <span class="s">&quot;could not get a list bitmap&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_jlock</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">unlock_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="cm">/* wake up any body waiting to join. */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">J_WRITERS_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_join_wait</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flush</span> <span class="o">&amp;&amp;</span> <span class="n">wait_on_commit</span> <span class="o">&amp;&amp;</span>
	    <span class="n">journal_list_still_alive</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">commit_trans_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">flush_commit_list</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">jl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
      <span class="nl">out:</span>
	<span class="n">reiserfs_check_lock_depth</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;journal end2&quot;</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">));</span>
	<span class="cm">/* Re-set th-&gt;t_super, so we can properly keep track of how many</span>
<span class="cm">	 * persistent transactions there are. We need to do this so if this</span>
<span class="cm">	 * call is part of a failed restart_transaction, we can free it later */</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send the file system read only and refuse new transactions */</span>
<span class="kt">void</span> <span class="nf">reiserfs_abort_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">errno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">J_ABORTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">)</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">J_ABORTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
