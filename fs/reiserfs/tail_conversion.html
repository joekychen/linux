<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › tail_conversion.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tail_conversion.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 1999 Hans Reiser, see reiserfs/README for licensing and copyright details</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>

<span class="cm">/* access to tail : when one is going to read tail it must make sure, that is not running.</span>
<span class="cm"> direct2indirect and indirect2direct can not run concurrently */</span>

<span class="cm">/* Converts direct items to an unformatted node. Panics if file has no</span>
<span class="cm">   tail. -ENOSPC if no disk space for conversion */</span>
<span class="cm">/* path points to first direct item of the file regarless of how many of</span>
<span class="cm">   them are there */</span>
<span class="kt">int</span> <span class="nf">direct2indirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">unbh</span><span class="p">,</span>
		    <span class="n">loff_t</span> <span class="n">tail_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">up_to_date_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">p_le_ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">end_key</span><span class="p">;</span>	<span class="cm">/* Key to search for the last byte of the</span>
<span class="cm">				   converted item. */</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="n">ind_ih</span><span class="p">;</span>	<span class="cm">/* new indirect item to be inserted or</span>
<span class="cm">					   key of unfm pointer to be pasted */</span>
	<span class="kt">int</span> <span class="n">blk_size</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>	<span class="cm">/* returned value for reiserfs_insert_item and clones */</span>
	<span class="n">unp_t</span> <span class="n">unfm_ptr</span><span class="p">;</span>		<span class="cm">/* Handle on an unformatted node</span>
<span class="cm">				   that will be inserted in the</span>
<span class="cm">				   tree. */</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_direct2indirect</span><span class="o">++</span><span class="p">;</span>

	<span class="n">blk_size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>

	<span class="cm">/* and key to search for append or insert pointer to the new</span>
<span class="cm">	   unformatted node. */</span>
	<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ind_ih</span><span class="p">,</span> <span class="n">p_le_ih</span><span class="p">);</span>
	<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ind_ih</span><span class="p">,</span> <span class="n">tail_offset</span><span class="p">);</span>
	<span class="n">set_le_ih_k_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ind_ih</span><span class="p">,</span> <span class="n">TYPE_INDIRECT</span><span class="p">);</span>

	<span class="cm">/* Set the key to search for the place for new unfm pointer */</span>
	<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">tail_offset</span><span class="p">,</span> <span class="n">TYPE_INDIRECT</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* FIXME: we could avoid this */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_key</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;PAP-14030&quot;</span><span class="p">,</span>
			       <span class="s">&quot;pasted or inserted byte exists in &quot;</span>
			       <span class="s">&quot;the tree %K. Use fsck to repair.&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_key</span><span class="p">);</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p_le_ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">unfm_ptr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">unbh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_statdata_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Insert new indirect item. */</span>
		<span class="n">set_ih_free_space</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ind_ih</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* delete at nearest future */</span>
		<span class="n">put_ih_item_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ind_ih</span><span class="p">,</span> <span class="n">UNFM_P_SIZE</span><span class="p">);</span>
		<span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span>
		    <span class="n">reiserfs_insert_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ind_ih</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">unfm_ptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Paste into last indirect item of an object. */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">reiserfs_paste_into_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						    <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">unfm_ptr</span><span class="p">,</span>
						    <span class="n">UNFM_P_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>note: from here there are two keys which have matching first
three key components. They only differ by the fourth one.</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* Set the key to search for the direct items of the file */</span>
	<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">max_reiserfs_offset</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">TYPE_DIRECT</span><span class="p">,</span>
		     <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Move bytes from the direct items to the new unformatted node</span>
<span class="cm">	   and delete them. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">tail_size</span><span class="p">;</span>

		<span class="cm">/* end_key.k_offset is set so, that we will always have found</span>
<span class="cm">		   last item of the file */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_key</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">POSITION_FOUND</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;PAP-14050&quot;</span><span class="p">,</span>
				       <span class="s">&quot;direct item (%K) not found&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_key</span><span class="p">);</span>
		<span class="n">p_le_ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">),</span>
		       <span class="s">&quot;vs-14055: direct item expected(%K), found %h&quot;</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">end_key</span><span class="p">,</span> <span class="n">p_le_ih</span><span class="p">);</span>
		<span class="n">tail_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blk_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		    <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* we only send the unbh pointer if the buffer is not up to date.</span>
<span class="cm">		 ** this avoids overwriting good data from writepage() with old data</span>
<span class="cm">		 ** from the disk or buffer cache</span>
<span class="cm">		 ** Special case: unbh-&gt;b_page will be NULL if we are coming through</span>
<span class="cm">		 ** DIRECT_IO handler here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unbh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">||</span> <span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">unbh</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">PageUptodate</span><span class="p">(</span><span class="n">unbh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">up_to_date_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">up_to_date_bh</span> <span class="o">=</span> <span class="n">unbh</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">reiserfs_delete_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						<span class="n">up_to_date_bh</span><span class="p">);</span>

		<span class="n">total_tail</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tail_size</span> <span class="o">==</span> <span class="n">retval</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>done: file does not have direct items anymore</p></td><td class="code"><div class="highlight"><pre>			<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="cm">/* if we&#39;ve copied bytes from disk into the page, we need to zero</span>
<span class="cm">	 ** out the unused part of the block (it was not up to date before)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">up_to_date_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">pgoff</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">tail_offset</span> <span class="o">+</span> <span class="n">total_tail</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">up_to_date_bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">pgoff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blk_size</span> <span class="o">-</span> <span class="n">total_tail</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_first_direct_byte</span> <span class="o">=</span> <span class="n">U32_MAX</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* stolen from fs/buffer.c */</span>
<span class="kt">void</span> <span class="nf">reiserfs_unmap_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="cm">/* Remove the buffer from whatever list it belongs to. We are mostly</span>
<span class="cm">	   interested in removing it from per-sb j_dirty_buffers list, to avoid</span>
<span class="cm">	   BUG() on attempt to write not mapped buffer */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="o">||</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">);</span>
		<span class="n">reiserfs_free_jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">clear_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_req</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* this first locks inode (neither reads nor sync are permitted),</span>
<span class="cm">   reads tail through page cache, insert direct item. When direct item</span>
<span class="cm">   inserted successfully inode is left locked. Return value is always</span>
<span class="cm">   what we expect from it (number of cut bytes). But when tail remains</span>
<span class="cm">   in the unformatted node, we set mode to SKIP_BALANCING and unlock</span>
<span class="cm">   inode */</span>
<span class="kt">int</span> <span class="nf">indirect2direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>	<span class="cm">/* path to the indirect item. */</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">item_key</span><span class="p">,</span>	<span class="cm">/* Key to look for</span>
<span class="cm">							 * unformatted node</span>
<span class="cm">							 * pointer to be cut. */</span>
		    <span class="n">loff_t</span> <span class="n">n_new_file_size</span><span class="p">,</span>	<span class="cm">/* New file size. */</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="n">s_ih</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tail_len</span><span class="p">,</span> <span class="n">round_tail_len</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">pos1</span><span class="p">;</span>	<span class="cm">/* position of first byte of the tail */</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_indirect2direct</span><span class="o">++</span><span class="p">;</span>

	<span class="o">*</span><span class="n">mode</span> <span class="o">=</span> <span class="n">M_SKIP_BALANCING</span><span class="p">;</span>

	<span class="cm">/* store item head path points to. */</span>
	<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">,</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>

	<span class="n">tail_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_new_file_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_inode_sd_version</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">STAT_DATA_V2</span><span class="p">)</span>
		<span class="n">round_tail_len</span> <span class="o">=</span> <span class="n">ROUND_UP</span><span class="p">(</span><span class="n">tail_len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">round_tail_len</span> <span class="o">=</span> <span class="n">tail_len</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span>
	    <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">)</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span> <span class="o">-</span>
					 <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">pos1</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>we are protected by i<em>mutex. The tail can not disapper, not
append can be done either
we are in truncate or packing tail in file</em>release</p></td><td class="code"><div class="highlight"><pre>	<span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>	<span class="cm">/* this can schedule */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path_changed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* re-search indirect item */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">item_key</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
		    <span class="o">==</span> <span class="n">POSITION_NOT_FOUND</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;PAP-5520&quot;</span><span class="p">,</span>
				       <span class="s">&quot;item to be converted %K does not exist&quot;</span><span class="p">,</span>
				       <span class="n">item_key</span><span class="p">);</span>
		<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">,</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">)</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span> <span class="o">-</span>
		     <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">pos1</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-5530&quot;</span><span class="p">,</span> <span class="s">&quot;tail position &quot;</span>
				       <span class="s">&quot;changed while we were reading it&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* Set direct item header to insert. */</span>
	<span class="n">make_le_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">get_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
			  <span class="n">pos1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TYPE_DIRECT</span><span class="p">,</span> <span class="n">round_tail_len</span><span class="p">,</span>
			  <span class="mh">0xffff</span> <span class="cm">/*ih_free_space */</span> <span class="p">);</span>

	<span class="cm">/* we want a pointer to the first byte of the tail in the page.</span>
<span class="cm">	 ** the page was locked and this part of the page was up to date when</span>
<span class="cm">	 ** indirect2direct was called, so we know the bytes are still valid</span>
<span class="cm">	 */</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="n">item_key</span><span class="p">;</span>
	<span class="n">set_cpu_key_k_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">TYPE_DIRECT</span><span class="p">);</span>
	<span class="n">key</span><span class="p">.</span><span class="n">key_length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="cm">/* Insert tail as new direct item in the tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_insert_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_ih</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
				 <span class="n">tail</span> <span class="o">?</span> <span class="n">tail</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No disk memory. So we can not convert last unformatted node</span>
<span class="cm">		   to the direct item.  In this case we used to adjust</span>
<span class="cm">		   indirect items&#39;s ih_free_space. Now ih_free_space is not</span>
<span class="cm">		   used, it would be ideal to write zeros to corresponding</span>
<span class="cm">		   unformatted node. For now i_size is considered as guard for</span>
<span class="cm">		   going out of file size */</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">block_size</span> <span class="o">-</span> <span class="n">round_tail_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/* make sure to get the i_blocks changes from reiserfs_insert_item */</span>
	<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>note: we have now the same as in above direct2indirect
conversion: there are two keys which have matching first three
key components. They only differ by the fouhth one.</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* We have inserted new direct item and must remove last</span>
<span class="cm">	   unformatted node. */</span>
	<span class="o">*</span><span class="n">mode</span> <span class="o">=</span> <span class="n">M_CUT</span><span class="p">;</span>

	<span class="cm">/* we store position of first direct item in the in-core inode */</span>
	<span class="cm">/* mark_file_with_tail (inode, pos1 + 1); */</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_first_direct_byte</span> <span class="o">=</span> <span class="n">pos1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">block_size</span> <span class="o">-</span> <span class="n">round_tail_len</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
