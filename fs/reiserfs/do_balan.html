<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › do_balan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>do_balan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>

<span class="cm">/* Now we have all buffers that must be used in balancing of the tree 	*/</span>
<span class="cm">/* Further calculations can not cause schedule(), and thus the buffer 	*/</span>
<span class="cm">/* tree will be stable until the balancing will be finished 		*/</span>
<span class="cm">/* balance the tree according to the analysis made before,		*/</span>
<span class="cm">/* and using buffers obtained after all above.				*/</span>

<span class="cm">/**</span>
<span class="cm"> ** balance_leaf_when_delete</span>
<span class="cm"> ** balance_leaf</span>
<span class="cm"> ** do_balance</span>
<span class="cm"> **</span>
<span class="cm"> **/</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_info_init_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
                                         <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span>          <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span>       <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span>   <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_info_init_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
                                          <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span>          <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span>       <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span>   <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_info_init_tbS0</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
                                         <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span>          <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span>        <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span>   <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buffer_info_init_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
                                       <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span>
                                       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span>          <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span>       <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span>   <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">transaction_handle</span><span class="p">,</span>
			   <span class="n">tb</span><span class="o">-&gt;</span><span class="n">transaction_handle</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty</span>
<span class="cp">#define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty</span>

<span class="cm">/* summary:</span>
<span class="cm"> if deleting something ( tb-&gt;insert_size[0] &lt; 0 )</span>
<span class="cm">   return(balance_leaf_when_delete()); (flag d handled here)</span>
<span class="cm"> else</span>
<span class="cm">   if lnum is larger than 0 we put items into the left node</span>
<span class="cm">   if rnum is larger than 0 we put items into the right node</span>
<span class="cm">   if snum1 is larger than 0 we put items into the new node s1</span>
<span class="cm">   if snum2 is larger than 0 we put items into the new node s2</span>
<span class="cm">Note that all *num* count new items being created.</span>

<span class="cm">It would be easier to read balance_leaf() if each of these summary</span>
<span class="cm">lines was a separate procedure rather than being inlined.  I think</span>
<span class="cm">that there are many passages here and in balance_leaf_when_delete() in</span>
<span class="cm">which two calls to one procedure can replace two passages, and it</span>
<span class="cm">might save cache space and improve software maintenance costs to do so.</span>

<span class="cm">Vladimir made the perceptive comment that we should offload most of</span>
<span class="cm">the decision making in this function into fix_nodes/check_balance, and</span>
<span class="cm">then create some sort of structure in tb that says what actions should</span>
<span class="cm">be performed by do_balance.</span>

<span class="cm">-Hans */</span>

<span class="cm">/* Balance leaf node in case of delete or cut: insert_size[0] &lt; 0</span>
<span class="cm"> *</span>
<span class="cm"> * lnum, rnum can have values &gt;= -1</span>
<span class="cm"> *	-1 means that the neighbor must be joined with S</span>
<span class="cm"> *	 0 means that nothing should be done with the neighbor</span>
<span class="cm"> *	&gt;0 means to shift entirely or partly the specified number of items to the neighbor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">balance_leaf_when_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbS0</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">item_pos</span> <span class="o">=</span> <span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pos_in_item</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="o">-&gt;</span><span class="n">pos_in_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">bi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">B_LEVEL</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">DISK_LEAF_NODE_LEVEL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	       <span class="s">&quot;vs- 12000: level: wrong FR %z&quot;</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>
	       <span class="s">&quot;PAP-12005: tb-&gt;blknum == %d, can not be &gt; 1&quot;</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	       <span class="s">&quot;PAP-12010: tree can not be empty&quot;</span><span class="p">);</span>

	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">);</span>
	<span class="n">buffer_info_init_tbS0</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>

	<span class="cm">/* Delete or truncate the item */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">M_DELETE</span>:		<span class="cm">/* delete item in S[0] */</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">IH_SIZE</span> <span class="o">!=</span> <span class="o">-</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="s">&quot;vs-12013: mode Delete, insert size %d, ih to be deleted %h&quot;</span><span class="p">,</span>
		       <span class="o">-</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ih</span><span class="p">);</span>

		<span class="n">leaf_delete_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item_pos</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbS0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tbS0</span><span class="p">,</span>
					    <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
					<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						    <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
								   <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">item_pos</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="s">&quot;PAP-12020: tb-&gt;CFL[0]==%p, tb-&gt;L[0]==%p&quot;</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">M_CUT</span>:<span class="p">{</span>		<span class="cm">/* cut item in S[0] */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>

				<span class="cm">/* UFS unlink semantics are such that you can only delete one directory entry at a time. */</span>
				<span class="cm">/* when we cut a directory tb-&gt;insert_size[0] means number of entries to be cut (always 1) */</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">leaf_cut_from_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">,</span>
						     <span class="o">-</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

				<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">item_pos</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pos_in_item</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				       <span class="s">&quot;PAP-12030: can not change delimiting key. CFL[0]=%p&quot;</span><span class="p">,</span>
				       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item_pos</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pos_in_item</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						    <span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">leaf_cut_from_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">,</span>
						     <span class="o">-</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

				<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
				       <span class="s">&quot;PAP-12035: cut must leave non-zero dynamic length of item&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;12040&quot;</span><span class="p">);</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-12040&quot;</span><span class="p">,</span>
			       <span class="s">&quot;unexpected mode: %s(%d)&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">flag</span> <span class="o">==</span>
				<span class="n">M_PASTE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;PASTE&quot;</span> <span class="o">:</span> <span class="p">((</span><span class="n">flag</span> <span class="o">==</span>
						       <span class="n">M_INSERT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;INSERT&quot;</span> <span class="o">:</span>
						      <span class="s">&quot;UNKNOWN&quot;</span><span class="p">),</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* the rule is that no shifting occurs unless by shifting a node can be freed */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbS0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>	<span class="cm">/* L[0] takes part in balancing */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* L[0] must be joined with S[0] */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* R[0] must be also joined with S[0] */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* all contents of all the 3 buffers will be in L[0] */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
					    <span class="o">&amp;&amp;</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
						<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>

					<span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_L</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
							<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
					<span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_R_TO_L</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span>
							<span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
							<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

					<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbS0</span><span class="p">);</span>
					<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
								   <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* all contents of all the 3 buffers will be in R[0] */</span>
				<span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_R</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">);</span>
				<span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_L_TO_R</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span>
						<span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

				<span class="cm">/* right_delimiting_key is correct in R[0] */</span>
				<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

				<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbS0</span><span class="p">);</span>
				<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
			       <span class="s">&quot;PAP-12045: rnum must be 0 (%d)&quot;</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="cm">/* all contents of L[0] and S[0] will be in L[0] */</span>
			<span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbS0</span><span class="p">);</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */</span>

		<span class="n">RFALSE</span><span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">||</span>
		       <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
		       <span class="s">&quot;PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent&quot;</span><span class="p">,</span>
		       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
		       <span class="s">&quot;PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split&quot;</span><span class="p">,</span>
		       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
		       <span class="s">&quot;PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split&quot;</span><span class="p">,</span>
		       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">);</span>

		<span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">);</span>
		<span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>

		<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbS0</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* all contents of R[0] and S[0] will be in R[0] */</span>
		<span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbS0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
	       <span class="s">&quot;PAP-12065: bad rnum parameter must be 0 (%d)&quot;</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">balance_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span>	<span class="cm">/* item header of inserted item (this is on little endian) */</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span>	<span class="cm">/* body  of inserted item or bytes to paste */</span>
			<span class="kt">int</span> <span class="n">flag</span><span class="p">,</span>	<span class="cm">/* i - insert, d - delete, c - cut, p - paste</span>
<span class="cm">					   (see comment to do_balance) */</span>
			<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">insert_key</span><span class="p">,</span>	<span class="cm">/* in our processing of one level we sometimes determine what</span>
<span class="cm">							   must be inserted into the next higher level.  This insertion</span>
<span class="cm">							   consists of a key or two keys and their corresponding</span>
<span class="cm">							   pointers */</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">insert_ptr</span>	<span class="cm">/* inserted node-ptrs for the next level */</span>
    <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbS0</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">item_pos</span> <span class="o">=</span> <span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>	<span class="cm">/*  index into the array of item headers in S[0]</span>
<span class="cm">							   of the affected item */</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">S_new</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* new nodes allocated to hold what could not fit into S */</span>
	<span class="kt">int</span> <span class="n">snum</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* number of items that will be placed</span>
<span class="cm">				   into S_new (includes partially shifted</span>
<span class="cm">				   items) */</span>
	<span class="kt">int</span> <span class="n">sbytes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* if an item is partially shifted into S_new then</span>
<span class="cm">				   if it is a directory item</span>
<span class="cm">				   it is the number of entries from the item that are shifted into S_new</span>
<span class="cm">				   else</span>
<span class="cm">				   it is the number of bytes from the item that are shifted into S_new</span>
<span class="cm">				 */</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">zeros_num</span><span class="p">;</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">balance_at</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* Make balance in case insert_size[0] &lt; 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">balance_leaf_when_delete</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

	<span class="n">zeros_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">M_INSERT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">body</span><span class="p">)</span>
		<span class="n">zeros_num</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

	<span class="n">pos_in_item</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="o">-&gt;</span><span class="n">pos_in_item</span><span class="p">;</span>
	<span class="cm">/* for indirect item pos_in_item is measured in unformatted node</span>
<span class="cm">	   pointers. Recalculate to bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="n">M_INSERT</span>
	    <span class="o">&amp;&amp;</span> <span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">)))</span>
		<span class="n">pos_in_item</span> <span class="o">*=</span> <span class="n">UNFM_P_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Shift lnum[0] items from S[0] to the left neighbor L[0] */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">&lt;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* new item or it part falls to L[0], shift it too */</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">M_INSERT</span>:	<span class="cm">/* insert item into L[0] */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">==</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
				    <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* part of new item falls into L[0] */</span>
					<span class="kt">int</span> <span class="n">new_item_len</span><span class="p">;</span>
					<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>

					<span class="n">ret_val</span> <span class="o">=</span>
					    <span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
							    <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

					<span class="cm">/* Calculate item length to insert to S[0] */</span>
					<span class="n">new_item_len</span> <span class="o">=</span>
					    <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">;</span>
					<span class="cm">/* Calculate and check item length to insert to L[0] */</span>
					<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span>
							<span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span>
							<span class="n">new_item_len</span><span class="p">);</span>

					<span class="n">RFALSE</span><span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="s">&quot;PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d&quot;</span><span class="p">,</span>
					       <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>

					<span class="cm">/* Insert new item into L[0] */</span>
					<span class="n">buffer_info_init_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
					<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
							     <span class="n">n</span> <span class="o">+</span> <span class="n">item_pos</span> <span class="o">-</span>
							     <span class="n">ret_val</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span>
							     <span class="n">zeros_num</span> <span class="o">&gt;</span>
							     <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">?</span>
							     <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">:</span>
							     <span class="n">zeros_num</span><span class="p">);</span>

					<span class="n">version</span> <span class="o">=</span> <span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

					<span class="cm">/* Calculate key component, item length and body to insert into S[0] */</span>
					<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span>
							   <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
							   <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
							    <span class="n">lbytes</span> <span class="o">&lt;&lt;</span>
							    <span class="p">(</span><span class="n">is_indirect_le_ih</span>
							     <span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">?</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="o">-&gt;</span>
							     <span class="n">s_blocksize_bits</span> <span class="o">-</span>
							     <span class="n">UNFM_P_SHIFT</span> <span class="o">:</span>
							     <span class="mi">0</span><span class="p">)));</span>

					<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">new_item_len</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">&gt;</span> <span class="n">zeros_num</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">body</span> <span class="o">+=</span>
						    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">-</span> <span class="n">zeros_num</span><span class="p">);</span>
						<span class="n">zeros_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="n">zeros_num</span> <span class="o">-=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">;</span>

					<span class="n">RFALSE</span><span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="s">&quot;PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d&quot;</span><span class="p">,</span>
					       <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* new item in whole falls into L[0] */</span>
					<span class="cm">/* Shift lnum[0]-1 items to L[0] */</span>
					<span class="n">ret_val</span> <span class="o">=</span>
					    <span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">);</span>
					<span class="cm">/* Insert new item into L[0] */</span>
					<span class="n">buffer_info_init_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
					<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
							     <span class="n">n</span> <span class="o">+</span> <span class="n">item_pos</span> <span class="o">-</span>
							     <span class="n">ret_val</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span>
							     <span class="n">zeros_num</span><span class="p">);</span>
					<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">zeros_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">M_PASTE</span>:	<span class="cm">/* append item in L[0] */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">==</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
				    <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* we must shift the part of the appended item */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span>
					    <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">)))</span> <span class="p">{</span>

						<span class="n">RFALSE</span><span class="p">(</span><span class="n">zeros_num</span><span class="p">,</span>
						       <span class="s">&quot;PAP-12090: invalid parameter in case of a directory&quot;</span><span class="p">);</span>
						<span class="cm">/* directory item */</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">&gt;</span> <span class="n">pos_in_item</span><span class="p">)</span> <span class="p">{</span>
							<span class="cm">/* new directory entry falls into L[0] */</span>
							<span class="k">struct</span> <span class="n">item_head</span>
							    <span class="o">*</span><span class="n">pasted</span><span class="p">;</span>
							<span class="kt">int</span> <span class="n">l_pos_in_item</span> <span class="o">=</span>
							    <span class="n">pos_in_item</span><span class="p">;</span>

							<span class="cm">/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */</span>
							<span class="n">ret_val</span> <span class="o">=</span>
							    <span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">lnum</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">lbytes</span>
									    <span class="o">-</span>
									    <span class="mi">1</span><span class="p">);</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span>
							    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">item_pos</span><span class="p">)</span> <span class="p">{</span>
								<span class="n">pasted</span> <span class="o">=</span>
								    <span class="n">B_N_PITEM_HEAD</span>
								    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								     <span class="n">B_NR_ITEMS</span>
								     <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
								      <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span>
								     <span class="mi">1</span><span class="p">);</span>
								<span class="n">l_pos_in_item</span> <span class="o">+=</span>
								    <span class="n">I_ENTRY_COUNT</span>
								    <span class="p">(</span><span class="n">pasted</span><span class="p">)</span> <span class="o">-</span>
								    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
								     <span class="n">lbytes</span> <span class="o">-</span>
								     <span class="mi">1</span><span class="p">);</span>
							<span class="p">}</span>

							<span class="cm">/* Append given directory entry to directory item */</span>
							<span class="n">buffer_info_init_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
							<span class="n">leaf_paste_in_buffer</span>
							    <span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
							     <span class="n">n</span> <span class="o">+</span> <span class="n">item_pos</span> <span class="o">-</span>
							     <span class="n">ret_val</span><span class="p">,</span>
							     <span class="n">l_pos_in_item</span><span class="p">,</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							     <span class="n">body</span><span class="p">,</span> <span class="n">zeros_num</span><span class="p">);</span>

							<span class="cm">/* previous string prepared space for pasting new entry, following string pastes this entry */</span>

							<span class="cm">/* when we have merge directory item, pos_in_item has been changed too */</span>

							<span class="cm">/* paste new directory entry. 1 is entry number */</span>
							<span class="n">leaf_paste_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
									   <span class="n">n</span> <span class="o">+</span>
									   <span class="n">item_pos</span>
									   <span class="o">-</span>
									   <span class="n">ret_val</span><span class="p">,</span>
									   <span class="n">l_pos_in_item</span><span class="p">,</span>
									   <span class="mi">1</span><span class="p">,</span>
									   <span class="p">(</span><span class="k">struct</span>
									    <span class="n">reiserfs_de_head</span>
									    <span class="o">*</span><span class="p">)</span>
									   <span class="n">body</span><span class="p">,</span>
									   <span class="n">body</span>
									   <span class="o">+</span>
									   <span class="n">DEH_SIZE</span><span class="p">,</span>
									   <span class="n">tb</span><span class="o">-&gt;</span>
									   <span class="n">insert_size</span>
									   <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
							    <span class="p">);</span>
							<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="cm">/* new directory item doesn&#39;t fall into L[0] */</span>
							<span class="cm">/* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */</span>
							<span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
									<span class="n">tb</span><span class="o">-&gt;</span>
									<span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									<span class="n">tb</span><span class="o">-&gt;</span>
									<span class="n">lbytes</span><span class="p">);</span>
						<span class="p">}</span>
						<span class="cm">/* Calculate new position to append in item body */</span>
						<span class="n">pos_in_item</span> <span class="o">-=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="cm">/* regular object */</span>
						<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span>
						       <span class="s">&quot;PAP-12095: there is nothing to shift to L[0]. lbytes=%d&quot;</span><span class="p">,</span>
						       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">);</span>
						<span class="n">RFALSE</span><span class="p">(</span><span class="n">pos_in_item</span> <span class="o">!=</span>
						       <span class="n">ih_item_len</span>
						       <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
							<span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">)),</span>
						       <span class="s">&quot;PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d&quot;</span><span class="p">,</span>
						       <span class="n">ih_item_len</span>
						       <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
							<span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">)),</span>
						       <span class="n">pos_in_item</span><span class="p">);</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">&gt;=</span> <span class="n">pos_in_item</span><span class="p">)</span> <span class="p">{</span>
							<span class="cm">/* appended item will be in L[0] in whole */</span>
							<span class="kt">int</span> <span class="n">l_n</span><span class="p">;</span>

							<span class="cm">/* this bytes number must be appended to the last item of L[h] */</span>
							<span class="n">l_n</span> <span class="o">=</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">-</span>
							    <span class="n">pos_in_item</span><span class="p">;</span>

							<span class="cm">/* Calculate new insert_size[0] */</span>
							<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span>
							    <span class="n">l_n</span><span class="p">;</span>

							<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
							       <span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span>
							       <span class="mi">0</span><span class="p">,</span>
							       <span class="s">&quot;PAP-12105: there is nothing to paste into L[0]. insert_size=%d&quot;</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span>
							       <span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
							<span class="n">ret_val</span> <span class="o">=</span>
							    <span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">lnum</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									    <span class="n">ih_item_len</span>
									    <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
									     <span class="p">(</span><span class="n">tbS0</span><span class="p">,</span>
									      <span class="n">item_pos</span><span class="p">)));</span>
							<span class="cm">/* Append to body of item in L[0] */</span>
							<span class="n">buffer_info_init_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
							<span class="n">leaf_paste_in_buffer</span>
							    <span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
							     <span class="n">n</span> <span class="o">+</span> <span class="n">item_pos</span> <span class="o">-</span>
							     <span class="n">ret_val</span><span class="p">,</span>
							     <span class="n">ih_item_len</span>
							     <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
							      <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							       <span class="n">n</span> <span class="o">+</span> <span class="n">item_pos</span> <span class="o">-</span>
							       <span class="n">ret_val</span><span class="p">)),</span> <span class="n">l_n</span><span class="p">,</span>
							     <span class="n">body</span><span class="p">,</span>
							     <span class="n">zeros_num</span> <span class="o">&gt;</span>
							     <span class="n">l_n</span> <span class="o">?</span> <span class="n">l_n</span> <span class="o">:</span>
							     <span class="n">zeros_num</span><span class="p">);</span>
							<span class="cm">/* 0-th item in S0 can be only of DIRECT type when l_n != 0 */</span>
							<span class="p">{</span>
								<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
								<span class="kt">int</span> <span class="n">temp_l</span> <span class="o">=</span>
								    <span class="n">l_n</span><span class="p">;</span>

								<span class="n">RFALSE</span>
								    <span class="p">(</span><span class="n">ih_item_len</span>
								     <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
								      <span class="p">(</span><span class="n">tbS0</span><span class="p">,</span>
								       <span class="mi">0</span><span class="p">)),</span>
								     <span class="s">&quot;PAP-12106: item length must be 0&quot;</span><span class="p">);</span>
								<span class="n">RFALSE</span>
								    <span class="p">(</span><span class="n">comp_short_le_keys</span>
								     <span class="p">(</span><span class="n">B_N_PKEY</span>
								      <span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
								      <span class="n">B_N_PKEY</span>
								      <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								       <span class="n">n</span> <span class="o">+</span>
								       <span class="n">item_pos</span>
								       <span class="o">-</span>
								       <span class="n">ret_val</span><span class="p">)),</span>
								     <span class="s">&quot;PAP-12107: items must be of the same file&quot;</span><span class="p">);</span>
								<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span> <span class="o">+</span> <span class="n">item_pos</span> <span class="o">-</span> <span class="n">ret_val</span><span class="p">)))</span> <span class="p">{</span>
									<span class="n">temp_l</span> <span class="o">=</span>
									    <span class="n">l_n</span>
									    <span class="o">&lt;&lt;</span>
									    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
									     <span class="n">tb_sb</span><span class="o">-&gt;</span>
									     <span class="n">s_blocksize_bits</span>
									     <span class="o">-</span>
									     <span class="n">UNFM_P_SHIFT</span><span class="p">);</span>
								<span class="p">}</span>
								<span class="cm">/* update key of first item in S0 */</span>
								<span class="n">version</span> <span class="o">=</span>
								    <span class="n">ih_version</span>
								    <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
								     <span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
								<span class="n">set_le_key_k_offset</span>
								    <span class="p">(</span><span class="n">version</span><span class="p">,</span>
								     <span class="n">B_N_PKEY</span>
								     <span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
								     <span class="n">le_key_k_offset</span>
								     <span class="p">(</span><span class="n">version</span><span class="p">,</span>
								      <span class="n">B_N_PKEY</span>
								      <span class="p">(</span><span class="n">tbS0</span><span class="p">,</span>
								       <span class="mi">0</span><span class="p">))</span> <span class="o">+</span>
								     <span class="n">temp_l</span><span class="p">);</span>
								<span class="cm">/* update left delimiting key */</span>
								<span class="n">set_le_key_k_offset</span>
								    <span class="p">(</span><span class="n">version</span><span class="p">,</span>
								     <span class="n">B_N_PDELIM_KEY</span>
								     <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
								      <span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								      <span class="n">tb</span><span class="o">-&gt;</span>
								      <span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
								     <span class="n">le_key_k_offset</span>
								     <span class="p">(</span><span class="n">version</span><span class="p">,</span>
								      <span class="n">B_N_PDELIM_KEY</span>
								      <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
								       <span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								       <span class="n">tb</span><span class="o">-&gt;</span>
								       <span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
								     <span class="o">+</span> <span class="n">temp_l</span><span class="p">);</span>
							<span class="p">}</span>

							<span class="cm">/* Calculate new body, position in item and insert_size[0] */</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">l_n</span> <span class="o">&gt;</span> <span class="n">zeros_num</span><span class="p">)</span> <span class="p">{</span>
								<span class="n">body</span> <span class="o">+=</span>
								    <span class="p">(</span><span class="n">l_n</span> <span class="o">-</span>
								     <span class="n">zeros_num</span><span class="p">);</span>
								<span class="n">zeros_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
							<span class="p">}</span> <span class="k">else</span>
								<span class="n">zeros_num</span> <span class="o">-=</span>
								    <span class="n">l_n</span><span class="p">;</span>
							<span class="n">pos_in_item</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

							<span class="n">RFALSE</span>
							    <span class="p">(</span><span class="n">comp_short_le_keys</span>
							     <span class="p">(</span><span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
							      <span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								       <span class="n">B_NR_ITEMS</span>
								       <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
									<span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span>
								       <span class="mi">1</span><span class="p">))</span>
							     <span class="o">||</span>
							     <span class="o">!</span><span class="n">op_is_left_mergeable</span>
							     <span class="p">(</span><span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
							      <span class="n">tbS0</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span>
							     <span class="o">||</span>
							     <span class="o">!</span><span class="n">op_is_left_mergeable</span>
							     <span class="p">(</span><span class="n">B_N_PDELIM_KEY</span>
							      <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
							      <span class="n">tbS0</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">),</span>
							     <span class="s">&quot;PAP-12120: item must be merge-able with left neighboring item&quot;</span><span class="p">);</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* only part of the appended item will be in L[0] */</span>

							<span class="cm">/* Calculate position in item for append in S[0] */</span>
							<span class="n">pos_in_item</span> <span class="o">-=</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">;</span>

							<span class="n">RFALSE</span><span class="p">(</span><span class="n">pos_in_item</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span>
							       <span class="s">&quot;PAP-12125: no place for paste. pos_in_item=%d&quot;</span><span class="p">,</span>
							       <span class="n">pos_in_item</span><span class="p">);</span>

							<span class="cm">/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */</span>
							<span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
									<span class="n">tb</span><span class="o">-&gt;</span>
									<span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									<span class="n">tb</span><span class="o">-&gt;</span>
									<span class="n">lbytes</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* appended item will be in L[0] in whole */</span>

					<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">pasted</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item_pos</span> <span class="o">&amp;&amp;</span> <span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">tbS0</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* if we paste into first item of S[0] and it is left mergable */</span>
						<span class="cm">/* then increment pos_in_item by the size of the last item in L[0] */</span>
						<span class="n">pasted</span> <span class="o">=</span>
						    <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								   <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span>
							<span class="n">pos_in_item</span> <span class="o">+=</span>
							    <span class="n">ih_entry_count</span>
							    <span class="p">(</span><span class="n">pasted</span><span class="p">);</span>
						<span class="k">else</span>
							<span class="n">pos_in_item</span> <span class="o">+=</span>
							    <span class="n">ih_item_len</span><span class="p">(</span><span class="n">pasted</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="cm">/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */</span>
					<span class="n">ret_val</span> <span class="o">=</span>
					    <span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">);</span>
					<span class="cm">/* Append to body of item in L[0] */</span>
					<span class="n">buffer_info_init_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
					<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
							     <span class="n">n</span> <span class="o">+</span> <span class="n">item_pos</span> <span class="o">-</span>
							     <span class="n">ret_val</span><span class="p">,</span>
							     <span class="n">pos_in_item</span><span class="p">,</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							     <span class="n">body</span><span class="p">,</span> <span class="n">zeros_num</span><span class="p">);</span>

					<span class="cm">/* if appended item is directory, paste entry */</span>
					<span class="n">pasted</span> <span class="o">=</span>
					    <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							   <span class="n">n</span> <span class="o">+</span> <span class="n">item_pos</span> <span class="o">-</span>
							   <span class="n">ret_val</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span>
						<span class="n">leaf_paste_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
								   <span class="n">n</span> <span class="o">+</span>
								   <span class="n">item_pos</span> <span class="o">-</span>
								   <span class="n">ret_val</span><span class="p">,</span>
								   <span class="n">pos_in_item</span><span class="p">,</span>
								   <span class="mi">1</span><span class="p">,</span>
								   <span class="p">(</span><span class="k">struct</span>
								    <span class="n">reiserfs_de_head</span>
								    <span class="o">*</span><span class="p">)</span><span class="n">body</span><span class="p">,</span>
								   <span class="n">body</span> <span class="o">+</span>
								   <span class="n">DEH_SIZE</span><span class="p">,</span>
								   <span class="n">tb</span><span class="o">-&gt;</span>
								   <span class="n">insert_size</span>
								   <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						    <span class="p">);</span>
					<span class="cm">/* if appended item is indirect item, put unformatted node into un list */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span>
						<span class="n">set_ih_free_space</span><span class="p">(</span><span class="n">pasted</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">zeros_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>	<span class="cm">/* cases d and t */</span>
				<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-12130&quot;</span><span class="p">,</span>
					       <span class="s">&quot;lnum &gt; 0: unexpected mode: &quot;</span>
					       <span class="s">&quot; %s(%d)&quot;</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">flag</span> <span class="o">==</span>
						<span class="n">M_DELETE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;DELETE&quot;</span> <span class="o">:</span> <span class="p">((</span><span class="n">flag</span> <span class="o">==</span>
									 <span class="n">M_CUT</span><span class="p">)</span>
									<span class="o">?</span> <span class="s">&quot;CUT&quot;</span>
									<span class="o">:</span>
									<span class="s">&quot;UNKNOWN&quot;</span><span class="p">),</span>
					       <span class="n">flag</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* new item doesn&#39;t fall into L[0] */</span>
			<span class="n">leaf_shift_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* tb-&gt;lnum[0] &gt; 0 */</span>
	<span class="cm">/* Calculate new item position */</span>
	<span class="n">item_pos</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* shift rnum[0] items from S[0] to the right neighbor R[0] */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbS0</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">M_INSERT</span>:	<span class="cm">/* insert item */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">item_pos</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* new item or its part falls to R[0] */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* part of new item falls into R[0] */</span>
					<span class="n">loff_t</span> <span class="n">old_key_comp</span><span class="p">,</span> <span class="n">old_len</span><span class="p">,</span>
					    <span class="n">r_zeros_number</span><span class="p">;</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">r_body</span><span class="p">;</span>
					<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
					<span class="n">loff_t</span> <span class="n">offset</span><span class="p">;</span>

					<span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
							 <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

					<span class="n">version</span> <span class="o">=</span> <span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
					<span class="cm">/* Remember key component and item length */</span>
					<span class="n">old_key_comp</span> <span class="o">=</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
					<span class="n">old_len</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

					<span class="cm">/* Calculate key component and item length to insert into R[0] */</span>
					<span class="n">offset</span> <span class="o">=</span>
					    <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
					    <span class="p">((</span><span class="n">old_len</span> <span class="o">-</span>
					      <span class="n">tb</span><span class="o">-&gt;</span>
					      <span class="n">rbytes</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span>
							  <span class="o">?</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="o">-&gt;</span>
							  <span class="n">s_blocksize_bits</span> <span class="o">-</span>
							  <span class="n">UNFM_P_SHIFT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
					<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
					<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>
					<span class="cm">/* Insert part of the item into R[0] */</span>
					<span class="n">buffer_info_init_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">old_len</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">zeros_num</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">r_zeros_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">r_body</span> <span class="o">=</span>
						    <span class="n">body</span> <span class="o">+</span> <span class="p">(</span><span class="n">old_len</span> <span class="o">-</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">)</span> <span class="o">-</span>
						    <span class="n">zeros_num</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">r_body</span> <span class="o">=</span> <span class="n">body</span><span class="p">;</span>
						<span class="n">r_zeros_number</span> <span class="o">=</span>
						    <span class="n">zeros_num</span> <span class="o">-</span> <span class="p">(</span><span class="n">old_len</span> <span class="o">-</span>
								 <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>
						<span class="n">zeros_num</span> <span class="o">-=</span> <span class="n">r_zeros_number</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">r_body</span><span class="p">,</span>
							     <span class="n">r_zeros_number</span><span class="p">);</span>

					<span class="cm">/* Replace right delimiting key by first key in R[0] */</span>
					<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

					<span class="cm">/* Calculate key component and item length to insert into S[0] */</span>
					<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">old_key_comp</span><span class="p">);</span>
					<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span>
							<span class="n">old_len</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>

					<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">;</span>

				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* whole new item falls into R[0] */</span>

					<span class="cm">/* Shift rnum[0]-1 items to R[0] */</span>
					<span class="n">ret_val</span> <span class="o">=</span>
					    <span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>
					<span class="cm">/* Insert new item into R[0] */</span>
					<span class="n">buffer_info_init_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
					<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
							     <span class="n">item_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
							     <span class="n">ih</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span>
							     <span class="n">zeros_num</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

					<span class="p">}</span>
					<span class="n">zeros_num</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* new item or part of it doesn&#39;t fall into R[0] */</span>

				<span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">M_PASTE</span>:	<span class="cm">/* append item */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">item_pos</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* pasted item or part of it falls to R[0] */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* we must shift the part of the appended item */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">)))</span> <span class="p">{</span>	<span class="cm">/* we append to directory item */</span>
						<span class="kt">int</span> <span class="n">entry_count</span><span class="p">;</span>

						<span class="n">RFALSE</span><span class="p">(</span><span class="n">zeros_num</span><span class="p">,</span>
						       <span class="s">&quot;PAP-12145: invalid parameter in case of a directory&quot;</span><span class="p">);</span>
						<span class="n">entry_count</span> <span class="o">=</span>
						    <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
								  <span class="p">(</span><span class="n">tbS0</span><span class="p">,</span>
								   <span class="n">item_pos</span><span class="p">));</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">entry_count</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">&lt;</span>
						    <span class="n">pos_in_item</span><span class="p">)</span>
							<span class="cm">/* new directory entry falls into R[0] */</span>
						<span class="p">{</span>
							<span class="kt">int</span> <span class="n">paste_entry_position</span><span class="p">;</span>

							<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span>
							       <span class="n">entry_count</span>
							       <span class="o">||</span> <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span>
							       <span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							       <span class="s">&quot;PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d&quot;</span><span class="p">,</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">,</span>
							       <span class="n">entry_count</span><span class="p">);</span>
							<span class="cm">/* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */</span>
							<span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
									 <span class="n">tb</span><span class="o">-&gt;</span>
									 <span class="n">rnum</span>
									 <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									 <span class="n">tb</span><span class="o">-&gt;</span>
									 <span class="n">rbytes</span>
									 <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
							<span class="cm">/* Paste given directory entry to directory item */</span>
							<span class="n">paste_entry_position</span> <span class="o">=</span>
							    <span class="n">pos_in_item</span> <span class="o">-</span>
							    <span class="n">entry_count</span> <span class="o">+</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
							<span class="n">buffer_info_init_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
							<span class="n">leaf_paste_in_buffer</span>
							    <span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							     <span class="n">paste_entry_position</span><span class="p">,</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							     <span class="n">body</span><span class="p">,</span> <span class="n">zeros_num</span><span class="p">);</span>
							<span class="cm">/* paste entry */</span>
							<span class="n">leaf_paste_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
									   <span class="mi">0</span><span class="p">,</span>
									   <span class="n">paste_entry_position</span><span class="p">,</span>
									   <span class="mi">1</span><span class="p">,</span>
									   <span class="p">(</span><span class="k">struct</span>
									    <span class="n">reiserfs_de_head</span>
									    <span class="o">*</span><span class="p">)</span>
									   <span class="n">body</span><span class="p">,</span>
									   <span class="n">body</span>
									   <span class="o">+</span>
									   <span class="n">DEH_SIZE</span><span class="p">,</span>
									   <span class="n">tb</span><span class="o">-&gt;</span>
									   <span class="n">insert_size</span>
									   <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
							    <span class="p">);</span>

							<span class="k">if</span> <span class="p">(</span><span class="n">paste_entry_position</span>
							    <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
								<span class="cm">/* change delimiting keys */</span>
								<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">CFR</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">rkey</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">R</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									    <span class="mi">0</span><span class="p">);</span>
							<span class="p">}</span>

							<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
							<span class="n">pos_in_item</span><span class="o">++</span><span class="p">;</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* new directory entry doesn&#39;t fall into R[0] */</span>

							<span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
									 <span class="n">tb</span><span class="o">-&gt;</span>
									 <span class="n">rnum</span>
									 <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									 <span class="n">tb</span><span class="o">-&gt;</span>
									 <span class="n">rbytes</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* regular object */</span>

						<span class="kt">int</span> <span class="n">n_shift</span><span class="p">,</span> <span class="n">n_rem</span><span class="p">,</span>
						    <span class="n">r_zeros_number</span><span class="p">;</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">r_body</span><span class="p">;</span>

						<span class="cm">/* Calculate number of bytes which must be shifted from appended item */</span>
						<span class="k">if</span> <span class="p">((</span><span class="n">n_shift</span> <span class="o">=</span>
						     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span> <span class="o">-</span>
						     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
							<span class="n">n_shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

						<span class="n">RFALSE</span><span class="p">(</span><span class="n">pos_in_item</span> <span class="o">!=</span>
						       <span class="n">ih_item_len</span>
						       <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
							<span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">)),</span>
						       <span class="s">&quot;PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d&quot;</span><span class="p">,</span>
						       <span class="n">pos_in_item</span><span class="p">,</span>
						       <span class="n">ih_item_len</span>
						       <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
							<span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">)));</span>

						<span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
								 <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								 <span class="n">n_shift</span><span class="p">);</span>
						<span class="cm">/* Calculate number of bytes which must remain in body after appending to R[0] */</span>
						<span class="k">if</span> <span class="p">((</span><span class="n">n_rem</span> <span class="o">=</span>
						     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
						     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
							<span class="n">n_rem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

						<span class="p">{</span>
							<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
							<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">temp_rem</span> <span class="o">=</span>
							    <span class="n">n_rem</span><span class="p">;</span>

							<span class="n">version</span> <span class="o">=</span>
							    <span class="n">ih_version</span>
							    <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
							     <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">));</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_key</span>
							    <span class="p">(</span><span class="n">version</span><span class="p">,</span>
							     <span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								      <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
								<span class="n">temp_rem</span> <span class="o">=</span>
								    <span class="n">n_rem</span> <span class="o">&lt;&lt;</span>
								    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="o">-&gt;</span>
								     <span class="n">s_blocksize_bits</span>
								     <span class="o">-</span>
								     <span class="n">UNFM_P_SHIFT</span><span class="p">);</span>
							<span class="p">}</span>
							<span class="n">set_le_key_k_offset</span>
							    <span class="p">(</span><span class="n">version</span><span class="p">,</span>
							     <span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								      <span class="mi">0</span><span class="p">),</span>
							     <span class="n">le_key_k_offset</span>
							     <span class="p">(</span><span class="n">version</span><span class="p">,</span>
							      <span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								       <span class="mi">0</span><span class="p">))</span> <span class="o">+</span>
							     <span class="n">temp_rem</span><span class="p">);</span>
							<span class="n">set_le_key_k_offset</span>
							    <span class="p">(</span><span class="n">version</span><span class="p">,</span>
							     <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">CFR</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">rkey</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
							     <span class="n">le_key_k_offset</span>
							     <span class="p">(</span><span class="n">version</span><span class="p">,</span>
							      <span class="n">B_N_PDELIM_KEY</span>
							      <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span>
							     <span class="n">temp_rem</span><span class="p">);</span>
						<span class="p">}</span>
<span class="cm">/*		  k_offset (B_N_PKEY(tb-&gt;R[0],0)) += n_rem;</span>
<span class="cm">		  k_offset (B_N_PDELIM_KEY(tb-&gt;CFR[0],tb-&gt;rkey[0])) += n_rem;*/</span>
						<span class="n">do_balance_mark_internal_dirty</span>
						    <span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

						<span class="cm">/* Append part of body into R[0] */</span>
						<span class="n">buffer_info_init_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">n_rem</span> <span class="o">&gt;</span> <span class="n">zeros_num</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">r_zeros_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
							<span class="n">r_body</span> <span class="o">=</span>
							    <span class="n">body</span> <span class="o">+</span> <span class="n">n_rem</span> <span class="o">-</span>
							    <span class="n">zeros_num</span><span class="p">;</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="n">r_body</span> <span class="o">=</span> <span class="n">body</span><span class="p">;</span>
							<span class="n">r_zeros_number</span> <span class="o">=</span>
							    <span class="n">zeros_num</span> <span class="o">-</span> <span class="n">n_rem</span><span class="p">;</span>
							<span class="n">zeros_num</span> <span class="o">-=</span>
							    <span class="n">r_zeros_number</span><span class="p">;</span>
						<span class="p">}</span>

						<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
								     <span class="n">n_shift</span><span class="p">,</span>
								     <span class="n">tb</span><span class="o">-&gt;</span>
								     <span class="n">insert_size</span>
								     <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
								     <span class="n">n_rem</span><span class="p">,</span>
								     <span class="n">r_body</span><span class="p">,</span>
								     <span class="n">r_zeros_number</span><span class="p">);</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span>
						    <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
						     <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">							RFALSE(n_rem,</span>
<span class="c">							       &quot;PAP-12160: paste more than one unformatted node pointer&quot;);</span>
<span class="cp">#endif</span>
							<span class="n">set_ih_free_space</span>
							    <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
							     <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
						<span class="p">}</span>
						<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_rem</span><span class="p">;</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_rem</span><span class="p">)</span>
							<span class="n">pos_in_item</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* pasted item in whole falls into R[0] */</span>

					<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">pasted</span><span class="p">;</span>

					<span class="n">ret_val</span> <span class="o">=</span>
					    <span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>
					<span class="cm">/* append item in R[0] */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_item</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">buffer_info_init_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
						<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
								     <span class="n">item_pos</span> <span class="o">-</span>
								     <span class="n">n</span> <span class="o">+</span>
								     <span class="n">tb</span><span class="o">-&gt;</span>
								     <span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								     <span class="n">pos_in_item</span><span class="p">,</span>
								     <span class="n">tb</span><span class="o">-&gt;</span>
								     <span class="n">insert_size</span>
								     <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">body</span><span class="p">,</span>
								     <span class="n">zeros_num</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="cm">/* paste new entry, if item is directory item */</span>
					<span class="n">pasted</span> <span class="o">=</span>
					    <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							   <span class="n">item_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span>
							   <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">)</span>
					    <span class="o">&amp;&amp;</span> <span class="n">pos_in_item</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">leaf_paste_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
								   <span class="n">item_pos</span> <span class="o">-</span>
								   <span class="n">n</span> <span class="o">+</span>
								   <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								   <span class="n">pos_in_item</span><span class="p">,</span>
								   <span class="mi">1</span><span class="p">,</span>
								   <span class="p">(</span><span class="k">struct</span>
								    <span class="n">reiserfs_de_head</span>
								    <span class="o">*</span><span class="p">)</span><span class="n">body</span><span class="p">,</span>
								   <span class="n">body</span> <span class="o">+</span>
								   <span class="n">DEH_SIZE</span><span class="p">,</span>
								   <span class="n">tb</span><span class="o">-&gt;</span>
								   <span class="n">insert_size</span>
								   <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						    <span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos_in_item</span><span class="p">)</span> <span class="p">{</span>

							<span class="n">RFALSE</span><span class="p">(</span><span class="n">item_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span>
							       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							       <span class="s">&quot;PAP-12165: directory item must be first item of node when pasting is in 0th position&quot;</span><span class="p">);</span>

							<span class="cm">/* update delimiting keys */</span>
							<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
								    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
								    <span class="mi">0</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span>
						<span class="n">set_ih_free_space</span><span class="p">(</span><span class="n">pasted</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">zeros_num</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* new item doesn&#39;t fall into R[0] */</span>

				<span class="n">leaf_shift_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>	<span class="cm">/* cases d and t */</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-12175&quot;</span><span class="p">,</span>
				       <span class="s">&quot;rnum &gt; 0: unexpected mode: %s(%d)&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">flag</span> <span class="o">==</span>
					<span class="n">M_DELETE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;DELETE&quot;</span> <span class="o">:</span> <span class="p">((</span><span class="n">flag</span> <span class="o">==</span>
								 <span class="n">M_CUT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;CUT&quot;</span>
								<span class="o">:</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">),</span>
				       <span class="n">flag</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="cm">/* tb-&gt;rnum[0] &gt; 0 */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span>
	       <span class="s">&quot;PAP-12180: blknum can not be %d. It must be &lt;= 3&quot;</span><span class="p">,</span>
	       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="s">&quot;PAP-12185: blknum can not be %d. It must be &gt;= 0&quot;</span><span class="p">,</span>
	       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* if while adding to a node we discover that it is possible to split</span>
<span class="cm">	   it in two, and merge the left part into the left neighbor and the</span>
<span class="cm">	   right part into the right neighbor, eliminating the node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* node S[0] is empty now */</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="s">&quot;PAP-12190: lnum and rnum must not be zero&quot;</span><span class="p">);</span>
		<span class="cm">/* if insertion was done before 0-th position in R[0], right</span>
<span class="cm">		   delimiting key of the tb-&gt;L[0]&#39;s and left delimiting key are</span>
<span class="cm">		   not set correctly */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-12195&quot;</span><span class="p">,</span>
					       <span class="s">&quot;CFR not initialized&quot;</span><span class="p">);</span>
			<span class="n">copy_key</span><span class="p">(</span><span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				 <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbS0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill new nodes that appear in place of S[0] */</span>

	<span class="cm">/* I am told that this copying is because we need an array to enable</span>
<span class="cm">	   the looping code. -Hans */</span>
	<span class="n">snum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">s1num</span><span class="p">,</span> <span class="n">snum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">s2num</span><span class="p">;</span>
	<span class="n">sbytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">s1bytes</span><span class="p">;</span>
	<span class="n">sbytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">s2bytes</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;PAP-12200: snum[%d] == %d. Must be &gt; 0&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
		       <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/* here we shift from S to S_new nodes */</span>

		<span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_FEB</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>

		<span class="cm">/* initialized block type and tree level */</span>
		<span class="n">set_blkh_level</span><span class="p">(</span><span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">DISK_LEAF_NODE_LEVEL</span><span class="p">);</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbS0</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">M_INSERT</span>:	<span class="cm">/* insert item */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">item_pos</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* new item or it&#39;s part falls to first new node S_new[i] */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* part of new item falls into S_new[i] */</span>
					<span class="kt">int</span> <span class="n">old_key_comp</span><span class="p">,</span> <span class="n">old_len</span><span class="p">,</span>
					    <span class="n">r_zeros_number</span><span class="p">;</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">r_body</span><span class="p">;</span>
					<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>

					<span class="cm">/* Move snum[i]-1 items from S[0] to S_new[i] */</span>
					<span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_SNEW</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span>
							<span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
							<span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="cm">/* Remember key component and item length */</span>
					<span class="n">version</span> <span class="o">=</span> <span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
					<span class="n">old_key_comp</span> <span class="o">=</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
					<span class="n">old_len</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

					<span class="cm">/* Calculate key component and item length to insert into S_new[i] */</span>
					<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span>
							   <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
							   <span class="p">((</span><span class="n">old_len</span> <span class="o">-</span>
							     <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span>
							    <span class="p">(</span><span class="n">is_indirect_le_ih</span>
							     <span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">?</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="o">-&gt;</span>
							     <span class="n">s_blocksize_bits</span> <span class="o">-</span>
							     <span class="n">UNFM_P_SHIFT</span> <span class="o">:</span>
							     <span class="mi">0</span><span class="p">)));</span>

					<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

					<span class="cm">/* Insert part of the item into S_new[i] before 0-th item */</span>
					<span class="n">buffer_info_init_bh</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

					<span class="k">if</span> <span class="p">((</span><span class="n">old_len</span> <span class="o">-</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">zeros_num</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">r_zeros_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">r_body</span> <span class="o">=</span>
						    <span class="n">body</span> <span class="o">+</span> <span class="p">(</span><span class="n">old_len</span> <span class="o">-</span>
							    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span>
						    <span class="n">zeros_num</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">r_body</span> <span class="o">=</span> <span class="n">body</span><span class="p">;</span>
						<span class="n">r_zeros_number</span> <span class="o">=</span>
						    <span class="n">zeros_num</span> <span class="o">-</span> <span class="p">(</span><span class="n">old_len</span> <span class="o">-</span>
								 <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
						<span class="n">zeros_num</span> <span class="o">-=</span> <span class="n">r_zeros_number</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">r_body</span><span class="p">,</span>
							     <span class="n">r_zeros_number</span><span class="p">);</span>

					<span class="cm">/* Calculate key component and item length to insert into S[i] */</span>
					<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">old_key_comp</span><span class="p">);</span>
					<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span>
							<span class="n">old_len</span> <span class="o">-</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* whole new item falls into S_new[i] */</span>

					<span class="cm">/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */</span>
					<span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_SNEW</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span>
							<span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							<span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

					<span class="cm">/* Insert new item into S_new[i] */</span>
					<span class="n">buffer_info_init_bh</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
							     <span class="n">item_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span>
							     <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span>
							     <span class="n">body</span><span class="p">,</span> <span class="n">zeros_num</span><span class="p">);</span>

					<span class="n">zeros_num</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">else</span> <span class="p">{</span>	<span class="cm">/* new item or it part don&#39;t falls into S_new[i] */</span>

				<span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_SNEW</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span>
						<span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">M_PASTE</span>:	<span class="cm">/* append item */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">item_pos</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* pasted item or part if it falls to S_new[i] */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* we must shift part of the appended item */</span>
					<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">aux_ih</span><span class="p">;</span>

					<span class="n">RFALSE</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="s">&quot;PAP-12210: ih must be 0&quot;</span><span class="p">);</span>

					<span class="n">aux_ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">aux_ih</span><span class="p">))</span> <span class="p">{</span>
						<span class="cm">/* we append to directory item */</span>

						<span class="kt">int</span> <span class="n">entry_count</span><span class="p">;</span>

						<span class="n">entry_count</span> <span class="o">=</span>
						    <span class="n">ih_entry_count</span><span class="p">(</span><span class="n">aux_ih</span><span class="p">);</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">entry_count</span> <span class="o">-</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span>
						    <span class="n">pos_in_item</span>
						    <span class="o">&amp;&amp;</span> <span class="n">pos_in_item</span> <span class="o">&lt;=</span>
						    <span class="n">entry_count</span><span class="p">)</span> <span class="p">{</span>
							<span class="cm">/* new directory entry falls into S_new[i] */</span>

							<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span>
							       <span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							       <span class="s">&quot;PAP-12215: insert_size is already 0&quot;</span><span class="p">);</span>
							<span class="n">RFALSE</span><span class="p">(</span><span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span>
							       <span class="n">entry_count</span><span class="p">,</span>
							       <span class="s">&quot;PAP-12220: there are no so much entries (%d), only %d&quot;</span><span class="p">,</span>
							       <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
							       <span class="n">entry_count</span><span class="p">);</span>

							<span class="cm">/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */</span>
							<span class="n">leaf_move_items</span>
							    <span class="p">(</span><span class="n">LEAF_FROM_S_TO_SNEW</span><span class="p">,</span>
							     <span class="n">tb</span><span class="p">,</span> <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							     <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
							     <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
							<span class="cm">/* Paste given directory entry to directory item */</span>
							<span class="n">buffer_info_init_bh</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
							<span class="n">leaf_paste_in_buffer</span>
							    <span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							     <span class="n">pos_in_item</span> <span class="o">-</span>
							     <span class="n">entry_count</span> <span class="o">+</span>
							     <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							     <span class="n">body</span><span class="p">,</span> <span class="n">zeros_num</span><span class="p">);</span>
							<span class="cm">/* paste new directory entry */</span>
							<span class="n">leaf_paste_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
									   <span class="mi">0</span><span class="p">,</span>
									   <span class="n">pos_in_item</span>
									   <span class="o">-</span>
									   <span class="n">entry_count</span>
									   <span class="o">+</span>
									   <span class="n">sbytes</span>
									   <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
									   <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
									   <span class="p">(</span><span class="k">struct</span>
									    <span class="n">reiserfs_de_head</span>
									    <span class="o">*</span><span class="p">)</span>
									   <span class="n">body</span><span class="p">,</span>
									   <span class="n">body</span>
									   <span class="o">+</span>
									   <span class="n">DEH_SIZE</span><span class="p">,</span>
									   <span class="n">tb</span><span class="o">-&gt;</span>
									   <span class="n">insert_size</span>
									   <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
							    <span class="p">);</span>
							<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
							<span class="n">pos_in_item</span><span class="o">++</span><span class="p">;</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* new directory entry doesn&#39;t fall into S_new[i] */</span>
							<span class="n">leaf_move_items</span>
							    <span class="p">(</span><span class="n">LEAF_FROM_S_TO_SNEW</span><span class="p">,</span>
							     <span class="n">tb</span><span class="p">,</span> <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							     <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							     <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
						<span class="p">}</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* regular object */</span>

						<span class="kt">int</span> <span class="n">n_shift</span><span class="p">,</span> <span class="n">n_rem</span><span class="p">,</span>
						    <span class="n">r_zeros_number</span><span class="p">;</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">r_body</span><span class="p">;</span>

						<span class="n">RFALSE</span><span class="p">(</span><span class="n">pos_in_item</span> <span class="o">!=</span>
						       <span class="n">ih_item_len</span>
						       <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
							<span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">))</span>
						       <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span>
						       <span class="mi">0</span><span class="p">,</span>
						       <span class="s">&quot;PAP-12225: item too short or insert_size &lt;= 0&quot;</span><span class="p">);</span>

						<span class="cm">/* Calculate number of bytes which must be shifted from appended item */</span>
						<span class="n">n_shift</span> <span class="o">=</span>
						    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
						    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">n_shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
							<span class="n">n_shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">leaf_move_items</span>
						    <span class="p">(</span><span class="n">LEAF_FROM_S_TO_SNEW</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span>
						     <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n_shift</span><span class="p">,</span>
						     <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

						<span class="cm">/* Calculate number of bytes which must remain in body after append to S_new[i] */</span>
						<span class="n">n_rem</span> <span class="o">=</span>
						    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
						    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">n_rem</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
							<span class="n">n_rem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="cm">/* Append part of body into S_new[0] */</span>
						<span class="n">buffer_info_init_bh</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">n_rem</span> <span class="o">&gt;</span> <span class="n">zeros_num</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">r_zeros_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
							<span class="n">r_body</span> <span class="o">=</span>
							    <span class="n">body</span> <span class="o">+</span> <span class="n">n_rem</span> <span class="o">-</span>
							    <span class="n">zeros_num</span><span class="p">;</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="n">r_body</span> <span class="o">=</span> <span class="n">body</span><span class="p">;</span>
							<span class="n">r_zeros_number</span> <span class="o">=</span>
							    <span class="n">zeros_num</span> <span class="o">-</span> <span class="n">n_rem</span><span class="p">;</span>
							<span class="n">zeros_num</span> <span class="o">-=</span>
							    <span class="n">r_zeros_number</span><span class="p">;</span>
						<span class="p">}</span>

						<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
								     <span class="n">n_shift</span><span class="p">,</span>
								     <span class="n">tb</span><span class="o">-&gt;</span>
								     <span class="n">insert_size</span>
								     <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
								     <span class="n">n_rem</span><span class="p">,</span>
								     <span class="n">r_body</span><span class="p">,</span>
								     <span class="n">r_zeros_number</span><span class="p">);</span>
						<span class="p">{</span>
							<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

							<span class="n">tmp</span> <span class="o">=</span>
							    <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">S_new</span>
									   <span class="p">[</span><span class="n">i</span><span class="p">],</span>
									   <span class="mi">0</span><span class="p">);</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span>
							    <span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
								<span class="n">set_ih_free_space</span>
								    <span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
								<span class="n">set_le_ih_k_offset</span>
								    <span class="p">(</span><span class="n">tmp</span><span class="p">,</span>
								     <span class="n">le_ih_k_offset</span>
								     <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span>
								     <span class="p">(</span><span class="n">n_rem</span> <span class="o">&lt;&lt;</span>
								      <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
								       <span class="n">tb_sb</span><span class="o">-&gt;</span>
								       <span class="n">s_blocksize_bits</span>
								       <span class="o">-</span>
								       <span class="n">UNFM_P_SHIFT</span><span class="p">)));</span>
							<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
								<span class="n">set_le_ih_k_offset</span>
								    <span class="p">(</span><span class="n">tmp</span><span class="p">,</span>
								     <span class="n">le_ih_k_offset</span>
								     <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span>
								     <span class="n">n_rem</span><span class="p">);</span>
							<span class="p">}</span>
						<span class="p">}</span>

						<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_rem</span><span class="p">;</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_rem</span><span class="p">)</span>
							<span class="n">pos_in_item</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="cm">/* item falls wholly into S_new[i] */</span>
				<span class="p">{</span>
					<span class="kt">int</span> <span class="n">leaf_mi</span><span class="p">;</span>
					<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">pasted</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
					<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih_check</span> <span class="o">=</span>
					    <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih_check</span><span class="p">)</span>
					    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pos_in_item</span> <span class="o">!=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih_check</span><span class="p">)</span>
						<span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
						<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
							     <span class="s">&quot;PAP-12235&quot;</span><span class="p">,</span>
							     <span class="s">&quot;pos_in_item &quot;</span>
							     <span class="s">&quot;must be equal &quot;</span>
							     <span class="s">&quot;to ih_item_len&quot;</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_REISERFS_CHECK */</span><span class="cp"></span>

					<span class="n">leaf_mi</span> <span class="o">=</span>
					    <span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_SNEW</span><span class="p">,</span>
							    <span class="n">tb</span><span class="p">,</span> <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							    <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

					<span class="n">RFALSE</span><span class="p">(</span><span class="n">leaf_mi</span><span class="p">,</span>
					       <span class="s">&quot;PAP-12240: unexpected value returned by leaf_move_items (%d)&quot;</span><span class="p">,</span>
					       <span class="n">leaf_mi</span><span class="p">);</span>

					<span class="cm">/* paste into item */</span>
					<span class="n">buffer_info_init_bh</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
							     <span class="n">item_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span>
							     <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							     <span class="n">pos_in_item</span><span class="p">,</span>
							     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							     <span class="n">body</span><span class="p">,</span> <span class="n">zeros_num</span><span class="p">);</span>

					<span class="n">pasted</span> <span class="o">=</span>
					    <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							   <span class="n">item_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span>
							   <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">leaf_paste_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
								   <span class="n">item_pos</span> <span class="o">-</span>
								   <span class="n">n</span> <span class="o">+</span> <span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
								   <span class="n">pos_in_item</span><span class="p">,</span>
								   <span class="mi">1</span><span class="p">,</span>
								   <span class="p">(</span><span class="k">struct</span>
								    <span class="n">reiserfs_de_head</span>
								    <span class="o">*</span><span class="p">)</span><span class="n">body</span><span class="p">,</span>
								   <span class="n">body</span> <span class="o">+</span>
								   <span class="n">DEH_SIZE</span><span class="p">,</span>
								   <span class="n">tb</span><span class="o">-&gt;</span>
								   <span class="n">insert_size</span>
								   <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						    <span class="p">);</span>
					<span class="p">}</span>

					<span class="cm">/* if we paste to indirect item update ih_free_space */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span>
						<span class="n">set_ih_free_space</span><span class="p">(</span><span class="n">pasted</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">zeros_num</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">else</span> <span class="p">{</span>	<span class="cm">/* pasted item doesn&#39;t fall into S_new[i] */</span>

				<span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_SNEW</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span>
						<span class="n">snum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>	<span class="cm">/* cases d and t */</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-12245&quot;</span><span class="p">,</span>
				       <span class="s">&quot;blknum &gt; 2: unexpected mode: %s(%d)&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">flag</span> <span class="o">==</span>
					<span class="n">M_DELETE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;DELETE&quot;</span> <span class="o">:</span> <span class="p">((</span><span class="n">flag</span> <span class="o">==</span>
								 <span class="n">M_CUT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;CUT&quot;</span>
								<span class="o">:</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">),</span>
				       <span class="n">flag</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">insert_key</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
		<span class="n">insert_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		       <span class="o">||</span> <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		       <span class="o">||</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s">&quot;PAP-12247: S_new[%d] : (%b)&quot;</span><span class="p">,</span>
		       <span class="n">i</span><span class="p">,</span> <span class="n">S_new</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the</span>
<span class="cm">	   affected item which remains in S */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">item_pos</span> <span class="o">&amp;&amp;</span> <span class="n">item_pos</span> <span class="o">&lt;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">s0num</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* if we must insert or append into buffer S[0] */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">M_INSERT</span>:	<span class="cm">/* insert item into S[0] */</span>
			<span class="n">buffer_info_init_tbS0</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
			<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span>
					     <span class="n">zeros_num</span><span class="p">);</span>

			<span class="cm">/* If we insert the first key change the delimiting key */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">item_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>	<span class="cm">/* can be 0 in reiserfsck */</span>
					<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						    <span class="n">tbS0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">M_PASTE</span>:<span class="p">{</span>	<span class="cm">/* append item in S[0] */</span>
				<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">pasted</span><span class="p">;</span>

				<span class="n">pasted</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">tbS0</span><span class="p">,</span> <span class="n">item_pos</span><span class="p">);</span>
				<span class="cm">/* when directory, may be new entry already pasted */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_item</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
					    <span class="n">pos_in_item</span> <span class="o">&lt;=</span>
					    <span class="n">ih_entry_count</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span> <span class="p">{</span>

						<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						       <span class="s">&quot;PAP-12260: insert_size is 0 already&quot;</span><span class="p">);</span>

						<span class="cm">/* prepare space */</span>
						<span class="n">buffer_info_init_tbS0</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
						<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
								     <span class="n">item_pos</span><span class="p">,</span>
								     <span class="n">pos_in_item</span><span class="p">,</span>
								     <span class="n">tb</span><span class="o">-&gt;</span>
								     <span class="n">insert_size</span>
								     <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">body</span><span class="p">,</span>
								     <span class="n">zeros_num</span><span class="p">);</span>

						<span class="cm">/* paste entry */</span>
						<span class="n">leaf_paste_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
								   <span class="n">item_pos</span><span class="p">,</span>
								   <span class="n">pos_in_item</span><span class="p">,</span>
								   <span class="mi">1</span><span class="p">,</span>
								   <span class="p">(</span><span class="k">struct</span>
								    <span class="n">reiserfs_de_head</span>
								    <span class="o">*</span><span class="p">)</span><span class="n">body</span><span class="p">,</span>
								   <span class="n">body</span> <span class="o">+</span>
								   <span class="n">DEH_SIZE</span><span class="p">,</span>
								   <span class="n">tb</span><span class="o">-&gt;</span>
								   <span class="n">insert_size</span>
								   <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						    <span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item_pos</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pos_in_item</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
							       <span class="o">||</span> <span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							       <span class="s">&quot;PAP-12270: CFL[0]/L[0] must be specified&quot;</span><span class="p">);</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
								<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">CFL</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									    <span class="n">tb</span><span class="o">-&gt;</span>
									    <span class="n">lkey</span>
									    <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
									    <span class="n">tbS0</span><span class="p">,</span>
									    <span class="mi">0</span><span class="p">);</span>

							<span class="p">}</span>
						<span class="p">}</span>
						<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* regular object */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_item</span> <span class="o">==</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span> <span class="p">{</span>

						<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span>
						       <span class="s">&quot;PAP-12275: insert size must not be %d&quot;</span><span class="p">,</span>
						       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
						<span class="n">buffer_info_init_tbS0</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
						<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
								     <span class="n">item_pos</span><span class="p">,</span>
								     <span class="n">pos_in_item</span><span class="p">,</span>
								     <span class="n">tb</span><span class="o">-&gt;</span>
								     <span class="n">insert_size</span>
								     <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">body</span><span class="p">,</span>
								     <span class="n">zeros_num</span><span class="p">);</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">pasted</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">							RFALSE(tb-&gt;</span>
<span class="c">							       insert_size[0] !=</span>
<span class="c">							       UNFM_P_SIZE,</span>
<span class="c">							       &quot;PAP-12280: insert_size for indirect item must be %d, not %d&quot;,</span>
<span class="c">							       UNFM_P_SIZE,</span>
<span class="c">							       tb-&gt;</span>
<span class="c">							       insert_size[0]);</span>
<span class="cp">#endif</span>
							<span class="n">set_ih_free_space</span>
							    <span class="p">(</span><span class="n">pasted</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
						<span class="p">}</span>
						<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
					<span class="k">else</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
							<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;12285&quot;</span><span class="p">);</span>
							<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span>
								       <span class="n">tb_sb</span><span class="p">,</span>
							    <span class="s">&quot;PAP-12285&quot;</span><span class="p">,</span>
							    <span class="s">&quot;insert_size &quot;</span>
							    <span class="s">&quot;must be 0 &quot;</span>
							    <span class="s">&quot;(%d)&quot;</span><span class="p">,</span>
							    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
						<span class="p">}</span>
					<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_REISERFS_CHECK */</span><span class="cp"></span>

				<span class="p">}</span>
			<span class="p">}</span>	<span class="cm">/* case M_PASTE: */</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">M_PASTE</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;12290&quot;</span><span class="p">);</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
			       <span class="s">&quot;PAP-12290&quot;</span><span class="p">,</span> <span class="s">&quot;insert_size is still not 0 (%d)&quot;</span><span class="p">,</span>
			       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_REISERFS_CHECK */</span><span class="cp"></span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>				<span class="cm">/* Leaf level of the tree is balanced (end of balance_leaf) */</span>

<span class="cm">/* Make empty node */</span>
<span class="kt">void</span> <span class="nf">make_empty_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;PAP-12295: pointer to the buffer is NULL&quot;</span><span class="p">);</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">);</span>
	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span>
		<span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Endian safe if 0 */</span>
<span class="p">}</span>

<span class="cm">/* Get first empty buffer */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">get_FEB</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">bi</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_FEB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_FEB_SIZE</span><span class="p">)</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-12300&quot;</span><span class="p">,</span> <span class="s">&quot;FEB list is empty&quot;</span><span class="p">);</span>

	<span class="n">buffer_info_init_bh</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">make_empty_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">FEB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* This is now used because reiserfs_free_block has to be able to</span>
<span class="cm">** schedule.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">store_thrown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-12320&quot;</span><span class="p">,</span>
				 <span class="s">&quot;called with dirty buffer&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">thrown</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">thrown</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">thrown</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>	<span class="cm">/* free_thrown puts this */</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-12321&quot;</span><span class="p">,</span>
			 <span class="s">&quot;too many thrown buffers&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_thrown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">thrown</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">thrown</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">blocknr</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">thrown</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">thrown</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
				<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-12322&quot;</span><span class="p">,</span>
						 <span class="s">&quot;called with dirty buffer %d&quot;</span><span class="p">,</span>
						 <span class="n">blocknr</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">thrown</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>	<span class="cm">/* incremented in store_thrown */</span>
			<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">transaction_handle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					    <span class="n">blocknr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">set_blkh_level</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">FREE_LEVEL</span><span class="p">);</span>
	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">store_thrown</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Replace n_dest&#39;th key in buffer dest by n_src&#39;th key of buffer src.*/</span>
<span class="kt">void</span> <span class="nf">replace_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_dest</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_src</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">dest</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">src</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
	       <span class="s">&quot;vs-12305: source or destination buffer is 0 (src=%p, dest=%p)&quot;</span><span class="p">,</span>
	       <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">B_IS_KEYS_LEVEL</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span>
	       <span class="s">&quot;vs-12310: invalid level (%z) for destination buffer. dest must be leaf&quot;</span><span class="p">,</span>
	       <span class="n">dest</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">n_dest</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n_src</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="s">&quot;vs-12315: src(%d) or dest(%d) key number &lt; 0&quot;</span><span class="p">,</span> <span class="n">n_src</span><span class="p">,</span> <span class="n">n_dest</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">n_dest</span> <span class="o">&gt;=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">||</span> <span class="n">n_src</span> <span class="o">&gt;=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">),</span>
	       <span class="s">&quot;vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big&quot;</span><span class="p">,</span>
	       <span class="n">n_src</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">n_dest</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">B_IS_ITEMS_LEVEL</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
		<span class="cm">/* source buffer contains leaf node */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">n_dest</span><span class="p">),</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">n_src</span><span class="p">),</span>
		       <span class="n">KEY_SIZE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">n_dest</span><span class="p">),</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">n_src</span><span class="p">),</span>
		       <span class="n">KEY_SIZE</span><span class="p">);</span>

	<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_left_neighbor_position</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">Sh_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
	       <span class="s">&quot;vs-12325: FL[%d](%p) or F[%d](%p) does not exist&quot;</span><span class="p">,</span>
	       <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">Sh_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">Sh_position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_right_neighbor_position</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">Sh_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
	       <span class="s">&quot;vs-12330: F[%d](%p) or FR[%d](%p) does not exist&quot;</span><span class="p">,</span>
	       <span class="n">h</span><span class="p">,</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">Sh_position</span> <span class="o">==</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">Sh_position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>

<span class="kt">int</span> <span class="n">is_reusable</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_value</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_internal_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">mes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">dc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;PAP-12336: bh == 0&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span> <span class="o">||</span> <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="p">(</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)),</span>
	       <span class="s">&quot;PAP-12337: buffer (%b) must be dirty&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">dc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_reusable</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dc_block_number</span><span class="p">(</span><span class="n">dc</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">print_cur_tb</span><span class="p">(</span><span class="n">mes</span><span class="p">);</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;PAP-12338&quot;</span><span class="p">,</span>
				       <span class="s">&quot;invalid child pointer %y in %b&quot;</span><span class="p">,</span>
				       <span class="n">dc</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">locked_or_not_in_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">which</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">buffer_journal_prepared</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-12339&quot;</span><span class="p">,</span> <span class="s">&quot;%s (%b)&quot;</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_before_balancing</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_tb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-12335&quot;</span><span class="p">,</span> <span class="s">&quot;suspect that schedule &quot;</span>
			       <span class="s">&quot;occurred based on cur_tb not being null at &quot;</span>
			       <span class="s">&quot;this point in code. do_balance cannot properly &quot;</span>
			       <span class="s">&quot;handle concurrent tree accesses on a same &quot;</span>
			       <span class="s">&quot;mount point.&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* double check that buffers that we will modify are unlocked. (fix_nodes should already have</span>
<span class="cm">	   prepped all of these for us). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">locked_or_not_in_tree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;L[0]&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">locked_or_not_in_tree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;FL[0]&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">locked_or_not_in_tree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;CFL[0]&quot;</span><span class="p">);</span>
		<span class="n">check_leaf</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">locked_or_not_in_tree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;R[0]&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">locked_or_not_in_tree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;FR[0]&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">|=</span> <span class="n">locked_or_not_in_tree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;CFR[0]&quot;</span><span class="p">);</span>
		<span class="n">check_leaf</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">|=</span> <span class="n">locked_or_not_in_tree</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">),</span>
					<span class="s">&quot;S[0]&quot;</span><span class="p">);</span>
	<span class="n">check_leaf</span><span class="p">(</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_after_balance_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span>
		    <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span>
		    <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span>
			    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;12221&quot;</span><span class="p">);</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-12355&quot;</span><span class="p">,</span>
				       <span class="s">&quot;shift to left was incorrect&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span>
		    <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span>
		    <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span>
			    <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;12222&quot;</span><span class="p">);</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-12360&quot;</span><span class="p">,</span>
				       <span class="s">&quot;shift to right was incorrect&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">!=</span>
	     <span class="p">(</span><span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span>
	      <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span>
			     <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
					       <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
							       <span class="mi">1</span><span class="p">))));</span>
		<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;12223&quot;</span><span class="p">);</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-12363&quot;</span><span class="p">,</span>
				 <span class="s">&quot;B_FREE_SPACE (PATH_H_PBUFFER(tb-&gt;tb_path,0)) = %d; &quot;</span>
				 <span class="s">&quot;MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d&quot;</span><span class="p">,</span>
				 <span class="n">left</span><span class="p">,</span>
				 <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
				 <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
				 <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
				 <span class="n">dc_size</span><span class="p">(</span><span class="n">B_N_CHILD</span>
					 <span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
					  <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span>
				 <span class="n">right</span><span class="p">);</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-12365&quot;</span><span class="p">,</span> <span class="s">&quot;S is incorrect&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_leaf_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">check_leaf</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">check_leaf</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">check_leaf</span><span class="p">(</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_internal_levels</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">h</span><span class="p">;</span>

	<span class="cm">/* check all internal nodes */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">];</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">check_internal_node</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span>
				    <span class="s">&quot;BAD BUFFER ON PATH&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">])</span>
			<span class="n">check_internal_node</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="s">&quot;BAD L&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">])</span>
			<span class="n">check_internal_node</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="s">&quot;BAD R&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/* Now we have all of the buffers that must be used in balancing of</span>
<span class="cm">   the tree.  We rely on the assumption that schedule() will not occur</span>
<span class="cm">   while do_balance works. ( Only interrupt handlers are acceptable.)</span>
<span class="cm">   We balance the tree according to the analysis made before this,</span>
<span class="cm">   using buffers already obtained.  For SMP support it will someday be</span>
<span class="cm">   necessary to add ordered locking of tb. */</span>

<span class="cm">/* Some interesting rules of balancing:</span>

<span class="cm">   we delete a maximum of two nodes per level per balancing: we never</span>
<span class="cm">   delete R, when we delete two of three nodes L, S, R then we move</span>
<span class="cm">   them into R.</span>

<span class="cm">   we only delete L if we are deleting two nodes, if we delete only</span>
<span class="cm">   one node we delete S</span>

<span class="cm">   if we shift leaves then we shift as much as we can: this is a</span>
<span class="cm">   deliberate policy of extremism in node packing which results in</span>
<span class="cm">   higher average utilization after repeated random balance operations</span>
<span class="cm">   at the cost of more memory copies and more balancing as a result of</span>
<span class="cm">   small insertions to full nodes.</span>

<span class="cm">   if we shift internal nodes we try to evenly balance the node</span>
<span class="cm">   utilization, with consequent less balancing at the cost of lower</span>
<span class="cm">   utilization.</span>

<span class="cm">   one could argue that the policy for directories in leaves should be</span>
<span class="cm">   that of internal nodes, but we will wait until another day to</span>
<span class="cm">   evaluate this....  It would be nice to someday measure and prove</span>
<span class="cm">   these assumptions as to what is optimal....</span>

<span class="cm">*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">do_balance_starts</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* use print_cur_tb() to see initial state of struct</span>
<span class="cm">	   tree_balance */</span>

	<span class="cm">/* store_print_tb (tb); */</span>

	<span class="cm">/* do not delete, just comment it out */</span>
<span class="cm">/*    print_tb(flag, PATH_LAST_POSITION(tb-&gt;tb_path), tb-&gt;tb_path-&gt;pos_in_item, tb,</span>
<span class="cm">	     &quot;check&quot;);*/</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">check_before_balancing</span><span class="p">(</span><span class="n">tb</span><span class="p">),</span> <span class="s">&quot;PAP-12340: locked buffers in TB&quot;</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">do_balance_completed</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="n">check_leaf_level</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
	<span class="n">check_internal_levels</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
	<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_tb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* reiserfs_free_block is no longer schedule safe.  So, we need to</span>
<span class="cm">	 ** put the buffers we want freed on the thrown list during do_balance,</span>
<span class="cm">	 ** and then free them now</span>
<span class="cm">	 */</span>

	<span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_do_balance</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* release all nodes hold to perform the balancing */</span>
	<span class="n">unfix_nodes</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>

	<span class="n">free_thrown</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>	<span class="cm">/* tree_balance structure */</span>
		<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span>	<span class="cm">/* item header of inserted item */</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span>	<span class="cm">/* body  of inserted item or bytes to paste */</span>
		<span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* i - insert, d - delete</span>
<span class="cm">				   c - cut, p - paste</span>

<span class="cm">				   Cut means delete part of an item</span>
<span class="cm">				   (includes removing an entry from a</span>
<span class="cm">				   directory).</span>

<span class="cm">				   Delete means delete whole item.</span>

<span class="cm">				   Insert means add a new item into the</span>
<span class="cm">				   tree.</span>

<span class="cm">				   Paste means to append to the end of an</span>
<span class="cm">				   existing file or to insert a directory</span>
<span class="cm">				   entry.  */</span>
	<span class="kt">int</span> <span class="n">child_pos</span><span class="p">,</span>		<span class="cm">/* position of a child node in its parent */</span>
	 <span class="n">h</span><span class="p">;</span>			<span class="cm">/* level of the tree being processed */</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="n">insert_key</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* in our processing of one level</span>
<span class="cm">					   we sometimes determine what</span>
<span class="cm">					   must be inserted into the next</span>
<span class="cm">					   higher level.  This insertion</span>
<span class="cm">					   consists of a key or two keys</span>
<span class="cm">					   and their corresponding</span>
<span class="cm">					   pointers */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">insert_ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* inserted node-ptrs for the next</span>
<span class="cm">						   level */</span>

	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_mode</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">need_balance_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">FILESYSTEM_CHANGED_TB</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;clm-6000&quot;</span><span class="p">,</span> <span class="s">&quot;fs generation has &quot;</span>
			       <span class="s">&quot;changed&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* if we have no real work to do  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;PAP-12350&quot;</span><span class="p">,</span>
				 <span class="s">&quot;insert_size == 0, mode == %c&quot;</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="n">unfix_nodes</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fs_generation</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)));</span>
	<span class="n">do_balance_starts</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>

	<span class="cm">/* balance leaf returns 0 except if combining L R and S into</span>
<span class="cm">	   one node.  see balance_internal() for explanation of this</span>
<span class="cm">	   line of code. */</span>
	<span class="n">child_pos</span> <span class="o">=</span> <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
	    <span class="n">balance_leaf</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">insert_key</span><span class="p">,</span> <span class="n">insert_ptr</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="n">check_after_balance_leaf</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Balance internal level of the tree. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">];</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span>
		<span class="n">child_pos</span> <span class="o">=</span>
		    <span class="n">balance_internal</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">child_pos</span><span class="p">,</span> <span class="n">insert_key</span><span class="p">,</span> <span class="n">insert_ptr</span><span class="p">);</span>

	<span class="n">do_balance_completed</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
