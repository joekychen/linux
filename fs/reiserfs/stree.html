<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › stree.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>stree.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  Written by Anatoly P. Pinchuk pap@namesys.botik.ru</span>
<span class="cm"> *  Programm System Institute</span>
<span class="cm"> *  Pereslavl-Zalessky Russia</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  This file contains functions dealing with S+tree</span>
<span class="cm"> *</span>
<span class="cm"> * B_IS_IN_TREE</span>
<span class="cm"> * copy_item_head</span>
<span class="cm"> * comp_short_keys</span>
<span class="cm"> * comp_keys</span>
<span class="cm"> * comp_short_le_keys</span>
<span class="cm"> * le_key2cpu_key</span>
<span class="cm"> * comp_le_keys</span>
<span class="cm"> * bin_search</span>
<span class="cm"> * get_lkey</span>
<span class="cm"> * get_rkey</span>
<span class="cm"> * key_in_buffer</span>
<span class="cm"> * decrement_bcount</span>
<span class="cm"> * reiserfs_check_path</span>
<span class="cm"> * pathrelse_and_restore</span>
<span class="cm"> * pathrelse</span>
<span class="cm"> * search_by_key_reada</span>
<span class="cm"> * search_by_key</span>
<span class="cm"> * search_for_position_by_key</span>
<span class="cm"> * comp_items</span>
<span class="cm"> * prepare_for_direct_item</span>
<span class="cm"> * prepare_for_direntry_item</span>
<span class="cm"> * prepare_for_delete_or_cut</span>
<span class="cm"> * calc_deleted_bytes_number</span>
<span class="cm"> * init_tb_struct</span>
<span class="cm"> * padd_item</span>
<span class="cm"> * reiserfs_delete_item</span>
<span class="cm"> * reiserfs_delete_solid_item</span>
<span class="cm"> * reiserfs_delete_object</span>
<span class="cm"> * maybe_indirect_to_direct</span>
<span class="cm"> * indirect_to_direct_roll_back</span>
<span class="cm"> * reiserfs_cut_from_item</span>
<span class="cm"> * truncate_directory</span>
<span class="cm"> * reiserfs_do_truncate</span>
<span class="cm"> * reiserfs_paste_into_item</span>
<span class="cm"> * reiserfs_insert_item</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>

<span class="cm">/* Does the buffer contain a disk block which is in the tree. */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">B_IS_IN_TREE</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_LEVEL</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_HEIGHT</span><span class="p">,</span>
	       <span class="s">&quot;PAP-1010: block (%b) has too big level (%z)&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">B_LEVEL</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FREE_LEVEL</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>to gets item head in le form</p></td><td class="code"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">copy_item_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">IH_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* k1 is pointer to on-disk structure which is stored in little-endian</span>
<span class="cm">   form. k2 is pointer to cpu variable. For key of items of the same</span>
<span class="cm">   object this returns 0.</span>
<span class="cm">   Returns: -1 if key1 &lt; key2</span>
<span class="cm">   0 if key1 == key2</span>
<span class="cm">   1 if key1 &gt; key2 */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">comp_short_keys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">le_key</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">le_key</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">cpu_key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">cpu_key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">le_key</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">cpu_key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">cpu_key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* k1 is pointer to on-disk structure which is stored in little-endian</span>
<span class="cm">   form. k2 is pointer to cpu variable.</span>
<span class="cm">   Compare keys using all 4 key fields.</span>
<span class="cm">   Returns: -1 if key1 &lt; key2 0</span>
<span class="cm">   if key1 = key2 1 if key1 &gt; key2 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">comp_keys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">le_key</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">comp_short_keys</span><span class="p">(</span><span class="n">le_key</span><span class="p">,</span> <span class="n">cpu_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le_key_k_offset</span><span class="p">(</span><span class="n">le_key_version</span><span class="p">(</span><span class="n">le_key</span><span class="p">),</span> <span class="n">le_key</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="n">cpu_key</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le_key_k_offset</span><span class="p">(</span><span class="n">le_key_version</span><span class="p">(</span><span class="n">le_key</span><span class="p">),</span> <span class="n">le_key</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="n">cpu_key</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_key</span><span class="o">-&gt;</span><span class="n">key_length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* this part is needed only when tail conversion is in progress */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le_key_k_type</span><span class="p">(</span><span class="n">le_key_version</span><span class="p">(</span><span class="n">le_key</span><span class="p">),</span> <span class="n">le_key</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="n">cpu_key_k_type</span><span class="p">(</span><span class="n">cpu_key</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le_key_k_type</span><span class="p">(</span><span class="n">le_key_version</span><span class="p">(</span><span class="n">le_key</span><span class="p">),</span> <span class="n">le_key</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">cpu_key_k_type</span><span class="p">(</span><span class="n">cpu_key</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">comp_short_le_keys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="o">*</span><span class="n">k1_u32</span><span class="p">,</span> <span class="o">*</span><span class="n">k2_u32</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">key_length</span> <span class="o">=</span> <span class="n">REISERFS_SHORT_KEY_LEN</span><span class="p">;</span>

	<span class="n">k1_u32</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">key1</span><span class="p">;</span>
	<span class="n">k2_u32</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">key2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">key_length</span><span class="o">--</span><span class="p">;</span> <span class="o">++</span><span class="n">k1_u32</span><span class="p">,</span> <span class="o">++</span><span class="n">k2_u32</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">k1_u32</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">k2_u32</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">k1_u32</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">k2_u32</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">le_key2cpu_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_dir_id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>find out version of the key</p></td><td class="code"><div class="highlight"><pre>	<span class="n">version</span> <span class="o">=</span> <span class="n">le_key_version</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_offset</span> <span class="o">=</span> <span class="n">le_key_k_offset</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_type</span> <span class="o">=</span> <span class="n">le_key_k_type</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>this does not say which one is bigger, it only returns 1 if keys
are not equal, 0 otherwise</p></td><td class="code"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">comp_le_keys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">k1</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">k2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_key</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> *  Binary search toolkit function                                        *</span>
<span class="cm"> *  Search for an item in the array by the item key                       *</span>
<span class="cm"> *  Returns:    1 if found,  0 if not found;                              *</span>
<span class="cm"> *        *pos = number of the searched element if found, else the        *</span>
<span class="cm"> *        number of the first element that is larger than key.            *</span>
<span class="cm"> **************************************************************************/</span>
<span class="cm">/* For those not familiar with binary search: lbound is the leftmost item that it</span>
<span class="cm"> could be, rbound the rightmost item that it could be.  We examine the item</span>
<span class="cm"> halfway between lbound and rbound, and that tells us either that we can increase</span>
<span class="cm"> lbound, or decrease rbound, or that we have found it, or if lbound &lt;= rbound that</span>
<span class="cm"> there are no possible items, and we have not found it. With each examination we</span>
<span class="cm"> cut the number of possible items it could be by one more than half rounded down,</span>
<span class="cm"> or we find it. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bin_search</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>	<span class="cm">/* Key to search for. */</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>	<span class="cm">/* First item in the array. */</span>
			     <span class="kt">int</span> <span class="n">num</span><span class="p">,</span>	<span class="cm">/* Number of items in the array. */</span>
			     <span class="kt">int</span> <span class="n">width</span><span class="p">,</span>	<span class="cm">/* Item size in the array.</span>
<span class="cm">					   searched. Lest the reader be</span>
<span class="cm">					   confused, note that this is crafted</span>
<span class="cm">					   as a general function, and when it</span>
<span class="cm">					   is applied specifically to the array</span>
<span class="cm">					   of item headers in a node, width</span>
<span class="cm">					   is actually the item header size not</span>
<span class="cm">					   the item size. */</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">pos</span> <span class="cm">/* Number of the searched for element. */</span>
    <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rbound</span><span class="p">,</span> <span class="n">lbound</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="p">((</span><span class="n">rbound</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">lbound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	     <span class="n">lbound</span> <span class="o">&lt;=</span> <span class="n">rbound</span><span class="p">;</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">rbound</span> <span class="o">+</span> <span class="n">lbound</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">comp_keys</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">width</span><span class="p">),</span>
			 <span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="mi">1</span>:
			<span class="n">lbound</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">rbound</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ITEM_FOUND</span><span class="p">;</span>	<span class="cm">/* Key found in the array.  */</span>
		<span class="p">}</span>

	<span class="cm">/* bin_search did not find given key, it returns position of key,</span>
<span class="cm">	   that is minimal and greater than the given one. */</span>
	<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">lbound</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ITEM_NOT_FOUND</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Minimal possible key. It is never in the tree. */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="n">MIN_KEY</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},}</span> <span class="p">};</span>

<span class="cm">/* Maximal possible key. It is never in the tree. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="n">MAX_KEY</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__constant_cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">),</span>
	<span class="n">__constant_cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">),</span>
	<span class="p">{{</span><span class="n">__constant_cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">),</span>
	  <span class="n">__constant_cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">)},}</span>
<span class="p">};</span>

<span class="cm">/* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom</span>
<span class="cm">   of the path, and going upwards.  We must check the path&#39;s validity at each step.  If the key is not in</span>
<span class="cm">   the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this</span>
<span class="cm">   case we return a special key, either MIN_KEY or MAX_KEY. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="nf">get_lkey</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">chk_path</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">position</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">=</span> <span class="n">chk_path</span><span class="o">-&gt;</span><span class="n">path_length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">path_offset</span> <span class="o">&lt;</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">,</span>
	       <span class="s">&quot;PAP-5010: invalid offset in the path&quot;</span><span class="p">);</span>

	<span class="cm">/* While not higher in path than first element. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">path_offset</span><span class="o">--</span> <span class="o">&gt;</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span>
		       <span class="p">(</span><span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="p">)),</span>
		       <span class="s">&quot;PAP-5020: parent is not uptodate&quot;</span><span class="p">);</span>

		<span class="cm">/* Parent at the path is not in the tree now. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span>
		    <span class="p">(</span><span class="n">parent</span> <span class="o">=</span>
		     <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">MAX_KEY</span><span class="p">;</span>
		<span class="cm">/* Check whether position in the parent is correct. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">position</span> <span class="o">=</span>
		     <span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span>
					  <span class="n">path_offset</span><span class="p">))</span> <span class="o">&gt;</span>
		    <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">MAX_KEY</span><span class="p">;</span>
		<span class="cm">/* Check whether parent at the path really points to the child. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span>
					<span class="n">path_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">MAX_KEY</span><span class="p">;</span>
		<span class="cm">/* Return delimiting key if position in the parent is not equal to zero. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">position</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Return MIN_KEY if we are in the root of the buffer tree. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span><span class="o">-&gt;</span>
	    <span class="n">b_blocknr</span> <span class="o">==</span> <span class="n">SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">MIN_KEY</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">MAX_KEY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get delimiting key of the buffer at the path and its right neighbor. */</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="nf">get_rkey</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">chk_path</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">position</span><span class="p">,</span> <span class="n">path_offset</span> <span class="o">=</span> <span class="n">chk_path</span><span class="o">-&gt;</span><span class="n">path_length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">path_offset</span> <span class="o">&lt;</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">,</span>
	       <span class="s">&quot;PAP-5030: invalid offset in the path&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">path_offset</span><span class="o">--</span> <span class="o">&gt;</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span>
		       <span class="p">(</span><span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="p">)),</span>
		       <span class="s">&quot;PAP-5040: parent is not uptodate&quot;</span><span class="p">);</span>

		<span class="cm">/* Parent at the path is not in the tree now. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span>
		    <span class="p">(</span><span class="n">parent</span> <span class="o">=</span>
		     <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">MIN_KEY</span><span class="p">;</span>
		<span class="cm">/* Check whether position in the parent is correct. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">position</span> <span class="o">=</span>
		     <span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span>
					  <span class="n">path_offset</span><span class="p">))</span> <span class="o">&gt;</span>
		    <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">MIN_KEY</span><span class="p">;</span>
		<span class="cm">/* Check whether parent at the path really points to the child. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span>
					<span class="n">path_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">MIN_KEY</span><span class="p">;</span>
		<span class="cm">/* Return delimiting key if position in the parent is not the last one. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">!=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">position</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Return MAX_KEY if we are in the root of the buffer tree. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span><span class="p">)</span><span class="o">-&gt;</span>
	    <span class="n">b_blocknr</span> <span class="o">==</span> <span class="n">SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">MAX_KEY</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">MIN_KEY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether a key is contained in the tree rooted from a buffer at a path. */</span>
<span class="cm">/* This works by looking at the left and right delimiting keys for the buffer in the last path_element in</span>
<span class="cm">   the path.  These delimiting keys are stored at least one level above that buffer in the tree. If the</span>
<span class="cm">   buffer is the first or last node in the tree order then one of the delimiting keys may be absent, and in</span>
<span class="cm">   this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">key_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">chk_path</span><span class="p">,</span>	<span class="cm">/* Path which should be checked.  */</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>	<span class="cm">/* Key which should be checked.   */</span>
				<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span>
    <span class="p">)</span>
<span class="p">{</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">key</span> <span class="o">||</span> <span class="n">chk_path</span><span class="o">-&gt;</span><span class="n">path_length</span> <span class="o">&lt;</span> <span class="n">FIRST_PATH_ELEMENT_OFFSET</span>
	       <span class="o">||</span> <span class="n">chk_path</span><span class="o">-&gt;</span><span class="n">path_length</span> <span class="o">&gt;</span> <span class="n">MAX_HEIGHT</span><span class="p">,</span>
	       <span class="s">&quot;PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)&quot;</span><span class="p">,</span>
	       <span class="n">key</span><span class="p">,</span> <span class="n">chk_path</span><span class="o">-&gt;</span><span class="n">path_length</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">chk_path</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span>
	       <span class="s">&quot;PAP-5060: device must not be NODEV&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">comp_keys</span><span class="p">(</span><span class="n">get_lkey</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span> <span class="n">sb</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* left delimiting key is bigger, that the key we look for */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*  if ( comp_keys(key, get_rkey(chk_path, sb)) != -1 ) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">comp_keys</span><span class="p">(</span><span class="n">get_rkey</span><span class="p">(</span><span class="n">chk_path</span><span class="p">,</span> <span class="n">sb</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* key must be less than right delimitiing key */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_check_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">path_length</span> <span class="o">!=</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">,</span>
	       <span class="s">&quot;path not properly relsed&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Drop the reference to each buffer in a path and restore</span>
<span class="cm"> * dirty bits clean when preparing the buffer for the log.</span>
<span class="cm"> * This version should only be called from fix_nodes() */</span>
<span class="kt">void</span> <span class="nf">pathrelse_and_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">path_offset</span> <span class="o">=</span> <span class="n">search_path</span><span class="o">-&gt;</span><span class="n">path_length</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">path_offset</span> <span class="o">&lt;</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">,</span>
	       <span class="s">&quot;clm-4000: invalid path offset&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">path_offset</span> <span class="o">&gt;</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">search_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="o">--</span><span class="p">);</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">search_path</span><span class="o">-&gt;</span><span class="n">path_length</span> <span class="o">=</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Drop the reference to each buffer in a path */</span>
<span class="kt">void</span> <span class="nf">pathrelse</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">path_offset</span> <span class="o">=</span> <span class="n">search_path</span><span class="o">-&gt;</span><span class="n">path_length</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">path_offset</span> <span class="o">&lt;</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">,</span>
	       <span class="s">&quot;PAP-5090: invalid path offset&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">path_offset</span> <span class="o">&gt;</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">search_path</span><span class="p">,</span> <span class="n">path_offset</span><span class="o">--</span><span class="p">));</span>

	<span class="n">search_path</span><span class="o">-&gt;</span><span class="n">path_length</span> <span class="o">=</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used_space</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prev_location</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blkh_level</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DISK_LEAF_NODE_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5080&quot;</span><span class="p">,</span>
				 <span class="s">&quot;this should be caught earlier&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">nr</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">BLKH_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">MIN_ITEM_LEN</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* item number is too big or too small */</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5081&quot;</span><span class="p">,</span>
				 <span class="s">&quot;nr_item seems wrong: %z&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">BLKH_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">used_space</span> <span class="o">=</span> <span class="n">BLKH_SIZE</span> <span class="o">+</span> <span class="n">IH_SIZE</span> <span class="o">*</span> <span class="n">nr</span> <span class="o">+</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used_space</span> <span class="o">!=</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* free space does not match to calculated amount of use space */</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5082&quot;</span><span class="p">,</span>
				 <span class="s">&quot;free space seems wrong: %z&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>FIXME: it is_leaf will hit performance too much - we may have
return 1 here</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* check tables of item heads */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">BLKH_SIZE</span><span class="p">);</span>
	<span class="n">prev_location</span> <span class="o">=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ih</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le_ih_k_type</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_ANY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5083&quot;</span><span class="p">,</span>
					 <span class="s">&quot;wrong item type for item %h&quot;</span><span class="p">,</span>
					 <span class="n">ih</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">blocksize</span>
		    <span class="o">||</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">IH_SIZE</span> <span class="o">*</span> <span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5084&quot;</span><span class="p">,</span>
					 <span class="s">&quot;item location seems wrong: %h&quot;</span><span class="p">,</span>
					 <span class="n">ih</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span>
		    <span class="o">||</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_ITEM_LEN</span><span class="p">(</span><span class="n">blocksize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5085&quot;</span><span class="p">,</span>
					 <span class="s">&quot;item length seems wrong: %h&quot;</span><span class="p">,</span>
					 <span class="n">ih</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_location</span> <span class="o">-</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5086&quot;</span><span class="p">,</span>
					 <span class="s">&quot;item location seems wrong &quot;</span>
					 <span class="s">&quot;(second one): %h&quot;</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prev_location</span> <span class="o">=</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>one may imagine much more checks</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns 1 if buf looks like an internal node, 0 otherwise */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_internal</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used_space</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_level</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;=</span> <span class="n">DISK_LEAF_NODE_LEVEL</span> <span class="o">||</span> <span class="n">nr</span> <span class="o">&gt;</span> <span class="n">MAX_HEIGHT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this level is not possible for internal nodes */</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5087&quot;</span><span class="p">,</span>
				 <span class="s">&quot;this should be caught earlier&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">BLKH_SIZE</span> <span class="o">-</span> <span class="n">DC_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="n">DC_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* for internal which is not root we might check min number of keys */</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5088&quot;</span><span class="p">,</span>
				 <span class="s">&quot;number of key seems wrong: %z&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">used_space</span> <span class="o">=</span> <span class="n">BLKH_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span> <span class="o">*</span> <span class="n">nr</span> <span class="o">+</span> <span class="n">DC_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used_space</span> <span class="o">!=</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5089&quot;</span><span class="p">,</span>
				 <span class="s">&quot;free space seems wrong: %z&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>one may imagine much more checks</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>make sure that bh contains formatted node of reiserfs tree of
'level'-th level</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">is_tree_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">B_LEVEL</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">!=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;reiserfs-5090&quot;</span><span class="p">,</span> <span class="s">&quot;node level %d does &quot;</span>
				 <span class="s">&quot;not match to the expected one %d&quot;</span><span class="p">,</span>
				 <span class="n">B_LEVEL</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span> <span class="n">level</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">DISK_LEAF_NODE_LEVEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">is_internal</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SEARCH_BY_KEY_READA 16</span>

<span class="cm">/*</span>
<span class="cm"> * The function is NOT SCHEDULE-SAFE!</span>
<span class="cm"> * It might unlock the write lock if we needed to wait for a block</span>
<span class="cm"> * to be read. Note that in this case it won&#39;t recover the lock to avoid</span>
<span class="cm"> * high contention resulting from too much lock requests, especially</span>
<span class="cm"> * the caller (search_by_key) will perform other schedule-unsafe</span>
<span class="cm"> * operations just after calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * @return true if we have unlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">search_by_key_reada</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bh</span><span class="p">,</span>
				<span class="n">b_blocknr_t</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">unlocked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are going to read some blocks on which we</span>
<span class="cm">	 * have a reference. It&#39;s safe, though we might be</span>
<span class="cm">	 * reading blocks concurrently changed if we release</span>
<span class="cm">	 * the lock. But it&#39;s still fine because we check later</span>
<span class="cm">	 * if the tree changed</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * note, this needs attention if we are getting rid of the BKL</span>
<span class="cm">		 * you have to make sure the prepared bit isn&#39;t set on this buffer</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlocked</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="n">unlocked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READA</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bh</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">unlocked</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> * Algorithm   SearchByKey                                                *</span>
<span class="cm"> *             look for item in the Disk S+Tree by its key                *</span>
<span class="cm"> * Input:  sb   -  super block                                            *</span>
<span class="cm"> *         key  - pointer to the key to search                            *</span>
<span class="cm"> * Output: ITEM_FOUND, ITEM_NOT_FOUND or IO_ERROR                         *</span>
<span class="cm"> *         search_path - path from the root to the needed leaf            *</span>
<span class="cm"> **************************************************************************/</span>

<span class="cm">/* This function fills up the path from the root to the leaf as it</span>
<span class="cm">   descends the tree looking for the key.  It uses reiserfs_bread to</span>
<span class="cm">   try to find buffers in the cache given their block number.  If it</span>
<span class="cm">   does not find them in the cache it reads them from disk.  For each</span>
<span class="cm">   node search_by_key finds using reiserfs_bread it then uses</span>
<span class="cm">   bin_search to look through that node.  bin_search will find the</span>
<span class="cm">   position of the block_number of the next node if it is looking</span>
<span class="cm">   through an internal node.  If it is looking through a leaf node</span>
<span class="cm">   bin_search will find the position of the item which has key either</span>
<span class="cm">   equal to given key, or which is the maximal key less than the given</span>
<span class="cm">   key.  search_by_key returns a path that must be checked for the</span>
<span class="cm">   correctness of the top of the path but need not be checked for the</span>
<span class="cm">   correctness of the bottom of the path */</span>
<span class="cm">/* The function is NOT SCHEDULE-SAFE! */</span>
<span class="kt">int</span> <span class="nf">search_by_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>	<span class="cm">/* Key to search. */</span>
		  <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span><span class="p">,</span><span class="cm">/* This structure was</span>
<span class="cm">						   allocated and initialized</span>
<span class="cm">						   by the calling</span>
<span class="cm">						   function. It is filled up</span>
<span class="cm">						   by this function.  */</span>
		  <span class="kt">int</span> <span class="n">stop_level</span>	<span class="cm">/* How far down the tree to search. To</span>
<span class="cm">					   stop at leaf level - set to</span>
<span class="cm">					   DISK_LEAF_NODE_LEVEL */</span>
    <span class="p">)</span>
<span class="p">{</span>
	<span class="n">b_blocknr_t</span> <span class="n">block_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">expected_level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path_element</span> <span class="o">*</span><span class="n">last_element</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node_level</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">right_neighbor_of_leaf_node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fs_gen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">reada_bh</span><span class="p">[</span><span class="n">SEARCH_BY_KEY_READA</span><span class="p">];</span>
	<span class="n">b_blocknr_t</span> <span class="n">reada_blocks</span><span class="p">[</span><span class="n">SEARCH_BY_KEY_READA</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">reada_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="kt">int</span> <span class="n">repeat_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">search_by_key</span><span class="p">);</span>

	<span class="cm">/* As we add each node to a path we increase its count.  This means that</span>
<span class="cm">	   we must be careful to release all nodes in a path before we either</span>
<span class="cm">	   discard the path struct or re-use the path struct, as we do here. */</span>

	<span class="n">pathrelse</span><span class="p">(</span><span class="n">search_path</span><span class="p">);</span>

	<span class="n">right_neighbor_of_leaf_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* With each iteration of this loop we search through the items in the</span>
<span class="cm">	   current node, and calculate the next current node(next path element)</span>
<span class="cm">	   for the next iteration of this loop.. */</span>
	<span class="n">block_number</span> <span class="o">=</span> <span class="n">SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">expected_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">repeat_counter</span> <span class="o">%</span> <span class="mi">50000</span><span class="p">))</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;PAP-5100&quot;</span><span class="p">,</span>
					 <span class="s">&quot;%s: there were %d iterations of &quot;</span>
					 <span class="s">&quot;while loop looking for key %K&quot;</span><span class="p">,</span>
					 <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">repeat_counter</span><span class="p">,</span>
					 <span class="n">key</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="cm">/* prep path to have another element added to it. */</span>
		<span class="n">last_element</span> <span class="o">=</span>
		    <span class="n">PATH_OFFSET_PELEMENT</span><span class="p">(</span><span class="n">search_path</span><span class="p">,</span>
					 <span class="o">++</span><span class="n">search_path</span><span class="o">-&gt;</span><span class="n">path_length</span><span class="p">);</span>
		<span class="n">fs_gen</span> <span class="o">=</span> <span class="n">get_generation</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="cm">/* Read the next tree node, and set the last element in the path to</span>
<span class="cm">		   have a pointer to it. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">last_element</span><span class="o">-&gt;</span><span class="n">pe_buffer</span> <span class="o">=</span>
		     <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_number</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">unlocked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">reada_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="cm">/* may unlock the write lock */</span>
				<span class="n">unlocked</span> <span class="o">=</span> <span class="n">search_by_key_reada</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">reada_bh</span><span class="p">,</span>
						    <span class="n">reada_blocks</span><span class="p">,</span> <span class="n">reada_count</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we haven&#39;t already unlocked the write lock,</span>
<span class="cm">			 * then we need to do that here before reading</span>
<span class="cm">			 * the current block</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">unlocked</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
				<span class="n">unlocked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlocked</span><span class="p">)</span>
				<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		      <span class="nl">io_error:</span>
			<span class="n">search_path</span><span class="o">-&gt;</span><span class="n">path_length</span><span class="o">--</span><span class="p">;</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="n">search_path</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IO_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reada_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">expected_level</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">expected_level</span> <span class="o">=</span> <span class="n">SB_TREE_HEIGHT</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">expected_level</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* It is possible that schedule occurred. We must check whether the key</span>
<span class="cm">		   to search is still in the tree rooted from the current buffer. If</span>
<span class="cm">		   not then repeat search from the root. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fs_changed</span><span class="p">(</span><span class="n">fs_gen</span><span class="p">,</span> <span class="n">sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">B_LEVEL</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_level</span> <span class="o">||</span>
		     <span class="o">!</span><span class="n">key_in_buffer</span><span class="p">(</span><span class="n">search_path</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">sb</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">search_by_key_fs_changed</span><span class="p">);</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">search_by_key_restarted</span><span class="p">);</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				      <span class="n">sbk_restarted</span><span class="p">[</span><span class="n">expected_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="n">search_path</span><span class="p">);</span>

			<span class="cm">/* Get the root block number so that we can repeat the search</span>
<span class="cm">			   starting from the root. */</span>
			<span class="n">block_number</span> <span class="o">=</span> <span class="n">SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="n">expected_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">right_neighbor_of_leaf_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* repeat search from the root */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* only check that the key is in the buffer if key is not</span>
<span class="cm">		   equal to the MAX_KEY. Latter case is only possible in</span>
<span class="cm">		   &quot;finish_unfinished()&quot; processing during mount. */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">comp_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MAX_KEY</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="n">key_in_buffer</span><span class="p">(</span><span class="n">search_path</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">sb</span><span class="p">),</span>
		       <span class="s">&quot;PAP-5130: key is not in the buffer&quot;</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_tb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;5140&quot;</span><span class="p">);</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;PAP-5140&quot;</span><span class="p">,</span>
				       <span class="s">&quot;schedule occurred in do_balance!&quot;</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>make sure, that the node contents look like a node of
certain level</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_tree_node</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">expected_level</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-5150&quot;</span><span class="p">,</span>
				       <span class="s">&quot;invalid format found in block %ld. &quot;</span>
				       <span class="s">&quot;Fsck?&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="n">search_path</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IO_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* ok, we have acquired next formatted node in the tree */</span>
		<span class="n">node_level</span> <span class="o">=</span> <span class="n">B_LEVEL</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="n">PROC_INFO_BH_STAT</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">node_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">node_level</span> <span class="o">&lt;</span> <span class="n">stop_level</span><span class="p">,</span>
		       <span class="s">&quot;vs-5152: tree level (%d) is less than stop level (%d)&quot;</span><span class="p">,</span>
		       <span class="n">node_level</span><span class="p">,</span> <span class="n">stop_level</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">bin_search</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				      <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
				      <span class="p">(</span><span class="n">node_level</span> <span class="o">==</span>
				       <span class="n">DISK_LEAF_NODE_LEVEL</span><span class="p">)</span> <span class="o">?</span> <span class="n">IH_SIZE</span> <span class="o">:</span>
				      <span class="n">KEY_SIZE</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="p">(</span><span class="n">last_element</span><span class="o">-&gt;</span><span class="n">pe_position</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_level</span> <span class="o">==</span> <span class="n">stop_level</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we are not in the stop level */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ITEM_FOUND</span><span class="p">)</span>
			<span class="cm">/* item has been found, so we choose the pointer which is to the right of the found one */</span>
			<span class="n">last_element</span><span class="o">-&gt;</span><span class="n">pe_position</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* if item was not found we choose the position which is to</span>
<span class="cm">		   the left of the found item. This requires no code,</span>
<span class="cm">		   bin_search did it already. */</span>

		<span class="cm">/* So we have chosen a position in the current node which is</span>
<span class="cm">		   an internal node.  Now we calculate child block number by</span>
<span class="cm">		   position in the node. */</span>
		<span class="n">block_number</span> <span class="o">=</span>
		    <span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">last_element</span><span class="o">-&gt;</span><span class="n">pe_position</span><span class="p">);</span>

		<span class="cm">/* if we are going to read leaf nodes, try for read ahead as well */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">search_path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">&amp;</span> <span class="n">PATH_READA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">node_level</span> <span class="o">==</span> <span class="n">DISK_LEAF_NODE_LEVEL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">last_element</span><span class="o">-&gt;</span><span class="n">pe_position</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">le_key</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">search_path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">&amp;</span> <span class="n">PATH_READA_BACK</span><span class="p">)</span>
				<span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">reada_count</span> <span class="o">&lt;</span> <span class="n">SEARCH_BY_KEY_READA</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">limit</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">reada_blocks</span><span class="p">[</span><span class="n">reada_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
				    <span class="n">B_N_CHILD_NUM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">search_path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">&amp;</span> <span class="n">PATH_READA_BACK</span><span class="p">)</span>
					<span class="n">pos</span><span class="o">--</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">pos</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * check to make sure we&#39;re in the same object</span>
<span class="cm">				 */</span>
				<span class="n">le_key</span> <span class="o">=</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">le_key</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">)</span> <span class="o">!=</span>
				    <span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Form the path to an item and position in this item which contains</span>
<span class="cm">   file byte defined by key. If there is no such item</span>
<span class="cm">   corresponding to the key, we point the path to the item with</span>
<span class="cm">   maximal key less than key, and *pos_in_item is set to one</span>
<span class="cm">   past the last entry/byte in the item.  If searching for entry in a</span>
<span class="cm">   directory item, and it is not found, *pos_in_item is set to one</span>
<span class="cm">   entry more than the entry with maximal key which is less than the</span>
<span class="cm">   sought key.</span>

<span class="cm">   Note that if there is no entry in this same node which is one more,</span>
<span class="cm">   then we point to an imaginary entry.  for direct items, the</span>
<span class="cm">   position is in units of bytes, for indirect items the position is</span>
<span class="cm">   in units of blocknr entries, for directory items the position is in</span>
<span class="cm">   units of directory entries.  */</span>

<span class="cm">/* The function is NOT SCHEDULE-SAFE! */</span>
<span class="kt">int</span> <span class="nf">search_for_position_by_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>	<span class="cm">/* Pointer to the super block.          */</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">p_cpu_key</span><span class="p">,</span>	<span class="cm">/* Key to search (cpu variable)         */</span>
			       <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span>	<span class="cm">/* Filled up by this function.          */</span>
    <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">p_le_ih</span><span class="p">;</span>	<span class="cm">/* pointer to on-disk structure */</span>
	<span class="kt">int</span> <span class="n">blk_size</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">item_offset</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_dir_entry</span> <span class="n">de</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* If searching for directory entry. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_cpu_key</span><span class="p">(</span><span class="n">p_cpu_key</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">search_by_entry_key</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p_cpu_key</span><span class="p">,</span> <span class="n">search_path</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">de</span><span class="p">);</span>

	<span class="cm">/* If not searching for directory entry. */</span>

	<span class="cm">/* If item is found. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">search_item</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p_cpu_key</span><span class="p">,</span> <span class="n">search_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ITEM_FOUND</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">ih_item_len</span>
		       <span class="p">(</span><span class="n">B_N_PITEM_HEAD</span>
			<span class="p">(</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">search_path</span><span class="p">),</span>
			 <span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">search_path</span><span class="p">))),</span>
		       <span class="s">&quot;PAP-5165: item length equals zero&quot;</span><span class="p">);</span>

		<span class="n">pos_in_item</span><span class="p">(</span><span class="n">search_path</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">POSITION_FOUND</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">search_path</span><span class="p">),</span>
	       <span class="s">&quot;PAP-5170: position equals zero&quot;</span><span class="p">);</span>

	<span class="cm">/* Item is not found. Set path to the previous item. */</span>
	<span class="n">p_le_ih</span> <span class="o">=</span>
	    <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">search_path</span><span class="p">),</span>
			   <span class="o">--</span><span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">search_path</span><span class="p">));</span>
	<span class="n">blk_size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">comp_short_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">p_le_ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">p_cpu_key</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">FILE_NOT_FOUND</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>FIXME: quite ugly this far</p></td><td class="code"><div class="highlight"><pre>	<span class="n">item_offset</span> <span class="o">=</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="n">p_cpu_key</span><span class="p">);</span>

	<span class="cm">/* Needed byte is contained in the item pointed to by the path. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item_offset</span> <span class="o">&lt;=</span> <span class="n">offset</span> <span class="o">&amp;&amp;</span>
	    <span class="n">item_offset</span> <span class="o">+</span> <span class="n">op_bytes_number</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">,</span> <span class="n">blk_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos_in_item</span><span class="p">(</span><span class="n">search_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">item_offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pos_in_item</span><span class="p">(</span><span class="n">search_path</span><span class="p">)</span> <span class="o">/=</span> <span class="n">blk_size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">POSITION_FOUND</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Needed byte is not contained in the item pointed to by the</span>
<span class="cm">	   path. Set pos_in_item out of the item. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span>
		<span class="n">pos_in_item</span><span class="p">(</span><span class="n">search_path</span><span class="p">)</span> <span class="o">=</span>
		    <span class="n">ih_item_len</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">)</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pos_in_item</span><span class="p">(</span><span class="n">search_path</span><span class="p">)</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">POSITION_NOT_FOUND</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compare given item and item pointed to by the path. */</span>
<span class="kt">int</span> <span class="nf">comp_items</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">stored_ih</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>

	<span class="cm">/* Last buffer at the path is not in the tree. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Last path position is invalid. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* we need only to know, whether it is the same item */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">stored_ih</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">IH_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* unformatted nodes are not logged anymore, ever.  This is safe</span>
<span class="cm">** now</span>
<span class="cm">*/</span>
<span class="cp">#define held_by_others(bh) (atomic_read(&amp;(bh)-&gt;b_count) &gt; 1)</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>block can not be forgotten as it is in I/O or held by someone</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define block_in_use(bh) (buffer_locked(bh) || (held_by_others(bh)))</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>prepare for delete or cut of direct item</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">prepare_for_direct_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">le_ih</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					  <span class="n">loff_t</span> <span class="n">new_file_length</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cut_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">round_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_file_length</span> <span class="o">==</span> <span class="n">max_reiserfs_offset</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* item has to be deleted */</span>
		<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">le_ih</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">M_DELETE</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>new file gets truncated</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">get_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">KEY_FORMAT_3_6</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div></td><td class="code"><div class="highlight"><pre>		<span class="n">round_len</span> <span class="o">=</span> <span class="n">ROUND_UP</span><span class="p">(</span><span class="n">new_file_length</span><span class="p">);</span>
		<span class="cm">/* this was new_file_length &lt; le_ih ... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">round_len</span> <span class="o">&lt;</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">le_ih</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">le_ih</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">M_DELETE</span><span class="p">;</span>	<span class="cm">/* Delete this item. */</span>
		<span class="p">}</span>
		<span class="cm">/* Calculate first position and size for cutting from item. */</span>
		<span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">round_len</span> <span class="o">-</span> <span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">le_ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">le_ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>

		<span class="k">return</span> <span class="n">M_CUT</span><span class="p">;</span>	<span class="cm">/* Cut from this item. */</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>old file: items may have any length</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">new_file_length</span> <span class="o">&lt;</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">le_ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">le_ih</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">M_DELETE</span><span class="p">;</span>	<span class="cm">/* Delete this item. */</span>
	<span class="p">}</span>
	<span class="cm">/* Calculate first position and size for cutting from item. */</span>
	<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">le_ih</span><span class="p">)</span> <span class="o">-</span>
		      <span class="p">(</span><span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">=</span>
		       <span class="n">new_file_length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">le_ih</span><span class="p">)));</span>
	<span class="k">return</span> <span class="n">M_CUT</span><span class="p">;</span>		<span class="cm">/* Cut from this item. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">prepare_for_direntry_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">le_ih</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					    <span class="n">loff_t</span> <span class="n">new_file_length</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="o">*</span><span class="n">cut_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">le_ih</span><span class="p">)</span> <span class="o">==</span> <span class="n">DOT_OFFSET</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new_file_length</span> <span class="o">==</span> <span class="n">max_reiserfs_offset</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">ih_entry_count</span><span class="p">(</span><span class="n">le_ih</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">,</span>
		       <span class="s">&quot;PAP-5220: incorrect empty directory item (%h)&quot;</span><span class="p">,</span> <span class="n">le_ih</span><span class="p">);</span>
		<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">le_ih</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">M_DELETE</span><span class="p">;</span>	<span class="cm">/* Delete the directory item containing &quot;.&quot; and &quot;..&quot; entry. */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ih_entry_count</span><span class="p">(</span><span class="n">le_ih</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Delete the directory item such as there is one record only</span>
<span class="cm">		   in this item */</span>
		<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">le_ih</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">M_DELETE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Cut one record from the directory item. */</span>
	<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span>
	    <span class="o">-</span><span class="p">(</span><span class="n">DEH_SIZE</span> <span class="o">+</span>
	      <span class="n">entry_length</span><span class="p">(</span><span class="n">get_last_bh</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">le_ih</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">)));</span>
	<span class="k">return</span> <span class="n">M_CUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD (2 * JOURNAL_PER_BALANCE_CNT + 1)</span>

<span class="cm">/*  If the path points to a directory or direct item, calculate mode and the size cut, for balance.</span>
<span class="cm">    If the path points to an indirect item, remove some number of its unformatted nodes.</span>
<span class="cm">    In case of file truncate calculate whether this item must be deleted/truncated or last</span>
<span class="cm">    unformatted node of this item will be converted to a direct item.</span>
<span class="cm">    This function returns a determination of what balance mode the calling function should employ. */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="nf">prepare_for_delete_or_cut</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">item_key</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">removed</span><span class="p">,</span>	<span class="cm">/* Number of unformatted nodes which were removed</span>
<span class="cm">																						   from end of the file. */</span>
				      <span class="kt">int</span> <span class="o">*</span><span class="n">cut_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">new_file_length</span>	<span class="cm">/* MAX_KEY_OFFSET in case of delete. */</span>
    <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">p_le_ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="cm">/* Stat_data item. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_statdata_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">new_file_length</span> <span class="o">!=</span> <span class="n">max_reiserfs_offset</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
		       <span class="s">&quot;PAP-5210: mode must be M_DELETE&quot;</span><span class="p">);</span>

		<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">M_DELETE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Directory item. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">prepare_for_direntry_item</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">p_le_ih</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						 <span class="n">new_file_length</span><span class="p">,</span>
						 <span class="n">cut_size</span><span class="p">);</span>

	<span class="cm">/* Direct item. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">prepare_for_direct_item</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">p_le_ih</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					       <span class="n">new_file_length</span><span class="p">,</span> <span class="n">cut_size</span><span class="p">);</span>

	<span class="cm">/* Case of an indirect item. */</span>
	<span class="p">{</span>
	    <span class="kt">int</span> <span class="n">blk_size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	    <span class="k">struct</span> <span class="n">item_head</span> <span class="n">s_ih</span><span class="p">;</span>
	    <span class="kt">int</span> <span class="n">need_re_search</span><span class="p">;</span>
	    <span class="kt">int</span> <span class="n">delete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">M_CUT</span><span class="p">;</span>
	    <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	    <span class="k">if</span> <span class="p">(</span> <span class="n">new_file_length</span> <span class="o">==</span> <span class="n">max_reiserfs_offset</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* prepare_for_delete_or_cut() is called by</span>
<span class="cm">		 * reiserfs_delete_item() */</span>
		<span class="n">new_file_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">delete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	    <span class="p">}</span>

	    <span class="k">do</span> <span class="p">{</span>
		<span class="n">need_re_search</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cut_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">,</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">I_UNFM_NUM</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">le_ih_k_offset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">blk_size</span> <span class="o">&gt;</span> <span class="n">new_file_length</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">__le32</span> <span class="o">*</span><span class="n">unfm</span><span class="p">;</span>
		    <span class="n">__u32</span> <span class="n">block</span><span class="p">;</span>

		    <span class="cm">/* Each unformatted block deletion may involve one additional</span>
<span class="cm">		     * bitmap block into the transaction, thereby the initial</span>
<span class="cm">		     * journal space reservation might not be enough. */</span>
		    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delete</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">cut_size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">reiserfs_transaction_free_space</span><span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		    <span class="n">unfm</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		    <span class="n">block</span> <span class="o">=</span> <span class="n">get_block_num</span><span class="p">(</span><span class="n">unfm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		    <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">put_block_num</span><span class="p">(</span><span class="n">unfm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		    <span class="p">}</span>

		    <span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		    <span class="n">cond_resched</span><span class="p">();</span>
		    <span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		    <span class="k">if</span> <span class="p">(</span><span class="n">item_moved</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>  <span class="p">{</span>
			<span class="n">need_re_search</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span>

		    <span class="n">pos</span> <span class="o">--</span><span class="p">;</span>
		    <span class="p">(</span><span class="o">*</span><span class="n">removed</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		    <span class="p">(</span><span class="o">*</span><span class="n">cut_size</span><span class="p">)</span> <span class="o">-=</span> <span class="n">UNFM_P_SIZE</span><span class="p">;</span>

		    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">(</span><span class="o">*</span><span class="n">cut_size</span><span class="p">)</span> <span class="o">-=</span> <span class="n">IH_SIZE</span><span class="p">;</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">M_DELETE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		    <span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* a trick.  If the buffer has been logged, this will do nothing.  If</span>
<span class="cm">		** we&#39;ve broken the loop without logging it, it will restore the</span>
<span class="cm">		** buffer */</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_re_search</span> <span class="o">&amp;&amp;</span>
		     <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">item_key</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span><span class="p">);</span>
	    <span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">UNFM_P_SIZE</span><span class="p">;</span>

	    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cut_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Nothing were cut. maybe convert last unformatted node to the</span>
<span class="cm">		 * direct item? */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">M_CONVERT</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Calculate number of bytes which will be deleted or cut during balance */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calc_deleted_bytes_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">char</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">del_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">p_le_ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_statdata_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">del_size</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">mode</span> <span class="o">==</span>
	     <span class="n">M_DELETE</span><span class="p">)</span> <span class="o">?</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* return EMPTY_DIR_SIZE; We delete emty directoris only.</span>
<span class="cm">		 * we can&#39;t use EMPTY_DIR_SIZE, as old format dirs have a different</span>
<span class="cm">		 * empty size.  ick. FIXME, is this right? */</span>
		<span class="k">return</span> <span class="n">del_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span>
		<span class="n">del_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">del_size</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span><span class="p">)</span> <span class="o">*</span>
				<span class="p">(</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">del_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_tb_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span><span class="p">));</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">transaction_handle</span> <span class="o">=</span> <span class="n">th</span><span class="p">;</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
	<span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">PATH_OFFSET_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">padd_item</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">total_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">total_length</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">;)</span>
		<span class="n">item</span><span class="p">[</span><span class="o">--</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
<span class="kt">char</span> <span class="nf">key2type</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_key</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;d&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_key</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_key</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;i&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_statdata_le_key</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;s&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="sc">&#39;u&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">head2type</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;d&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;i&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_statdata_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
		<span class="k">return</span> <span class="sc">&#39;s&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="sc">&#39;u&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Delete object item.</span>
<span class="cm"> * th       - active transaction handle</span>
<span class="cm"> * path     - path to the deleted item</span>
<span class="cm"> * item_key - key to search for the deleted item</span>
<span class="cm"> * indode   - used for updating i_blocks and quotas</span>
<span class="cm"> * un_bh    - NULL or unformatted node pointer</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">reiserfs_delete_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">item_key</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">un_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_balance</span> <span class="n">s_del_balance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="n">s_ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">q_ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">quota_cut_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_value</span><span class="p">,</span> <span class="n">del_size</span><span class="p">,</span> <span class="n">removed</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="kt">char</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">init_tb_struct</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_del_balance</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
		       <span class="mi">0</span> <span class="cm">/*size is unknown */</span> <span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="n">iter</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mode</span> <span class="o">=</span>
<span class="cp">#endif</span>
		    <span class="n">prepare_for_delete_or_cut</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					      <span class="n">item_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">removed</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">del_size</span><span class="p">,</span>
					      <span class="n">max_reiserfs_offset</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">M_DELETE</span><span class="p">,</span> <span class="s">&quot;PAP-5320: mode must be M_DELETE&quot;</span><span class="p">);</span>

		<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">,</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
		<span class="n">s_del_balance</span><span class="p">.</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">del_size</span><span class="p">;</span>

		<span class="n">ret_value</span> <span class="o">=</span> <span class="n">fix_nodes</span><span class="p">(</span><span class="n">M_DELETE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_del_balance</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">!=</span> <span class="n">REPEAT_SEARCH</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">delete_item_restarted</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>file system changed, repeat search</p></td><td class="code"><div class="highlight"><pre>		<span class="n">ret_value</span> <span class="o">=</span>
		    <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">item_key</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">==</span> <span class="n">FILE_NOT_FOUND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-5340&quot;</span><span class="p">,</span>
					 <span class="s">&quot;no items of the file %K found&quot;</span><span class="p">,</span>
					 <span class="n">item_key</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>			<span class="cm">/* while (1) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unfix_nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_del_balance</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>reiserfs<em>delete</em>item returns item length when success</p></td><td class="code"><div class="highlight"><pre>	<span class="n">ret_value</span> <span class="o">=</span> <span class="n">calc_deleted_bytes_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_del_balance</span><span class="p">,</span> <span class="n">M_DELETE</span><span class="p">);</span>
	<span class="n">q_ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">quota_cut_bytes</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">q_ih</span><span class="p">);</span>

	<span class="cm">/* hack so the quota code doesn&#39;t have to guess if the file</span>
<span class="cm">	 ** has a tail.  On tail insert, we allocate quota for 1 unformatted node.</span>
<span class="cm">	 ** We test the offset because the tail might have been</span>
<span class="cm">	 ** split into multiple items, and we only want to decrement for</span>
<span class="cm">	 ** the unfm node once</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">q_ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">q_ih</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">quota_cut_bytes</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">+</span> <span class="n">UNFM_P_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">quota_cut_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">un_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">off</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* We are in direct2indirect conversion, so move tail contents</span>
<span class="cm">		   to the unformatted node */</span>
		<span class="cm">/* note, we do the copy before preparing the buffer because we</span>
<span class="cm">		 ** don&#39;t care about the contents of the unformatted node yet.</span>
<span class="cm">		 ** the only thing we really care about is the direct item&#39;s data</span>
<span class="cm">		 ** is in the unformatted node.</span>
<span class="cm">		 **</span>
<span class="cm">		 ** Otherwise, we would have to call reiserfs_prepare_for_journal on</span>
<span class="cm">		 ** the unformatted node, which might schedule, meaning we&#39;d have to</span>
<span class="cm">		 ** loop all the way back up to the start of the while loop.</span>
<span class="cm">		 **</span>
<span class="cm">		 ** The unformatted node must be dirtied later on.  We can&#39;t be</span>
<span class="cm">		 ** sure here if the entire tail has been deleted yet.</span>
<span class="cm">		 **</span>
<span class="cm">		 ** un_bh is from the page cache (all unformatted nodes are</span>
<span class="cm">		 ** from the page cache) and might be a highmem page.  So, we</span>
<span class="cm">		 ** can&#39;t use un_bh-&gt;b_data.</span>
<span class="cm">		 ** -clm</span>
<span class="cm">		 */</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">un_bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>
		<span class="n">off</span> <span class="o">=</span> <span class="p">((</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span>
		       <span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">s_ih</span><span class="p">),</span>
		       <span class="n">ret_value</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Perform balancing after all resources have been collected at once. */</span>
	<span class="n">do_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_del_balance</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">M_DELETE</span><span class="p">);</span>

<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
	<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
		       <span class="s">&quot;reiserquota delete_item(): freeing %u, id=%u type=%c&quot;</span><span class="p">,</span>
		       <span class="n">quota_cut_bytes</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">head2type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ih</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">dquot_free_space_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">quota_cut_bytes</span><span class="p">);</span>

	<span class="cm">/* Return deleted body length */</span>
	<span class="k">return</span> <span class="n">ret_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Summary Of Mechanisms For Handling Collisions Between Processes:</span>

<span class="cm"> deletion of the body of the object is performed by iput(), with the</span>
<span class="cm"> result that if multiple processes are operating on a file, the</span>
<span class="cm"> deletion of the body of the file is deferred until the last process</span>
<span class="cm"> that has an open inode performs its iput().</span>

<span class="cm"> writes and truncates are protected from collisions by use of</span>
<span class="cm"> semaphores.</span>

<span class="cm"> creates, linking, and mknod are protected from collisions with other</span>
<span class="cm"> processes by making the reiserfs_add_entry() the last step in the</span>
<span class="cm"> creation, and then rolling back all changes if there was a collision.</span>
<span class="cm"> - Hans</span>
<span class="cm">*/</span>

<span class="cm">/* this deletes item which never gets split */</span>
<span class="kt">void</span> <span class="nf">reiserfs_delete_solid_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_balance</span> <span class="n">tb</span><span class="p">;</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">item_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tb_init</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">cpu_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">quota_cut_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">le_key2cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_key</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">search_item</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;vs-5350&quot;</span><span class="p">,</span>
				       <span class="s">&quot;i/o failure occurred trying &quot;</span>
				       <span class="s">&quot;to delete %K&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_key</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">ITEM_FOUND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>No need for a warning, if there is just no free space to insert '..' item into the newly-created subdir</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span>
			    <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			     <span class="n">GET_HASH_VALUE</span><span class="p">(</span><span class="n">le_key_k_offset</span>
					    <span class="p">(</span><span class="n">le_key_version</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">key</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
			     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			     <span class="n">GET_GENERATION_NUMBER</span><span class="p">(</span><span class="n">le_key_k_offset</span>
						   <span class="p">(</span><span class="n">le_key_version</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
						    <span class="n">key</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;vs-5355&quot;</span><span class="p">,</span>
						 <span class="s">&quot;%k not found&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb_init</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tb_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">item_len</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">));</span>
			<span class="n">init_tb_struct</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tb</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span>
				       <span class="o">-</span><span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">item_len</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">quota_cut_bytes</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">));</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">fix_nodes</span><span class="p">(</span><span class="n">M_DELETE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">REPEAT_SEARCH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">delete_solid_item_restarted</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">CARRY_ON</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">do_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">M_DELETE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Should we count quota for item? (we don&#39;t count quotas for save-links) */</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
				<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
					       <span class="s">&quot;reiserquota delete_solid_item(): freeing %u id=%u type=%c&quot;</span><span class="p">,</span>
					       <span class="n">quota_cut_bytes</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span>
					       <span class="n">key2type</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="cp">#endif</span>
				<span class="n">dquot_free_space_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
							 <span class="n">quota_cut_bytes</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>IO<em>ERROR, NO</em>DISK_SPACE, etc</p></td><td class="code"><div class="highlight"><pre>		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;vs-5360&quot;</span><span class="p">,</span>
				 <span class="s">&quot;could not delete %K due to fix_nodes failure&quot;</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">cpu_key</span><span class="p">);</span>
		<span class="n">unfix_nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_delete_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="cm">/* for directory this deletes item containing &quot;.&quot; and &quot;..&quot; */</span>
	<span class="n">err</span> <span class="o">=</span>
	    <span class="n">reiserfs_do_truncate</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/*no timestamp updates */</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="cp">#if defined( USE_INODE_GENERATION_COUNTER )</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_format_only</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="o">*</span><span class="n">inode_generation</span><span class="p">;</span>

		<span class="n">inode_generation</span> <span class="o">=</span>
		    <span class="o">&amp;</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rs</span><span class="o">-&gt;</span><span class="n">s_inode_generation</span><span class="p">;</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="n">inode_generation</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cm">/* USE_INODE_GENERATION_COUNTER */</span>
<span class="cp">#endif</span>
	<span class="n">reiserfs_delete_solid_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cur_index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tail_index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">cur_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>

				<span class="cm">/* we want to unmap the buffers that contain the tail, and</span>
<span class="cm">				 ** all the buffers after it (since the tail must be at the</span>
<span class="cm">				 ** end of the file).  We don&#39;t want to unmap file data</span>
<span class="cm">				 ** before the tail, since it might be dirty and waiting to</span>
<span class="cm">				 ** reach disk</span>
<span class="cm">				 */</span>
				<span class="n">cur_index</span> <span class="o">+=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cur_index</span> <span class="o">&gt;</span> <span class="n">tail_index</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">reiserfs_unmap_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">maybe_indirect_to_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">item_key</span><span class="p">,</span>
				    <span class="n">loff_t</span> <span class="n">new_file_size</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cut_bytes</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">new_file_size</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>

	<span class="cm">/* the page being sent in could be NULL if there was an i/o error</span>
<span class="cm">	 ** reading in the last block.  The user will hit problems trying to</span>
<span class="cm">	 ** read the file, but for now we just skip the indirect2direct</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">tail_has_to_be_packed</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">page</span> <span class="o">||</span> <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">i_nopack_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* leave tail in an unformatted node */</span>
		<span class="o">*</span><span class="n">mode</span> <span class="o">=</span> <span class="n">M_SKIP_BALANCING</span><span class="p">;</span>
		<span class="n">cut_bytes</span> <span class="o">=</span>
		    <span class="n">block_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">new_file_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">cut_bytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Perform the conversion to a direct_item. */</span>
	<span class="cm">/* return indirect_to_direct(inode, path, item_key,</span>
<span class="cm">				  new_file_size, mode); */</span>
	<span class="k">return</span> <span class="n">indirect2direct</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">item_key</span><span class="p">,</span>
			       <span class="n">new_file_size</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* we did indirect_to_direct conversion. And we have inserted direct</span>
<span class="cm">   item successesfully, but there were no disk space to cut unfm</span>
<span class="cm">   pointer being converted. Therefore we have to delete inserted</span>
<span class="cm">   direct item(s) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">indirect_to_direct_roll_back</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">tail_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tail_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">removed</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TYPE_DIRECT</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="c1">// !!!!</span>
	<span class="n">tail_key</span><span class="p">.</span><span class="n">key_length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">tail_len</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail_key</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tail_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* look for the last byte of the tail */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_key</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">POSITION_NOT_FOUND</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-5615&quot;</span><span class="p">,</span>
				       <span class="s">&quot;found invalid item&quot;</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">pos_in_item</span> <span class="o">!=</span>
		       <span class="n">ih_item_len</span><span class="p">(</span><span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="s">&quot;vs-5616: appended bytes found&quot;</span><span class="p">);</span>
		<span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>

		<span class="n">removed</span> <span class="o">=</span>
		    <span class="n">reiserfs_delete_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					 <span class="nb">NULL</span> <span class="cm">/*unbh not needed */</span> <span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">removed</span> <span class="o">&lt;=</span> <span class="mi">0</span>
		       <span class="o">||</span> <span class="n">removed</span> <span class="o">&gt;</span> <span class="n">tail_len</span><span class="p">,</span>
		       <span class="s">&quot;vs-5617: there was tail %d bytes, removed item length %d bytes&quot;</span><span class="p">,</span>
		       <span class="n">tail_len</span><span class="p">,</span> <span class="n">removed</span><span class="p">);</span>
		<span class="n">tail_len</span> <span class="o">-=</span> <span class="n">removed</span><span class="p">;</span>
		<span class="n">set_cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail_key</span><span class="p">,</span>
				     <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail_key</span><span class="p">)</span> <span class="o">-</span> <span class="n">removed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-5091&quot;</span><span class="p">,</span> <span class="s">&quot;indirect_to_direct &quot;</span>
			 <span class="s">&quot;conversion has been rolled back due to &quot;</span>
			 <span class="s">&quot;lack of disk space&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>mark<em>file</em>without_tail (inode);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* (Truncate or cut entry) or delete object item. Returns &lt; 0 on failure */</span>
<span class="kt">int</span> <span class="nf">reiserfs_cut_from_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">item_key</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_file_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="cm">/* Every function which is going to call do_balance must first</span>
<span class="cm">	   create a tree_balance structure.  Then it must fill up this</span>
<span class="cm">	   structure by using the init_tb_struct and fix_nodes functions.</span>
<span class="cm">	   After that we can make tree balancing. */</span>
	<span class="k">struct</span> <span class="n">tree_balance</span> <span class="n">s_cut_balance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">p_le_ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cut_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Amount to be cut. */</span>
	    <span class="n">ret_value</span> <span class="o">=</span> <span class="n">CARRY_ON</span><span class="p">,</span> <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Number of the removed unformatted nodes. */</span>
	    <span class="n">is_inode_locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">mode</span><span class="p">;</span>		<span class="cm">/* Mode of the balance. */</span>
	<span class="kt">int</span> <span class="n">retval2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">quota_cut_bytes</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">tail_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">init_tb_struct</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_cut_balance</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
		       <span class="n">cut_size</span><span class="p">);</span>

	<span class="cm">/* Repeat this loop until we either cut the item without needing</span>
<span class="cm">	   to balance, or we fix_nodes without schedule occurring */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Determine the balance mode, position of the first byte to</span>
<span class="cm">		   be cut, and size to be cut.  In case of the indirect item</span>
<span class="cm">		   free unformatted nodes which are pointed to by the cut</span>
<span class="cm">		   pointers. */</span>

		<span class="n">mode</span> <span class="o">=</span>
		    <span class="n">prepare_for_delete_or_cut</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					      <span class="n">item_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">removed</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">cut_size</span><span class="p">,</span> <span class="n">new_file_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_CONVERT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* convert last unformatted node to direct item or leave</span>
<span class="cm">			   tail in the unformatted node */</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">ret_value</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">,</span>
			       <span class="s">&quot;PAP-5570: can not convert twice&quot;</span><span class="p">);</span>

			<span class="n">ret_value</span> <span class="o">=</span>
			    <span class="n">maybe_indirect_to_direct</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
						     <span class="n">path</span><span class="p">,</span> <span class="n">item_key</span><span class="p">,</span>
						     <span class="n">new_file_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_SKIP_BALANCING</span><span class="p">)</span>
				<span class="cm">/* tail has been left in the unformatted node */</span>
				<span class="k">return</span> <span class="n">ret_value</span><span class="p">;</span>

			<span class="n">is_inode_locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* removing of last unformatted node will change value we</span>
<span class="cm">			   have to return to truncate. Save it */</span>
			<span class="n">retval2</span> <span class="o">=</span> <span class="n">ret_value</span><span class="p">;</span>
			<span class="cm">/*retval2 = sb-&gt;s_blocksize - (new_file_size &amp; (sb-&gt;s_blocksize - 1)); */</span>

			<span class="cm">/* So, we have performed the first part of the conversion:</span>
<span class="cm">			   inserting the new direct item.  Now we are removing the</span>
<span class="cm">			   last unformatted node pointer. Set key to search for</span>
<span class="cm">			   it. */</span>
			<span class="n">set_cpu_key_k_type</span><span class="p">(</span><span class="n">item_key</span><span class="p">,</span> <span class="n">TYPE_INDIRECT</span><span class="p">);</span>
			<span class="n">item_key</span><span class="o">-&gt;</span><span class="n">key_length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">new_file_size</span> <span class="o">-=</span>
			    <span class="p">(</span><span class="n">new_file_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="n">tail_pos</span> <span class="o">=</span> <span class="n">new_file_size</span><span class="p">;</span>
			<span class="n">set_cpu_key_k_offset</span><span class="p">(</span><span class="n">item_key</span><span class="p">,</span> <span class="n">new_file_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">search_for_position_by_key</span>
			    <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">item_key</span><span class="p">,</span>
			     <span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">POSITION_NOT_FOUND</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">print_block</span><span class="p">(</span><span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span>
					    <span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					    <span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;PAP-5580&quot;</span><span class="p">,</span> <span class="s">&quot;item to &quot;</span>
					       <span class="s">&quot;convert does not exist (%K)&quot;</span><span class="p">,</span>
					       <span class="n">item_key</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cut_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">s_cut_balance</span><span class="p">.</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cut_size</span><span class="p">;</span>

		<span class="n">ret_value</span> <span class="o">=</span> <span class="n">fix_nodes</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_cut_balance</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">!=</span> <span class="n">REPEAT_SEARCH</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">cut_from_item_restarted</span><span class="p">);</span>

		<span class="n">ret_value</span> <span class="o">=</span>
		    <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">item_key</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;PAP-5610&quot;</span><span class="p">,</span> <span class="s">&quot;item %K not found&quot;</span><span class="p">,</span>
				 <span class="n">item_key</span><span class="p">);</span>
		<span class="n">unfix_nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_cut_balance</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>			<span class="cm">/* while */</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>check fix<em>nodes results (IO</em>ERROR or NO<em>DISK</em>SPACE)</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">!=</span> <span class="n">CARRY_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_inode_locked</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>FIXME: this seems to be not needed: we are always able
to cut item</p></td><td class="code"><div class="highlight"><pre>			<span class="n">indirect_to_direct_roll_back</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_value</span> <span class="o">==</span> <span class="n">NO_DISK_SPACE</span><span class="p">)</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-5092&quot;</span><span class="p">,</span>
					 <span class="s">&quot;NO_DISK_SPACE&quot;</span><span class="p">);</span>
		<span class="n">unfix_nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_cut_balance</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* go ahead and perform balancing */</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_PASTE</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">M_INSERT</span><span class="p">,</span> <span class="s">&quot;invalid mode&quot;</span><span class="p">);</span>

	<span class="cm">/* Calculate number of bytes that need to be cut from the item. */</span>
	<span class="n">quota_cut_bytes</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">mode</span> <span class="o">==</span>
	     <span class="n">M_DELETE</span><span class="p">)</span> <span class="o">?</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">get_ih</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="o">:</span> <span class="o">-</span><span class="n">s_cut_balance</span><span class="p">.</span>
	    <span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">ret_value</span> <span class="o">=</span> <span class="n">calc_deleted_bytes_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_cut_balance</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret_value</span> <span class="o">=</span> <span class="n">retval2</span><span class="p">;</span>

	<span class="cm">/* For direct items, we only change the quota when deleting the last</span>
<span class="cm">	 ** item.</span>
<span class="cm">	 */</span>
	<span class="n">p_le_ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">s_cut_balance</span><span class="p">.</span><span class="n">tb_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_DELETE</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span>
		    <span class="mi">1</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>FIXME: this is to keep 3.5 happy</p></td><td class="code"><div class="highlight"><pre>			<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_first_direct_byte</span> <span class="o">=</span> <span class="n">U32_MAX</span><span class="p">;</span>
			<span class="n">quota_cut_bytes</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">+</span> <span class="n">UNFM_P_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">quota_cut_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_inode_locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">le_ih</span> <span class="o">=</span>
		    <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">s_cut_balance</span><span class="p">.</span><span class="n">tb_path</span><span class="p">);</span>
		<span class="cm">/* we are going to complete indirect2direct conversion. Make</span>
<span class="cm">		   sure, that we exactly remove last unformatted node pointer</span>
<span class="cm">		   of the item */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">le_ih</span><span class="p">))</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-5652&quot;</span><span class="p">,</span>
				       <span class="s">&quot;item must be indirect %h&quot;</span><span class="p">,</span> <span class="n">le_ih</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_DELETE</span> <span class="o">&amp;&amp;</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">le_ih</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNFM_P_SIZE</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-5653&quot;</span><span class="p">,</span> <span class="s">&quot;completing &quot;</span>
				       <span class="s">&quot;indirect2direct conversion indirect &quot;</span>
				       <span class="s">&quot;item %h being deleted must be of &quot;</span>
				       <span class="s">&quot;4 byte long&quot;</span><span class="p">,</span> <span class="n">le_ih</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">M_CUT</span>
		    <span class="o">&amp;&amp;</span> <span class="n">s_cut_balance</span><span class="p">.</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">UNFM_P_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-5654&quot;</span><span class="p">,</span> <span class="s">&quot;can not complete &quot;</span>
				       <span class="s">&quot;indirect2direct conversion of %h &quot;</span>
				       <span class="s">&quot;(CUT, insert_size==%d)&quot;</span><span class="p">,</span>
				       <span class="n">le_ih</span><span class="p">,</span> <span class="n">s_cut_balance</span><span class="p">.</span><span class="n">insert_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="cm">/* it would be useful to make sure, that right neighboring</span>
<span class="cm">		   item is direct item of this file */</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">do_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_cut_balance</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_inode_locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we&#39;ve done an indirect-&gt;direct conversion.  when the data block</span>
<span class="cm">		 ** was freed, it was removed from the list of blocks that must</span>
<span class="cm">		 ** be flushed before the transaction commits, make sure to</span>
<span class="cm">		 ** unmap and invalidate it</span>
<span class="cm">		 */</span>
		<span class="n">unmap_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tail_pos</span><span class="p">);</span>
		<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">i_pack_on_close_mask</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
	<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
		       <span class="s">&quot;reiserquota cut_from_item(): freeing %u id=%u type=%c&quot;</span><span class="p">,</span>
		       <span class="n">quota_cut_bytes</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="sc">&#39;?&#39;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">dquot_free_space_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">quota_cut_bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">truncate_directory</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-5655&quot;</span><span class="p">,</span> <span class="s">&quot;link count != 0&quot;</span><span class="p">);</span>

	<span class="n">set_le_key_k_offset</span><span class="p">(</span><span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">DOT_OFFSET</span><span class="p">);</span>
	<span class="n">set_le_key_k_type</span><span class="p">(</span><span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">TYPE_DIRENTRY</span><span class="p">);</span>
	<span class="n">reiserfs_delete_solid_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">set_le_key_k_offset</span><span class="p">(</span><span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">SD_OFFSET</span><span class="p">);</span>
	<span class="n">set_le_key_k_type</span><span class="p">(</span><span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">TYPE_STAT_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Truncate file to the new size. Note, this must be called with a transaction</span>
<span class="cm">   already started */</span>
<span class="kt">int</span> <span class="nf">reiserfs_do_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>	<span class="cm">/* -&gt;i_size contains new size */</span>
			 <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>	<span class="cm">/* up to date for last block */</span>
			 <span class="kt">int</span> <span class="n">update_timestamps</span>	<span class="cm">/* when it is called by</span>
<span class="cm">						   file_release to convert</span>
<span class="cm">						   the tail - no timestamps</span>
<span class="cm">						   should be updated */</span>
    <span class="p">)</span>
<span class="p">{</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">s_search_path</span><span class="p">);</span>	<span class="cm">/* Path to the current object item. */</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">p_le_ih</span><span class="p">;</span>	<span class="cm">/* Pointer to an item header. */</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">s_item_key</span><span class="p">;</span>	<span class="cm">/* Key to search for a previous file item. */</span>
	<span class="n">loff_t</span> <span class="n">file_size</span><span class="p">,</span>	<span class="cm">/* Old file size. */</span>
	 <span class="n">new_file_size</span><span class="p">;</span>	<span class="cm">/* New file size. */</span>
	<span class="kt">int</span> <span class="n">deleted</span><span class="p">;</span>		<span class="cm">/* Number of deleted or truncated bytes. */</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span>
	    <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span>
	     <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>deletion of directory - no need to update timestamps</p></td><td class="code"><div class="highlight"><pre>		<span class="n">truncate_directory</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get new file size. */</span>
	<span class="n">new_file_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>FIXME: note, that key type is unimportant here</p></td><td class="code"><div class="highlight"><pre>	<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">max_reiserfs_offset</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
		     <span class="n">TYPE_DIRECT</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span>
	    <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">s_search_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-5657&quot;</span><span class="p">,</span>
			       <span class="s">&quot;i/o failure occurred trying to truncate %K&quot;</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span> <span class="o">||</span> <span class="n">retval</span> <span class="o">==</span> <span class="n">FILE_NOT_FOUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;PAP-5660&quot;</span><span class="p">,</span>
			       <span class="s">&quot;wrong result %d of search for %K&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s_search_path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Get real file size (total length of all file items) */</span>
	<span class="n">p_le_ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_search_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_statdata_le_ih</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">))</span>
		<span class="n">file_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span>
		    <span class="n">op_bytes_number</span><span class="p">(</span><span class="n">p_le_ih</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>

		<span class="cm">/* this may mismatch with real file size: if last direct item</span>
<span class="cm">		   had no padding zeros and last unformatted node had no free</span>
<span class="cm">		   space, this file would have this file size */</span>
		<span class="n">file_size</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * are we doing a full truncate or delete, if so</span>
<span class="cm">	 * kick in the reada code</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_file_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">s_search_path</span><span class="p">.</span><span class="n">reada</span> <span class="o">=</span> <span class="n">PATH_READA</span> <span class="o">|</span> <span class="n">PATH_READA_BACK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">file_size</span> <span class="o">&lt;</span> <span class="n">new_file_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">update_and_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update key to search for the last file item. */</span>
	<span class="n">set_cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">,</span> <span class="n">file_size</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Cut or delete file item. */</span>
		<span class="n">deleted</span> <span class="o">=</span>
		    <span class="n">reiserfs_cut_from_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_search_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">,</span>
					   <span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">new_file_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">deleted</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-5665&quot;</span><span class="p">,</span>
					 <span class="s">&quot;reiserfs_cut_from_item failed&quot;</span><span class="p">);</span>
			<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_search_path</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">deleted</span> <span class="o">&gt;</span> <span class="n">file_size</span><span class="p">,</span>
		       <span class="s">&quot;PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K&quot;</span><span class="p">,</span>
		       <span class="n">deleted</span><span class="p">,</span> <span class="n">file_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">);</span>

		<span class="cm">/* Change key to search the last file item. */</span>
		<span class="n">file_size</span> <span class="o">-=</span> <span class="n">deleted</span><span class="p">;</span>

		<span class="n">set_cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">,</span> <span class="n">file_size</span><span class="p">);</span>

		<span class="cm">/* While there are bytes to truncate and previous file item is presented in the tree. */</span>

		<span class="cm">/*</span>
<span class="cm">		 ** This loop could take a really long time, and could log</span>
<span class="cm">		 ** many more blocks than a transaction can hold.  So, we do a polite</span>
<span class="cm">		 ** journal end here, and if the transaction needs ending, we make</span>
<span class="cm">		 ** sure the file is consistent before ending the current trans</span>
<span class="cm">		 ** and starting a new one</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal_transaction_should_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">reiserfs_transaction_free_space</span><span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">orig_len_alloc</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">;</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_search_path</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">update_timestamps</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">orig_len_alloc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					    <span class="n">JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD</span> <span class="o">+</span> <span class="n">JOURNAL_PER_BALANCE_CNT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">file_size</span> <span class="o">&gt;</span> <span class="n">ROUND_UP</span><span class="p">(</span><span class="n">new_file_size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_item_key</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">s_search_path</span><span class="p">)</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">file_size</span> <span class="o">&gt;</span> <span class="n">ROUND_UP</span><span class="p">(</span><span class="n">new_file_size</span><span class="p">),</span>
	       <span class="s">&quot;PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d&quot;</span><span class="p">,</span>
	       <span class="n">new_file_size</span><span class="p">,</span> <span class="n">file_size</span><span class="p">,</span> <span class="n">s_item_key</span><span class="p">.</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">);</span>

      <span class="nl">update_and_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_timestamps</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>this is truncate, not file closing</p></td><td class="code"><div class="highlight"><pre>		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

      <span class="nl">out:</span>
	<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_search_path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>this makes sure, that we <strong>append</strong>, not overwrite or add holes</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">check_research_for_paste</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">found_ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">found_ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">found_ih</span><span class="p">)</span> <span class="o">+</span>
		    <span class="n">op_bytes_number</span><span class="p">(</span><span class="n">found_ih</span><span class="p">,</span>
				    <span class="n">get_last_bh</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">op_bytes_number</span><span class="p">(</span><span class="n">found_ih</span><span class="p">,</span>
				       <span class="n">get_last_bh</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;PAP-5720&quot;</span><span class="p">,</span> <span class="s">&quot;found direct item &quot;</span>
				       <span class="s">&quot;%h or position (%d) does not match &quot;</span>
				       <span class="s">&quot;to key %K&quot;</span><span class="p">,</span> <span class="n">found_ih</span><span class="p">,</span>
				       <span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">key</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">found_ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">found_ih</span><span class="p">)</span> <span class="o">+</span>
		    <span class="n">op_bytes_number</span><span class="p">(</span><span class="n">found_ih</span><span class="p">,</span>
				    <span class="n">get_last_bh</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">I_UNFM_NUM</span><span class="p">(</span><span class="n">found_ih</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">found_ih</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;PAP-5730&quot;</span><span class="p">,</span> <span class="s">&quot;found indirect &quot;</span>
				       <span class="s">&quot;item (%h) or position (%d) does not &quot;</span>
				       <span class="s">&quot;match to key (%K)&quot;</span><span class="p">,</span>
				       <span class="n">found_ih</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">key</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* config reiserfs check */</span><span class="cp"></span>

<span class="cm">/* Paste bytes to the existing item. Returns bytes number pasted into the item. */</span>
<span class="kt">int</span> <span class="nf">reiserfs_paste_into_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span><span class="p">,</span>	<span class="cm">/* Path to the pasted item.	  */</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>	<span class="cm">/* Key to search for the needed item. */</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>	<span class="cm">/* Inode item belongs to */</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span>	<span class="cm">/* Pointer to the bytes to paste.    */</span>
			     <span class="kt">int</span> <span class="n">pasted_size</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* Size of pasted bytes.             */</span>
	<span class="k">struct</span> <span class="n">tree_balance</span> <span class="n">s_paste_balance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fs_gen</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">fs_gen</span> <span class="o">=</span> <span class="n">get_generation</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
	<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
		       <span class="s">&quot;reiserquota paste_into_item(): allocating %u id=%u type=%c&quot;</span><span class="p">,</span>
		       <span class="n">pasted_size</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span>
		       <span class="n">key2type</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">)));</span>
<span class="cp">#endif</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">dquot_alloc_space_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pasted_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="n">search_path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_tb_struct</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_paste_balance</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">search_path</span><span class="p">,</span>
		       <span class="n">pasted_size</span><span class="p">);</span>
<span class="cp">#ifdef DISPLACE_NEW_PACKING_LOCALITIES</span>
	<span class="n">s_paste_balance</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* DQUOT_* can schedule, must check before the fix_nodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fs_changed</span><span class="p">(</span><span class="n">fs_gen</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">search_again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span>
		<span class="n">fix_nodes</span><span class="p">(</span><span class="n">M_PASTE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_paste_balance</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			  <span class="n">body</span><span class="p">))</span> <span class="o">==</span> <span class="n">REPEAT_SEARCH</span><span class="p">)</span> <span class="p">{</span>
	      <span class="nl">search_again:</span>
		<span class="cm">/* file system changed while we were in the fix_nodes */</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">paste_into_item_restarted</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span>
		    <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
					       <span class="n">search_path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;PAP-5710&quot;</span><span class="p">,</span>
					 <span class="s">&quot;entry or pasted byte (%K) exists&quot;</span><span class="p">,</span>
					 <span class="n">key</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="n">check_research_for_paste</span><span class="p">(</span><span class="n">search_path</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* Perform balancing after all resources are collected by fix_nodes, and</span>
<span class="cm">	   accessing them will not risk triggering schedule. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">CARRY_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_paste_balance</span><span class="p">,</span> <span class="nb">NULL</span> <span class="cm">/*ih */</span> <span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">M_PASTE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">NO_DISK_SPACE</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
      <span class="nl">error_out:</span>
	<span class="cm">/* this also releases the path */</span>
	<span class="n">unfix_nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_paste_balance</span><span class="p">);</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
	<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
		       <span class="s">&quot;reiserquota paste_into_item(): freeing %u id=%u type=%c&quot;</span><span class="p">,</span>
		       <span class="n">pasted_size</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span>
		       <span class="n">key2type</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">)));</span>
<span class="cp">#endif</span>
	<span class="n">dquot_free_space_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pasted_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Insert new item into the buffer at the path.</span>
<span class="cm"> * th   - active transaction handle</span>
<span class="cm"> * path - path to the inserted item</span>
<span class="cm"> * ih   - pointer to the item header to insert</span>
<span class="cm"> * body - pointer to the bytes to insert</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">reiserfs_insert_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_balance</span> <span class="n">s_ins_balance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fs_gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">quota_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Do we count quotas for item? */</span>
		<span class="n">fs_gen</span> <span class="o">=</span> <span class="n">get_generation</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">quota_bytes</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

		<span class="cm">/* hack so the quota code doesn&#39;t have to guess if the file has</span>
<span class="cm">		 ** a tail, links are always tails, so there&#39;s no guessing needed</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
			<span class="n">quota_bytes</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">+</span> <span class="n">UNFM_P_SIZE</span><span class="p">;</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
		<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
			       <span class="s">&quot;reiserquota insert_item(): allocating %u id=%u type=%c&quot;</span><span class="p">,</span>
			       <span class="n">quota_bytes</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">head2type</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="cm">/* We can&#39;t dirty inode here. It would be immediately written but</span>
<span class="cm">		 * appropriate stat item isn&#39;t inserted yet... */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">dquot_alloc_space_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">quota_bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">init_tb_struct</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_ins_balance</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
		       <span class="n">IH_SIZE</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
<span class="cp">#ifdef DISPLACE_NEW_PACKING_LOCALITIES</span>
	<span class="n">s_ins_balance</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* DQUOT_* can schedule, must check to be sure calling fix_nodes is safe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="n">fs_changed</span><span class="p">(</span><span class="n">fs_gen</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">search_again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span>
		<span class="n">fix_nodes</span><span class="p">(</span><span class="n">M_INSERT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_ins_balance</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span>
			  <span class="n">body</span><span class="p">))</span> <span class="o">==</span> <span class="n">REPEAT_SEARCH</span><span class="p">)</span> <span class="p">{</span>
	      <span class="nl">search_again:</span>
		<span class="cm">/* file system changed while we were in the fix_nodes */</span>
		<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">insert_item_restarted</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">search_item</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ITEM_FOUND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="s">&quot;PAP-5760&quot;</span><span class="p">,</span>
					 <span class="s">&quot;key %K already exists in the tree&quot;</span><span class="p">,</span>
					 <span class="n">key</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* make balancing after all resources will be collected at a time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">CARRY_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ins_balance</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">M_INSERT</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">NO_DISK_SPACE</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
      <span class="nl">error_out:</span>
	<span class="cm">/* also releases the path */</span>
	<span class="n">unfix_nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_ins_balance</span><span class="p">);</span>
<span class="cp">#ifdef REISERQUOTA_DEBUG</span>
	<span class="n">reiserfs_debug</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">REISERFS_DEBUG_CODE</span><span class="p">,</span>
		       <span class="s">&quot;reiserquota insert_item(): freeing %u id=%u type=%c&quot;</span><span class="p">,</span>
		       <span class="n">quota_bytes</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">head2type</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">dquot_free_space_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">quota_bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
