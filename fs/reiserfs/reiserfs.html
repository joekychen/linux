<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › reiserfs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>reiserfs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/reiserfs_fs.h&gt;</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>

<span class="cm">/* the 32 bit compat definitions with int argument */</span>
<span class="cp">#define REISERFS_IOC32_UNPACK		_IOW(0xCD, 1, int)</span>
<span class="cp">#define REISERFS_IOC32_GETFLAGS		FS_IOC32_GETFLAGS</span>
<span class="cp">#define REISERFS_IOC32_SETFLAGS		FS_IOC32_SETFLAGS</span>
<span class="cp">#define REISERFS_IOC32_GETVERSION	FS_IOC32_GETVERSION</span>
<span class="cp">#define REISERFS_IOC32_SETVERSION	FS_IOC32_SETVERSION</span>

<span class="k">struct</span> <span class="n">reiserfs_journal_list</span><span class="p">;</span>

<span class="cm">/** bitmasks for i_flags field in reiserfs-specific part of inode */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="cm">/** this says what format of key do all items (but stat data) of</span>
<span class="cm">      an object have.  If this is set, that format is 3.6 otherwise</span>
<span class="cm">      - 3.5 */</span>
	<span class="n">i_item_key_version_mask</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
    <span class="cm">/** If this is unset, object has 3.5 stat data, otherwise, it has</span>
<span class="cm">      3.6 stat data with 64bit size, 32bit nlink etc. */</span>
	<span class="n">i_stat_data_version_mask</span> <span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
    <span class="cm">/** file might need tail packing on close */</span>
	<span class="n">i_pack_on_close_mask</span> <span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
    <span class="cm">/** don&#39;t pack tail of file */</span>
	<span class="n">i_nopack_mask</span> <span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
    <span class="cm">/** If those is set, &quot;safe link&quot; was created for this file during</span>
<span class="cm">      truncate or unlink. Safe link is used to avoid leakage of disk</span>
<span class="cm">      space on crash with some files open, but unlinked. */</span>
	<span class="n">i_link_saved_unlink_mask</span> <span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="n">i_link_saved_truncate_mask</span> <span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="n">i_has_xattr_dir</span> <span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>
	<span class="n">i_data_log</span> <span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>
<span class="p">}</span> <span class="n">reiserfs_inode_flags</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">reiserfs_inode_info</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">i_key</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* key is still 4 32 bit integers */</span>
    <span class="cm">/** transient inode flags that are never stored on disk. Bitmasks</span>
<span class="cm">      for this field are defined above. */</span>
	<span class="n">__u32</span> <span class="n">i_flags</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">i_first_direct_byte</span><span class="p">;</span>	<span class="c1">// offset of first byte stored in direct item.</span>

	<span class="cm">/* copy of persistent inode flags read from sd_attrs. */</span>
	<span class="n">__u32</span> <span class="n">i_attrs</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">i_prealloc_block</span><span class="p">;</span>	<span class="cm">/* first unused block of a sequence of unused blocks */</span>
	<span class="kt">int</span> <span class="n">i_prealloc_count</span><span class="p">;</span>	<span class="cm">/* length of that sequence */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_prealloc_list</span><span class="p">;</span>	<span class="cm">/* per-transaction list of inodes which</span>
<span class="cm">						 * have preallocated blocks */</span>

	<span class="kt">unsigned</span> <span class="n">new_packing_locality</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* new_packig_locality is created; new blocks</span>
<span class="cm">						 * for the contents of this directory should be</span>
<span class="cm">						 * displaced */</span>

	<span class="cm">/* we use these for fsync or O_SYNC to decide which transaction</span>
<span class="cm">	 ** needs to be committed in order for this inode to be properly</span>
<span class="cm">	 ** flushed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_trans_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">i_jl</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">openers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">tailpack</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_REISERFS_FS_XATTR</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">i_xattr_sem</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">reiserfs_attrs_cleared</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
<span class="p">}</span> <span class="n">reiserfs_super_block_flags</span><span class="p">;</span>

<span class="cm">/* struct reiserfs_super_block accessors/mutators</span>
<span class="cm"> * since this is a disk structure, it will always be in</span>
<span class="cm"> * little endian format. */</span>
<span class="cp">#define sb_block_count(sbp)         (le32_to_cpu((sbp)-&gt;s_v1.s_block_count))</span>
<span class="cp">#define set_sb_block_count(sbp,v)   ((sbp)-&gt;s_v1.s_block_count = cpu_to_le32(v))</span>
<span class="cp">#define sb_free_blocks(sbp)         (le32_to_cpu((sbp)-&gt;s_v1.s_free_blocks))</span>
<span class="cp">#define set_sb_free_blocks(sbp,v)   ((sbp)-&gt;s_v1.s_free_blocks = cpu_to_le32(v))</span>
<span class="cp">#define sb_root_block(sbp)          (le32_to_cpu((sbp)-&gt;s_v1.s_root_block))</span>
<span class="cp">#define set_sb_root_block(sbp,v)    ((sbp)-&gt;s_v1.s_root_block = cpu_to_le32(v))</span>

<span class="cp">#define sb_jp_journal_1st_block(sbp)  \</span>
<span class="cp">              (le32_to_cpu((sbp)-&gt;s_v1.s_journal.jp_journal_1st_block))</span>
<span class="cp">#define set_sb_jp_journal_1st_block(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_journal.jp_journal_1st_block = cpu_to_le32(v))</span>
<span class="cp">#define sb_jp_journal_dev(sbp) \</span>
<span class="cp">              (le32_to_cpu((sbp)-&gt;s_v1.s_journal.jp_journal_dev))</span>
<span class="cp">#define set_sb_jp_journal_dev(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_journal.jp_journal_dev = cpu_to_le32(v))</span>
<span class="cp">#define sb_jp_journal_size(sbp) \</span>
<span class="cp">              (le32_to_cpu((sbp)-&gt;s_v1.s_journal.jp_journal_size))</span>
<span class="cp">#define set_sb_jp_journal_size(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_journal.jp_journal_size = cpu_to_le32(v))</span>
<span class="cp">#define sb_jp_journal_trans_max(sbp) \</span>
<span class="cp">              (le32_to_cpu((sbp)-&gt;s_v1.s_journal.jp_journal_trans_max))</span>
<span class="cp">#define set_sb_jp_journal_trans_max(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_journal.jp_journal_trans_max = cpu_to_le32(v))</span>
<span class="cp">#define sb_jp_journal_magic(sbp) \</span>
<span class="cp">              (le32_to_cpu((sbp)-&gt;s_v1.s_journal.jp_journal_magic))</span>
<span class="cp">#define set_sb_jp_journal_magic(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_journal.jp_journal_magic = cpu_to_le32(v))</span>
<span class="cp">#define sb_jp_journal_max_batch(sbp) \</span>
<span class="cp">              (le32_to_cpu((sbp)-&gt;s_v1.s_journal.jp_journal_max_batch))</span>
<span class="cp">#define set_sb_jp_journal_max_batch(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_journal.jp_journal_max_batch = cpu_to_le32(v))</span>
<span class="cp">#define sb_jp_jourmal_max_commit_age(sbp) \</span>
<span class="cp">              (le32_to_cpu((sbp)-&gt;s_v1.s_journal.jp_journal_max_commit_age))</span>
<span class="cp">#define set_sb_jp_journal_max_commit_age(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_journal.jp_journal_max_commit_age = cpu_to_le32(v))</span>

<span class="cp">#define sb_blocksize(sbp)          (le16_to_cpu((sbp)-&gt;s_v1.s_blocksize))</span>
<span class="cp">#define set_sb_blocksize(sbp,v)    ((sbp)-&gt;s_v1.s_blocksize = cpu_to_le16(v))</span>
<span class="cp">#define sb_oid_maxsize(sbp)        (le16_to_cpu((sbp)-&gt;s_v1.s_oid_maxsize))</span>
<span class="cp">#define set_sb_oid_maxsize(sbp,v)  ((sbp)-&gt;s_v1.s_oid_maxsize = cpu_to_le16(v))</span>
<span class="cp">#define sb_oid_cursize(sbp)        (le16_to_cpu((sbp)-&gt;s_v1.s_oid_cursize))</span>
<span class="cp">#define set_sb_oid_cursize(sbp,v)  ((sbp)-&gt;s_v1.s_oid_cursize = cpu_to_le16(v))</span>
<span class="cp">#define sb_umount_state(sbp)       (le16_to_cpu((sbp)-&gt;s_v1.s_umount_state))</span>
<span class="cp">#define set_sb_umount_state(sbp,v) ((sbp)-&gt;s_v1.s_umount_state = cpu_to_le16(v))</span>
<span class="cp">#define sb_fs_state(sbp)           (le16_to_cpu((sbp)-&gt;s_v1.s_fs_state))</span>
<span class="cp">#define set_sb_fs_state(sbp,v)     ((sbp)-&gt;s_v1.s_fs_state = cpu_to_le16(v))</span>
<span class="cp">#define sb_hash_function_code(sbp) \</span>
<span class="cp">              (le32_to_cpu((sbp)-&gt;s_v1.s_hash_function_code))</span>
<span class="cp">#define set_sb_hash_function_code(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_hash_function_code = cpu_to_le32(v))</span>
<span class="cp">#define sb_tree_height(sbp)        (le16_to_cpu((sbp)-&gt;s_v1.s_tree_height))</span>
<span class="cp">#define set_sb_tree_height(sbp,v)  ((sbp)-&gt;s_v1.s_tree_height = cpu_to_le16(v))</span>
<span class="cp">#define sb_bmap_nr(sbp)            (le16_to_cpu((sbp)-&gt;s_v1.s_bmap_nr))</span>
<span class="cp">#define set_sb_bmap_nr(sbp,v)      ((sbp)-&gt;s_v1.s_bmap_nr = cpu_to_le16(v))</span>
<span class="cp">#define sb_version(sbp)            (le16_to_cpu((sbp)-&gt;s_v1.s_version))</span>
<span class="cp">#define set_sb_version(sbp,v)      ((sbp)-&gt;s_v1.s_version = cpu_to_le16(v))</span>

<span class="cp">#define sb_mnt_count(sbp)	   (le16_to_cpu((sbp)-&gt;s_mnt_count))</span>
<span class="cp">#define set_sb_mnt_count(sbp, v)   ((sbp)-&gt;s_mnt_count = cpu_to_le16(v))</span>

<span class="cp">#define sb_reserved_for_journal(sbp) \</span>
<span class="cp">              (le16_to_cpu((sbp)-&gt;s_v1.s_reserved_for_journal))</span>
<span class="cp">#define set_sb_reserved_for_journal(sbp,v) \</span>
<span class="cp">              ((sbp)-&gt;s_v1.s_reserved_for_journal = cpu_to_le16(v))</span>

<span class="cm">/* LOGGING -- */</span>

<span class="cm">/* These all interelate for performance.</span>
<span class="cm">**</span>
<span class="cm">** If the journal block count is smaller than n transactions, you lose speed.</span>
<span class="cm">** I don&#39;t know what n is yet, I&#39;m guessing 8-16.</span>
<span class="cm">**</span>
<span class="cm">** typical transaction size depends on the application, how often fsync is</span>
<span class="cm">** called, and how many metadata blocks you dirty in a 30 second period.</span>
<span class="cm">** The more small files (&lt;16k) you use, the larger your transactions will</span>
<span class="cm">** be.</span>
<span class="cm">**</span>
<span class="cm">** If your journal fills faster than dirty buffers get flushed to disk, it must flush them before allowing the journal</span>
<span class="cm">** to wrap, which slows things down.  If you need high speed meta data updates, the journal should be big enough</span>
<span class="cm">** to prevent wrapping before dirty meta blocks get to disk.</span>
<span class="cm">**</span>
<span class="cm">** If the batch max is smaller than the transaction max, you&#39;ll waste space at the end of the journal</span>
<span class="cm">** because journal_end sets the next transaction to start at 0 if the next transaction has any chance of wrapping.</span>
<span class="cm">**</span>
<span class="cm">** The large the batch max age, the better the speed, and the more meta data changes you&#39;ll lose after a crash.</span>
<span class="cm">**</span>
<span class="cm">*/</span>

<span class="cm">/* don&#39;t mess with these for a while */</span>
				<span class="cm">/* we have a node size define somewhere in reiserfs_fs.h. -Hans */</span>
<span class="cp">#define JOURNAL_BLOCK_SIZE  4096	</span><span class="cm">/* BUG gotta get rid of this */</span><span class="cp"></span>
<span class="cp">#define JOURNAL_MAX_CNODE   1500	</span><span class="cm">/* max cnodes to allocate. */</span><span class="cp"></span>
<span class="cp">#define JOURNAL_HASH_SIZE 8192</span>
<span class="cp">#define JOURNAL_NUM_BITMAPS 5	</span><span class="cm">/* number of copies of the bitmaps to have floating.  Must be &gt;= 2 */</span><span class="cp"></span>

<span class="cm">/* One of these for every block in every transaction</span>
<span class="cm">** Each one is in two hash tables.  First, a hash of the current transaction, and after journal_end, a</span>
<span class="cm">** hash of all the in memory transactions.</span>
<span class="cm">** next and prev are used by the current transaction (journal_hash).</span>
<span class="cm">** hnext and hprev are used by journal_list_hash.  If a block is in more than one transaction, the journal_list_hash</span>
<span class="cm">** links it in multiple times.  This allows flush_journal_list to remove just the cnode belonging</span>
<span class="cm">** to a given transaction.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>	<span class="cm">/* real buffer head */</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>	<span class="cm">/* dev of real buffer head */</span>
	<span class="n">__u32</span> <span class="n">blocknr</span><span class="p">;</span>		<span class="cm">/* block number of real buffer head, == 0 when buffer on disk */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jlist</span><span class="p">;</span>	<span class="cm">/* journal list this cnode lives in */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/* next in transaction list */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>	<span class="cm">/* prev in transaction list */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">hprev</span><span class="p">;</span>	<span class="cm">/* prev in hash list */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">hnext</span><span class="p">;</span>	<span class="cm">/* next in hash list */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">journal_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_node</span> <span class="o">**</span><span class="n">bitmaps</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">** one of these for each transaction.  The most important part here is the j_realblock.</span>
<span class="cm">** this list of cnodes is used to hash all the blocks in all the commits, to mark all the</span>
<span class="cm">** real buffer heads dirty once all the commits hit the disk,</span>
<span class="cm">** and to make sure every real block in a transaction is on disk before allowing the log area</span>
<span class="cm">** to be overwritten */</span>
<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_len</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">j_nonzerolen</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">j_commit_left</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">j_older_commits_done</span><span class="p">;</span>	<span class="cm">/* all commits older than this on disk */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">j_commit_mutex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_trans_id</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">j_timestamp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="n">j_list_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">j_commit_bh</span><span class="p">;</span>	<span class="cm">/* commit buffer head */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">j_realblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">j_freedlist</span><span class="p">;</span>	<span class="cm">/* list of buffers that were freed during this trans.  free each of these on flush */</span>
	<span class="cm">/* time ordered list of all active transactions */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_list</span><span class="p">;</span>

	<span class="cm">/* time ordered list of all transactions we haven&#39;t tried to flush yet */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_working_list</span><span class="p">;</span>

	<span class="cm">/* list of tail conversion targets in need of flush before commit */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_tail_bh_list</span><span class="p">;</span>
	<span class="cm">/* list of data=ordered buffers in need of flush before commit */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_bh_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j_refcount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">j_ap_blocks</span><span class="p">;</span>	<span class="cm">/* journal blocks on disk */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">j_last</span><span class="p">;</span>	<span class="cm">/* newest journal block */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">j_first</span><span class="p">;</span>	<span class="cm">/*  oldest journal block.  start here for traverse */</span>

	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">j_dev_bd</span><span class="p">;</span>
	<span class="n">fmode_t</span> <span class="n">j_dev_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j_1st_reserved_block</span><span class="p">;</span>	<span class="cm">/* first block on s_dev of reserved area journal */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_trans_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_mount_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_start</span><span class="p">;</span>	<span class="cm">/* start of current waiting commit (index into j_ap_blocks) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_len</span><span class="p">;</span>	<span class="cm">/* length of current waiting commit */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_len_alloc</span><span class="p">;</span>	<span class="cm">/* number of buffers requested by journal_begin() */</span>
	<span class="n">atomic_t</span> <span class="n">j_wcount</span><span class="p">;</span>	<span class="cm">/* count of writers for current commit */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_bcount</span><span class="p">;</span>	<span class="cm">/* batch count. allows turning X transactions into 1 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_first_unflushed_offset</span><span class="p">;</span>	<span class="cm">/* first unflushed transactions offset */</span>
	<span class="kt">unsigned</span> <span class="n">j_last_flush_trans_id</span><span class="p">;</span>	<span class="cm">/* last fully flushed journal timestamp */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">j_header_bh</span><span class="p">;</span>

	<span class="kt">time_t</span> <span class="n">j_trans_start_time</span><span class="p">;</span>	<span class="cm">/* time this transaction started */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">j_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">j_flush_mutex</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">j_join_wait</span><span class="p">;</span>	<span class="cm">/* wait for current transaction to finish before starting new one */</span>
	<span class="n">atomic_t</span> <span class="n">j_jlock</span><span class="p">;</span>	<span class="cm">/* lock for j_join_wait */</span>
	<span class="kt">int</span> <span class="n">j_list_bitmap_index</span><span class="p">;</span>	<span class="cm">/* number of next list bitmap to use */</span>
	<span class="kt">int</span> <span class="n">j_must_wait</span><span class="p">;</span>	<span class="cm">/* no more journal begins allowed. MUST sleep on j_join_wait */</span>
	<span class="kt">int</span> <span class="n">j_next_full_flush</span><span class="p">;</span>	<span class="cm">/* next journal_end will flush all journal list */</span>
	<span class="kt">int</span> <span class="n">j_next_async_flush</span><span class="p">;</span>	<span class="cm">/* next journal_end will flush all async commits */</span>

	<span class="kt">int</span> <span class="n">j_cnode_used</span><span class="p">;</span>	<span class="cm">/* number of cnodes on the used list */</span>
	<span class="kt">int</span> <span class="n">j_cnode_free</span><span class="p">;</span>	<span class="cm">/* number of cnodes on the free list */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_trans_max</span><span class="p">;</span>	<span class="cm">/* max number of blocks in a transaction.  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_max_batch</span><span class="p">;</span>	<span class="cm">/* max number of blocks to batch into a trans */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_max_commit_age</span><span class="p">;</span>	<span class="cm">/* in seconds, how old can an async commit be */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_max_trans_age</span><span class="p">;</span>	<span class="cm">/* in seconds, how old can a transaction be */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_default_max_commit_age</span><span class="p">;</span>	<span class="cm">/* the default for the max commit age */</span>

	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">j_cnode_free_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">j_cnode_free_orig</span><span class="p">;</span>	<span class="cm">/* orig pointer returned from vmalloc */</span>

	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">j_current_jl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j_free_bitmap_nodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j_used_bitmap_nodes</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">j_num_lists</span><span class="p">;</span>	<span class="cm">/* total number of active transactions */</span>
	<span class="kt">int</span> <span class="n">j_num_work_lists</span><span class="p">;</span>	<span class="cm">/* number that need attention from kreiserfsd */</span>

	<span class="cm">/* debugging to make sure things are flushed in order */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_last_flush_id</span><span class="p">;</span>

	<span class="cm">/* debugging to make sure things are committed in order */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j_last_commit_id</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_bitmap_nodes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_dirty_buffers</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">j_dirty_buffers_lock</span><span class="p">;</span>	<span class="cm">/* protects j_dirty_buffers */</span>

	<span class="cm">/* list of all active transactions */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_journal_list</span><span class="p">;</span>
	<span class="cm">/* lists that haven&#39;t been touched by writeback attempts */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_working_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="n">j_list_bitmap</span><span class="p">[</span><span class="n">JOURNAL_NUM_BITMAPS</span><span class="p">];</span>	<span class="cm">/* array of bitmaps to record the deleted blocks */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">j_hash_table</span><span class="p">[</span><span class="n">JOURNAL_HASH_SIZE</span><span class="p">];</span>	<span class="cm">/* hash table for real buffer heads in current trans */</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_cnode</span> <span class="o">*</span><span class="n">j_list_hash_table</span><span class="p">[</span><span class="n">JOURNAL_HASH_SIZE</span><span class="p">];</span>	<span class="cm">/* hash table for all the real buffer heads in all</span>
<span class="cm">										   the transactions */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">j_prealloc_list</span><span class="p">;</span>	<span class="cm">/* list of inodes which have preallocated blocks */</span>
	<span class="kt">int</span> <span class="n">j_persistent_trans</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_max_trans_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j_max_batch_size</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">j_errno</span><span class="p">;</span>

	<span class="cm">/* when flushing ordered buffers, throttle new ordered writers */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">j_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">j_work_sb</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">j_async_throttle</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">journal_state_bits</span> <span class="p">{</span>
	<span class="n">J_WRITERS_BLOCKED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* set when new writers not allowed */</span>
	<span class="n">J_WRITERS_QUEUED</span><span class="p">,</span>	<span class="cm">/* set when log is full due to too many writers */</span>
	<span class="n">J_ABORTED</span><span class="p">,</span>		<span class="cm">/* set when log is aborted */</span>
<span class="p">};</span>

<span class="cp">#define JOURNAL_DESC_MAGIC &quot;ReIsErLB&quot;	</span><span class="cm">/* ick.  magic string to find desc blocks in the journal */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="n">__u32</span><span class="p">(</span><span class="o">*</span><span class="n">hashf_t</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">free_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">proc_dir_entry</span><span class="p">;</span>

<span class="cp">#if defined( CONFIG_PROC_FS ) &amp;&amp; defined( CONFIG_REISERFS_PROC_INFO )</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">stat_cnt_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">reiserfs_proc_info_data</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exiting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_hash_collisions</span><span class="p">;</span>

	<span class="n">stat_cnt_t</span> <span class="n">breads</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">bread_miss</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">search_by_key</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">search_by_key_fs_changed</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">search_by_key_restarted</span><span class="p">;</span>

	<span class="n">stat_cnt_t</span> <span class="n">insert_item_restarted</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">paste_into_item_restarted</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">cut_from_item_restarted</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">delete_solid_item_restarted</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">delete_item_restarted</span><span class="p">;</span>

	<span class="n">stat_cnt_t</span> <span class="n">leaked_oid</span><span class="p">;</span>
	<span class="n">stat_cnt_t</span> <span class="n">leaves_removable</span><span class="p">;</span>

	<span class="cm">/* balances per level. Use explicit 5 as MAX_HEIGHT is not visible yet. */</span>
	<span class="n">stat_cnt_t</span> <span class="n">balance_at</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="cm">/* sbk == search_by_key */</span>
	<span class="n">stat_cnt_t</span> <span class="n">sbk_read_at</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="n">stat_cnt_t</span> <span class="n">sbk_fs_changed</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">stat_cnt_t</span> <span class="n">sbk_restarted</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">stat_cnt_t</span> <span class="n">items_at</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="n">stat_cnt_t</span> <span class="n">free_at</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="n">stat_cnt_t</span> <span class="n">can_node_be_removed</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="kt">long</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="kt">long</span> <span class="kt">int</span> <span class="n">rnum</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="kt">long</span> <span class="kt">int</span> <span class="n">lbytes</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="kt">long</span> <span class="kt">int</span> <span class="n">rbytes</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* XXX */</span>
	<span class="n">stat_cnt_t</span> <span class="n">get_neighbors</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">stat_cnt_t</span> <span class="n">get_neighbors_restart</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">stat_cnt_t</span> <span class="n">need_l_neighbor</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">stat_cnt_t</span> <span class="n">need_r_neighbor</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="n">stat_cnt_t</span> <span class="n">free_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__scan_bitmap_stats</span> <span class="p">{</span>
		<span class="n">stat_cnt_t</span> <span class="n">call</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">wait</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">bmap</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">retry</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">in_journal_hint</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">in_journal_nohint</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">stolen</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">scan_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__journal_stats</span> <span class="p">{</span>
		<span class="n">stat_cnt_t</span> <span class="n">in_journal</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">in_journal_bitmap</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">in_journal_reusable</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">lock_journal</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">lock_journal_wait</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">journal_being</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">journal_relock_writers</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">journal_relock_wcount</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">mark_dirty</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">mark_dirty_already</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">mark_dirty_notjournal</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">restore_prepared</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">prepare</span><span class="p">;</span>
		<span class="n">stat_cnt_t</span> <span class="n">prepare_retry</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">journal</span><span class="p">;</span>
<span class="p">}</span> <span class="n">reiserfs_proc_info_data_t</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">reiserfs_proc_info_data</span> <span class="p">{</span>
<span class="p">}</span> <span class="n">reiserfs_proc_info_data_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* reiserfs union of in-core super block data */</span>
<span class="k">struct</span> <span class="n">reiserfs_sb_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">s_sbh</span><span class="p">;</span>	<span class="cm">/* Buffer containing the super block */</span>
	<span class="cm">/* both the comment and the choice of</span>
<span class="cm">	   name are unclear for s_rs -Hans */</span>
	<span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">s_rs</span><span class="p">;</span>	<span class="cm">/* Pointer to the super block in the buffer */</span>
	<span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="o">*</span><span class="n">s_ap_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">s_journal</span><span class="p">;</span>	<span class="cm">/* pointer to journal information */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">s_mount_state</span><span class="p">;</span>	<span class="cm">/* reiserfs state (valid, invalid) */</span>

	<span class="cm">/* Serialize writers access, replace the old bkl */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="cm">/* Owner of the lock (can be recursive) */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">lock_owner</span><span class="p">;</span>
	<span class="cm">/* Depth of the lock, start from -1 like the bkl */</span>
	<span class="kt">int</span> <span class="n">lock_depth</span><span class="p">;</span>

	<span class="cm">/* Comment? -Hans */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">end_io_handler</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">hashf_t</span> <span class="n">s_hash_function</span><span class="p">;</span>	<span class="cm">/* pointer to function which is used</span>
<span class="cm">					   to sort names in directory. Set on</span>
<span class="cm">					   mount */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_mount_opt</span><span class="p">;</span>	<span class="cm">/* reiserfs&#39;s mount options are set</span>
<span class="cm">					   here (currently - NOTAIL, NOLOG,</span>
<span class="cm">					   REPLAYONLY) */</span>

	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* This is a structure that describes block allocator options */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bits</span><span class="p">;</span>	<span class="cm">/* Bitfield for enable/disable kind of options */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">large_file_size</span><span class="p">;</span>	<span class="cm">/* size started from which we consider file to be a large one(in blocks) */</span>
		<span class="kt">int</span> <span class="n">border</span><span class="p">;</span>	<span class="cm">/* percentage of disk, border takes */</span>
		<span class="kt">int</span> <span class="n">preallocmin</span><span class="p">;</span>	<span class="cm">/* Minimal file size (in blocks) starting from which we do preallocations */</span>
		<span class="kt">int</span> <span class="n">preallocsize</span><span class="p">;</span>	<span class="cm">/* Number of blocks we try to prealloc when file</span>
<span class="cm">					   reaches preallocmin size (in blocks) or</span>
<span class="cm">					   prealloc_list is empty. */</span>
	<span class="p">}</span> <span class="n">s_alloc_options</span><span class="p">;</span>

	<span class="cm">/* Comment? -Hans */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">s_wait</span><span class="p">;</span>
	<span class="cm">/* To be obsoleted soon by per buffer seals.. -Hans */</span>
	<span class="n">atomic_t</span> <span class="n">s_generation_counter</span><span class="p">;</span>	<span class="c1">// increased by one every time the</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>tree gets re-balanced</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_properties</span><span class="p">;</span>	<span class="cm">/* File system properties. Currently holds</span>
<span class="cm">					   on-disk FS format */</span>

	<span class="cm">/* session statistics */</span>
	<span class="kt">int</span> <span class="n">s_disk_reads</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_disk_writes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_fix_nodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_do_balance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_unneeded_left_neighbor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_good_search_by_key_reada</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_bmaps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_bmaps_without_search</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_direct2indirect</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_indirect2direct</span><span class="p">;</span>
	<span class="cm">/* set up when it&#39;s ok for reiserfs_read_inode2() to read from</span>
<span class="cm">	   disk inode with nlink==0. Currently this is only used during</span>
<span class="cm">	   finish_unfinished() processing at mount time */</span>
	<span class="kt">int</span> <span class="n">s_is_unlinked_ok</span><span class="p">;</span>
	<span class="n">reiserfs_proc_info_data_t</span> <span class="n">s_proc_info_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">procdir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reserved_blocks</span><span class="p">;</span>	<span class="cm">/* amount of blocks reserved for further allocations */</span>
	<span class="n">spinlock_t</span> <span class="n">bitmap_lock</span><span class="p">;</span>	<span class="cm">/* this lock on now only used to protect reserved_blocks variable */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">priv_root</span><span class="p">;</span>	<span class="cm">/* root of /.reiserfs_priv */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">xattr_root</span><span class="p">;</span>	<span class="cm">/* root of /.reiserfs_priv/xattrs */</span>
	<span class="kt">int</span> <span class="n">j_errno</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">work_queued</span><span class="p">;</span>              <span class="cm">/* non-zero delayed work is queued */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">old_work</span><span class="p">;</span> <span class="cm">/* old transactions flush delayed work */</span>
	<span class="n">spinlock_t</span> <span class="n">old_work_lock</span><span class="p">;</span>     <span class="cm">/* protects old_work and work_queued */</span>

<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s_qf_names</span><span class="p">[</span><span class="n">MAXQUOTAS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">s_jquota_fmt</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s_jdev</span><span class="p">;</span>		<span class="cm">/* Stored jdev for mount option showing */</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>

	<span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">cur_tb</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">					 * Detects whether more than one</span>
<span class="cm">					 * copy of tb exists per superblock</span>
<span class="cm">					 * as a means of checking whether</span>
<span class="cm">					 * do_balance is executing concurrently</span>
<span class="cm">					 * against another tree reader/writer</span>
<span class="cm">					 * on a same mount point.</span>
<span class="cm">					 */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Definitions of reiserfs on-disk properties: */</span>
<span class="cp">#define REISERFS_3_5 0</span>
<span class="cp">#define REISERFS_3_6 1</span>
<span class="cp">#define REISERFS_OLD_FORMAT 2</span>

<span class="k">enum</span> <span class="n">reiserfs_mount_options</span> <span class="p">{</span>
<span class="cm">/* Mount options */</span>
	<span class="n">REISERFS_LARGETAIL</span><span class="p">,</span>	<span class="cm">/* large tails will be created in a session */</span>
	<span class="n">REISERFS_SMALLTAIL</span><span class="p">,</span>	<span class="cm">/* small (for files less than block size) tails will be created in a session */</span>
	<span class="n">REPLAYONLY</span><span class="p">,</span>		<span class="cm">/* replay journal and return 0. Use by fsck */</span>
	<span class="n">REISERFS_CONVERT</span><span class="p">,</span>	<span class="cm">/* -o conv: causes conversion of old</span>
<span class="cm">				   format super block to the new</span>
<span class="cm">				   format. If not specified - old</span>
<span class="cm">				   partition will be dealt with in a</span>
<span class="cm">				   manner of 3.5.x */</span>

<span class="cm">/* -o hash={tea, rupasov, r5, detect} is meant for properly mounting</span>
<span class="cm">** reiserfs disks from 3.5.19 or earlier.  99% of the time, this option</span>
<span class="cm">** is not required.  If the normal autodection code can&#39;t determine which</span>
<span class="cm">** hash to use (because both hashes had the same value for a file)</span>
<span class="cm">** use this option to force a specific hash.  It won&#39;t allow you to override</span>
<span class="cm">** the existing hash on the FS, so if you have a tea hash disk, and mount</span>
<span class="cm">** with -o hash=rupasov, the mount will fail.</span>
<span class="cm">*/</span>
	<span class="n">FORCE_TEA_HASH</span><span class="p">,</span>		<span class="cm">/* try to force tea hash on mount */</span>
	<span class="n">FORCE_RUPASOV_HASH</span><span class="p">,</span>	<span class="cm">/* try to force rupasov hash on mount */</span>
	<span class="n">FORCE_R5_HASH</span><span class="p">,</span>		<span class="cm">/* try to force rupasov hash on mount */</span>
	<span class="n">FORCE_HASH_DETECT</span><span class="p">,</span>	<span class="cm">/* try to detect hash function on mount */</span>

	<span class="n">REISERFS_DATA_LOG</span><span class="p">,</span>
	<span class="n">REISERFS_DATA_ORDERED</span><span class="p">,</span>
	<span class="n">REISERFS_DATA_WRITEBACK</span><span class="p">,</span>

<span class="cm">/* used for testing experimental features, makes benchmarking new</span>
<span class="cm">   features with and without more convenient, should never be used by</span>
<span class="cm">   users in any code shipped to users (ideally) */</span>

	<span class="n">REISERFS_NO_BORDER</span><span class="p">,</span>
	<span class="n">REISERFS_NO_UNHASHED_RELOCATION</span><span class="p">,</span>
	<span class="n">REISERFS_HASHED_RELOCATION</span><span class="p">,</span>
	<span class="n">REISERFS_ATTRS</span><span class="p">,</span>
	<span class="n">REISERFS_XATTRS_USER</span><span class="p">,</span>
	<span class="n">REISERFS_POSIXACL</span><span class="p">,</span>
	<span class="n">REISERFS_EXPOSE_PRIVROOT</span><span class="p">,</span>
	<span class="n">REISERFS_BARRIER_NONE</span><span class="p">,</span>
	<span class="n">REISERFS_BARRIER_FLUSH</span><span class="p">,</span>

	<span class="cm">/* Actions on error */</span>
	<span class="n">REISERFS_ERROR_PANIC</span><span class="p">,</span>
	<span class="n">REISERFS_ERROR_RO</span><span class="p">,</span>
	<span class="n">REISERFS_ERROR_CONTINUE</span><span class="p">,</span>

	<span class="n">REISERFS_USRQUOTA</span><span class="p">,</span>	<span class="cm">/* User quota option specified */</span>
	<span class="n">REISERFS_GRPQUOTA</span><span class="p">,</span>	<span class="cm">/* Group quota option specified */</span>

	<span class="n">REISERFS_TEST1</span><span class="p">,</span>
	<span class="n">REISERFS_TEST2</span><span class="p">,</span>
	<span class="n">REISERFS_TEST3</span><span class="p">,</span>
	<span class="n">REISERFS_TEST4</span><span class="p">,</span>
	<span class="n">REISERFS_UNSUPPORTED_OPT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define reiserfs_r5_hash(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; FORCE_R5_HASH))</span>
<span class="cp">#define reiserfs_rupasov_hash(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; FORCE_RUPASOV_HASH))</span>
<span class="cp">#define reiserfs_tea_hash(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; FORCE_TEA_HASH))</span>
<span class="cp">#define reiserfs_hash_detect(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; FORCE_HASH_DETECT))</span>
<span class="cp">#define reiserfs_no_border(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_NO_BORDER))</span>
<span class="cp">#define reiserfs_no_unhashed_relocation(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_NO_UNHASHED_RELOCATION))</span>
<span class="cp">#define reiserfs_hashed_relocation(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_HASHED_RELOCATION))</span>
<span class="cp">#define reiserfs_test4(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_TEST4))</span>

<span class="cp">#define have_large_tails(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_LARGETAIL))</span>
<span class="cp">#define have_small_tails(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_SMALLTAIL))</span>
<span class="cp">#define replay_only(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REPLAYONLY))</span>
<span class="cp">#define reiserfs_attrs(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_ATTRS))</span>
<span class="cp">#define old_format_only(s) (REISERFS_SB(s)-&gt;s_properties &amp; (1 &lt;&lt; REISERFS_3_5))</span>
<span class="cp">#define convert_reiserfs(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_CONVERT))</span>
<span class="cp">#define reiserfs_data_log(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_DATA_LOG))</span>
<span class="cp">#define reiserfs_data_ordered(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_DATA_ORDERED))</span>
<span class="cp">#define reiserfs_data_writeback(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_DATA_WRITEBACK))</span>
<span class="cp">#define reiserfs_xattrs_user(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_XATTRS_USER))</span>
<span class="cp">#define reiserfs_posixacl(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_POSIXACL))</span>
<span class="cp">#define reiserfs_expose_privroot(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_EXPOSE_PRIVROOT))</span>
<span class="cp">#define reiserfs_xattrs_optional(s) (reiserfs_xattrs_user(s) || reiserfs_posixacl(s))</span>
<span class="cp">#define reiserfs_barrier_none(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_BARRIER_NONE))</span>
<span class="cp">#define reiserfs_barrier_flush(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_BARRIER_FLUSH))</span>

<span class="cp">#define reiserfs_error_panic(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_ERROR_PANIC))</span>
<span class="cp">#define reiserfs_error_ro(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; (1 &lt;&lt; REISERFS_ERROR_RO))</span>

<span class="kt">void</span> <span class="n">reiserfs_file_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">list</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">reiserfs_fs_type</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">reiserfs_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cp">#define CARRY_ON                0</span>
<span class="cp">#define SCHEDULE_OCCURRED       1</span>

<span class="cp">#define SB_BUFFER_WITH_SB(s) (REISERFS_SB(s)-&gt;s_sbh)</span>
<span class="cp">#define SB_JOURNAL(s) (REISERFS_SB(s)-&gt;s_journal)</span>
<span class="cp">#define SB_JOURNAL_1st_RESERVED_BLOCK(s) (SB_JOURNAL(s)-&gt;j_1st_reserved_block)</span>
<span class="cp">#define SB_JOURNAL_LEN_FREE(s) (SB_JOURNAL(s)-&gt;j_journal_len_free)</span>
<span class="cp">#define SB_AP_BITMAP(s) (REISERFS_SB(s)-&gt;s_ap_bitmap)</span>

<span class="cp">#define SB_DISK_JOURNAL_HEAD(s) (SB_JOURNAL(s)-&gt;j_header_bh-&gt;)</span>

<span class="cm">/* A safe version of the &quot;bdevname&quot;, which returns the &quot;s_id&quot; field of</span>
<span class="cm"> * a superblock or else &quot;Null superblock&quot; if the super block is NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">reiserfs_bdevname</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Null superblock&quot;</span> <span class="o">:</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define reiserfs_is_journal_aborted(journal) (unlikely (__reiserfs_is_journal_aborted (journal)))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__reiserfs_is_journal_aborted</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_journal</span>
						<span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">J_ABORTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Locking primitives. The write lock is a per superblock</span>
<span class="cm"> * special mutex that has properties close to the Big Kernel Lock</span>
<span class="cm"> * which was used in the previous locking scheme.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock_depth</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
<span class="kt">void</span> <span class="n">reiserfs_lock_check_recursive</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reiserfs_lock_check_recursive</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Several mutexes depend on the write lock.</span>
<span class="cm"> * However sometimes we want to relax the write lock while we hold</span>
<span class="cm"> * these mutexes, according to the release/reacquire on schedule()</span>
<span class="cm"> * properties of the Bkl that were used.</span>
<span class="cm"> * Reiserfs performances and locking were based on this scheme.</span>
<span class="cm"> * Now that the write lock is a mutex and not the bkl anymore, doing so</span>
<span class="cm"> * may result in a deadlock:</span>
<span class="cm"> *</span>
<span class="cm"> * A acquire write_lock</span>
<span class="cm"> * A acquire j_commit_mutex</span>
<span class="cm"> * A release write_lock and wait for something</span>
<span class="cm"> * B acquire write_lock</span>
<span class="cm"> * B can&#39;t acquire j_commit_mutex and sleep</span>
<span class="cm"> * A can&#39;t acquire write lock anymore</span>
<span class="cm"> * deadlock</span>
<span class="cm"> *</span>
<span class="cm"> * What we do here is avoiding such deadlock by playing the same game</span>
<span class="cm"> * than the Bkl: if we can&#39;t acquire a mutex that depends on the write lock,</span>
<span class="cm"> * we release the write lock, wait a bit and then retry.</span>
<span class="cm"> *</span>
<span class="cm"> * The mutexes concerned by this hack are:</span>
<span class="cm"> * - The commit mutex of a journal list</span>
<span class="cm"> * - The flush mutex</span>
<span class="cm"> * - The journal lock</span>
<span class="cm"> * - The inode mutex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reiserfs_mutex_lock_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reiserfs_lock_check_recursive</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">reiserfs_mutex_lock_nested_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reiserfs_lock_check_recursive</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">subclass</span><span class="p">);</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">reiserfs_down_read_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reiserfs_lock_check_recursive</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">down_read</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we schedule, we usually want to also release the write lock,</span>
<span class="cm"> * according to the previous bkl based locking scheme of reiserfs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reiserfs_cond_resched</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">fid</span><span class="p">;</span>

<span class="cm">/* in reading the #defines, it may help to understand that they employ</span>
<span class="cm">   the following abbreviations:</span>

<span class="cm">   B = Buffer</span>
<span class="cm">   I = Item header</span>
<span class="cm">   H = Height within the tree (should be changed to LEV)</span>
<span class="cm">   N = Number of the item in the node</span>
<span class="cm">   STAT = stat data</span>
<span class="cm">   DEH = Directory Entry Header</span>
<span class="cm">   EC = Entry Count</span>
<span class="cm">   E = Entry number</span>
<span class="cm">   UL = Unsigned Long</span>
<span class="cm">   BLKH = BLocK Header</span>
<span class="cm">   UNFM = UNForMatted node</span>
<span class="cm">   DC = Disk Child</span>
<span class="cm">   P = Path</span>

<span class="cm">   These #defines are named by concatenating these abbreviations,</span>
<span class="cm">   where first comes the arguments, and last comes the return value,</span>
<span class="cm">   of the macro.</span>

<span class="cm">*/</span>

<span class="cp">#define USE_INODE_GENERATION_COUNTER</span>

<span class="cp">#define REISERFS_PREALLOCATE</span>
<span class="cp">#define DISPLACE_NEW_PACKING_LOCALITIES</span>
<span class="cp">#define PREALLOCATION_SIZE 9</span>

<span class="cm">/* n must be power of 2 */</span>
<span class="cp">#define _ROUND_UP(x,n) (((x)+(n)-1u) &amp; ~((n)-1u))</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>to be ok for alpha and others we have to align structures to 8 byte
boundary.
FIXME: do not change 4 by anything else: there is code which relies on that</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define ROUND_UP(x) _ROUND_UP(x,8LL)</span>

<span class="cm">/* debug levels.  Right now, CONFIG_REISERFS_CHECK means print all debug</span>
<span class="cm">** messages.</span>
<span class="cm">*/</span>
<span class="cp">#define REISERFS_DEBUG_CODE 5	</span><span class="cm">/* extra messages to help find/debug errors */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">__reiserfs_warning</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#define reiserfs_warning(s, id, fmt, args...) \</span>
<span class="cp">	 __reiserfs_warning(s, id, __func__, fmt, ##args)</span>
<span class="cm">/* assertions handling */</span>

<span class="cm">/** always check a condition and panic if it&#39;s false. */</span>
<span class="cp">#define __RASSERT(cond, scond, format, args...)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (!(cond))							\</span>
<span class="cp">		reiserfs_panic(NULL, &quot;assertion failure&quot;, &quot;(&quot; #cond &quot;) at &quot; \</span>
<span class="cp">			       __FILE__ &quot;:%i:%s: &quot; format &quot;\n&quot;,		\</span>
<span class="cp">			       in_interrupt() ? -1 : task_pid_nr(current), \</span>
<span class="cp">			       __LINE__, __func__ , ##args);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define RASSERT(cond, format, args...) __RASSERT(cond, #cond, format, ##args)</span>

<span class="cp">#if defined( CONFIG_REISERFS_CHECK )</span>
<span class="cp">#define RFALSE(cond, format, args...) __RASSERT(!(cond), &quot;!(&quot; #cond &quot;)&quot;, format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define RFALSE( cond, format, args... ) do {;} while( 0 )</span>
<span class="cp">#endif</span>

<span class="cp">#define CONSTF __attribute_const__</span>
<span class="cm">/*</span>
<span class="cm"> * Disk Data Structures</span>
<span class="cm"> */</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                             SUPER BLOCK                                 */</span>
<span class="cm">/***************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of super block on disk, a version of which in RAM is often accessed as REISERFS_SB(s)-&gt;s_rs</span>
<span class="cm"> * the version in RAM is part of a larger structure containing fields never written to disk.</span>
<span class="cm"> */</span>
<span class="cp">#define UNSET_HASH 0		</span><span class="c1">// read_super will guess about, what hash names</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>in directories were sorted with</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define TEA_HASH  1</span>
<span class="cp">#define YURA_HASH 2</span>
<span class="cp">#define R5_HASH   3</span>
<span class="cp">#define DEFAULT_HASH R5_HASH</span>

<span class="k">struct</span> <span class="n">journal_params</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">jp_journal_1st_block</span><span class="p">;</span>	<span class="cm">/* where does journal start from on its</span>
<span class="cm">					 * device */</span>
	<span class="n">__le32</span> <span class="n">jp_journal_dev</span><span class="p">;</span>	<span class="cm">/* journal device st_rdev */</span>
	<span class="n">__le32</span> <span class="n">jp_journal_size</span><span class="p">;</span>	<span class="cm">/* size of the journal */</span>
	<span class="n">__le32</span> <span class="n">jp_journal_trans_max</span><span class="p">;</span>	<span class="cm">/* max number of blocks in a transaction. */</span>
	<span class="n">__le32</span> <span class="n">jp_journal_magic</span><span class="p">;</span>	<span class="cm">/* random value made on fs creation (this</span>
<span class="cm">					 * was sb_journal_block_count) */</span>
	<span class="n">__le32</span> <span class="n">jp_journal_max_batch</span><span class="p">;</span>	<span class="cm">/* max number of blocks to batch into a</span>
<span class="cm">					 * trans */</span>
	<span class="n">__le32</span> <span class="n">jp_journal_max_commit_age</span><span class="p">;</span>	<span class="cm">/* in seconds, how old can an async</span>
<span class="cm">						 * commit be */</span>
	<span class="n">__le32</span> <span class="n">jp_journal_max_trans_age</span><span class="p">;</span>	<span class="cm">/* in seconds, how old can a transaction</span>
<span class="cm">						 * be */</span>
<span class="p">};</span>

<span class="cm">/* this is the super from 3.5.X, where X &gt;= 10 */</span>
<span class="k">struct</span> <span class="n">reiserfs_super_block_v1</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">s_block_count</span><span class="p">;</span>	<span class="cm">/* blocks count         */</span>
	<span class="n">__le32</span> <span class="n">s_free_blocks</span><span class="p">;</span>	<span class="cm">/* free blocks count    */</span>
	<span class="n">__le32</span> <span class="n">s_root_block</span><span class="p">;</span>	<span class="cm">/* root block number    */</span>
	<span class="k">struct</span> <span class="n">journal_params</span> <span class="n">s_journal</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">s_blocksize</span><span class="p">;</span>	<span class="cm">/* block size */</span>
	<span class="n">__le16</span> <span class="n">s_oid_maxsize</span><span class="p">;</span>	<span class="cm">/* max size of object id array, see</span>
<span class="cm">				 * get_objectid() commentary  */</span>
	<span class="n">__le16</span> <span class="n">s_oid_cursize</span><span class="p">;</span>	<span class="cm">/* current size of object id array */</span>
	<span class="n">__le16</span> <span class="n">s_umount_state</span><span class="p">;</span>	<span class="cm">/* this is set to 1 when filesystem was</span>
<span class="cm">				 * umounted, to 2 - when not */</span>
	<span class="kt">char</span> <span class="n">s_magic</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="cm">/* reiserfs magic string indicates that</span>
<span class="cm">				 * file system is reiserfs:</span>
<span class="cm">				 * &quot;ReIsErFs&quot; or &quot;ReIsEr2Fs&quot; or &quot;ReIsEr3Fs&quot; */</span>
	<span class="n">__le16</span> <span class="n">s_fs_state</span><span class="p">;</span>	<span class="cm">/* it is set to used by fsck to mark which</span>
<span class="cm">				 * phase of rebuilding is done */</span>
	<span class="n">__le32</span> <span class="n">s_hash_function_code</span><span class="p">;</span>	<span class="cm">/* indicate, what hash function is being use</span>
<span class="cm">					 * to sort names in a directory*/</span>
	<span class="n">__le16</span> <span class="n">s_tree_height</span><span class="p">;</span>	<span class="cm">/* height of disk tree */</span>
	<span class="n">__le16</span> <span class="n">s_bmap_nr</span><span class="p">;</span>	<span class="cm">/* amount of bitmap blocks needed to address</span>
<span class="cm">				 * each block of file system */</span>
	<span class="n">__le16</span> <span class="n">s_version</span><span class="p">;</span>	<span class="cm">/* this field is only reliable on filesystem</span>
<span class="cm">				 * with non-standard journal */</span>
	<span class="n">__le16</span> <span class="n">s_reserved_for_journal</span><span class="p">;</span>	<span class="cm">/* size in blocks of journal area on main</span>
<span class="cm">					 * device, we need to keep after</span>
<span class="cm">					 * making fs with non-standard journal */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="cp">#define SB_SIZE_V1 (sizeof(struct reiserfs_super_block_v1))</span>

<span class="cm">/* this is the on disk super block */</span>
<span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_super_block_v1</span> <span class="n">s_v1</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">s_inode_generation</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">s_flags</span><span class="p">;</span>		<span class="cm">/* Right now used only by inode-attributes, if enabled */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">s_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* filesystem unique identifier */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">s_label</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* filesystem volume label */</span>
	<span class="n">__le16</span> <span class="n">s_mnt_count</span><span class="p">;</span>		<span class="cm">/* Count of mounts since last fsck */</span>
	<span class="n">__le16</span> <span class="n">s_max_mnt_count</span><span class="p">;</span>		<span class="cm">/* Maximum mounts before check */</span>
	<span class="n">__le32</span> <span class="n">s_lastcheck</span><span class="p">;</span>		<span class="cm">/* Timestamp of last fsck */</span>
	<span class="n">__le32</span> <span class="n">s_check_interval</span><span class="p">;</span>	<span class="cm">/* Interval between checks */</span>
	<span class="kt">char</span> <span class="n">s_unused</span><span class="p">[</span><span class="mi">76</span><span class="p">];</span>	<span class="cm">/* zero filled by mkreiserfs and</span>
<span class="cm">				 * reiserfs_convert_objectid_map_v1()</span>
<span class="cm">				 * so any additions must be updated</span>
<span class="cm">				 * there as well. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="cp">#define SB_SIZE (sizeof(struct reiserfs_super_block))</span>

<span class="cp">#define REISERFS_VERSION_1 0</span>
<span class="cp">#define REISERFS_VERSION_2 2</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>on-disk super block fields converted to cpu form</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define SB_DISK_SUPER_BLOCK(s) (REISERFS_SB(s)-&gt;s_rs)</span>
<span class="cp">#define SB_V1_DISK_SUPER_BLOCK(s) (&amp;(SB_DISK_SUPER_BLOCK(s)-&gt;s_v1))</span>
<span class="cp">#define SB_BLOCKSIZE(s) \</span>
<span class="cp">        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_blocksize))</span>
<span class="cp">#define SB_BLOCK_COUNT(s) \</span>
<span class="cp">        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_block_count))</span>
<span class="cp">#define SB_FREE_BLOCKS(s) \</span>
<span class="cp">        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_free_blocks))</span>
<span class="cp">#define SB_REISERFS_MAGIC(s) \</span>
<span class="cp">        (SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_magic)</span>
<span class="cp">#define SB_ROOT_BLOCK(s) \</span>
<span class="cp">        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_root_block))</span>
<span class="cp">#define SB_TREE_HEIGHT(s) \</span>
<span class="cp">        le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_tree_height))</span>
<span class="cp">#define SB_REISERFS_STATE(s) \</span>
<span class="cp">        le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_umount_state))</span>
<span class="cp">#define SB_VERSION(s) le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_version))</span>
<span class="cp">#define SB_BMAP_NR(s) le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_bmap_nr))</span>

<span class="cp">#define PUT_SB_BLOCK_COUNT(s, val) \</span>
<span class="cp">   do { SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_block_count = cpu_to_le32(val); } while (0)</span>
<span class="cp">#define PUT_SB_FREE_BLOCKS(s, val) \</span>
<span class="cp">   do { SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_free_blocks = cpu_to_le32(val); } while (0)</span>
<span class="cp">#define PUT_SB_ROOT_BLOCK(s, val) \</span>
<span class="cp">   do { SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_root_block = cpu_to_le32(val); } while (0)</span>
<span class="cp">#define PUT_SB_TREE_HEIGHT(s, val) \</span>
<span class="cp">   do { SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_tree_height = cpu_to_le16(val); } while (0)</span>
<span class="cp">#define PUT_SB_REISERFS_STATE(s, val) \</span>
<span class="cp">   do { SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_umount_state = cpu_to_le16(val); } while (0)</span>
<span class="cp">#define PUT_SB_VERSION(s, val) \</span>
<span class="cp">   do { SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_version = cpu_to_le16(val); } while (0)</span>
<span class="cp">#define PUT_SB_BMAP_NR(s, val) \</span>
<span class="cp">   do { SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_bmap_nr = cpu_to_le16 (val); } while (0)</span>

<span class="cp">#define SB_ONDISK_JP(s) (&amp;SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_journal)</span>
<span class="cp">#define SB_ONDISK_JOURNAL_SIZE(s) \</span>
<span class="cp">         le32_to_cpu ((SB_ONDISK_JP(s)-&gt;jp_journal_size))</span>
<span class="cp">#define SB_ONDISK_JOURNAL_1st_BLOCK(s) \</span>
<span class="cp">         le32_to_cpu ((SB_ONDISK_JP(s)-&gt;jp_journal_1st_block))</span>
<span class="cp">#define SB_ONDISK_JOURNAL_DEVICE(s) \</span>
<span class="cp">         le32_to_cpu ((SB_ONDISK_JP(s)-&gt;jp_journal_dev))</span>
<span class="cp">#define SB_ONDISK_RESERVED_FOR_JOURNAL(s) \</span>
<span class="cp">         le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)-&gt;s_reserved_for_journal))</span>

<span class="cp">#define is_block_in_log_or_reserved_area(s, block) \</span>
<span class="cp">         block &gt;= SB_JOURNAL_1st_RESERVED_BLOCK(s) \</span>
<span class="cp">         &amp;&amp; block &lt; SB_JOURNAL_1st_RESERVED_BLOCK(s) +  \</span>
<span class="cp">         ((!is_reiserfs_jr(SB_DISK_SUPER_BLOCK(s)) ? \</span>
<span class="cp">         SB_ONDISK_JOURNAL_SIZE(s) + 1 : SB_ONDISK_RESERVED_FOR_JOURNAL(s)))</span>

<span class="kt">int</span> <span class="n">is_reiserfs_3_5</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">rs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_reiserfs_3_6</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">rs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_reiserfs_jr</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">rs</span><span class="p">);</span>

<span class="cm">/* ReiserFS leaves the first 64k unused, so that partition labels have</span>
<span class="cm">   enough space.  If someone wants to write a fancy bootloader that</span>
<span class="cm">   needs more than 64k, let us know, and this will be increased in size.</span>
<span class="cm">   This number must be larger than than the largest block size on any</span>
<span class="cm">   platform, or code will break.  -Hans */</span>
<span class="cp">#define REISERFS_DISK_OFFSET_IN_BYTES (64 * 1024)</span>
<span class="cp">#define REISERFS_FIRST_BLOCK unused_define</span>
<span class="cp">#define REISERFS_JOURNAL_OFFSET_IN_BYTES REISERFS_DISK_OFFSET_IN_BYTES</span>

<span class="cm">/* the spot for the super in versions 3.5 - 3.5.10 (inclusive) */</span>
<span class="cp">#define REISERFS_OLD_DISK_OFFSET_IN_BYTES (8 * 1024)</span>

<span class="cm">/* reiserfs internal error code (used by search_by_key and fix_nodes)) */</span>
<span class="cp">#define CARRY_ON      0</span>
<span class="cp">#define REPEAT_SEARCH -1</span>
<span class="cp">#define IO_ERROR      -2</span>
<span class="cp">#define NO_DISK_SPACE -3</span>
<span class="cp">#define NO_BALANCING_NEEDED  (-4)</span>
<span class="cp">#define NO_MORE_UNUSED_CONTIGUOUS_BLOCKS (-5)</span>
<span class="cp">#define QUOTA_EXCEEDED -6</span>

<span class="k">typedef</span> <span class="n">__u32</span> <span class="n">b_blocknr_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__le32</span> <span class="n">unp_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">unfm_nodeinfo</span> <span class="p">{</span>
	<span class="n">unp_t</span> <span class="n">unfm_nodenum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">unfm_freespace</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* there are two formats of keys: 3.5 and 3.6</span>
<span class="cm"> */</span>
<span class="cp">#define KEY_FORMAT_3_5 0</span>
<span class="cp">#define KEY_FORMAT_3_6 1</span>

<span class="cm">/* there are two stat datas */</span>
<span class="cp">#define STAT_DATA_V1 0</span>
<span class="cp">#define STAT_DATA_V2 1</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">reiserfs_inode_info</span> <span class="o">*</span><span class="nf">REISERFS_I</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">reiserfs_sb_info</span> <span class="o">*</span><span class="nf">REISERFS_SB</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Don&#39;t trust REISERFS_SB(sb)-&gt;s_bmap_nr, it&#39;s a u16</span>
<span class="cm"> * which overflows on large file systems. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">reiserfs_bmap_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">SB_BLOCK_COUNT</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bmap_would_wrap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">bmap_nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bmap_nr</span> <span class="o">&gt;</span> <span class="p">((</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/** this says about version of key of all items (but stat data) the</span>
<span class="cm">    object consists of */</span>
<span class="cp">#define get_inode_item_key_version( inode )                                    \</span>
<span class="cp">    ((REISERFS_I(inode)-&gt;i_flags &amp; i_item_key_version_mask) ? KEY_FORMAT_3_6 : KEY_FORMAT_3_5)</span>

<span class="cp">#define set_inode_item_key_version( inode, version )                           \</span>
<span class="cp">         ({ if((version)==KEY_FORMAT_3_6)                                      \</span>
<span class="cp">                REISERFS_I(inode)-&gt;i_flags |= i_item_key_version_mask;      \</span>
<span class="cp">            else                                                               \</span>
<span class="cp">                REISERFS_I(inode)-&gt;i_flags &amp;= ~i_item_key_version_mask; })</span>

<span class="cp">#define get_inode_sd_version(inode)                                            \</span>
<span class="cp">    ((REISERFS_I(inode)-&gt;i_flags &amp; i_stat_data_version_mask) ? STAT_DATA_V2 : STAT_DATA_V1)</span>

<span class="cp">#define set_inode_sd_version(inode, version)                                   \</span>
<span class="cp">         ({ if((version)==STAT_DATA_V2)                                        \</span>
<span class="cp">                REISERFS_I(inode)-&gt;i_flags |= i_stat_data_version_mask;     \</span>
<span class="cp">            else                                                               \</span>
<span class="cp">                REISERFS_I(inode)-&gt;i_flags &amp;= ~i_stat_data_version_mask; })</span>

<span class="cm">/* This is an aggressive tail suppression policy, I am hoping it</span>
<span class="cm">   improves our benchmarks. The principle behind it is that percentage</span>
<span class="cm">   space saving is what matters, not absolute space saving.  This is</span>
<span class="cm">   non-intuitive, but it helps to understand it if you consider that the</span>
<span class="cm">   cost to access 4 blocks is not much more than the cost to access 1</span>
<span class="cm">   block, if you have to do a seek and rotate.  A tail risks a</span>
<span class="cm">   non-linear disk access that is significant as a percentage of total</span>
<span class="cm">   time cost for a 4 block file and saves an amount of space that is</span>
<span class="cm">   less significant as a percentage of space, or so goes the hypothesis.</span>
<span class="cm">   -Hans */</span>
<span class="cp">#define STORE_TAIL_IN_UNFM_S1(n_file_size,n_tail_size,n_block_size) \</span>
<span class="cp">(\</span>
<span class="cp">  (!(n_tail_size)) || \</span>
<span class="cp">  (((n_tail_size) &gt; MAX_DIRECT_ITEM_LEN(n_block_size)) || \</span>
<span class="cp">   ( (n_file_size) &gt;= (n_block_size) * 4 ) || \</span>
<span class="cp">   ( ( (n_file_size) &gt;= (n_block_size) * 3 ) &amp;&amp; \</span>
<span class="cp">     ( (n_tail_size) &gt;=   (MAX_DIRECT_ITEM_LEN(n_block_size))/4) ) || \</span>
<span class="cp">   ( ( (n_file_size) &gt;= (n_block_size) * 2 ) &amp;&amp; \</span>
<span class="cp">     ( (n_tail_size) &gt;=   (MAX_DIRECT_ITEM_LEN(n_block_size))/2) ) || \</span>
<span class="cp">   ( ( (n_file_size) &gt;= (n_block_size) ) &amp;&amp; \</span>
<span class="cp">     ( (n_tail_size) &gt;=   (MAX_DIRECT_ITEM_LEN(n_block_size) * 3)/4) ) ) \</span>
<span class="cp">)</span>

<span class="cm">/* Another strategy for tails, this one means only create a tail if all the</span>
<span class="cm">   file would fit into one DIRECT item.</span>
<span class="cm">   Primary intention for this one is to increase performance by decreasing</span>
<span class="cm">   seeking.</span>
<span class="cm">*/</span>
<span class="cp">#define STORE_TAIL_IN_UNFM_S2(n_file_size,n_tail_size,n_block_size) \</span>
<span class="cp">(\</span>
<span class="cp">  (!(n_tail_size)) || \</span>
<span class="cp">  (((n_file_size) &gt; MAX_DIRECT_ITEM_LEN(n_block_size)) ) \</span>
<span class="cp">)</span>

<span class="cm">/*</span>
<span class="cm"> * values for s_umount_state field</span>
<span class="cm"> */</span>
<span class="cp">#define REISERFS_VALID_FS    1</span>
<span class="cp">#define REISERFS_ERROR_FS    2</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>there are 5 item types currently</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define TYPE_STAT_DATA 0</span>
<span class="cp">#define TYPE_INDIRECT 1</span>
<span class="cp">#define TYPE_DIRECT 2</span>
<span class="cp">#define TYPE_DIRENTRY 3</span>
<span class="cp">#define TYPE_MAXTYPE 3</span>
<span class="cp">#define TYPE_ANY 15		</span><span class="c1">// FIXME: comment is required</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                       KEY &amp; ITEM HEAD                                   */</span>
<span class="cm">/***************************************************************************/</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>directories use this key as well as old files</p></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">offset_v1</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">k_offset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">k_uniqueness</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">offset_v2</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span> <span class="nf">offset_v2_k_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">offset_v2</span> <span class="o">*</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="n">type</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">60</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;=</span> <span class="n">TYPE_MAXTYPE</span><span class="p">)</span> <span class="o">?</span> <span class="n">type</span> <span class="o">:</span> <span class="n">TYPE_ANY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_offset_v2_k_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">offset_v2</span> <span class="o">*</span><span class="n">v2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">v2</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="o">~</span><span class="mi">0ULL</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">|</span> <span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">__u64</span><span class="p">)</span> <span class="n">type</span> <span class="o">&lt;&lt;</span> <span class="mi">60</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">offset_v2_k_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">offset_v2</span> <span class="o">*</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">0ULL</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_offset_v2_k_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">offset_v2</span> <span class="o">*</span><span class="n">v2</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">offset</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="mi">0ULL</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">v2</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v2</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="mi">15ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">60</span><span class="p">))</span> <span class="o">|</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Key of an item determines its location in the S+tree, and</span>
<span class="cm">   is composed of 4 components */</span>
<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">k_dir_id</span><span class="p">;</span>	<span class="cm">/* packing locality: by default parent</span>
<span class="cm">				   directory object id */</span>
	<span class="n">__le32</span> <span class="n">k_objectid</span><span class="p">;</span>	<span class="cm">/* object identifier */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">offset_v1</span> <span class="n">k_offset_v1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">offset_v2</span> <span class="n">k_offset_v2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">in_core_key</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">k_dir_id</span><span class="p">;</span>		<span class="cm">/* packing locality: by default parent</span>
<span class="cm">				   directory object id */</span>
	<span class="n">__u32</span> <span class="n">k_objectid</span><span class="p">;</span>	<span class="cm">/* object identifier */</span>
	<span class="n">__u64</span> <span class="n">k_offset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">k_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cpu_key</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_core_key</span> <span class="n">on_disk_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">key_length</span><span class="p">;</span>		<span class="cm">/* 3 in all cases but direct2indirect and</span>
<span class="cm">				   indirect2direct conversion */</span>
<span class="p">};</span>

<span class="cm">/* Our function for comparing keys can compare keys of different</span>
<span class="cm">   lengths.  It takes as a parameter the length of the keys it is to</span>
<span class="cm">   compare.  These defines are used in determining what is to be passed</span>
<span class="cm">   to it as that parameter. */</span>
<span class="cp">#define REISERFS_FULL_KEY_LEN     4</span>
<span class="cp">#define REISERFS_SHORT_KEY_LEN    2</span>

<span class="cm">/* The result of the key compare */</span>
<span class="cp">#define FIRST_GREATER 1</span>
<span class="cp">#define SECOND_GREATER -1</span>
<span class="cp">#define KEYS_IDENTICAL 0</span>
<span class="cp">#define KEY_FOUND 1</span>
<span class="cp">#define KEY_NOT_FOUND 0</span>

<span class="cp">#define KEY_SIZE (sizeof(struct reiserfs_key))</span>
<span class="cp">#define SHORT_KEY_SIZE (sizeof (__u32) + sizeof (__u32))</span>

<span class="cm">/* return values for search_by_key and clones */</span>
<span class="cp">#define ITEM_FOUND 1</span>
<span class="cp">#define ITEM_NOT_FOUND 0</span>
<span class="cp">#define ENTRY_FOUND 1</span>
<span class="cp">#define ENTRY_NOT_FOUND 0</span>
<span class="cp">#define DIRECTORY_NOT_FOUND -1</span>
<span class="cp">#define REGULAR_FILE_FOUND -2</span>
<span class="cp">#define DIRECTORY_FOUND -3</span>
<span class="cp">#define BYTE_FOUND 1</span>
<span class="cp">#define BYTE_NOT_FOUND 0</span>
<span class="cp">#define FILE_NOT_FOUND -1</span>

<span class="cp">#define POSITION_FOUND 1</span>
<span class="cp">#define POSITION_NOT_FOUND 0</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>return values for reiserfs<em>find</em>entry and search<em>by</em>entry_key</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define NAME_FOUND 1</span>
<span class="cp">#define NAME_NOT_FOUND 0</span>
<span class="cp">#define GOTO_PREVIOUS_ITEM 2</span>
<span class="cp">#define NAME_FOUND_INVISIBLE 3</span>

<span class="cm">/*  Everything in the filesystem is stored as a set of items.  The</span>
<span class="cm">    item head contains the key of the item, its free space (for</span>
<span class="cm">    indirect items) and specifies the location of the item itself</span>
<span class="cm">    within the block.  */</span>

<span class="k">struct</span> <span class="n">item_head</span> <span class="p">{</span>
	<span class="cm">/* Everything in the tree is found by searching for it based on</span>
<span class="cm">	 * its key.*/</span>
	<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="n">ih_key</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* The free space in the last unformatted node of an</span>
<span class="cm">		   indirect item if this is an indirect item.  This</span>
<span class="cm">		   equals 0xFFFF iff this is a direct item or stat data</span>
<span class="cm">		   item. Note that the key, not this field, is used to</span>
<span class="cm">		   determine the item type, and thus which field this</span>
<span class="cm">		   union contains. */</span>
		<span class="n">__le16</span> <span class="n">ih_free_space_reserved</span><span class="p">;</span>
		<span class="cm">/* Iff this is a directory item, this field equals the</span>
<span class="cm">		   number of directory entries in the directory item. */</span>
		<span class="n">__le16</span> <span class="n">ih_entry_count</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">u</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ih_item_len</span><span class="p">;</span>	<span class="cm">/* total size of the item body */</span>
	<span class="n">__le16</span> <span class="n">ih_item_location</span><span class="p">;</span>	<span class="cm">/* an offset to the item body</span>
<span class="cm">					 * within the block */</span>
	<span class="n">__le16</span> <span class="n">ih_version</span><span class="p">;</span>	<span class="cm">/* 0 for all old items, 2 for new</span>
<span class="cm">				   ones. Highest bit is set by fsck</span>
<span class="cm">				   temporary, cleaned after all</span>
<span class="cm">				   done */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>
<span class="cm">/* size of item header     */</span>
<span class="cp">#define IH_SIZE (sizeof(struct item_head))</span>

<span class="cp">#define ih_free_space(ih)            le16_to_cpu((ih)-&gt;u.ih_free_space_reserved)</span>
<span class="cp">#define ih_version(ih)               le16_to_cpu((ih)-&gt;ih_version)</span>
<span class="cp">#define ih_entry_count(ih)           le16_to_cpu((ih)-&gt;u.ih_entry_count)</span>
<span class="cp">#define ih_location(ih)              le16_to_cpu((ih)-&gt;ih_item_location)</span>
<span class="cp">#define ih_item_len(ih)              le16_to_cpu((ih)-&gt;ih_item_len)</span>

<span class="cp">#define put_ih_free_space(ih, val)   do { (ih)-&gt;u.ih_free_space_reserved = cpu_to_le16(val); } while(0)</span>
<span class="cp">#define put_ih_version(ih, val)      do { (ih)-&gt;ih_version = cpu_to_le16(val); } while (0)</span>
<span class="cp">#define put_ih_entry_count(ih, val)  do { (ih)-&gt;u.ih_entry_count = cpu_to_le16(val); } while (0)</span>
<span class="cp">#define put_ih_location(ih, val)     do { (ih)-&gt;ih_item_location = cpu_to_le16(val); } while (0)</span>
<span class="cp">#define put_ih_item_len(ih, val)     do { (ih)-&gt;ih_item_len = cpu_to_le16(val); } while (0)</span>

<span class="cp">#define unreachable_item(ih) (ih_version(ih) &amp; (1 &lt;&lt; 15))</span>

<span class="cp">#define get_ih_free_space(ih) (ih_version (ih) == KEY_FORMAT_3_6 ? 0 : ih_free_space (ih))</span>
<span class="cp">#define set_ih_free_space(ih,val) put_ih_free_space((ih), ((ih_version(ih) == KEY_FORMAT_3_6) ? 0 : (val)))</span>

<span class="cm">/* these operate on indirect items, where you&#39;ve got an array of ints</span>
<span class="cm">** at a possibly unaligned location.  These are a noop on ia32</span>
<span class="cm">** </span>
<span class="cm">** p is the array of __u32, i is the index into the array, v is the value</span>
<span class="cm">** to store there.</span>
<span class="cm">*/</span>
<span class="cp">#define get_block_num(p, i) get_unaligned_le32((p) + (i))</span>
<span class="cp">#define put_block_num(p, i, v) put_unaligned_le32((v), (p) + (i))</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>in old version uniqueness field shows key type</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define V1_SD_UNIQUENESS 0</span>
<span class="cp">#define V1_INDIRECT_UNIQUENESS 0xfffffffe</span>
<span class="cp">#define V1_DIRECT_UNIQUENESS 0xffffffff</span>
<span class="cp">#define V1_DIRENTRY_UNIQUENESS 500</span>
<span class="cp">#define V1_ANY_UNIQUENESS 555	</span><span class="c1">// FIXME: comment is required</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>here are conversion routines</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">uniqueness2type</span><span class="p">(</span><span class="n">__u32</span> <span class="n">uniqueness</span><span class="p">)</span> <span class="n">CONSTF</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uniqueness2type</span><span class="p">(</span><span class="n">__u32</span> <span class="n">uniqueness</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">uniqueness</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V1_SD_UNIQUENESS</span>:
		<span class="k">return</span> <span class="n">TYPE_STAT_DATA</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V1_INDIRECT_UNIQUENESS</span>:
		<span class="k">return</span> <span class="n">TYPE_INDIRECT</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V1_DIRECT_UNIQUENESS</span>:
		<span class="k">return</span> <span class="n">TYPE_DIRECT</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V1_DIRENTRY_UNIQUENESS</span>:
		<span class="k">return</span> <span class="n">TYPE_DIRENTRY</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V1_ANY_UNIQUENESS</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">TYPE_ANY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="n">type2uniqueness</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span> <span class="n">CONSTF</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">type2uniqueness</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TYPE_STAT_DATA</span>:
		<span class="k">return</span> <span class="n">V1_SD_UNIQUENESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TYPE_INDIRECT</span>:
		<span class="k">return</span> <span class="n">V1_INDIRECT_UNIQUENESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TYPE_DIRECT</span>:
		<span class="k">return</span> <span class="n">V1_DIRECT_UNIQUENESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TYPE_DIRENTRY</span>:
		<span class="k">return</span> <span class="n">V1_DIRENTRY_UNIQUENESS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TYPE_ANY</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">V1_ANY_UNIQUENESS</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>key is pointer to on disk key which is stored in le, result is cpu,
there is no way to get version of object from key, so, provide
version to these defines</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">le_key_k_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">version</span> <span class="o">==</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">)</span> <span class="o">?</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v1</span><span class="p">.</span><span class="n">k_offset</span><span class="p">)</span> <span class="o">:</span>
	    <span class="n">offset_v2_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">le_ih_k_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le_key_k_offset</span><span class="p">(</span><span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">le_key_k_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">version</span> <span class="o">==</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">)</span> <span class="o">?</span>
	    <span class="n">uniqueness2type</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v1</span><span class="p">.</span><span class="n">k_uniqueness</span><span class="p">))</span> <span class="o">:</span>
	    <span class="n">offset_v2_k_type</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">le_ih_k_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le_key_k_type</span><span class="p">(</span><span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_le_key_k_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				       <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="n">version</span> <span class="o">==</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v1</span><span class="p">.</span><span class="n">k_offset</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span> <span class="o">:</span>	<span class="cm">/* jdm check */</span>
	    <span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">set_offset_v2_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v2</span><span class="p">),</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_le_ih_k_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_le_key_k_offset</span><span class="p">(</span><span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_le_key_k_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="n">version</span> <span class="o">==</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">)</span> <span class="o">?</span>
	    <span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v1</span><span class="p">.</span><span class="n">k_uniqueness</span> <span class="o">=</span>
		   <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">type2uniqueness</span><span class="p">(</span><span class="n">type</span><span class="p">)))</span>
	    <span class="o">:</span> <span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">set_offset_v2_k_type</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v2</span><span class="p">),</span> <span class="n">type</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_le_ih_k_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_le_key_k_type</span><span class="p">(</span><span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_direntry_le_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le_key_k_type</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_DIRENTRY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_direct_le_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le_key_k_type</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_DIRECT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_indirect_le_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le_key_k_type</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_INDIRECT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_statdata_le_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le_key_k_type</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_STAT_DATA</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>item header has version.</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_direntry_le_ih</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">is_direntry_le_key</span><span class="p">(</span><span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_direct_le_ih</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">is_direct_le_key</span><span class="p">(</span><span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_indirect_le_ih</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">is_indirect_le_key</span><span class="p">(</span><span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_statdata_le_ih</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">is_statdata_le_key</span><span class="p">(</span><span class="n">ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>key is pointer to cpu key, result is cpu</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">cpu_key_k_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">cpu_key_k_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_cpu_key_k_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_cpu_key_k_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpu_key_k_offset_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_offset</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define is_direntry_cpu_key(key) (cpu_key_k_type (key) == TYPE_DIRENTRY)</span>
<span class="cp">#define is_direct_cpu_key(key) (cpu_key_k_type (key) == TYPE_DIRECT)</span>
<span class="cp">#define is_indirect_cpu_key(key) (cpu_key_k_type (key) == TYPE_INDIRECT)</span>
<span class="cp">#define is_statdata_cpu_key(key) (cpu_key_k_type (key) == TYPE_STAT_DATA)</span>

<span class="cm">/* are these used ? */</span>
<span class="cp">#define is_direntry_cpu_ih(ih) (is_direntry_cpu_key (&amp;((ih)-&gt;ih_key)))</span>
<span class="cp">#define is_direct_cpu_ih(ih) (is_direct_cpu_key (&amp;((ih)-&gt;ih_key)))</span>
<span class="cp">#define is_indirect_cpu_ih(ih) (is_indirect_cpu_key (&amp;((ih)-&gt;ih_key)))</span>
<span class="cp">#define is_statdata_cpu_ih(ih) (is_statdata_cpu_key (&amp;((ih)-&gt;ih_key)))</span>

<span class="cp">#define I_K_KEY_IN_ITEM(ih, key, n_blocksize) \</span>
<span class="cp">    (!COMP_SHORT_KEYS(ih, key) &amp;&amp; \</span>
<span class="cp">	  I_OFF_BYTE_IN_ITEM(ih, k_offset(key), n_blocksize))</span>

<span class="cm">/* maximal length of item */</span>
<span class="cp">#define MAX_ITEM_LEN(block_size) (block_size - BLKH_SIZE - IH_SIZE)</span>
<span class="cp">#define MIN_ITEM_LEN 1</span>

<span class="cm">/* object identifier for root dir */</span>
<span class="cp">#define REISERFS_ROOT_OBJECTID 2</span>
<span class="cp">#define REISERFS_ROOT_PARENT_OBJECTID 1</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="n">root_key</span><span class="p">;</span>

<span class="cm">/* </span>
<span class="cm"> * Picture represents a leaf of the S+tree</span>
<span class="cm"> *  ______________________________________________________</span>
<span class="cm"> * |      |  Array of     |                   |           |</span>
<span class="cm"> * |Block |  Object-Item  |      F r e e      |  Objects- |</span>
<span class="cm"> * | head |  Headers      |     S p a c e     |   Items   |</span>
<span class="cm"> * |______|_______________|___________________|___________|</span>
<span class="cm"> */</span>

<span class="cm">/* Header of a disk block.  More precisely, header of a formatted leaf</span>
<span class="cm">   or internal node, and not the header of an unformatted node. */</span>
<span class="k">struct</span> <span class="n">block_head</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">blk_level</span><span class="p">;</span>	<span class="cm">/* Level of a block in the tree. */</span>
	<span class="n">__le16</span> <span class="n">blk_nr_item</span><span class="p">;</span>	<span class="cm">/* Number of keys/items in a block. */</span>
	<span class="n">__le16</span> <span class="n">blk_free_space</span><span class="p">;</span>	<span class="cm">/* Block free space in bytes. */</span>
	<span class="n">__le16</span> <span class="n">blk_reserved</span><span class="p">;</span>
	<span class="cm">/* dump this in v4/planA */</span>
	<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="n">blk_right_delim_key</span><span class="p">;</span>	<span class="cm">/* kept only for compatibility */</span>
<span class="p">};</span>

<span class="cp">#define BLKH_SIZE                     (sizeof(struct block_head))</span>
<span class="cp">#define blkh_level(p_blkh)            (le16_to_cpu((p_blkh)-&gt;blk_level))</span>
<span class="cp">#define blkh_nr_item(p_blkh)          (le16_to_cpu((p_blkh)-&gt;blk_nr_item))</span>
<span class="cp">#define blkh_free_space(p_blkh)       (le16_to_cpu((p_blkh)-&gt;blk_free_space))</span>
<span class="cp">#define blkh_reserved(p_blkh)         (le16_to_cpu((p_blkh)-&gt;blk_reserved))</span>
<span class="cp">#define set_blkh_level(p_blkh,val)    ((p_blkh)-&gt;blk_level = cpu_to_le16(val))</span>
<span class="cp">#define set_blkh_nr_item(p_blkh,val)  ((p_blkh)-&gt;blk_nr_item = cpu_to_le16(val))</span>
<span class="cp">#define set_blkh_free_space(p_blkh,val) ((p_blkh)-&gt;blk_free_space = cpu_to_le16(val))</span>
<span class="cp">#define set_blkh_reserved(p_blkh,val) ((p_blkh)-&gt;blk_reserved = cpu_to_le16(val))</span>
<span class="cp">#define blkh_right_delim_key(p_blkh)  ((p_blkh)-&gt;blk_right_delim_key)</span>
<span class="cp">#define set_blkh_right_delim_key(p_blkh,val)  ((p_blkh)-&gt;blk_right_delim_key = val)</span>

<span class="cm">/*</span>
<span class="cm"> * values for blk_level field of the struct block_head</span>
<span class="cm"> */</span>

<span class="cp">#define FREE_LEVEL 0		</span><span class="cm">/* when node gets removed from the tree its</span>
<span class="cm">				   blk_level is set to FREE_LEVEL. It is then</span>
<span class="cm">				   used to see whether the node is still in the</span>
<span class="cm">				   tree */</span><span class="cp"></span>

<span class="cp">#define DISK_LEAF_NODE_LEVEL  1	</span><span class="cm">/* Leaf node level. */</span><span class="cp"></span>

<span class="cm">/* Given the buffer head of a formatted node, resolve to the block head of that node. */</span>
<span class="cp">#define B_BLK_HEAD(bh)			((struct block_head *)((bh)-&gt;b_data))</span>
<span class="cm">/* Number of items that are in buffer. */</span>
<span class="cp">#define B_NR_ITEMS(bh)			(blkh_nr_item(B_BLK_HEAD(bh)))</span>
<span class="cp">#define B_LEVEL(bh)			(blkh_level(B_BLK_HEAD(bh)))</span>
<span class="cp">#define B_FREE_SPACE(bh)		(blkh_free_space(B_BLK_HEAD(bh)))</span>

<span class="cp">#define PUT_B_NR_ITEMS(bh, val)		do { set_blkh_nr_item(B_BLK_HEAD(bh), val); } while (0)</span>
<span class="cp">#define PUT_B_LEVEL(bh, val)		do { set_blkh_level(B_BLK_HEAD(bh), val); } while (0)</span>
<span class="cp">#define PUT_B_FREE_SPACE(bh, val)	do { set_blkh_free_space(B_BLK_HEAD(bh), val); } while (0)</span>

<span class="cm">/* Get right delimiting key. -- little endian */</span>
<span class="cp">#define B_PRIGHT_DELIM_KEY(bh)		(&amp;(blk_right_delim_key(B_BLK_HEAD(bh))))</span>

<span class="cm">/* Does the buffer contain a disk leaf. */</span>
<span class="cp">#define B_IS_ITEMS_LEVEL(bh)		(B_LEVEL(bh) == DISK_LEAF_NODE_LEVEL)</span>

<span class="cm">/* Does the buffer contain a disk internal node */</span>
<span class="cp">#define B_IS_KEYS_LEVEL(bh)      (B_LEVEL(bh) &gt; DISK_LEAF_NODE_LEVEL \</span>
<span class="cp">					    &amp;&amp; B_LEVEL(bh) &lt;= MAX_HEIGHT)</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                             STAT DATA                                   */</span>
<span class="cm">/***************************************************************************/</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>old stat data is 32 bytes long. We are going to distinguish new one by
different size</p></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">stat_data_v1</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">sd_mode</span><span class="p">;</span>		<span class="cm">/* file type, permissions */</span>
	<span class="n">__le16</span> <span class="n">sd_nlink</span><span class="p">;</span>	<span class="cm">/* number of hard links */</span>
	<span class="n">__le16</span> <span class="n">sd_uid</span><span class="p">;</span>		<span class="cm">/* owner */</span>
	<span class="n">__le16</span> <span class="n">sd_gid</span><span class="p">;</span>		<span class="cm">/* group */</span>
	<span class="n">__le32</span> <span class="n">sd_size</span><span class="p">;</span>		<span class="cm">/* file size */</span>
	<span class="n">__le32</span> <span class="n">sd_atime</span><span class="p">;</span>	<span class="cm">/* time of last access */</span>
	<span class="n">__le32</span> <span class="n">sd_mtime</span><span class="p">;</span>	<span class="cm">/* time file was last modified  */</span>
	<span class="n">__le32</span> <span class="n">sd_ctime</span><span class="p">;</span>	<span class="cm">/* time inode (stat data) was last changed (except changes to sd_atime and sd_mtime) */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">sd_rdev</span><span class="p">;</span>
		<span class="n">__le32</span> <span class="n">sd_blocks</span><span class="p">;</span>	<span class="cm">/* number of blocks file uses */</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">u</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">sd_first_direct_byte</span><span class="p">;</span>	<span class="cm">/* first byte of file which is stored</span>
<span class="cm">					   in a direct item: except that if it</span>
<span class="cm">					   equals 1 it is a symlink and if it</span>
<span class="cm">					   equals ~(__u32)0 there is no</span>
<span class="cm">					   direct item.  The existence of this</span>
<span class="cm">					   field really grates on me. Let&#39;s</span>
<span class="cm">					   replace it with a macro based on</span>
<span class="cm">					   sd_size and our tail suppression</span>
<span class="cm">					   policy.  Someday.  -Hans */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="cp">#define SD_V1_SIZE              (sizeof(struct stat_data_v1))</span>
<span class="cp">#define stat_data_v1(ih)        (ih_version (ih) == KEY_FORMAT_3_5)</span>
<span class="cp">#define sd_v1_mode(sdp)         (le16_to_cpu((sdp)-&gt;sd_mode))</span>
<span class="cp">#define set_sd_v1_mode(sdp,v)   ((sdp)-&gt;sd_mode = cpu_to_le16(v))</span>
<span class="cp">#define sd_v1_nlink(sdp)        (le16_to_cpu((sdp)-&gt;sd_nlink))</span>
<span class="cp">#define set_sd_v1_nlink(sdp,v)  ((sdp)-&gt;sd_nlink = cpu_to_le16(v))</span>
<span class="cp">#define sd_v1_uid(sdp)          (le16_to_cpu((sdp)-&gt;sd_uid))</span>
<span class="cp">#define set_sd_v1_uid(sdp,v)    ((sdp)-&gt;sd_uid = cpu_to_le16(v))</span>
<span class="cp">#define sd_v1_gid(sdp)          (le16_to_cpu((sdp)-&gt;sd_gid))</span>
<span class="cp">#define set_sd_v1_gid(sdp,v)    ((sdp)-&gt;sd_gid = cpu_to_le16(v))</span>
<span class="cp">#define sd_v1_size(sdp)         (le32_to_cpu((sdp)-&gt;sd_size))</span>
<span class="cp">#define set_sd_v1_size(sdp,v)   ((sdp)-&gt;sd_size = cpu_to_le32(v))</span>
<span class="cp">#define sd_v1_atime(sdp)        (le32_to_cpu((sdp)-&gt;sd_atime))</span>
<span class="cp">#define set_sd_v1_atime(sdp,v)  ((sdp)-&gt;sd_atime = cpu_to_le32(v))</span>
<span class="cp">#define sd_v1_mtime(sdp)        (le32_to_cpu((sdp)-&gt;sd_mtime))</span>
<span class="cp">#define set_sd_v1_mtime(sdp,v)  ((sdp)-&gt;sd_mtime = cpu_to_le32(v))</span>
<span class="cp">#define sd_v1_ctime(sdp)        (le32_to_cpu((sdp)-&gt;sd_ctime))</span>
<span class="cp">#define set_sd_v1_ctime(sdp,v)  ((sdp)-&gt;sd_ctime = cpu_to_le32(v))</span>
<span class="cp">#define sd_v1_rdev(sdp)         (le32_to_cpu((sdp)-&gt;u.sd_rdev))</span>
<span class="cp">#define set_sd_v1_rdev(sdp,v)   ((sdp)-&gt;u.sd_rdev = cpu_to_le32(v))</span>
<span class="cp">#define sd_v1_blocks(sdp)       (le32_to_cpu((sdp)-&gt;u.sd_blocks))</span>
<span class="cp">#define set_sd_v1_blocks(sdp,v) ((sdp)-&gt;u.sd_blocks = cpu_to_le32(v))</span>
<span class="cp">#define sd_v1_first_direct_byte(sdp) \</span>
<span class="cp">                                (le32_to_cpu((sdp)-&gt;sd_first_direct_byte))</span>
<span class="cp">#define set_sd_v1_first_direct_byte(sdp,v) \</span>
<span class="cp">                                ((sdp)-&gt;sd_first_direct_byte = cpu_to_le32(v))</span>

<span class="cm">/* inode flags stored in sd_attrs (nee sd_reserved) */</span>

<span class="cm">/* we want common flags to have the same values as in ext2,</span>
<span class="cm">   so chattr(1) will work without problems */</span>
<span class="cp">#define REISERFS_IMMUTABLE_FL FS_IMMUTABLE_FL</span>
<span class="cp">#define REISERFS_APPEND_FL    FS_APPEND_FL</span>
<span class="cp">#define REISERFS_SYNC_FL      FS_SYNC_FL</span>
<span class="cp">#define REISERFS_NOATIME_FL   FS_NOATIME_FL</span>
<span class="cp">#define REISERFS_NODUMP_FL    FS_NODUMP_FL</span>
<span class="cp">#define REISERFS_SECRM_FL     FS_SECRM_FL</span>
<span class="cp">#define REISERFS_UNRM_FL      FS_UNRM_FL</span>
<span class="cp">#define REISERFS_COMPR_FL     FS_COMPR_FL</span>
<span class="cp">#define REISERFS_NOTAIL_FL    FS_NOTAIL_FL</span>

<span class="cm">/* persistent flags that file inherits from the parent directory */</span>
<span class="cp">#define REISERFS_INHERIT_MASK ( REISERFS_IMMUTABLE_FL |	\</span>
<span class="cp">				REISERFS_SYNC_FL |	\</span>
<span class="cp">				REISERFS_NOATIME_FL |	\</span>
<span class="cp">				REISERFS_NODUMP_FL |	\</span>
<span class="cp">				REISERFS_SECRM_FL |	\</span>
<span class="cp">				REISERFS_COMPR_FL |	\</span>
<span class="cp">				REISERFS_NOTAIL_FL )</span>

<span class="cm">/* Stat Data on disk (reiserfs version of UFS disk inode minus the</span>
<span class="cm">   address blocks) */</span>
<span class="k">struct</span> <span class="n">stat_data</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">sd_mode</span><span class="p">;</span>		<span class="cm">/* file type, permissions */</span>
	<span class="n">__le16</span> <span class="n">sd_attrs</span><span class="p">;</span>	<span class="cm">/* persistent inode flags */</span>
	<span class="n">__le32</span> <span class="n">sd_nlink</span><span class="p">;</span>	<span class="cm">/* number of hard links */</span>
	<span class="n">__le64</span> <span class="n">sd_size</span><span class="p">;</span>		<span class="cm">/* file size */</span>
	<span class="n">__le32</span> <span class="n">sd_uid</span><span class="p">;</span>		<span class="cm">/* owner */</span>
	<span class="n">__le32</span> <span class="n">sd_gid</span><span class="p">;</span>		<span class="cm">/* group */</span>
	<span class="n">__le32</span> <span class="n">sd_atime</span><span class="p">;</span>	<span class="cm">/* time of last access */</span>
	<span class="n">__le32</span> <span class="n">sd_mtime</span><span class="p">;</span>	<span class="cm">/* time file was last modified  */</span>
	<span class="n">__le32</span> <span class="n">sd_ctime</span><span class="p">;</span>	<span class="cm">/* time inode (stat data) was last changed (except changes to sd_atime and sd_mtime) */</span>
	<span class="n">__le32</span> <span class="n">sd_blocks</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">sd_rdev</span><span class="p">;</span>
		<span class="n">__le32</span> <span class="n">sd_generation</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p><em>_le32 sd</em>first<em>direct</em>byte;</p></td><td class="code"><div class="highlight"><pre>		<span class="cm">/* first byte of file which is stored in a</span>
<span class="cm">		   direct item: except that if it equals 1</span>
<span class="cm">		   it is a symlink and if it equals</span>
<span class="cm">		   ~(__u32)0 there is no direct item.  The</span>
<span class="cm">		   existence of this field really grates</span>
<span class="cm">		   on me. Let&#39;s replace it with a macro</span>
<span class="cm">		   based on sd_size and our tail</span>
<span class="cm">		   suppression policy? */</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>this is 44 bytes long</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define SD_SIZE (sizeof(struct stat_data))</span>
<span class="cp">#define SD_V2_SIZE              SD_SIZE</span>
<span class="cp">#define stat_data_v2(ih)        (ih_version (ih) == KEY_FORMAT_3_6)</span>
<span class="cp">#define sd_v2_mode(sdp)         (le16_to_cpu((sdp)-&gt;sd_mode))</span>
<span class="cp">#define set_sd_v2_mode(sdp,v)   ((sdp)-&gt;sd_mode = cpu_to_le16(v))</span>
<span class="cm">/* sd_reserved */</span>
<span class="cm">/* set_sd_reserved */</span>
<span class="cp">#define sd_v2_nlink(sdp)        (le32_to_cpu((sdp)-&gt;sd_nlink))</span>
<span class="cp">#define set_sd_v2_nlink(sdp,v)  ((sdp)-&gt;sd_nlink = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_size(sdp)         (le64_to_cpu((sdp)-&gt;sd_size))</span>
<span class="cp">#define set_sd_v2_size(sdp,v)   ((sdp)-&gt;sd_size = cpu_to_le64(v))</span>
<span class="cp">#define sd_v2_uid(sdp)          (le32_to_cpu((sdp)-&gt;sd_uid))</span>
<span class="cp">#define set_sd_v2_uid(sdp,v)    ((sdp)-&gt;sd_uid = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_gid(sdp)          (le32_to_cpu((sdp)-&gt;sd_gid))</span>
<span class="cp">#define set_sd_v2_gid(sdp,v)    ((sdp)-&gt;sd_gid = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_atime(sdp)        (le32_to_cpu((sdp)-&gt;sd_atime))</span>
<span class="cp">#define set_sd_v2_atime(sdp,v)  ((sdp)-&gt;sd_atime = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_mtime(sdp)        (le32_to_cpu((sdp)-&gt;sd_mtime))</span>
<span class="cp">#define set_sd_v2_mtime(sdp,v)  ((sdp)-&gt;sd_mtime = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_ctime(sdp)        (le32_to_cpu((sdp)-&gt;sd_ctime))</span>
<span class="cp">#define set_sd_v2_ctime(sdp,v)  ((sdp)-&gt;sd_ctime = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_blocks(sdp)       (le32_to_cpu((sdp)-&gt;sd_blocks))</span>
<span class="cp">#define set_sd_v2_blocks(sdp,v) ((sdp)-&gt;sd_blocks = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_rdev(sdp)         (le32_to_cpu((sdp)-&gt;u.sd_rdev))</span>
<span class="cp">#define set_sd_v2_rdev(sdp,v)   ((sdp)-&gt;u.sd_rdev = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_generation(sdp)   (le32_to_cpu((sdp)-&gt;u.sd_generation))</span>
<span class="cp">#define set_sd_v2_generation(sdp,v) ((sdp)-&gt;u.sd_generation = cpu_to_le32(v))</span>
<span class="cp">#define sd_v2_attrs(sdp)         (le16_to_cpu((sdp)-&gt;sd_attrs))</span>
<span class="cp">#define set_sd_v2_attrs(sdp,v)   ((sdp)-&gt;sd_attrs = cpu_to_le16(v))</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                      DIRECTORY STRUCTURE                                */</span>
<span class="cm">/***************************************************************************/</span>
<span class="cm">/* </span>
<span class="cm">   Picture represents the structure of directory items</span>
<span class="cm">   ________________________________________________</span>
<span class="cm">   |  Array of     |   |     |        |       |   |</span>
<span class="cm">   | directory     |N-1| N-2 | ....   |   1st |0th|</span>
<span class="cm">   | entry headers |   |     |        |       |   |</span>
<span class="cm">   |_______________|___|_____|________|_______|___|</span>
<span class="cm">                    &lt;----   directory entries         ------&gt;</span>

<span class="cm"> First directory item has k_offset component 1. We store &quot;.&quot; and &quot;..&quot;</span>
<span class="cm"> in one item, always, we never split &quot;.&quot; and &quot;..&quot; into differing</span>
<span class="cm"> items.  This makes, among other things, the code for removing</span>
<span class="cm"> directories simpler. */</span>
<span class="cp">#define SD_OFFSET  0</span>
<span class="cp">#define SD_UNIQUENESS 0</span>
<span class="cp">#define DOT_OFFSET 1</span>
<span class="cp">#define DOT_DOT_OFFSET 2</span>
<span class="cp">#define DIRENTRY_UNIQUENESS 500</span>

<span class="cm">/* */</span>
<span class="cp">#define FIRST_ITEM_OFFSET 1</span>

<span class="cm">/*</span>
<span class="cm">   Q: How to get key of object pointed to by entry from entry?  </span>

<span class="cm">   A: Each directory entry has its header. This header has deh_dir_id and deh_objectid fields, those are key</span>
<span class="cm">      of object, entry points to */</span>

<span class="cm">/* NOT IMPLEMENTED:   </span>
<span class="cm">   Directory will someday contain stat data of object */</span>

<span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">deh_offset</span><span class="p">;</span>	<span class="cm">/* third component of the directory entry key */</span>
	<span class="n">__le32</span> <span class="n">deh_dir_id</span><span class="p">;</span>	<span class="cm">/* objectid of the parent directory of the object, that is referenced</span>
<span class="cm">				   by directory entry */</span>
	<span class="n">__le32</span> <span class="n">deh_objectid</span><span class="p">;</span>	<span class="cm">/* objectid of the object, that is referenced by directory entry */</span>
	<span class="n">__le16</span> <span class="n">deh_location</span><span class="p">;</span>	<span class="cm">/* offset of name in the whole item */</span>
	<span class="n">__le16</span> <span class="n">deh_state</span><span class="p">;</span>	<span class="cm">/* whether 1) entry contains stat data (for future), and 2) whether</span>
<span class="cm">				   entry is hidden (unlinked) */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>
<span class="cp">#define DEH_SIZE                  sizeof(struct reiserfs_de_head)</span>
<span class="cp">#define deh_offset(p_deh)         (le32_to_cpu((p_deh)-&gt;deh_offset))</span>
<span class="cp">#define deh_dir_id(p_deh)         (le32_to_cpu((p_deh)-&gt;deh_dir_id))</span>
<span class="cp">#define deh_objectid(p_deh)       (le32_to_cpu((p_deh)-&gt;deh_objectid))</span>
<span class="cp">#define deh_location(p_deh)       (le16_to_cpu((p_deh)-&gt;deh_location))</span>
<span class="cp">#define deh_state(p_deh)          (le16_to_cpu((p_deh)-&gt;deh_state))</span>

<span class="cp">#define put_deh_offset(p_deh,v)   ((p_deh)-&gt;deh_offset = cpu_to_le32((v)))</span>
<span class="cp">#define put_deh_dir_id(p_deh,v)   ((p_deh)-&gt;deh_dir_id = cpu_to_le32((v)))</span>
<span class="cp">#define put_deh_objectid(p_deh,v) ((p_deh)-&gt;deh_objectid = cpu_to_le32((v)))</span>
<span class="cp">#define put_deh_location(p_deh,v) ((p_deh)-&gt;deh_location = cpu_to_le16((v)))</span>
<span class="cp">#define put_deh_state(p_deh,v)    ((p_deh)-&gt;deh_state = cpu_to_le16((v)))</span>

<span class="cm">/* empty directory contains two entries &quot;.&quot; and &quot;..&quot; and their headers */</span>
<span class="cp">#define EMPTY_DIR_SIZE \</span>
<span class="cp">(DEH_SIZE * 2 + ROUND_UP (strlen (&quot;.&quot;)) + ROUND_UP (strlen (&quot;..&quot;)))</span>

<span class="cm">/* old format directories have this size when empty */</span>
<span class="cp">#define EMPTY_DIR_SIZE_V1 (DEH_SIZE * 2 + 3)</span>

<span class="cp">#define DEH_Statdata 0		</span><span class="cm">/* not used now */</span><span class="cp"></span>
<span class="cp">#define DEH_Visible 2</span>

<span class="cm">/* 64 bit systems (and the S/390) need to be aligned explicitly -jdm */</span>
<span class="cp">#if BITS_PER_LONG == 64 || defined(__s390__) || defined(__hppa__)</span>
<span class="cp">#   define ADDR_UNALIGNED_BITS  (3)</span>
<span class="cp">#endif</span>

<span class="cm">/* These are only used to manipulate deh_state.</span>
<span class="cm"> * Because of this, we&#39;ll use the ext2_ bit routines,</span>
<span class="cm"> * since they are little endian */</span>
<span class="cp">#ifdef ADDR_UNALIGNED_BITS</span>

<span class="cp">#   define aligned_address(addr)           ((void *)((long)(addr) &amp; ~((1UL &lt;&lt; ADDR_UNALIGNED_BITS) - 1)))</span>
<span class="cp">#   define unaligned_offset(addr)          (((int)((long)(addr) &amp; ((1 &lt;&lt; ADDR_UNALIGNED_BITS) - 1))) &lt;&lt; 3)</span>

<span class="cp">#   define set_bit_unaligned(nr, addr)	\</span>
<span class="cp">	__test_and_set_bit_le((nr) + unaligned_offset(addr), aligned_address(addr))</span>
<span class="cp">#   define clear_bit_unaligned(nr, addr)	\</span>
<span class="cp">	__test_and_clear_bit_le((nr) + unaligned_offset(addr), aligned_address(addr))</span>
<span class="cp">#   define test_bit_unaligned(nr, addr)	\</span>
<span class="cp">	test_bit_le((nr) + unaligned_offset(addr), aligned_address(addr))</span>

<span class="cp">#else</span>

<span class="cp">#   define set_bit_unaligned(nr, addr)	__test_and_set_bit_le(nr, addr)</span>
<span class="cp">#   define clear_bit_unaligned(nr, addr)	__test_and_clear_bit_le(nr, addr)</span>
<span class="cp">#   define test_bit_unaligned(nr, addr)	test_bit_le(nr, addr)</span>

<span class="cp">#endif</span>

<span class="cp">#define mark_de_with_sd(deh)        set_bit_unaligned (DEH_Statdata, &amp;((deh)-&gt;deh_state))</span>
<span class="cp">#define mark_de_without_sd(deh)     clear_bit_unaligned (DEH_Statdata, &amp;((deh)-&gt;deh_state))</span>
<span class="cp">#define mark_de_visible(deh)	    set_bit_unaligned (DEH_Visible, &amp;((deh)-&gt;deh_state))</span>
<span class="cp">#define mark_de_hidden(deh)	    clear_bit_unaligned (DEH_Visible, &amp;((deh)-&gt;deh_state))</span>

<span class="cp">#define de_with_sd(deh)		    test_bit_unaligned (DEH_Statdata, &amp;((deh)-&gt;deh_state))</span>
<span class="cp">#define de_visible(deh)	    	    test_bit_unaligned (DEH_Visible, &amp;((deh)-&gt;deh_state))</span>
<span class="cp">#define de_hidden(deh)	    	    !test_bit_unaligned (DEH_Visible, &amp;((deh)-&gt;deh_state))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">make_empty_dir_item_v1</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">dirid</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">objid</span><span class="p">,</span>
				   <span class="n">__le32</span> <span class="n">par_dirid</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">par_objid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">make_empty_dir_item</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">dirid</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">objid</span><span class="p">,</span>
				<span class="n">__le32</span> <span class="n">par_dirid</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">par_objid</span><span class="p">);</span>

<span class="cm">/* array of the entry headers */</span>
 <span class="cm">/* get item body */</span>
<span class="cp">#define B_I_PITEM(bh,ih) ( (bh)-&gt;b_data + ih_location(ih) )</span>
<span class="cp">#define B_I_DEH(bh,ih) ((struct reiserfs_de_head *)(B_I_PITEM(bh,ih)))</span>

<span class="cm">/* length of the directory entry in directory item. This define</span>
<span class="cm">   calculates length of i-th directory entry using directory entry</span>
<span class="cm">   locations from dir entry head. When it calculates length of 0-th</span>
<span class="cm">   directory entry, it uses length of whole item in place of entry</span>
<span class="cm">   location of the non-existent following entry in the calculation.</span>
<span class="cm">   See picture above.*/</span>
<span class="cm">/*</span>
<span class="cm">#define I_DEH_N_ENTRY_LENGTH(ih,deh,i) \</span>
<span class="cm">((i) ? (deh_location((deh)-1) - deh_location((deh))) : (ih_item_len((ih)) - deh_location((deh))))</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">entry_length</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="o">*</span><span class="n">deh</span><span class="p">;</span>

	<span class="n">deh</span> <span class="o">=</span> <span class="n">B_I_DEH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">pos_in_item</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_item</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">deh_location</span><span class="p">(</span><span class="n">deh</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">deh_location</span><span class="p">(</span><span class="n">deh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">deh_location</span><span class="p">(</span><span class="n">deh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* number of entries in the directory item, depends on ENTRY_COUNT being at the start of directory dynamic data. */</span>
<span class="cp">#define I_ENTRY_COUNT(ih) (ih_entry_count((ih)))</span>

<span class="cm">/* name by bh, ih and entry_num */</span>
<span class="cp">#define B_I_E_NAME(bh,ih,entry_num) ((char *)(bh-&gt;b_data + ih_location(ih) + deh_location(B_I_DEH(bh,ih)+(entry_num))))</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>two entries per block (at least)</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define REISERFS_MAX_NAME(block_size) 255</span>

<span class="cm">/* this structure is used for operations on directory entries. It is</span>
<span class="cm">   not a disk structure. */</span>
<span class="cm">/* When reiserfs_find_entry or search_by_entry_key find directory</span>
<span class="cm">   entry, they return filled reiserfs_dir_entry structure */</span>
<span class="k">struct</span> <span class="n">reiserfs_dir_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">de_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">de_item_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">de_ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">de_entry_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="o">*</span><span class="n">de_deh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">de_entrylen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">de_namelen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">de_name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">de_gen_number_bit_string</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">de_dir_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">de_objectid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">de_entry_key</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* these defines are useful when a particular member of a reiserfs_dir_entry is needed */</span>

<span class="cm">/* pointer to file name, stored in entry */</span>
<span class="cp">#define B_I_DEH_ENTRY_FILE_NAME(bh,ih,deh) (B_I_PITEM (bh, ih) + deh_location(deh))</span>

<span class="cm">/* length of name */</span>
<span class="cp">#define I_DEH_N_ENTRY_FILE_NAME_LENGTH(ih,deh,entry_num) \</span>
<span class="cp">(I_DEH_N_ENTRY_LENGTH (ih, deh, entry_num) - (de_with_sd (deh) ? SD_SIZE : 0))</span>

<span class="cm">/* hash value occupies bits from 7 up to 30 */</span>
<span class="cp">#define GET_HASH_VALUE(offset) ((offset) &amp; 0x7fffff80LL)</span>
<span class="cm">/* generation number occupies 7 bits starting from 0 up to 6 */</span>
<span class="cp">#define GET_GENERATION_NUMBER(offset) ((offset) &amp; 0x7fLL)</span>
<span class="cp">#define MAX_GENERATION_NUMBER  127</span>

<span class="cp">#define SET_GENERATION_NUMBER(offset,gen_number) (GET_HASH_VALUE(offset)|(gen_number))</span>

<span class="cm">/*</span>
<span class="cm"> * Picture represents an internal node of the reiserfs tree</span>
<span class="cm"> *  ______________________________________________________</span>
<span class="cm"> * |      |  Array of     |  Array of         |  Free     |</span>
<span class="cm"> * |block |    keys       |  pointers         | space     |</span>
<span class="cm"> * | head |      N        |      N+1          |           |</span>
<span class="cm"> * |______|_______________|___________________|___________|</span>
<span class="cm"> */</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                      DISK CHILD                                         */</span>
<span class="cm">/***************************************************************************/</span>
<span class="cm">/* Disk child pointer: The pointer from an internal node of the tree</span>
<span class="cm">   to a node that is on disk. */</span>
<span class="k">struct</span> <span class="n">disk_child</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">dc_block_number</span><span class="p">;</span>	<span class="cm">/* Disk child&#39;s block number. */</span>
	<span class="n">__le16</span> <span class="n">dc_size</span><span class="p">;</span>		<span class="cm">/* Disk child&#39;s used space.   */</span>
	<span class="n">__le16</span> <span class="n">dc_reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DC_SIZE (sizeof(struct disk_child))</span>
<span class="cp">#define dc_block_number(dc_p)	(le32_to_cpu((dc_p)-&gt;dc_block_number))</span>
<span class="cp">#define dc_size(dc_p)		(le16_to_cpu((dc_p)-&gt;dc_size))</span>
<span class="cp">#define put_dc_block_number(dc_p, val)   do { (dc_p)-&gt;dc_block_number = cpu_to_le32(val); } while(0)</span>
<span class="cp">#define put_dc_size(dc_p, val)   do { (dc_p)-&gt;dc_size = cpu_to_le16(val); } while(0)</span>

<span class="cm">/* Get disk child by buffer header and position in the tree node. */</span>
<span class="cp">#define B_N_CHILD(bh, n_pos)  ((struct disk_child *)\</span>
<span class="cp">((bh)-&gt;b_data + BLKH_SIZE + B_NR_ITEMS(bh) * KEY_SIZE + DC_SIZE * (n_pos)))</span>

<span class="cm">/* Get disk child number by buffer header and position in the tree node. */</span>
<span class="cp">#define B_N_CHILD_NUM(bh, n_pos) (dc_block_number(B_N_CHILD(bh, n_pos)))</span>
<span class="cp">#define PUT_B_N_CHILD_NUM(bh, n_pos, val) \</span>
<span class="cp">				(put_dc_block_number(B_N_CHILD(bh, n_pos), val))</span>

 <span class="cm">/* maximal value of field child_size in structure disk_child */</span>
 <span class="cm">/* child size is the combined size of all items and their headers */</span>
<span class="cp">#define MAX_CHILD_SIZE(bh) ((int)( (bh)-&gt;b_size - BLKH_SIZE ))</span>

<span class="cm">/* amount of used space in buffer (not including block head) */</span>
<span class="cp">#define B_CHILD_SIZE(cur) (MAX_CHILD_SIZE(cur)-(B_FREE_SPACE(cur)))</span>

<span class="cm">/* max and min number of keys in internal node */</span>
<span class="cp">#define MAX_NR_KEY(bh) ( (MAX_CHILD_SIZE(bh)-DC_SIZE)/(KEY_SIZE+DC_SIZE) )</span>
<span class="cp">#define MIN_NR_KEY(bh)    (MAX_NR_KEY(bh)/2)</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                      PATH STRUCTURES AND DEFINES                        */</span>
<span class="cm">/***************************************************************************/</span>

<span class="cm">/* Search_by_key fills up the path from the root to the leaf as it descends the tree looking for the</span>
<span class="cm">   key.  It uses reiserfs_bread to try to find buffers in the cache given their block number.  If it</span>
<span class="cm">   does not find them in the cache it reads them from disk.  For each node search_by_key finds using</span>
<span class="cm">   reiserfs_bread it then uses bin_search to look through that node.  bin_search will find the</span>
<span class="cm">   position of the block_number of the next node if it is looking through an internal node.  If it</span>
<span class="cm">   is looking through a leaf node bin_search will find the position of the item which has key either</span>
<span class="cm">   equal to given key, or which is the maximal key less than the given key. */</span>

<span class="k">struct</span> <span class="n">path_element</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">pe_buffer</span><span class="p">;</span>	<span class="cm">/* Pointer to the buffer at the path in the tree. */</span>
	<span class="kt">int</span> <span class="n">pe_position</span><span class="p">;</span>	<span class="cm">/* Position in the tree node which is placed in the */</span>
	<span class="cm">/* buffer above.                                  */</span>
<span class="p">};</span>

<span class="cp">#define MAX_HEIGHT 5		</span><span class="cm">/* maximal height of a tree. don&#39;t change this without changing JOURNAL_PER_BALANCE_CNT */</span><span class="cp"></span>
<span class="cp">#define EXTENDED_MAX_HEIGHT         7	</span><span class="cm">/* Must be equals MAX_HEIGHT + FIRST_PATH_ELEMENT_OFFSET */</span><span class="cp"></span>
<span class="cp">#define FIRST_PATH_ELEMENT_OFFSET   2	</span><span class="cm">/* Must be equal to at least 2. */</span><span class="cp"></span>

<span class="cp">#define ILLEGAL_PATH_ELEMENT_OFFSET 1	</span><span class="cm">/* Must be equal to FIRST_PATH_ELEMENT_OFFSET - 1 */</span><span class="cp"></span>
<span class="cp">#define MAX_FEB_SIZE 6		</span><span class="cm">/* this MUST be MAX_HEIGHT + 1. See about FEB below */</span><span class="cp"></span>

<span class="cm">/* We need to keep track of who the ancestors of nodes are.  When we</span>
<span class="cm">   perform a search we record which nodes were visited while</span>
<span class="cm">   descending the tree looking for the node we searched for. This list</span>
<span class="cm">   of nodes is called the path.  This information is used while</span>
<span class="cm">   performing balancing.  Note that this path information may become</span>
<span class="cm">   invalid, and this means we must check it when using it to see if it</span>
<span class="cm">   is still valid. You&#39;ll need to read search_by_key and the comments</span>
<span class="cm">   in it, especially about decrement_counters_in_path(), to understand</span>
<span class="cm">   this structure.  </span>

<span class="cm">Paths make the code so much harder to work with and debug.... An</span>
<span class="cm">enormous number of bugs are due to them, and trying to write or modify</span>
<span class="cm">code that uses them just makes my head hurt.  They are based on an</span>
<span class="cm">excessive effort to avoid disturbing the precious VFS code.:-( The</span>
<span class="cm">gods only know how we are going to SMP the code that uses them.</span>
<span class="cm">znodes are the way! */</span>

<span class="cp">#define PATH_READA	0x1	</span><span class="cm">/* do read ahead */</span><span class="cp"></span>
<span class="cp">#define PATH_READA_BACK 0x2	</span><span class="cm">/* read backwards */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">treepath</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">path_length</span><span class="p">;</span>	<span class="cm">/* Length of the array above.   */</span>
	<span class="kt">int</span> <span class="n">reada</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path_element</span> <span class="n">path_elements</span><span class="p">[</span><span class="n">EXTENDED_MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* Array of the path elements.  */</span>
	<span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define pos_in_item(path) ((path)-&gt;pos_in_item)</span>

<span class="cp">#define INITIALIZE_PATH(var) \</span>
<span class="cp">struct treepath var = {.path_length = ILLEGAL_PATH_ELEMENT_OFFSET, .reada = 0,}</span>

<span class="cm">/* Get path element by path and path position. */</span>
<span class="cp">#define PATH_OFFSET_PELEMENT(path, n_offset)  ((path)-&gt;path_elements + (n_offset))</span>

<span class="cm">/* Get buffer header at the path by path and path position. */</span>
<span class="cp">#define PATH_OFFSET_PBUFFER(path, n_offset)   (PATH_OFFSET_PELEMENT(path, n_offset)-&gt;pe_buffer)</span>

<span class="cm">/* Get position in the element at the path by path and path position. */</span>
<span class="cp">#define PATH_OFFSET_POSITION(path, n_offset) (PATH_OFFSET_PELEMENT(path, n_offset)-&gt;pe_position)</span>

<span class="cp">#define PATH_PLAST_BUFFER(path) (PATH_OFFSET_PBUFFER((path), (path)-&gt;path_length))</span>
				<span class="cm">/* you know, to the person who didn&#39;t</span>
<span class="cm">				   write this the macro name does not</span>
<span class="cm">				   at first suggest what it does.</span>
<span class="cm">				   Maybe POSITION_FROM_PATH_END? Or</span>
<span class="cm">				   maybe we should just focus on</span>
<span class="cm">				   dumping paths... -Hans */</span>
<span class="cp">#define PATH_LAST_POSITION(path) (PATH_OFFSET_POSITION((path), (path)-&gt;path_length))</span>

<span class="cp">#define PATH_PITEM_HEAD(path)    B_N_PITEM_HEAD(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path))</span>

<span class="cm">/* in do_balance leaf has h == 0 in contrast with path structure,</span>
<span class="cm">   where root has level == 0. That is why we need these defines */</span>
<span class="cp">#define PATH_H_PBUFFER(path, h) PATH_OFFSET_PBUFFER (path, path-&gt;path_length - (h))	</span><span class="cm">/* tb-&gt;S[h] */</span><span class="cp"></span>
<span class="cp">#define PATH_H_PPARENT(path, h) PATH_H_PBUFFER (path, (h) + 1)	</span><span class="cm">/* tb-&gt;F[h] or tb-&gt;S[0]-&gt;b_parent */</span><span class="cp"></span>
<span class="cp">#define PATH_H_POSITION(path, h) PATH_OFFSET_POSITION (path, path-&gt;path_length - (h))</span>
<span class="cp">#define PATH_H_B_ITEM_ORDER(path, h) PATH_H_POSITION(path, h + 1)	</span><span class="cm">/* tb-&gt;S[h]-&gt;b_item_order */</span><span class="cp"></span>

<span class="cp">#define PATH_H_PATH_OFFSET(path, n_h) ((path)-&gt;path_length - (n_h))</span>

<span class="cp">#define get_last_bh(path) PATH_PLAST_BUFFER(path)</span>
<span class="cp">#define get_ih(path) PATH_PITEM_HEAD(path)</span>
<span class="cp">#define get_item_pos(path) PATH_LAST_POSITION(path)</span>
<span class="cp">#define get_item(path) ((void *)B_N_PITEM(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION (path)))</span>
<span class="cp">#define item_moved(ih,path) comp_items(ih, path)</span>
<span class="cp">#define path_changed(ih,path) comp_items (ih, path)</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                       MISC                                              */</span>
<span class="cm">/***************************************************************************/</span>

<span class="cm">/* Size of pointer to the unformatted node. */</span>
<span class="cp">#define UNFM_P_SIZE (sizeof(unp_t))</span>
<span class="cp">#define UNFM_P_SHIFT 2</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>in in-core inode key is stored on le form</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define INODE_PKEY(inode) ((struct reiserfs_key *)(REISERFS_I(inode)-&gt;i_key))</span>

<span class="cp">#define MAX_UL_INT 0xffffffff</span>
<span class="cp">#define MAX_INT    0x7ffffff</span>
<span class="cp">#define MAX_US_INT 0xffff</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>reiserfs version 2 has max offset 60 bits. Version 1 - 32 bit offset</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define U32_MAX (~(__u32)0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">max_reiserfs_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">U32_MAX</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="p">((</span><span class="o">~</span><span class="p">(</span><span class="n">__u64</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*#define MAX_KEY_UNIQUENESS	MAX_UL_INT*/</span>
<span class="cp">#define MAX_KEY_OBJECTID	MAX_UL_INT</span>

<span class="cp">#define MAX_B_NUM  MAX_UL_INT</span>
<span class="cp">#define MAX_FC_NUM MAX_US_INT</span>

<span class="cm">/* the purpose is to detect overflow of an unsigned short */</span>
<span class="cp">#define REISERFS_LINK_MAX (MAX_US_INT - 1000)</span>

<span class="cm">/* The following defines are used in reiserfs_insert_item and reiserfs_append_item  */</span>
<span class="cp">#define REISERFS_KERNEL_MEM		0	</span><span class="cm">/* reiserfs kernel memory mode  */</span><span class="cp"></span>
<span class="cp">#define REISERFS_USER_MEM		1	</span><span class="cm">/* reiserfs user memory mode            */</span><span class="cp"></span>

<span class="cp">#define fs_generation(s) (REISERFS_SB(s)-&gt;s_generation_counter)</span>
<span class="cp">#define get_generation(s) atomic_read (&amp;fs_generation(s))</span>
<span class="cp">#define FILESYSTEM_CHANGED_TB(tb)  (get_generation((tb)-&gt;tb_sb) != (tb)-&gt;fs_gen)</span>
<span class="cp">#define __fs_changed(gen,s) (gen != get_generation (s))</span>
<span class="cp">#define fs_changed(gen,s)		\</span>
<span class="cp">({					\</span>
<span class="cp">	reiserfs_cond_resched(s);	\</span>
<span class="cp">	__fs_changed(gen, s);		\</span>
<span class="cp">})</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                  FIXATE NODES                                           */</span>
<span class="cm">/***************************************************************************/</span>

<span class="cp">#define VI_TYPE_LEFT_MERGEABLE 1</span>
<span class="cp">#define VI_TYPE_RIGHT_MERGEABLE 2</span>

<span class="cm">/* To make any changes in the tree we always first find node, that</span>
<span class="cm">   contains item to be changed/deleted or place to insert a new</span>
<span class="cm">   item. We call this node S. To do balancing we need to decide what</span>
<span class="cm">   we will shift to left/right neighbor, or to a new node, where new</span>
<span class="cm">   item will be etc. To make this analysis simpler we build virtual</span>
<span class="cm">   node. Virtual node is an array of items, that will replace items of</span>
<span class="cm">   node S. (For instance if we are going to delete an item, virtual</span>
<span class="cm">   node does not contain it). Virtual node keeps information about</span>
<span class="cm">   item sizes and types, mergeability of first and last items, sizes</span>
<span class="cm">   of all entries in directory item. We use this array of items when</span>
<span class="cm">   calculating what we can shift to neighbors and how many nodes we</span>
<span class="cm">   have to have if we do not any shiftings, if we shift to left/right</span>
<span class="cm">   neighbor or to both. */</span>
<span class="k">struct</span> <span class="n">virtual_item</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">vi_index</span><span class="p">;</span>		<span class="c1">// index in the array of item operations</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vi_type</span><span class="p">;</span>	<span class="c1">// left/right mergeability</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vi_item_len</span><span class="p">;</span>	<span class="cm">/* length of item that it will have after balancing */</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">vi_ih</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vi_item</span><span class="p">;</span>	<span class="c1">// body of item (old or new)</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vi_new_data</span><span class="p">;</span>	<span class="c1">// 0 always but paste mode</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vi_uarea</span><span class="p">;</span>		<span class="c1">// item specific area</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">virtual_node</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">vn_free_ptr</span><span class="p">;</span>	<span class="cm">/* this is a pointer to the free space in the buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vn_nr_item</span><span class="p">;</span>	<span class="cm">/* number of items in virtual node */</span>
	<span class="kt">short</span> <span class="n">vn_size</span><span class="p">;</span>		<span class="cm">/* size of node , that node would have if it has unlimited size and no balancing is performed */</span>
	<span class="kt">short</span> <span class="n">vn_mode</span><span class="p">;</span>		<span class="cm">/* mode of balancing (paste, insert, delete, cut) */</span>
	<span class="kt">short</span> <span class="n">vn_affected_item_num</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">vn_pos_in_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">vn_ins_ih</span><span class="p">;</span>	<span class="cm">/* item header of inserted item, 0 for other modes */</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vn_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span><span class="n">vn_vi</span><span class="p">;</span>	<span class="cm">/* array of items (including a new one, excluding item to be deleted) */</span>
<span class="p">};</span>

<span class="cm">/* used by directory items when creating virtual nodes */</span>
<span class="k">struct</span> <span class="n">direntry_uarea</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">entry_count</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">entry_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                  TREE BALANCE                                           */</span>
<span class="cm">/***************************************************************************/</span>

<span class="cm">/* This temporary structure is used in tree balance algorithms, and</span>
<span class="cm">   constructed as we go to the extent that its various parts are</span>
<span class="cm">   needed.  It contains arrays of nodes that can potentially be</span>
<span class="cm">   involved in the balancing of node S, and parameters that define how</span>
<span class="cm">   each of the nodes must be balanced.  Note that in these algorithms</span>
<span class="cm">   for balancing the worst case is to need to balance the current node</span>
<span class="cm">   S and the left and right neighbors and all of their parents plus</span>
<span class="cm">   create a new node.  We implement S1 balancing for the leaf nodes</span>
<span class="cm">   and S0 balancing for the internal nodes (S1 and S0 are defined in</span>
<span class="cm">   our papers.)*/</span>

<span class="cp">#define MAX_FREE_BLOCK 7	</span><span class="cm">/* size of the array of buffers to free at end of do_balance */</span><span class="cp"></span>

<span class="cm">/* maximum number of FEB blocknrs on a single level */</span>
<span class="cp">#define MAX_AMOUNT_NEEDED 2</span>

<span class="cm">/* someday somebody will prefix every field in this struct with tb_ */</span>
<span class="k">struct</span> <span class="n">tree_balance</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">tb_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_balance_dirty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">tb_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">transaction_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">tb_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* array of left neighbors of nodes in the path */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* array of right neighbors of nodes in the path */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">FL</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* array of fathers of the left  neighbors      */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">FR</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* array of fathers of the right neighbors      */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">CFL</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* array of common parents of center node and its left neighbor  */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">CFR</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* array of common parents of center node and its right neighbor */</span>

	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">FEB</span><span class="p">[</span><span class="n">MAX_FEB_SIZE</span><span class="p">];</span>	<span class="cm">/* array of empty buffers. Number of buffers in array equals</span>
<span class="cm">						   cur_blknum. */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">used</span><span class="p">[</span><span class="n">MAX_FEB_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">thrown</span><span class="p">[</span><span class="n">MAX_FEB_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* array of number of items which must be</span>
<span class="cm">				   shifted to the left in order to balance the</span>
<span class="cm">				   current node; for leaves includes item that</span>
<span class="cm">				   will be partially shifted; for internal</span>
<span class="cm">				   nodes, it is the number of child pointers</span>
<span class="cm">				   rather than items. It includes the new item</span>
<span class="cm">				   being created. The code sometimes subtracts</span>
<span class="cm">				   one to get the number of wholly shifted</span>
<span class="cm">				   items for other purposes. */</span>
	<span class="kt">int</span> <span class="n">rnum</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* substitute right for left in comment above */</span>
	<span class="kt">int</span> <span class="n">lkey</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* array indexed by height h mapping the key delimiting L[h] and</span>
<span class="cm">				   S[h] to its item number within the node CFL[h] */</span>
	<span class="kt">int</span> <span class="n">rkey</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* substitute r for l in comment above */</span>
	<span class="kt">int</span> <span class="n">insert_size</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* the number of bytes by we are trying to add or remove from</span>
<span class="cm">					   S[h]. A negative value means removing.  */</span>
	<span class="kt">int</span> <span class="n">blknum</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>	<span class="cm">/* number of nodes that will replace node S[h] after</span>
<span class="cm">				   balancing on the level h of the tree.  If 0 then S is</span>
<span class="cm">				   being deleted, if 1 then S is remaining and no new nodes</span>
<span class="cm">				   are being created, if 2 or 3 then 1 or 2 new nodes is</span>
<span class="cm">				   being created */</span>

	<span class="cm">/* fields that are used only for balancing leaves of the tree */</span>
	<span class="kt">int</span> <span class="n">cur_blknum</span><span class="p">;</span>		<span class="cm">/* number of empty blocks having been already allocated                 */</span>
	<span class="kt">int</span> <span class="n">s0num</span><span class="p">;</span>		<span class="cm">/* number of items that fall into left most  node when S[0] splits     */</span>
	<span class="kt">int</span> <span class="n">s1num</span><span class="p">;</span>		<span class="cm">/* number of items that fall into first  new node when S[0] splits     */</span>
	<span class="kt">int</span> <span class="n">s2num</span><span class="p">;</span>		<span class="cm">/* number of items that fall into second new node when S[0] splits     */</span>
	<span class="kt">int</span> <span class="n">lbytes</span><span class="p">;</span>		<span class="cm">/* number of bytes which can flow to the left neighbor from the        left    */</span>
	<span class="cm">/* most liquid item that cannot be shifted from S[0] entirely         */</span>
	<span class="cm">/* if -1 then nothing will be partially shifted */</span>
	<span class="kt">int</span> <span class="n">rbytes</span><span class="p">;</span>		<span class="cm">/* number of bytes which will flow to the right neighbor from the right        */</span>
	<span class="cm">/* most liquid item that cannot be shifted from S[0] entirely         */</span>
	<span class="cm">/* if -1 then nothing will be partially shifted                           */</span>
	<span class="kt">int</span> <span class="n">s1bytes</span><span class="p">;</span>		<span class="cm">/* number of bytes which flow to the first  new node when S[0] splits   */</span>
	<span class="cm">/* note: if S[0] splits into 3 nodes, then items do not need to be cut  */</span>
	<span class="kt">int</span> <span class="n">s2bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">buf_to_free</span><span class="p">[</span><span class="n">MAX_FREE_BLOCK</span><span class="p">];</span>	<span class="cm">/* buffers which are to be freed after do_balance finishes by unfix_nodes */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">vn_buf</span><span class="p">;</span>		<span class="cm">/* kmalloced memory. Used to create</span>
<span class="cm">				   virtual node and keep map of</span>
<span class="cm">				   dirtied bitmap blocks */</span>
	<span class="kt">int</span> <span class="n">vn_buf_size</span><span class="p">;</span>	<span class="cm">/* size of the vn_buf */</span>
	<span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span><span class="n">tb_vn</span><span class="p">;</span>	<span class="cm">/* VN starts after bitmap of bitmap blocks */</span>

	<span class="kt">int</span> <span class="n">fs_gen</span><span class="p">;</span>		<span class="cm">/* saved value of `reiserfs_generation&#39; counter</span>
<span class="cm">				   see FILESYSTEM_CHANGED() macro in reiserfs_fs.h */</span>
<span class="cp">#ifdef DISPLACE_NEW_PACKING_LOCALITIES</span>
	<span class="k">struct</span> <span class="n">in_core_key</span> <span class="n">key</span><span class="p">;</span>	<span class="cm">/* key pointer, to pass to block allocator or</span>
<span class="cm">				   another low-level subsystem */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* These are modes of balancing */</span>

<span class="cm">/* When inserting an item. */</span>
<span class="cp">#define M_INSERT	&#39;i&#39;</span>
<span class="cm">/* When inserting into (directories only) or appending onto an already</span>
<span class="cm">   existent item. */</span>
<span class="cp">#define M_PASTE		&#39;p&#39;</span>
<span class="cm">/* When deleting an item. */</span>
<span class="cp">#define M_DELETE	&#39;d&#39;</span>
<span class="cm">/* When truncating an item or removing an entry from a (directory) item. */</span>
<span class="cp">#define M_CUT 		&#39;c&#39;</span>

<span class="cm">/* used when balancing on leaf level skipped (in reiserfsck) */</span>
<span class="cp">#define M_INTERNAL	&#39;n&#39;</span>

<span class="cm">/* When further balancing is not needed, then do_balance does not need</span>
<span class="cm">   to be called. */</span>
<span class="cp">#define M_SKIP_BALANCING 		&#39;s&#39;</span>
<span class="cp">#define M_CONVERT	&#39;v&#39;</span>

<span class="cm">/* modes of leaf_move_items */</span>
<span class="cp">#define LEAF_FROM_S_TO_L 0</span>
<span class="cp">#define LEAF_FROM_S_TO_R 1</span>
<span class="cp">#define LEAF_FROM_R_TO_L 2</span>
<span class="cp">#define LEAF_FROM_L_TO_R 3</span>
<span class="cp">#define LEAF_FROM_S_TO_SNEW 4</span>

<span class="cp">#define FIRST_TO_LAST 0</span>
<span class="cp">#define LAST_TO_FIRST 1</span>

<span class="cm">/* used in do_balance for passing parent of node information that has</span>
<span class="cm">   been gotten from tb struct */</span>
<span class="k">struct</span> <span class="n">buffer_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bi_parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bi_position</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">sb_from_tb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tb</span> <span class="o">?</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">sb_from_bi</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bi</span> <span class="o">?</span> <span class="n">sb_from_tb</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* there are 4 types of items: stat data, directory item, indirect, direct.</span>
<span class="cm">+-------------------+------------+--------------+------------+</span>
<span class="cm">|	            |  k_offset  | k_uniqueness | mergeable? |</span>
<span class="cm">+-------------------+------------+--------------+------------+</span>
<span class="cm">|     stat data     |	0        |      0       |   no       |</span>
<span class="cm">+-------------------+------------+--------------+------------+</span>
<span class="cm">| 1st directory item| DOT_OFFSET |DIRENTRY_UNIQUENESS|   no       | </span>
<span class="cm">| non 1st directory | hash value |              |   yes      |</span>
<span class="cm">|     item          |            |              |            |</span>
<span class="cm">+-------------------+------------+--------------+------------+</span>
<span class="cm">| indirect item     | offset + 1 |TYPE_INDIRECT |   if this is not the first indirect item of the object</span>
<span class="cm">+-------------------+------------+--------------+------------+</span>
<span class="cm">| direct item       | offset + 1 |TYPE_DIRECT   | if not this is not the first direct item of the object</span>
<span class="cm">+-------------------+------------+--------------+------------+</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">item_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bytes_number</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span> <span class="n">ih</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_size</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">decrement_key</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">is_left_mergeable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span> <span class="n">ih</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bsize</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">print_item</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">check_item</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">create_vi</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtual_node</span> <span class="o">*</span> <span class="n">vn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span> <span class="n">vi</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">is_affected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insert_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_left</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span> <span class="n">vi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">start_skip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end_skip</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_right</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span> <span class="n">vi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">part_size</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span> <span class="n">vi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unit_num</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span> <span class="n">vi</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">print_vi</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtual_item</span> <span class="o">*</span> <span class="n">vi</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">item_operations</span> <span class="o">*</span><span class="n">item_ops</span><span class="p">[</span><span class="n">TYPE_ANY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="cp">#define op_bytes_number(ih,bsize)                    item_ops[le_ih_k_type (ih)]-&gt;bytes_number (ih, bsize)</span>
<span class="cp">#define op_is_left_mergeable(key,bsize)              item_ops[le_key_k_type (le_key_version (key), key)]-&gt;is_left_mergeable (key, bsize)</span>
<span class="cp">#define op_print_item(ih,item)                       item_ops[le_ih_k_type (ih)]-&gt;print_item (ih, item)</span>
<span class="cp">#define op_check_item(ih,item)                       item_ops[le_ih_k_type (ih)]-&gt;check_item (ih, item)</span>
<span class="cp">#define op_create_vi(vn,vi,is_affected,insert_size)  item_ops[le_ih_k_type ((vi)-&gt;vi_ih)]-&gt;create_vi (vn,vi,is_affected,insert_size)</span>
<span class="cp">#define op_check_left(vi,free,start_skip,end_skip) item_ops[(vi)-&gt;vi_index]-&gt;check_left (vi, free, start_skip, end_skip)</span>
<span class="cp">#define op_check_right(vi,free)                      item_ops[(vi)-&gt;vi_index]-&gt;check_right (vi, free)</span>
<span class="cp">#define op_part_size(vi,from,to)                     item_ops[(vi)-&gt;vi_index]-&gt;part_size (vi, from, to)</span>
<span class="cp">#define op_unit_num(vi)				     item_ops[(vi)-&gt;vi_index]-&gt;unit_num (vi)</span>
<span class="cp">#define op_print_vi(vi)                              item_ops[(vi)-&gt;vi_index]-&gt;print_vi (vi)</span>

<span class="cp">#define COMP_SHORT_KEYS comp_short_keys</span>

<span class="cm">/* number of blocks pointed to by the indirect item */</span>
<span class="cp">#define I_UNFM_NUM(ih)	(ih_item_len(ih) / UNFM_P_SIZE)</span>

<span class="cm">/* the used space within the unformatted node corresponding to pos within the item pointed to by ih */</span>
<span class="cp">#define I_POS_UNFM_SIZE(ih,pos,size) (((pos) == I_UNFM_NUM(ih) - 1 ) ? (size) - ih_free_space(ih) : (size))</span>

<span class="cm">/* number of bytes contained by the direct item or the unformatted nodes the indirect item points to */</span>

<span class="cm">/* get the item header */</span>
<span class="cp">#define B_N_PITEM_HEAD(bh,item_num) ( (struct item_head * )((bh)-&gt;b_data + BLKH_SIZE) + (item_num) )</span>

<span class="cm">/* get key */</span>
<span class="cp">#define B_N_PDELIM_KEY(bh,item_num) ( (struct reiserfs_key * )((bh)-&gt;b_data + BLKH_SIZE) + (item_num) )</span>

<span class="cm">/* get the key */</span>
<span class="cp">#define B_N_PKEY(bh,item_num) ( &amp;(B_N_PITEM_HEAD(bh,item_num)-&gt;ih_key) )</span>

<span class="cm">/* get item body */</span>
<span class="cp">#define B_N_PITEM(bh,item_num) ( (bh)-&gt;b_data + ih_location(B_N_PITEM_HEAD((bh),(item_num))))</span>

<span class="cm">/* get the stat data by the buffer header and the item order */</span>
<span class="cp">#define B_N_STAT_DATA(bh,nr) \</span>
<span class="cp">( (struct stat_data *)((bh)-&gt;b_data + ih_location(B_N_PITEM_HEAD((bh),(nr))) ) )</span>

    <span class="cm">/* following defines use reiserfs buffer header and item header */</span>

<span class="cm">/* get stat-data */</span>
<span class="cp">#define B_I_STAT_DATA(bh, ih) ( (struct stat_data * )((bh)-&gt;b_data + ih_location(ih)) )</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>this is 3976 for size==4096</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define MAX_DIRECT_ITEM_LEN(size) ((size) - BLKH_SIZE - 2*IH_SIZE - SD_SIZE - UNFM_P_SIZE)</span>

<span class="cm">/* indirect items consist of entries which contain blocknrs, pos</span>
<span class="cm">   indicates which entry, and B_I_POS_UNFM_POINTER resolves to the</span>
<span class="cm">   blocknr contained by the entry pos points to */</span>
<span class="cp">#define B_I_POS_UNFM_POINTER(bh,ih,pos) le32_to_cpu(*(((unp_t *)B_I_PITEM(bh,ih)) + (pos)))</span>
<span class="cp">#define PUT_B_I_POS_UNFM_POINTER(bh,ih,pos, val) do {*(((unp_t *)B_I_PITEM(bh,ih)) + (pos)) = cpu_to_le32(val); } while (0)</span>

<span class="k">struct</span> <span class="n">reiserfs_iget_args</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">dirid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/***************************************************************************/</span>
<span class="cm">/*                    FUNCTION DECLARATIONS                                */</span>
<span class="cm">/***************************************************************************/</span>

<span class="cp">#define get_journal_desc_magic(bh) (bh-&gt;b_data + bh-&gt;b_size - 12)</span>

<span class="cp">#define journal_trans_half(blocksize) \</span>
<span class="cp">	((blocksize - sizeof (struct reiserfs_journal_desc) + sizeof (__u32) - 12) / sizeof (__u32))</span>

<span class="cm">/* journal.c see journal.c for all the comments here */</span>

<span class="cm">/* first block written in a commit.  */</span>
<span class="k">struct</span> <span class="n">reiserfs_journal_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">j_trans_id</span><span class="p">;</span>	<span class="cm">/* id of commit */</span>
	<span class="n">__le32</span> <span class="n">j_len</span><span class="p">;</span>		<span class="cm">/* length of commit. len +1 is the commit block */</span>
	<span class="n">__le32</span> <span class="n">j_mount_id</span><span class="p">;</span>	<span class="cm">/* mount id of this trans */</span>
	<span class="n">__le32</span> <span class="n">j_realblock</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* real locations for each block */</span>
<span class="p">};</span>

<span class="cp">#define get_desc_trans_id(d)   le32_to_cpu((d)-&gt;j_trans_id)</span>
<span class="cp">#define get_desc_trans_len(d)  le32_to_cpu((d)-&gt;j_len)</span>
<span class="cp">#define get_desc_mount_id(d)   le32_to_cpu((d)-&gt;j_mount_id)</span>

<span class="cp">#define set_desc_trans_id(d,val)       do { (d)-&gt;j_trans_id = cpu_to_le32 (val); } while (0)</span>
<span class="cp">#define set_desc_trans_len(d,val)      do { (d)-&gt;j_len = cpu_to_le32 (val); } while (0)</span>
<span class="cp">#define set_desc_mount_id(d,val)       do { (d)-&gt;j_mount_id = cpu_to_le32 (val); } while (0)</span>

<span class="cm">/* last block written in a commit */</span>
<span class="k">struct</span> <span class="n">reiserfs_journal_commit</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">j_trans_id</span><span class="p">;</span>	<span class="cm">/* must match j_trans_id from the desc block */</span>
	<span class="n">__le32</span> <span class="n">j_len</span><span class="p">;</span>		<span class="cm">/* ditto */</span>
	<span class="n">__le32</span> <span class="n">j_realblock</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* real locations for each block */</span>
<span class="p">};</span>

<span class="cp">#define get_commit_trans_id(c) le32_to_cpu((c)-&gt;j_trans_id)</span>
<span class="cp">#define get_commit_trans_len(c)        le32_to_cpu((c)-&gt;j_len)</span>
<span class="cp">#define get_commit_mount_id(c) le32_to_cpu((c)-&gt;j_mount_id)</span>

<span class="cp">#define set_commit_trans_id(c,val)     do { (c)-&gt;j_trans_id = cpu_to_le32 (val); } while (0)</span>
<span class="cp">#define set_commit_trans_len(c,val)    do { (c)-&gt;j_len = cpu_to_le32 (val); } while (0)</span>

<span class="cm">/* this header block gets written whenever a transaction is considered fully flushed, and is more recent than the</span>
<span class="cm">** last fully flushed transaction.  fully flushed means all the log blocks and all the real blocks are on disk,</span>
<span class="cm">** and this transaction does not need to be replayed.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">reiserfs_journal_header</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">j_last_flush_trans_id</span><span class="p">;</span>	<span class="cm">/* id of last fully flushed transaction */</span>
	<span class="n">__le32</span> <span class="n">j_first_unflushed_offset</span><span class="p">;</span>	<span class="cm">/* offset in the log of where to start replay after a crash */</span>
	<span class="n">__le32</span> <span class="n">j_mount_id</span><span class="p">;</span>
	<span class="cm">/* 12 */</span> <span class="k">struct</span> <span class="n">journal_params</span> <span class="n">jh_journal</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* biggest tunable defines are right here */</span>
<span class="cp">#define JOURNAL_BLOCK_COUNT 8192	</span><span class="cm">/* number of blocks in the journal */</span><span class="cp"></span>
<span class="cp">#define JOURNAL_TRANS_MAX_DEFAULT 1024	</span><span class="cm">/* biggest possible single transaction, don&#39;t change for now (8/3/99) */</span><span class="cp"></span>
<span class="cp">#define JOURNAL_TRANS_MIN_DEFAULT 256</span>
<span class="cp">#define JOURNAL_MAX_BATCH_DEFAULT   900	</span><span class="cm">/* max blocks to batch into one transaction, don&#39;t make this any bigger than 900 */</span><span class="cp"></span>
<span class="cp">#define JOURNAL_MIN_RATIO 2</span>
<span class="cp">#define JOURNAL_MAX_COMMIT_AGE 30</span>
<span class="cp">#define JOURNAL_MAX_TRANS_AGE 30</span>
<span class="cp">#define JOURNAL_PER_BALANCE_CNT (3 * (MAX_HEIGHT-2) + 9)</span>
<span class="cp">#define JOURNAL_BLOCKS_PER_OBJECT(sb)  (JOURNAL_PER_BALANCE_CNT * 3 + \</span>
<span class="cp">					 2 * (REISERFS_QUOTA_INIT_BLOCKS(sb) + \</span>
<span class="cp">					      REISERFS_QUOTA_TRANS_BLOCKS(sb)))</span>

<span class="cp">#ifdef CONFIG_QUOTA</span>
<span class="cp">#define REISERFS_QUOTA_OPTS ((1 &lt;&lt; REISERFS_USRQUOTA) | (1 &lt;&lt; REISERFS_GRPQUOTA))</span>
<span class="cm">/* We need to update data and inode (atime) */</span>
<span class="cp">#define REISERFS_QUOTA_TRANS_BLOCKS(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; REISERFS_QUOTA_OPTS ? 2 : 0)</span>
<span class="cm">/* 1 balancing, 1 bitmap, 1 data per write + stat data update */</span>
<span class="cp">#define REISERFS_QUOTA_INIT_BLOCKS(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; REISERFS_QUOTA_OPTS ? \</span>
<span class="cp">(DQUOT_INIT_ALLOC*(JOURNAL_PER_BALANCE_CNT+2)+DQUOT_INIT_REWRITE+1) : 0)</span>
<span class="cm">/* same as with INIT */</span>
<span class="cp">#define REISERFS_QUOTA_DEL_BLOCKS(s) (REISERFS_SB(s)-&gt;s_mount_opt &amp; REISERFS_QUOTA_OPTS ? \</span>
<span class="cp">(DQUOT_DEL_ALLOC*(JOURNAL_PER_BALANCE_CNT+2)+DQUOT_DEL_REWRITE+1) : 0)</span>
<span class="cp">#else</span>
<span class="cp">#define REISERFS_QUOTA_TRANS_BLOCKS(s) 0</span>
<span class="cp">#define REISERFS_QUOTA_INIT_BLOCKS(s) 0</span>
<span class="cp">#define REISERFS_QUOTA_DEL_BLOCKS(s) 0</span>
<span class="cp">#endif</span>

<span class="cm">/* both of these can be as low as 1, or as high as you want.  The min is the</span>
<span class="cm">** number of 4k bitmap nodes preallocated on mount. New nodes are allocated</span>
<span class="cm">** as needed, and released when transactions are committed.  On release, if </span>
<span class="cm">** the current number of nodes is &gt; max, the node is freed, otherwise, </span>
<span class="cm">** it is put on a free list for faster use later.</span>
<span class="cm">*/</span>
<span class="cp">#define REISERFS_MIN_BITMAP_NODES 10</span>
<span class="cp">#define REISERFS_MAX_BITMAP_NODES 100</span>

<span class="cp">#define JBH_HASH_SHIFT 13	</span><span class="cm">/* these are based on journal hash size of 8192 */</span><span class="cp"></span>
<span class="cp">#define JBH_HASH_MASK 8191</span>

<span class="cp">#define _jhashfn(sb,block)	\</span>
<span class="cp">	(((unsigned long)sb&gt;&gt;L1_CACHE_SHIFT) ^ \</span>
<span class="cp">	 (((block)&lt;&lt;(JBH_HASH_SHIFT - 6)) ^ ((block) &gt;&gt; 13) ^ ((block) &lt;&lt; (JBH_HASH_SHIFT - 12))))</span>
<span class="cp">#define journal_hash(t,sb,block) ((t)[_jhashfn((sb),(block)) &amp; JBH_HASH_MASK])</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>We need these to make journal.c code more readable</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define journal_find_get_block(s, block) __find_get_block(SB_JOURNAL(s)-&gt;j_dev_bd, block, s-&gt;s_blocksize)</span>
<span class="cp">#define journal_getblk(s, block) __getblk(SB_JOURNAL(s)-&gt;j_dev_bd, block, s-&gt;s_blocksize)</span>
<span class="cp">#define journal_bread(s, block) __bread(SB_JOURNAL(s)-&gt;j_dev_bd, block, s-&gt;s_blocksize)</span>

<span class="k">enum</span> <span class="n">reiserfs_bh_state_bits</span> <span class="p">{</span>
	<span class="n">BH_JDirty</span> <span class="o">=</span> <span class="n">BH_PrivateStart</span><span class="p">,</span>	<span class="cm">/* buffer is in current transaction */</span>
	<span class="n">BH_JDirty_wait</span><span class="p">,</span>
	<span class="n">BH_JNew</span><span class="p">,</span>		<span class="cm">/* disk block was taken off free list before</span>
<span class="cm">				 * being in a finished transaction, or</span>
<span class="cm">				 * written to disk. Can be reused immed. */</span>
	<span class="n">BH_JPrepared</span><span class="p">,</span>
	<span class="n">BH_JRestore_dirty</span><span class="p">,</span>
	<span class="n">BH_JTest</span><span class="p">,</span>		<span class="c1">// debugging only will go away</span>
<span class="p">};</span>

<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">JDirty</span><span class="p">,</span> <span class="n">journaled</span><span class="p">);</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">JDirty</span><span class="p">,</span> <span class="n">journaled</span><span class="p">);</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">JDirty_wait</span><span class="p">,</span> <span class="n">journal_dirty</span><span class="p">);</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">JDirty_wait</span><span class="p">,</span> <span class="n">journal_dirty</span><span class="p">);</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">JNew</span><span class="p">,</span> <span class="n">journal_new</span><span class="p">);</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">JNew</span><span class="p">,</span> <span class="n">journal_new</span><span class="p">);</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">JPrepared</span><span class="p">,</span> <span class="n">journal_prepared</span><span class="p">);</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">JPrepared</span><span class="p">,</span> <span class="n">journal_prepared</span><span class="p">);</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">JRestore_dirty</span><span class="p">,</span> <span class="n">journal_restore_dirty</span><span class="p">);</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">JRestore_dirty</span><span class="p">,</span> <span class="n">journal_restore_dirty</span><span class="p">);</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">JTest</span><span class="p">,</span> <span class="n">journal_test</span><span class="p">);</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">JTest</span><span class="p">,</span> <span class="n">journal_test</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">** transaction handle which is passed around for all journal calls</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">t_super</span><span class="p">;</span>	<span class="cm">/* super for this FS when journal_begin was</span>
<span class="cm">					   called. saves calls to reiserfs_get_super</span>
<span class="cm">					   also used by nested transactions to make</span>
<span class="cm">					   sure they are nesting on the right FS</span>
<span class="cm">					   _must_ be first in the handle</span>
<span class="cm">					 */</span>
	<span class="kt">int</span> <span class="n">t_refcount</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t_blocks_logged</span><span class="p">;</span>	<span class="cm">/* number of blocks this writer has logged */</span>
	<span class="kt">int</span> <span class="n">t_blocks_allocated</span><span class="p">;</span>	<span class="cm">/* number of blocks this writer allocated */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t_trans_id</span><span class="p">;</span>	<span class="cm">/* sanity check, equals the current trans id */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">t_handle_save</span><span class="p">;</span>	<span class="cm">/* save existing current-&gt;journal_info */</span>
	<span class="kt">unsigned</span> <span class="n">displace_new_blocks</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* if new block allocation occurres, that block</span>
<span class="cm">					   should be displaced from others */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">t_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* used to keep track of ordered and tail writes, attached to the buffer</span>
<span class="cm"> * head through b_journal_head.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">reiserfs_jh</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">reiserfs_free_jh</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_add_tail_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_add_ordered_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_mark_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_file_data_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_data_log</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">i_data_log</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_transaction_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span> <span class="o">==</span> <span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_transaction_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span> <span class="o">-</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_logged</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">reiserfs_persistent_transaction</span><span class="p">(</span><span class="k">struct</span>
								    <span class="n">super_block</span>
								    <span class="o">*</span><span class="p">,</span>
								    <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_commit_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_flush_old_commits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_commit_for_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_inode_needs_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_wait_on_write_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_block_writes</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_allow_writes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_check_lock_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caller</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">j_dev_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">old_format</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_release_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_end_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_mark_freed</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">blocknr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_transaction_should_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_in_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bmap_nr</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">bit_nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">searchall</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_join_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_abort_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">errno</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">errno</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="n">reiserfs_allocate_list_bitmaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">reiserfs_list_bitmap</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">reiserfs_schedule_old_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">add_save_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">truncate</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">remove_save_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">truncate</span><span class="p">);</span>

<span class="cm">/* objectid.c */</span>
<span class="n">__u32</span> <span class="n">reiserfs_get_unused_objectid</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_release_objectid</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			       <span class="n">__u32</span> <span class="n">objectid_to_release</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_convert_objectid_map_v1</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* stree.c */</span>
<span class="kt">int</span> <span class="n">B_IS_IN_TREE</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">copy_item_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>first key is in cpu form, second - le</p></td><td class="code"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="n">comp_short_keys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">le_key</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">le_key2cpu_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>both are in le form</p></td><td class="code"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="n">comp_le_keys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">comp_short_le_keys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>get key version from on disk key - kludge</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">le_key_version</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">offset_v2_k_type</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">k_offset_v2</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_DIRECT</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_INDIRECT</span>
	    <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">TYPE_DIRENTRY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">KEY_FORMAT_3_6</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">copy_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">comp_items</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">stored_ih</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">get_rkey</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">chk_path</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">search_by_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#define search_item(s,key,path) search_by_key (s, key, path, DISK_LEAF_NODE_LEVEL)</span>
<span class="kt">int</span> <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">decrement_bcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">decrement_counters_in_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pathrelse</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_check_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pathrelse_and_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">search_path</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">reiserfs_insert_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">reiserfs_paste_into_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paste_size</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">reiserfs_cut_from_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_file_size</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">reiserfs_delete_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">un_bh</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">reiserfs_delete_solid_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_delete_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_do_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">update_timestamps</span><span class="p">);</span>

<span class="cp">#define i_block_size(inode) ((inode)-&gt;i_sb-&gt;s_blocksize)</span>
<span class="cp">#define file_size(inode) ((inode)-&gt;i_size)</span>
<span class="cp">#define tail_size(inode) (file_size (inode) &amp; (i_block_size (inode) - 1))</span>

<span class="cp">#define tail_has_to_be_packed(inode) (have_large_tails ((inode)-&gt;i_sb)?\</span>
<span class="cp">!STORE_TAIL_IN_UNFM_S1(file_size (inode), tail_size(inode), inode-&gt;i_sb-&gt;s_blocksize):have_small_tails ((inode)-&gt;i_sb)?!STORE_TAIL_IN_UNFM_S2(file_size (inode), tail_size(inode), inode-&gt;i_sb-&gt;s_blocksize):0 )</span>

<span class="kt">void</span> <span class="n">padd_item</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">total_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>

<span class="cm">/* inode.c */</span>
<span class="cm">/* args for the create parameter of reiserfs_get_block */</span>
<span class="cp">#define GET_BLOCK_NO_CREATE 0	</span><span class="cm">/* don&#39;t create new blocks or convert tails */</span><span class="cp"></span>
<span class="cp">#define GET_BLOCK_CREATE 1	</span><span class="cm">/* add anything you need to find block */</span><span class="cp"></span>
<span class="cp">#define GET_BLOCK_NO_HOLE 2	</span><span class="cm">/* return -ENOENT for file holes */</span><span class="cp"></span>
<span class="cp">#define GET_BLOCK_READ_DIRECT 4	</span><span class="cm">/* read the tail if indirect item not found */</span><span class="cp"></span>
<span class="cp">#define GET_BLOCK_NO_IMUX     8	</span><span class="cm">/* i_mutex is not held, don&#39;t preallocate */</span><span class="cp"></span>
<span class="cp">#define GET_BLOCK_NO_DANGLE   16	</span><span class="cm">/* don&#39;t leave any transactions running */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">reiserfs_read_locked_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">reiserfs_iget_args</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_find_actor</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_init_locked_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">reiserfs_fh_to_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">reiserfs_fh_to_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_encode_fh</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">reiserfs_truncate_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">update_timestamps</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">make_cpu_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key_length</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">make_le_item_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">version</span><span class="p">,</span>
		       <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry_count</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">reiserfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">reiserfs_security_handle</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">reiserfs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">reiserfs_security_handle</span> <span class="o">*</span><span class="n">security</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">reiserfs_update_sd_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reiserfs_update_sd</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reiserfs_update_sd_size</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">sd_attrs_to_i_attrs</span><span class="p">(</span><span class="n">__u16</span> <span class="n">sd_attrs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">i_attrs_to_sd_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">__u16</span> <span class="o">*</span> <span class="n">sd_attrs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__reiserfs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* namei.c */</span>
<span class="kt">void</span> <span class="n">set_de_name_and_namelen</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_dir_entry</span> <span class="o">*</span><span class="n">de</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">search_by_entry_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_dir_entry</span> <span class="o">*</span><span class="n">de</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">reiserfs_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_REISERFS_PROC_INFO</span>
<span class="kt">int</span> <span class="n">reiserfs_proc_info_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_proc_info_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_proc_info_global_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_proc_info_global_done</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define PROC_EXP( e )   e</span>

<span class="cp">#define __PINFO( sb ) REISERFS_SB(sb) -&gt; s_proc_info_data</span>
<span class="cp">#define PROC_INFO_MAX( sb, field, value )								\</span>
<span class="cp">    __PINFO( sb ).field =												\</span>
<span class="cp">        max( REISERFS_SB( sb ) -&gt; s_proc_info_data.field, value )</span>
<span class="cp">#define PROC_INFO_INC( sb, field ) ( ++ ( __PINFO( sb ).field ) )</span>
<span class="cp">#define PROC_INFO_ADD( sb, field, val ) ( __PINFO( sb ).field += ( val ) )</span>
<span class="cp">#define PROC_INFO_BH_STAT( sb, bh, level )							\</span>
<span class="cp">    PROC_INFO_INC( sb, sbk_read_at[ ( level ) ] );						\</span>
<span class="cp">    PROC_INFO_ADD( sb, free_at[ ( level ) ], B_FREE_SPACE( bh ) );	\</span>
<span class="cp">    PROC_INFO_ADD( sb, items_at[ ( level ) ], B_NR_ITEMS( bh ) )</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_proc_info_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_proc_info_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_proc_info_global_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_proc_info_global_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PROC_EXP( e )</span>
<span class="cp">#define VOID_V ( ( void ) 0 )</span>
<span class="cp">#define PROC_INFO_MAX( sb, field, value ) VOID_V</span>
<span class="cp">#define PROC_INFO_INC( sb, field ) VOID_V</span>
<span class="cp">#define PROC_INFO_ADD( sb, field, val ) VOID_V</span>
<span class="cp">#define PROC_INFO_BH_STAT(sb, bh, n_node_level) VOID_V</span>
<span class="cp">#endif</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">reiserfs_dir_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">reiserfs_symlink_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">reiserfs_special_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">reiserfs_dir_operations</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">reiserfs_readdir_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">filldir_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* tail_conversion.c */</span>
<span class="kt">int</span> <span class="n">direct2indirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">indirect2direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="p">,</span>
		    <span class="n">loff_t</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_unmap_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* file.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">reiserfs_file_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">reiserfs_file_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">reiserfs_address_space_operations</span><span class="p">;</span>

<span class="cm">/* fix_nodes.c */</span>

<span class="kt">int</span> <span class="n">fix_nodes</span><span class="p">(</span><span class="kt">int</span> <span class="n">n_op_mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ins_ih</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unfix_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* prints.c */</span>
<span class="kt">void</span> <span class="n">__reiserfs_panic</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
    <span class="n">__attribute__</span> <span class="p">((</span><span class="n">noreturn</span><span class="p">));</span>
<span class="cp">#define reiserfs_panic(s, id, fmt, args...) \</span>
<span class="cp">	__reiserfs_panic(s, id, __func__, fmt, ##args)</span>
<span class="kt">void</span> <span class="n">__reiserfs_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#define reiserfs_error(s, id, fmt, args...) \</span>
<span class="cp">	 __reiserfs_error(s, id, __func__, fmt, ##args)</span>
<span class="kt">void</span> <span class="n">reiserfs_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">void</span> <span class="n">reiserfs_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">void</span> <span class="n">print_indirect_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">item_num</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">store_print_tb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_cur_tb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">mes</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_de</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_dir_entry</span> <span class="o">*</span><span class="n">de</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_bi</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mes</span><span class="p">);</span>
<span class="cp">#define PRINT_LEAF_ITEMS 1	</span><span class="cm">/* print all items */</span><span class="cp"></span>
<span class="cp">#define PRINT_DIRECTORY_ITEMS 2	</span><span class="cm">/* print directory items */</span><span class="cp"></span>
<span class="cp">#define PRINT_DIRECT_ITEMS 4	</span><span class="cm">/* print contents of direct items */</span><span class="cp"></span>
<span class="kt">void</span> <span class="n">print_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">void</span> <span class="n">print_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_bmap_block</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">);</span>
<span class="cm">/*void print_super_block (struct super_block * s, char * mes);*/</span>
<span class="kt">void</span> <span class="n">print_objectid_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_block_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mes</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">check_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">check_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">reiserfs_hashname</span><span class="p">(</span><span class="kt">int</span> <span class="n">code</span><span class="p">);</span>

<span class="cm">/* lbalance.c */</span>
<span class="kt">int</span> <span class="n">leaf_move_items</span><span class="p">(</span><span class="kt">int</span> <span class="n">shift_mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mov_num</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">mov_bytes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">Snew</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">leaf_shift_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift_bytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">leaf_shift_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift_bytes</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">leaf_delete_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">cur_bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">del_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">del_bytes</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">before</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">inserted_item_ih</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inserted_item_body</span><span class="p">,</span> <span class="kt">int</span> <span class="n">zeros_number</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pasted_item_num</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paste_size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">zeros_number</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">leaf_cut_from_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cut_item_num</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cut_size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">leaf_paste_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">item_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">before</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">new_entry_count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="o">*</span><span class="n">new_dehs</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">records</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paste_size</span><span class="p">);</span>
<span class="cm">/* ibalance.c */</span>
<span class="kt">int</span> <span class="n">balance_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="p">);</span>

<span class="cm">/* do_balance.c */</span>
<span class="kt">void</span> <span class="n">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="cp">#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty</span>
<span class="cp">#define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty</span>

<span class="kt">void</span> <span class="n">do_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">replace_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">make_empty_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">get_FEB</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* bitmap.c */</span>

<span class="cm">/* structure contains hints for block allocator, and it is a container for</span>
<span class="cm"> * arguments, such as node, search path, transaction_handle, etc. */</span>
<span class="k">struct</span> <span class="n">__reiserfs_blocknr_hint</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>	<span class="cm">/* inode passed to allocator, if we allocate unf. nodes */</span>
	<span class="n">sector_t</span> <span class="n">block</span><span class="p">;</span>		<span class="cm">/* file offset, in blocks */</span>
	<span class="k">struct</span> <span class="n">in_core_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>	<span class="cm">/* search path, used by allocator to deternine search_start by</span>
<span class="cm">				 * various ways */</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>	<span class="cm">/* transaction handle is needed to log super blocks and</span>
<span class="cm">						 * bitmap blocks changes  */</span>
	<span class="n">b_blocknr_t</span> <span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">search_start</span><span class="p">;</span>	<span class="cm">/* a field used to transfer search start value (block number)</span>
<span class="cm">					 * between different block allocator procedures</span>
<span class="cm">					 * (determine_search_start() and others) */</span>
	<span class="kt">int</span> <span class="n">prealloc_size</span><span class="p">;</span>	<span class="cm">/* is set in determine_prealloc_size() function, used by underlayed</span>
<span class="cm">				 * function that do actual allocation */</span>

	<span class="kt">unsigned</span> <span class="n">formatted_node</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* the allocator uses different polices for getting disk space for</span>
<span class="cm">					 * formatted/unformatted blocks with/without preallocation */</span>
	<span class="kt">unsigned</span> <span class="n">preallocate</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__reiserfs_blocknr_hint</span> <span class="n">reiserfs_blocknr_hint_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">reiserfs_parse_alloc_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_init_alloc_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * given a directory, this will tell you what packing locality</span>
<span class="cm"> * to use for a new object underneat it.  The locality is returned</span>
<span class="cm"> * in disk byte order (le).</span>
<span class="cm"> */</span>
<span class="n">__le32</span> <span class="n">reiserfs_choose_packing</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">reiserfs_init_bitmap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_free_bitmap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_cache_bitmap_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">reiserfs_bitmap_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">reiserfs_read_bitmap_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitmap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_reusable</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_value</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
			 <span class="n">b_blocknr_t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">for_unformatted</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_allocate_blocknrs</span><span class="p">(</span><span class="n">reiserfs_blocknr_hint_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
			       <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_new_form_blocknrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
					     <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">new_blocknrs</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">amount_needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reiserfs_blocknr_hint_t</span> <span class="n">hint</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">th</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">transaction_handle</span><span class="p">,</span>
		<span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
		<span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
		<span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">formatted_node</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">reiserfs_allocate_blocknrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hint</span><span class="p">,</span> <span class="n">new_blocknrs</span><span class="p">,</span> <span class="n">amount_needed</span><span class="p">,</span>
					  <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_new_unf_blocknrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span>
					    <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					    <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">new_blocknrs</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					    <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reiserfs_blocknr_hint_t</span> <span class="n">hint</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">th</span> <span class="o">=</span> <span class="n">th</span><span class="p">,</span>
		<span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span>
		<span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">,</span>
		<span class="p">.</span><span class="n">formatted_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preallocate</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">reiserfs_allocate_blocknrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hint</span><span class="p">,</span> <span class="n">new_blocknrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef REISERFS_PREALLOCATE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">reiserfs_new_unf_blocknrs2</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span>
					     <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					     <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">new_blocknrs</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					     <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reiserfs_blocknr_hint_t</span> <span class="n">hint</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">th</span> <span class="o">=</span> <span class="n">th</span><span class="p">,</span>
		<span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span>
		<span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">,</span>
		<span class="p">.</span><span class="n">formatted_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preallocate</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">reiserfs_allocate_blocknrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hint</span><span class="p">,</span> <span class="n">new_blocknrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">reiserfs_discard_prealloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">reiserfs_discard_all_prealloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* hashes.c */</span>
<span class="n">__u32</span> <span class="n">keyed_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="n">__u32</span> <span class="n">yura_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="n">__u32</span> <span class="n">r5_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#define reiserfs_set_le_bit		__set_bit_le</span>
<span class="cp">#define reiserfs_test_and_set_le_bit	__test_and_set_bit_le</span>
<span class="cp">#define reiserfs_clear_le_bit		__clear_bit_le</span>
<span class="cp">#define reiserfs_test_and_clear_le_bit	__test_and_clear_bit_le</span>
<span class="cp">#define reiserfs_test_le_bit		test_bit_le</span>
<span class="cp">#define reiserfs_find_next_zero_le_bit	find_next_zero_bit_le</span>

<span class="cm">/* sometimes reiserfs_truncate may require to allocate few new blocks</span>
<span class="cm">   to perform indirect2direct conversion. People probably used to</span>
<span class="cm">   think, that truncate should work without problems on a filesystem</span>
<span class="cm">   without free disk space. They may complain that they can not</span>
<span class="cm">   truncate due to lack of free disk space. This spare space allows us</span>
<span class="cm">   to not worry about it. 500 is probably too much, but it should be</span>
<span class="cm">   absolutely safe */</span>
<span class="cp">#define SPARE_SPACE 500</span>

<span class="cm">/* prototypes from ioctl.c */</span>
<span class="kt">long</span> <span class="n">reiserfs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">reiserfs_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">reiserfs_unpack</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
