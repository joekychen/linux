<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &quot;acl.h&quot;</span>
<span class="cp">#include &quot;xattr.h&quot;</span>
<span class="cp">#include &lt;linux/exportfs.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>

<span class="kt">int</span> <span class="n">reiserfs_commit_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">reiserfs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We need blocks for transaction + (user+group) quota update (possibly delete) */</span>
	<span class="kt">int</span> <span class="n">jbegin_count</span> <span class="o">=</span>
	    <span class="n">JOURNAL_PER_BALANCE_CNT</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span>
	    <span class="mi">2</span> <span class="o">*</span> <span class="n">REISERFS_QUOTA_INIT_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="cm">/* The = 0 happens when we abort creating a new inode for some reason like lack of space.. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* also handles bad_inode case */</span>
		<span class="n">reiserfs_delete_xattrs</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="n">reiserfs_discard_prealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">reiserfs_delete_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="cm">/* Do quota update inside a transaction for journaled quotas. We must do that</span>
<span class="cm">		 * after delete_object so that quota updates go into the same transaction as</span>
<span class="cm">		 * stat data deletion */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> 
			<span class="n">dquot_free_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* check return value from reiserfs_delete_object after</span>
<span class="cm">		 * ending the transaction</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* all items of file are deleted, so we can remove &quot;save&quot; link */</span>
		<span class="n">remove_save_link</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* not truncate */</span> <span class="p">);</span>	<span class="cm">/* we can&#39;t do anything</span>
<span class="cm">								 * about an error here */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* no object items are in the tree */</span>
		<span class="p">;</span>
	<span class="p">}</span>
      <span class="nl">out:</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>	<span class="cm">/* note this must go after the journal_end to prevent deadlock */</span>
	<span class="n">dquot_drop</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">no_delete:</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">dquot_drop</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_make_cpu_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">dirid</span><span class="p">,</span>
			  <span class="n">__u32</span> <span class="n">objectid</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="p">;</span>

	<span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_dir_id</span> <span class="o">=</span> <span class="n">dirid</span><span class="p">;</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">set_cpu_key_k_offset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">set_cpu_key_k_type</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">key_length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* take base of inode_key (it comes from inode always) (dirid, objectid) and version from an inode, set</span>
<span class="cm">   offset and type of key */</span>
<span class="kt">void</span> <span class="nf">make_cpu_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_make_cpu_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">get_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
		      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">),</span>
		      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">),</span> <span class="n">offset</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
		      <span class="n">length</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>when key is 0, do not set version and short key</p></td><td class="code"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">make_le_item_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">version</span><span class="p">,</span>
			      <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">entry_count</span> <span class="cm">/*or ih_free_space */</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_dir_id</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">);</span>
		<span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_ih_version</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
	<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">set_le_ih_k_type</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="cm">/*    set_ih_free_space (ih, 0); */</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>for directory items it is entry count, for directs and stat
datas - 0xffff, for indirects - 0</p></td><td class="code"><div class="highlight"><pre>	<span class="n">put_ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">entry_count</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>FIXME: we might cache recently accessed indirect item</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Ugh.  Not too eager for that....
 I cut the code until such time as I see a convincing argument (benchmark).
I don't want a bloated inode struct..., and I don't like code complexity....</p></td><td class="code"><div class="highlight"><pre><span class="cm">/* cutting the code is fine, since it really isn&#39;t in use yet and is easy</span>
<span class="cm">** to add back in.  But, Vladimir has a really good idea here.  Think</span>
<span class="cm">** about what happens for reading a file.  For each page,</span>
<span class="cm">** The VFS layer calls reiserfs_readpage, who searches the tree to find</span>
<span class="cm">** an indirect item.  This indirect item has X number of pointers, where</span>
<span class="cm">** X is a big number if we&#39;ve done the block allocation right.  But,</span>
<span class="cm">** we only use one or two of these pointers during each call to readpage,</span>
<span class="cm">** needlessly researching again later on.</span>
<span class="cm">**</span>
<span class="cm">** The size of the cache could be dynamic based on the size of the file.</span>
<span class="cm">**</span>
<span class="cm">** I&#39;d also like to see us cache the location the stat data item, since</span>
<span class="cm">** we are needlessly researching for that frequently.</span>
<span class="cm">**</span>
<span class="cm">** --chris</span>
<span class="cm">*/</span>

<span class="cm">/* If this page has a file tail in it, and</span>
<span class="cm">** it was read in by get_block_create_0, the page data is valid,</span>
<span class="cm">** but tail is still sitting in a direct item, and we can&#39;t write to</span>
<span class="cm">** it.  So, look through this page, and check all the mapped buffers</span>
<span class="cm">** to make sure they have valid block numbers.  Any that don&#39;t need</span>
<span class="cm">** to be unmapped, so that __block_write_begin will correctly call</span>
<span class="cm">** reiserfs_get_block to convert the tail into an unformatted node</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fix_tail_page_for_writing</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_unmap_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* reiserfs_get_block does not need to allocate a block only if it has been</span>
<span class="cm">   done already or non-hole position has been found in the indirect item */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">allocation_needed</span><span class="p">(</span><span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">b_blocknr_t</span> <span class="n">allocated</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span>
				    <span class="n">__le32</span> <span class="o">*</span> <span class="n">item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span> <span class="o">&amp;&amp;</span> <span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">get_block_num</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">indirect_item_found</span><span class="p">(</span><span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_block_dev_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
					<span class="n">b_blocknr_t</span> <span class="n">block</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>files which were created in the earlier version can not be longer,
than 2 gb</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">file_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">KEY_FORMAT_3_5</span> <span class="o">||</span>	<span class="c1">// it is new file.</span>
	    <span class="n">block</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">31</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)))</span>	<span class="c1">// old file, but &#39;block&#39; is inside of 2gb</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">restart_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">);</span>

	<span class="n">pathrelse</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="cm">/* we cannot restart while nested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">JOURNAL_PER_BALANCE_CNT</span> <span class="o">*</span> <span class="mi">6</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>it is called by get<em>block when create == 0. Returns block number
for 'block'-th logical block of file. When it hits direct item it
returns 0 (being called from bmap) or read direct item into piece
of page (bh</em>result)</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Please improve the english/clarity in the comment above, as it is
hard to understand.</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">_get_block_create_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="n">tmp_ih</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chars</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>prepare the key to look for the 'block'-th block of file</p></td><td class="code"><div class="highlight"><pre>	<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">block</span> <span class="o">*</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TYPE_ANY</span><span class="p">,</span>
		     <span class="mi">3</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">POSITION_FOUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>We do not return -ENOENT if there is a hole but page is uptodate, because it means
That there is some MMAPED data associated with it that is yet to be written to disk.</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">((</span><span class="n">args</span> <span class="o">&amp;</span> <span class="n">GET_BLOCK_NO_HOLE</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div></td><td class="code"><div class="highlight"><pre>	<span class="n">bh</span> <span class="o">=</span> <span class="n">get_last_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="o">*</span><span class="n">ind_item</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>

		<span class="cm">/* FIXME: here we could cache indirect item or part of it in</span>
<span class="cm">		   the inode to avoid search_by_key in case of subsequent</span>
<span class="cm">		   access to file */</span>
		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">get_block_num</span><span class="p">(</span><span class="n">ind_item</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blocknr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">map_bh</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span> <span class="o">==</span>
			    <span class="p">((</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">set_buffer_boundary</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>We do not return -ENOENT if there is a hole but page is uptodate, because it means
That there is some MMAPED data associated with it that is yet to  be written to disk.</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">((</span><span class="n">args</span> <span class="o">&amp;</span> <span class="n">GET_BLOCK_NO_HOLE</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>requested data are in direct item(s)</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">args</span> <span class="o">&amp;</span> <span class="n">GET_BLOCK_READ_DIRECT</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>we are called by bmap. FIXME: we can not map block of file
when it is stored in direct item(s)</p></td><td class="code"><div class="highlight"><pre>		<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if we&#39;ve got a direct item, and the buffer or page was uptodate,</span>
<span class="cm">	 ** we don&#39;t want to pull data off disk again.  skip to the</span>
<span class="cm">	 ** end, where we map the buffer and return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/*</span>
<span class="cm">		 ** grab_tail_page can trigger calls to reiserfs_get_block on up to date</span>
<span class="cm">		 ** pages without any buffers.  If the page is up to date, we don&#39;t want</span>
<span class="cm">		 ** read old data off disk.  Set the up to date bit on the buffer instead</span>
<span class="cm">		 ** and jump to the end</span>
<span class="cm">		 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">||</span> <span class="n">PageUptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">finished</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>read file tail into part of page</p></td><td class="code"><div class="highlight"><pre>	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>

	<span class="cm">/* we only want to kmap if we are reading the tail into the page.</span>
<span class="cm">	 ** this is not the common case, so we don&#39;t kmap until we are</span>
<span class="cm">	 ** sure we need to.  But, this means the item might move if</span>
<span class="cm">	 ** kmap schedules</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kmap</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="cm">/* make sure we don&#39;t read more bytes than actually exist in</span>
<span class="cm">		 ** the file.  This can happen in odd cases where i_size isn&#39;t</span>
<span class="cm">		 ** correct, and when direct item padding results in a few</span>
<span class="cm">		 ** extra bytes at the end of the direct item</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chars</span> <span class="o">=</span>
			    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
			    <span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="p">;</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">chars</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="p">,</span> <span class="n">chars</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">+=</span> <span class="n">chars</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>we done, if read direct item is not the last item of
node FIXME: we could try to check right delimiting key
to see whether direct item continues in the right
neighbor or rely on i_size</p></td><td class="code"><div class="highlight"><pre>			<span class="k">break</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>update key to look for the next piece</p></td><td class="code"><div class="highlight"><pre>		<span class="n">set_cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="n">chars</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">POSITION_FOUND</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>i/o error most likely</p></td><td class="code"><div class="highlight"><pre>			<span class="k">break</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">get_last_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>

      <span class="nl">finished:</span>
	<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* this buffer has valid data, but isn&#39;t valid for io.  mapping it to</span>
<span class="cm">	 * block #0 tells the rest of reiserfs it just has a tail in it</span>
<span class="cm">	 */</span>
	<span class="n">map_bh</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>this is called to create file map. So, <em>get</em>block<em>create</em>0 will not
read direct item</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="cm">/* do not read the direct item */</span>
	<span class="n">_get_block_create_0</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* special version of get_block that is only used by grab_tail_page right</span>
<span class="cm">** now.  It is sent to __block_write_begin, and when you try to get a</span>
<span class="cm">** block past the end of the file (or a block from a hole) it returns</span>
<span class="cm">** -ENOENT instead of a valid buffer.  __block_write_begin expects to</span>
<span class="cm">** be able to do i/o on the buffers returned, unless an error value</span>
<span class="cm">** is also returned.</span>
<span class="cm">**</span>
<span class="cm">** So, this allows __block_write_begin to be used for reading a single block</span>
<span class="cm">** in a page.  Where it does not produce a valid page for holes, or past the</span>
<span class="cm">** end of the file.  This turns out to be exactly what we need for reading</span>
<span class="cm">** tails for conversion.</span>
<span class="cm">**</span>
<span class="cm">** The point of the wrapper is forcing a certain value for create, even</span>
<span class="cm">** though the VFS layer is calling this function with create==1.  If you</span>
<span class="cm">** don&#39;t want to send create == GET_BLOCK_NO_HOLE to reiserfs_get_block,</span>
<span class="cm">** don&#39;t use this function.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_get_block_create_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">reiserfs_get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span> <span class="n">GET_BLOCK_NO_HOLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is special helper for reiserfs_get_block in case we are executing</span>
<span class="cm">   direct_IO request. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_get_blocks_direct_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					 <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* We set the b_size before reiserfs_get_block call since it is</span>
<span class="cm">	   referenced in convert_tail_for_hole() that may be called from</span>
<span class="cm">	   reiserfs_get_block() */</span>
	<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">reiserfs_get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span>
				 <span class="n">create</span> <span class="o">|</span> <span class="n">GET_BLOCK_NO_DANGLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* don&#39;t allow direct io onto tail pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* make sure future calls to the direct io funcs for this offset</span>
<span class="cm">		 ** in the file fail by unmapping the buffer</span>
<span class="cm">		 */</span>
		<span class="n">clear_buffer_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Possible unpacked tail. Flush the data before pages have</span>
<span class="cm">	   disappeared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">i_pack_on_close_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">reiserfs_commit_for_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">i_pack_on_close_mask</span><span class="p">;</span>

		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** helper function for when reiserfs_get_block is called for a hole</span>
<span class="cm">** but the file tail is still in a direct item</span>
<span class="cm">** bh_result is the buffer head for the hole</span>
<span class="cm">** tail_offset is the offset of the start of the tail in the file</span>
<span class="cm">**</span>
<span class="cm">** This calls prepare_write, which will start a new transaction</span>
<span class="cm">** you should not be in a transaction, or have any paths held when you</span>
<span class="cm">** call this.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_tail_for_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
				 <span class="n">loff_t</span> <span class="n">tail_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tail_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">hole_page</span> <span class="o">=</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tail_offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* always try to read until the end of the block */</span>
	<span class="n">tail_start</span> <span class="o">=</span> <span class="n">tail_offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tail_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">tail_start</span> <span class="o">|</span> <span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">tail_offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="cm">/* hole_page can be zero in case of direct_io, we are sure</span>
<span class="cm">	   that we cannot get here if we write with O_DIRECT into</span>
<span class="cm">	   tail page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hole_page</span> <span class="o">||</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">hole_page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tail_page</span> <span class="o">=</span> <span class="n">grab_cache_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tail_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tail_page</span> <span class="o">=</span> <span class="n">hole_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we don&#39;t have to make sure the conversion did not happen while</span>
<span class="cm">	 ** we were locking the page because anyone that could convert</span>
<span class="cm">	 ** must first take i_mutex.</span>
<span class="cm">	 **</span>
<span class="cm">	 ** We must fix the tail page for writing because it might have buffers</span>
<span class="cm">	 ** that are mapped, but have a block number of 0.  This indicates tail</span>
<span class="cm">	 ** data that has been read directly into the page, and</span>
<span class="cm">	 ** __block_write_begin won&#39;t trigger a get_block in this case.</span>
<span class="cm">	 */</span>
	<span class="n">fix_tail_page_for_writing</span><span class="p">(</span><span class="n">tail_page</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__reiserfs_write_begin</span><span class="p">(</span><span class="n">tail_page</span><span class="p">,</span> <span class="n">tail_start</span><span class="p">,</span>
				      <span class="n">tail_end</span> <span class="o">-</span> <span class="n">tail_start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* tail conversion might change the data in the page */</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">tail_page</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">reiserfs_commit_write</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">tail_page</span><span class="p">,</span> <span class="n">tail_start</span><span class="p">,</span> <span class="n">tail_end</span><span class="p">);</span>

      <span class="nl">unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail_page</span> <span class="o">!=</span> <span class="n">hole_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">tail_page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">tail_page</span><span class="p">);</span>
	<span class="p">}</span>
      <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_allocate_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				  <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				  <span class="n">b_blocknr_t</span> <span class="o">*</span> <span class="n">allocated_block_nr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

<span class="cp">#ifdef REISERFS_PREALLOCATE</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GET_BLOCK_NO_IMUX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">reiserfs_new_unf_blocknrs2</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">allocated_block_nr</span><span class="p">,</span>
						  <span class="n">path</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">reiserfs_new_unf_blocknrs</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					 <span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b_blocknr_t</span> <span class="n">allocated_block_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// b_blocknr_t is (unsigned) 32 bit int</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">unbh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="n">tmp_ih</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fs_gen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lock_depth</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* space reserved in transaction batch:</span>
<span class="cm">	   . 3 balancings in direct-&gt;indirect conversion</span>
<span class="cm">	   . 1 block involved into reiserfs_update_sd()</span>
<span class="cm">	   XXX in practically impossible worst case direct2indirect()</span>
<span class="cm">	   can incur (much) more than 3 balancings.</span>
<span class="cm">	   quota update for user, group */</span>
	<span class="kt">int</span> <span class="n">jbegin_count</span> <span class="o">=</span>
	    <span class="n">JOURNAL_PER_BALANCE_CNT</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
	    <span class="mi">2</span> <span class="o">*</span> <span class="n">REISERFS_QUOTA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dangle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">new_offset</span> <span class="o">=</span>
	    <span class="p">(((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">block</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lock_depth</span> <span class="o">=</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">version</span> <span class="o">=</span> <span class="n">get_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if !create, we aren&#39;t changing the FS, so we don&#39;t need to</span>
<span class="cm">	 ** log anything, so we don&#39;t need to start a transaction</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">create</span> <span class="o">&amp;</span> <span class="n">GET_BLOCK_CREATE</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="cm">/* find number of block-th logical block of the file */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_get_block_create_0</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span>
					  <span class="n">create</span> <span class="o">|</span> <span class="n">GET_BLOCK_READ_DIRECT</span><span class="p">);</span>
		<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if we&#39;re already in a transaction, make sure to close</span>
<span class="cm">	 * any new transactions we start in this func</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">create</span> <span class="o">&amp;</span> <span class="n">GET_BLOCK_NO_DANGLE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">reiserfs_transaction_running</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span>
		<span class="n">dangle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If file is of such a size, that it might have a tail and tails are enabled</span>
<span class="cm">	 ** we should mark it as possibly needing tail packing on close</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">have_large_tails</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
	     <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&lt;</span> <span class="n">i_block_size</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">have_small_tails</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&lt;</span> <span class="n">i_block_size</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
		<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">i_pack_on_close_mask</span><span class="p">;</span>

	<span class="cm">/* set the key of the first byte in the &#39;block&#39;-th block of file */</span>
	<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">new_offset</span><span class="p">,</span> <span class="n">TYPE_ANY</span><span class="p">,</span> <span class="mi">3</span> <span class="cm">/*key length */</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_offset</span> <span class="o">+</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
	      <span class="nl">start_trans:</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">reiserfs_persistent_transaction</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
      <span class="nl">research:</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">get_last_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">get_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">pos_in_item</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="p">;</span>

	<span class="n">fs_gen</span> <span class="o">=</span> <span class="n">get_generation</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">allocation_needed</span>
	    <span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we have to allocate block for the unformatted node */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">start_trans</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">repeat</span> <span class="o">=</span>
		    <span class="n">_allocate_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">allocated_block_nr</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">repeat</span> <span class="o">==</span> <span class="n">NO_DISK_SPACE</span> <span class="o">||</span> <span class="n">repeat</span> <span class="o">==</span> <span class="n">QUOTA_EXCEEDED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* restart the transaction to give the journal a chance to free</span>
<span class="cm">			 ** some blocks.  releases the path, so we have to go back to</span>
<span class="cm">			 ** research if we succeed on the second try</span>
<span class="cm">			 */</span>
			<span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_next_async_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">restart_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
			<span class="n">repeat</span> <span class="o">=</span>
			    <span class="n">_allocate_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">allocated_block_nr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">repeat</span> <span class="o">!=</span> <span class="n">NO_DISK_SPACE</span> <span class="o">&amp;&amp;</span> <span class="n">repeat</span> <span class="o">!=</span> <span class="n">QUOTA_EXCEEDED</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">research</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">repeat</span> <span class="o">==</span> <span class="n">QUOTA_EXCEEDED</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDQUOT</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fs_changed</span><span class="p">(</span><span class="n">fs_gen</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">item_moved</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">research</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">indirect_item_found</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">b_blocknr_t</span> <span class="n">unfm_ptr</span><span class="p">;</span>
		<span class="cm">/* &#39;block&#39;-th block is in the file already (there is</span>
<span class="cm">		   corresponding cell in some indirect item). But it may be</span>
<span class="cm">		   zero unformatted node pointer (hole) */</span>
		<span class="n">unfm_ptr</span> <span class="o">=</span> <span class="n">get_block_num</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unfm_ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* use allocated block to plug the hole */</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fs_changed</span><span class="p">(</span><span class="n">fs_gen</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="n">item_moved</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
								 <span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">research</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh_result</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="n">reiserfs_data_ordered</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span>
				<span class="n">reiserfs_add_ordered_list</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">);</span>
			<span class="n">put_block_num</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">,</span> <span class="n">allocated_block_nr</span><span class="p">);</span>
			<span class="n">unfm_ptr</span> <span class="o">=</span> <span class="n">allocated_block_nr</span><span class="p">;</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_block_dev_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">unfm_ptr</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dangle</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>

		<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>

		<span class="cm">/* the item was found, so new blocks were not added to the file</span>
<span class="cm">		 ** there is no need to make sure the inode is updated with this</span>
<span class="cm">		 ** transaction</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">start_trans</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* desired position is not found or is in the direct item. We have</span>
<span class="cm">	   to append file with holes up to &#39;block&#39;-th block converting</span>
<span class="cm">	   direct items to indirect one if necessary */</span>
	<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_statdata_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">unp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">tmp_key</span><span class="p">;</span>

			<span class="cm">/* indirect item has to be inserted */</span>
			<span class="n">make_le_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="n">TYPE_INDIRECT</span><span class="p">,</span> <span class="n">UNFM_P_SIZE</span><span class="p">,</span>
					  <span class="mi">0</span> <span class="cm">/* free_space */</span> <span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we are going to add &#39;block&#39;-th block to the file. Use</span>
<span class="cm">				   allocated block for that */</span>
				<span class="n">unp</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">allocated_block_nr</span><span class="p">);</span>
				<span class="n">set_block_dev_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span>
						     <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">tmp_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>	<span class="c1">// ;)</span>
			<span class="n">set_cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

			<span class="n">retval</span> <span class="o">=</span>
			    <span class="n">reiserfs_insert_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span>
						 <span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">unp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						    <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>	<span class="c1">// retval == -ENOSPC, -EDQUOT or -EIO or -EEXIST</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>mark<em>tail</em>converted (inode);</p></td><td class="code"><div class="highlight"><pre>		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* direct item has to be converted */</span>
			<span class="n">loff_t</span> <span class="n">tail_offset</span><span class="p">;</span>

			<span class="n">tail_offset</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span>
			      <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tail_offset</span> <span class="o">==</span> <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* direct item we just found fits into block we have</span>
<span class="cm">				   to map. Convert it into unformatted node: use</span>
<span class="cm">				   bh_result for the conversion */</span>
				<span class="n">set_block_dev_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span>
						     <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">unbh</span> <span class="o">=</span> <span class="n">bh_result</span><span class="p">;</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* we have to padd file tail stored in direct item(s)</span>
<span class="cm">				   up to block size and convert it to unformatted</span>
<span class="cm">				   node. FIXME: this should also get into page cache */</span>

				<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * ugly, but we can only end the transaction if</span>
<span class="cm">				 * we aren&#39;t nested</span>
<span class="cm">				 */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">retval</span> <span class="o">=</span>
					    <span class="n">reiserfs_end_persistent_transaction</span>
					    <span class="p">(</span><span class="n">th</span><span class="p">);</span>
					<span class="n">th</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">retval</span> <span class="o">=</span>
				    <span class="n">convert_tail_for_hole</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span>
							  <span class="n">tail_offset</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
						<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
							<span class="s">&quot;clm-6004&quot;</span><span class="p">,</span>
							<span class="s">&quot;convert tail failed &quot;</span>
							<span class="s">&quot;inode %lu, error %d&quot;</span><span class="p">,</span>
							<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
							<span class="n">retval</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">allocated_block_nr</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* the bitmap, the super, and the stat data == 3 */</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="p">)</span>
							<span class="n">th</span> <span class="o">=</span> <span class="n">reiserfs_persistent_transaction</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="p">)</span>
							<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span>
									    <span class="n">inode</span><span class="p">,</span>
									    <span class="n">allocated_block_nr</span><span class="p">,</span>
									    <span class="mi">1</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">research</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">retval</span> <span class="o">=</span>
			    <span class="n">direct2indirect</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">unbh</span><span class="p">,</span>
					    <span class="n">tail_offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_unmap_buffer</span><span class="p">(</span><span class="n">unbh</span><span class="p">);</span>
				<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						    <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* it is important the set_buffer_uptodate is done after</span>
<span class="cm">			 ** the direct2indirect.  The buffer might contain valid</span>
<span class="cm">			 ** data newer than the data on disk (read by readpage, changed,</span>
<span class="cm">			 ** and then sent here by writepage).  direct2indirect needs</span>
<span class="cm">			 ** to know if unbh was already up to date, so it can decide</span>
<span class="cm">			 ** if the data in unbh needs to be replaced with data from</span>
<span class="cm">			 ** the disk</span>
<span class="cm">			 */</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">unbh</span><span class="p">);</span>

			<span class="cm">/* unbh-&gt;b_page == NULL in case of DIRECT_IO request, this means</span>
<span class="cm">			   buffer will disappear shortly, so it should not be added to</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unbh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we&#39;ve converted the tail, so we must</span>
<span class="cm">				 ** flush unbh before the transaction commits</span>
<span class="cm">				 */</span>
				<span class="n">reiserfs_add_tail_list</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">unbh</span><span class="p">);</span>

				<span class="cm">/* mark it dirty now to prevent commit_write from adding</span>
<span class="cm">				 ** this buffer to the inode&#39;s dirty buffer list</span>
<span class="cm">				 */</span>
				<span class="cm">/*</span>
<span class="cm">				 * AKPM: changed __mark_buffer_dirty to mark_buffer_dirty().</span>
<span class="cm">				 * It&#39;s still atomic, but it sets the page dirty too,</span>
<span class="cm">				 * which makes it eligible for writeback at any time by the</span>
<span class="cm">				 * VM (which was also the case with __mark_buffer_dirty())</span>
<span class="cm">				 */</span>
				<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">unbh</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* append indirect item with holes if needed, when appending</span>
<span class="cm">			   pointer to &#39;block&#39;-th block use block, which is already</span>
<span class="cm">			   allocated */</span>
			<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">tmp_key</span><span class="p">;</span>
			<span class="n">unp_t</span> <span class="n">unf_single</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// We use this in case we need to allocate only</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>one block which is a fastpath</p></td><td class="code"><div class="highlight"><pre>			<span class="n">unp_t</span> <span class="o">*</span><span class="n">un</span><span class="p">;</span>
			<span class="n">__u64</span> <span class="n">max_to_insert</span> <span class="o">=</span>
			    <span class="n">MAX_ITEM_LEN</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span> <span class="o">/</span>
			    <span class="n">UNFM_P_SIZE</span><span class="p">;</span>
			<span class="n">__u64</span> <span class="n">blocks_needed</span><span class="p">;</span>

			<span class="n">RFALSE</span><span class="p">(</span><span class="n">pos_in_item</span> <span class="o">!=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span><span class="p">,</span>
			       <span class="s">&quot;vs-804: invalid position for append&quot;</span><span class="p">);</span>
			<span class="cm">/* indirect item has to be appended, set up key of that position */</span>
			<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
				     <span class="n">le_key_k_offset</span><span class="p">(</span><span class="n">version</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">))</span> <span class="o">+</span>
				     <span class="n">op_bytes_number</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span>
						     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">),</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>pos<em>in</em>item * inode->i<em>sb->s</em>blocksize,</p></td><td class="code"><div class="highlight"><pre>				     <span class="n">TYPE_INDIRECT</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>	<span class="c1">// key type is unimportant</span>

			<span class="n">RFALSE</span><span class="p">(</span><span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">),</span>
			       <span class="s">&quot;green-805: invalid offset&quot;</span><span class="p">);</span>
			<span class="n">blocks_needed</span> <span class="o">=</span>
			    <span class="mi">1</span> <span class="o">+</span>
			    <span class="p">((</span><span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">-</span>
			      <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_key</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span>
			     <span class="n">s_blocksize_bits</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">blocks_needed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">un</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unf_single</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">un</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">blocks_needed</span><span class="p">,</span> <span class="n">max_to_insert</span><span class="p">)</span> <span class="o">*</span> <span class="n">UNFM_P_SIZE</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">un</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">un</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unf_single</span><span class="p">;</span>
					<span class="n">blocks_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">max_to_insert</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blocks_needed</span> <span class="o">&lt;=</span> <span class="n">max_to_insert</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we are going to add target block to the file. Use allocated</span>
<span class="cm">				   block for that */</span>
				<span class="n">un</span><span class="p">[</span><span class="n">blocks_needed</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">allocated_block_nr</span><span class="p">);</span>
				<span class="n">set_block_dev_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span>
						     <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* paste hole to the indirect item */</span>
				<span class="cm">/* If kmalloc failed, max_to_insert becomes zero and it means we</span>
<span class="cm">				   only have space for one block */</span>
				<span class="n">blocks_needed</span> <span class="o">=</span>
				    <span class="n">max_to_insert</span> <span class="o">?</span> <span class="n">max_to_insert</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">retval</span> <span class="o">=</span>
			    <span class="n">reiserfs_paste_into_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						     <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">un</span><span class="p">,</span>
						     <span class="n">UNFM_P_SIZE</span> <span class="o">*</span>
						     <span class="n">blocks_needed</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">blocks_needed</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">un</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						    <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We need to mark new file size in case this function will be</span>
<span class="cm">				   interrupted/aborted later on. And we may do this only for</span>
<span class="cm">				   holes. */</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span>
				    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">*</span> <span class="n">blocks_needed</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">done</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* this loop could log more blocks than we had originally asked</span>
<span class="cm">		 ** for.  So, we have to allow the transaction to end if it is</span>
<span class="cm">		 ** too big or too full.  Update the inode so things are</span>
<span class="cm">		 ** consistent if we crash before the function returns</span>
<span class="cm">		 **</span>
<span class="cm">		 ** release the path so that anybody waiting on the path before</span>
<span class="cm">		 ** ending their transaction will be able to continue.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal_transaction_should_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">restart_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * inserting indirect pointers for a hole can take a</span>
<span class="cm">		 * long time.  reschedule if needed and also release the write</span>
<span class="cm">		 * lock for others.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">lock_depth</span> <span class="o">=</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">POSITION_FOUND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-825&quot;</span><span class="p">,</span>
					 <span class="s">&quot;%K should not be found&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">allocated_block_nr</span><span class="p">)</span>
				<span class="n">reiserfs_free_block</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						    <span class="n">allocated_block_nr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">get_last_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">get_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">pos_in_item</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="nl">failure:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">dangle</span> <span class="o">||</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">)</span>
			<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>
	<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">reiserfs_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">reiserfs_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Compute real number of used bytes by file</span>
<span class="cm"> * Following three functions can go away when we&#39;ll have enough space in stat item</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">real_space_diff</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sd_size</span><span class="p">;</span>

	<span class="cm">/* End of file is also in full block with indirect reference, so round</span>
<span class="cm">	 ** up to the next block.</span>
<span class="cm">	 **</span>
<span class="cm">	 ** there is just no way to know if the tail is actually packed</span>
<span class="cm">	 ** on the file, so we have to assume it isn&#39;t.  When we pack the</span>
<span class="cm">	 ** tail, we add 4 bytes to pretend there really is an unformatted</span>
<span class="cm">	 ** node pointer</span>
<span class="cm">	 */</span>
	<span class="n">bytes</span> <span class="o">=</span>
	    <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span>
	      <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span> <span class="o">*</span> <span class="n">UNFM_P_SIZE</span> <span class="o">+</span>
	    <span class="n">sd_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">to_real_used_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ulong</span> <span class="n">blocks</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">sd_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span>
		    <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="p">(</span><span class="n">real_space_diff</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">sd_size</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">real_space_diff</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">sd_size</span><span class="p">))</span> <span class="o">+</span>
	    <span class="p">(((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">blocks</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Compute number of blocks used by file in ReiserFS counting */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ulong</span> <span class="nf">to_fake_used_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">inode_get_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">real_space</span> <span class="o">=</span> <span class="n">real_space_diff</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">sd_size</span><span class="p">);</span>

	<span class="cm">/* keeps fsck and non-quota versions of reiserfs happy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bytes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="mi">511</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* files from before the quota patch might i_blocks such that</span>
<span class="cm">	 ** bytes &lt; real_space.  Deal with that here to prevent it from</span>
<span class="cm">	 ** going negative.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="n">real_space</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">-</span> <span class="n">real_space</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>BAD: new directories have stat data of new type and all other items
of old type. Version stored in the inode says about body items, so
in update<em>stat</em>data we can not rely on inode, but have to check
item version directly</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>called by read<em>locked</em>inode</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">init_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">rdev</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>int version = ITEM<em>VERSION</em>1;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">copy_key</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">));</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_list</span><span class="p">));</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_jl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">reiserfs_init_xattr_rwsem</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat_data_v1</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">stat_data_v1</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">struct</span> <span class="n">stat_data_v1</span> <span class="o">*</span><span class="p">)</span><span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocks</span><span class="p">;</span>

		<span class="n">set_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">);</span>
		<span class="n">set_inode_sd_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">STAT_DATA_V1</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">sd_v1_mode</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">sd_v1_nlink</span><span class="p">(</span><span class="n">sd</span><span class="p">));</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">sd_v1_uid</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">sd_v1_gid</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">sd_v1_size</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sd_v1_atime</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sd_v1_mtime</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sd_v1_ctime</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">sd_v1_blocks</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
		<span class="n">blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="mi">511</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">blocks</span> <span class="o">=</span> <span class="n">_ROUND_UP</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">&gt;</span> <span class="n">blocks</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>there was a bug in &lt;=3.5.23 when i<em>blocks could take negative
values. Starting from 3.5.17 this value could even be stored in
stat data. For such files we set i</em>blocks based on file
size. Just 2 notes: this can be wrong for sparce files. On-disk value will be
only updated if file's inode will ever change</p></td><td class="code"><div class="highlight"><pre>			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rdev</span> <span class="o">=</span> <span class="n">sd_v1_rdev</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_first_direct_byte</span> <span class="o">=</span>
		    <span class="n">sd_v1_first_direct_byte</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="cm">/* an early bug in the quota code can give us an odd number for the</span>
<span class="cm">		 ** block count.  This is incorrect, fix it here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inode_set_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">to_real_used_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">,</span>
						   <span class="n">SD_V1_SIZE</span><span class="p">));</span>
		<span class="cm">/* nopack is initially zero for v1 objects. For v2 objects,</span>
<span class="cm">		   nopack is initialised from sd_attrs */</span>
		<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">i_nopack_mask</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>new stat data found, but object may have old items
(directories and symlinks)</p></td><td class="code"><div class="highlight"><pre>		<span class="k">struct</span> <span class="n">stat_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">stat_data</span> <span class="o">*</span><span class="p">)</span><span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">sd_v2_mode</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">sd_v2_nlink</span><span class="p">(</span><span class="n">sd</span><span class="p">));</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">sd_v2_uid</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">sd_v2_size</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">sd_v2_gid</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sd_v2_mtime</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sd_v2_atime</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sd_v2_ctime</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">sd_v2_blocks</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">rdev</span> <span class="o">=</span> <span class="n">sd_v2_rdev</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">sd_v2_generation</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">set_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">set_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_6</span><span class="p">);</span>
		<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_first_direct_byte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">set_inode_sd_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">STAT_DATA_V2</span><span class="p">);</span>
		<span class="n">inode_set_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">to_real_used_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">,</span>
						   <span class="n">SD_V2_SIZE</span><span class="p">));</span>
		<span class="cm">/* read persistent inode attributes from sd and initialise</span>
<span class="cm">		   generic inode flags from them */</span>
		<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_attrs</span> <span class="o">=</span> <span class="n">sd_v2_attrs</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">sd_attrs_to_i_attrs</span><span class="p">(</span><span class="n">sd_v2_attrs</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pathrelse</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reiserfs_file_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reiserfs_file_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reiserfs_address_space_operations</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reiserfs_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reiserfs_dir_operations</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reiserfs_symlink_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reiserfs_address_space_operations</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reiserfs_special_inode_operations</span><span class="p">;</span>
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">new_decode_dev</span><span class="p">(</span><span class="n">rdev</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>update new stat data with inode fields</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">inode2sd</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stat_data</span> <span class="o">*</span><span class="n">sd_v2</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">stat_data</span> <span class="o">*</span><span class="p">)</span><span class="n">sd</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">set_sd_v2_mode</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">set_sd_v2_nlink</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="n">set_sd_v2_uid</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">set_sd_v2_size</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">set_sd_v2_gid</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="n">set_sd_v2_mtime</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">set_sd_v2_atime</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">set_sd_v2_ctime</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">set_sd_v2_blocks</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">to_fake_used_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">SD_V2_SIZE</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">set_sd_v2_rdev</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">new_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">set_sd_v2_generation</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_attrs</span><span class="p">;</span>
	<span class="n">i_attrs_to_sd_attrs</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_sd_v2_attrs</span><span class="p">(</span><span class="n">sd_v2</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>used to copy inode's fields to old stat data</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">inode2sd_v1</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stat_data_v1</span> <span class="o">*</span><span class="n">sd_v1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">stat_data_v1</span> <span class="o">*</span><span class="p">)</span><span class="n">sd</span><span class="p">;</span>

	<span class="n">set_sd_v1_mode</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">set_sd_v1_uid</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">set_sd_v1_gid</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="n">set_sd_v1_nlink</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="n">set_sd_v1_size</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">set_sd_v1_atime</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">set_sd_v1_ctime</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">set_sd_v1_mtime</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">set_sd_v1_rdev</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">new_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">set_sd_v1_blocks</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span> <span class="n">to_fake_used_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">SD_V1_SIZE</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>Sigh. i<em>first</em>direct_byte is back</p></td><td class="code"><div class="highlight"><pre>	<span class="n">set_sd_v1_first_direct_byte</span><span class="p">(</span><span class="n">sd_v1</span><span class="p">,</span>
				    <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_first_direct_byte</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* NOTE, you must prepare the buffer head before sending it here,</span>
<span class="cm">** and then log it after the call</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_stat_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">PATH_PITEM_HEAD</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_statdata_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-13065&quot;</span><span class="p">,</span> <span class="s">&quot;key %k, found item %h&quot;</span><span class="p">,</span>
			       <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">ih</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat_data_v1</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>path points to old stat data</p></td><td class="code"><div class="highlight"><pre>		<span class="n">inode2sd_v1</span><span class="p">(</span><span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">),</span> <span class="n">inode</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode2sd</span><span class="p">(</span><span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">),</span> <span class="n">inode</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reiserfs_update_sd_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fs_gen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="n">tmp_ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">SD_OFFSET</span><span class="p">,</span> <span class="n">TYPE_STAT_DATA</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>	<span class="c1">//key type is unimportant</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
		<span class="cm">/* look for the object&#39;s stat data */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">search_item</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-13050&quot;</span><span class="p">,</span>
				       <span class="s">&quot;i/o failure occurred trying to &quot;</span>
				       <span class="s">&quot;update %K stat data&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ITEM_NOT_FOUND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">PATH_LAST_POSITION</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*reiserfs_warning (inode-&gt;i_sb, &quot;vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found&quot;); */</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-13060&quot;</span><span class="p">,</span>
					 <span class="s">&quot;stat data of object %k (nlink == %d) &quot;</span>
					 <span class="s">&quot;not found (pos %d)&quot;</span><span class="p">,</span>
					 <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">,</span>
					 <span class="n">pos</span><span class="p">);</span>
			<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* sigh, prepare_for_journal might schedule.  When it schedules the</span>
<span class="cm">		 ** FS might change.  We have to detect that, and loop back to the</span>
<span class="cm">		 ** search if the stat data item has moved</span>
<span class="cm">		 */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">get_last_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
		<span class="n">fs_gen</span> <span class="o">=</span> <span class="n">get_generation</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fs_changed</span><span class="p">(</span><span class="n">fs_gen</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">item_moved</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* Stat_data item has been moved after scheduling. */</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">update_stat_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* reiserfs_read_locked_inode is called to read the inode off disk, and it</span>
<span class="cm">** does a make_bad_inode when things go wrong.  But, we need to make sure</span>
<span class="cm">** and clear the key in the private portion of the inode, otherwise a</span>
<span class="cm">** corresponding iput might try to delete whatever object the inode last</span>
<span class="cm">** represented.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reiserfs_make_bad_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
	<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>initially this function was derived from minix or ext2's analog and
evolved as the prototype did</p></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">reiserfs_init_locked_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_iget_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_iget_args</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dirid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* looks for stat data in the tree, and fills up the fields of in-core</span>
<span class="cm">   inode stat data fields */</span>
<span class="kt">void</span> <span class="nf">reiserfs_read_locked_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">reiserfs_iget_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">path_to_sd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirino</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">dirino</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dirid</span><span class="p">;</span>

	<span class="cm">/* set version 1, version 2 could be used too, because stat data</span>
<span class="cm">	   key is the same in both versions */</span>
	<span class="n">key</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_dir_id</span> <span class="o">=</span> <span class="n">dirino</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* look for the object&#39;s stat data */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">search_item</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path_to_sd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-13070&quot;</span><span class="p">,</span>
			       <span class="s">&quot;i/o failure occurred trying to find &quot;</span>
			       <span class="s">&quot;stat data of %K&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">reiserfs_make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">ITEM_FOUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* a stale NFS handle can trigger this without it being an error */</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_sd</span><span class="p">);</span>
		<span class="n">reiserfs_make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path_to_sd</span><span class="p">);</span>

	<span class="cm">/* It is possible that knfsd is trying to access inode of a file</span>
<span class="cm">	   that is being removed from the disk by some other thread. As we</span>
<span class="cm">	   update sd on unlink all that is required is to check for nlink</span>
<span class="cm">	   here. This bug was first found by Sizif when debugging</span>
<span class="cm">	   SquidNG/Butterfly, forgotten, and found again after Philippe</span>
<span class="cm">	   Gramoulle &lt;philippe.gramoulle@mmania.com&gt; reproduced it.</span>

<span class="cm">	   More logical fix would require changes in fs/inode.c:iput() to</span>
<span class="cm">	   remove inode from hash-table _after_ fs cleaned disk stuff up and</span>
<span class="cm">	   in iget() to return NULL if I_FREEING inode is found in</span>
<span class="cm">	   hash-table. */</span>
	<span class="cm">/* Currently there is one place where it&#39;s ok to meet inode with</span>
<span class="cm">	   nlink==0: processing of open-unlinked and half-truncated files</span>
<span class="cm">	   during mount (fs/reiserfs/super.c:finish_unfinished()). */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_is_unlinked_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;vs-13075&quot;</span><span class="p">,</span>
				 <span class="s">&quot;dead inode read from disk %K. &quot;</span>
				 <span class="s">&quot;This is likely to be race with knfsd. Ignore&quot;</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">reiserfs_make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_sd</span><span class="p">);</span>	<span class="cm">/* init inode should be relsing */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stat data v1 doesn&#39;t support ACLs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_inode_sd_version</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">STAT_DATA_V1</span><span class="p">)</span>
		<span class="n">cache_no_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reiserfs_find_actor() - &quot;find actor&quot; reiserfs supplies to iget5_locked().</span>
<span class="cm"> *</span>
<span class="cm"> * @inode:    inode from hash table to check</span>
<span class="cm"> * @opaque:   &quot;cookie&quot; passed to iget5_locked(). This is &amp;reiserfs_iget_args.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by iget5_locked() to distinguish reiserfs inodes</span>
<span class="cm"> * having the same inode numbers. Such inodes can only exist due to some</span>
<span class="cm"> * error condition. One of them should be bad. Inodes with identical</span>
<span class="cm"> * inode numbers (objectids) are distinguished by parent directory ids.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">reiserfs_find_actor</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_iget_args</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>

	<span class="n">args</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="cm">/* args is already in CPU order */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dirid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">reiserfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpu_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_iget_args</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">args</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">dirid</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">;</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget5_locked</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">,</span>
			     <span class="n">reiserfs_find_actor</span><span class="p">,</span> <span class="n">reiserfs_init_locked_inode</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">));</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_read_locked_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
		<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">comp_short_keys</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* either due to i/o error or a stale NFS handle */</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">reiserfs_get_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">objectid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dir_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">generation</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_objectid</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">on_disk_key</span><span class="p">.</span><span class="n">k_dir_id</span> <span class="o">=</span> <span class="n">dir_id</span><span class="p">;</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">reiserfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">generation</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">generation</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">d_obtain_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">reiserfs_fh_to_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* fhtype happens to reflect the number of u32s encoded.</span>
<span class="cm">	 * due to a bug in earlier code, fhtype might indicate there</span>
<span class="cm">	 * are more u32s then actually fitted.</span>
<span class="cm">	 * so if fhtype seems to be more than len, reduce fhtype.</span>
<span class="cm">	 * Valid types are:</span>
<span class="cm">	 *   2 - objectid + dir_id - legacy support</span>
<span class="cm">	 *   3 - objectid + dir_id + generation</span>
<span class="cm">	 *   4 - objectid + dir_id + objectid and dirid of parent - legacy</span>
<span class="cm">	 *   5 - objectid + dir_id + generation + objectid and dirid of parent</span>
<span class="cm">	 *   6 - as above plus generation of directory</span>
<span class="cm">	 * 6 does not fit in NFSv2 handles</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fh_type</span> <span class="o">&gt;</span> <span class="n">fh_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fh_type</span> <span class="o">!=</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">fh_len</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;reiserfs-13077&quot;</span><span class="p">,</span>
				<span class="s">&quot;nfsd/reiserfs, fhtype=%d, len=%d - odd&quot;</span><span class="p">,</span>
				<span class="n">fh_type</span><span class="p">,</span> <span class="n">fh_len</span><span class="p">);</span>
		<span class="n">fh_type</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">reiserfs_get_dentry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="p">(</span><span class="n">fh_type</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">fh_type</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">?</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">reiserfs_fh_to_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fh_type</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">reiserfs_get_dentry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
		<span class="p">(</span><span class="n">fh_type</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">?</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">:</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
		<span class="p">(</span><span class="n">fh_type</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">?</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">:</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		<span class="p">(</span><span class="n">fh_type</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="o">?</span> <span class="n">fid</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_encode_fh</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">maxlen</span> <span class="o">=</span> <span class="o">*</span><span class="n">lenp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">maxlen</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">255</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maxlen</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">255</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">;</span>
	<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">);</span>
		<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlen</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">;</span>
			<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">lenp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* looks for stat data, then copies fields to it, marks the buffer</span>
<span class="cm">   containing stat data as dirty */</span>
<span class="cm">/* reiserfs inodes are never really dirty, since the dirty inode call</span>
<span class="cm">** always logs them.  This call allows the VFS inode marking routines</span>
<span class="cm">** to properly mark inodes for datasync and such, but only actually</span>
<span class="cm">** does something when called for a synchronous update.</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">reiserfs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jbegin_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="cm">/* memory pressure can sometimes initiate write_inode calls with sync == 1,</span>
<span class="cm">	 ** these cases are just when the system needs ram, not when the</span>
<span class="cm">	 ** inode needs to reach disk for safety, and they can safely be</span>
<span class="cm">	 ** ignored because the altered inode has already been logged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">journal_end_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* stat data of new object is inserted already, this inserts the item</span>
<span class="cm">   containing &quot;.&quot; and &quot;..&quot; entries */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_new_directory</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">empty_dir</span><span class="p">[</span><span class="n">EMPTY_DIR_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">body</span> <span class="o">=</span> <span class="n">empty_dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">_make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">),</span>
		      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">),</span> <span class="n">DOT_OFFSET</span><span class="p">,</span>
		      <span class="n">TYPE_DIRENTRY</span><span class="p">,</span> <span class="mi">3</span> <span class="cm">/*key length */</span> <span class="p">);</span>

	<span class="cm">/* compose item head for new item. Directories consist of items of</span>
<span class="cm">	   old type (ITEM_VERSION_1). Do not set key (second arg is 0), it</span>
<span class="cm">	   is done by reiserfs_new_inode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_format_only</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">make_le_item_head</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="n">DOT_OFFSET</span><span class="p">,</span>
				  <span class="n">TYPE_DIRENTRY</span><span class="p">,</span> <span class="n">EMPTY_DIR_SIZE_V1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">make_empty_dir_item_v1</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">,</span>
				       <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">,</span>
				       <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">,</span>
				       <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">make_le_item_head</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="n">DOT_OFFSET</span><span class="p">,</span>
				  <span class="n">TYPE_DIRENTRY</span><span class="p">,</span> <span class="n">EMPTY_DIR_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">make_empty_dir_item</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">,</span>
				    <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">,</span>
				    <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_dir_id</span><span class="p">,</span>
				    <span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* look for place in the tree for new item */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">search_item</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-13080&quot;</span><span class="p">,</span>
			       <span class="s">&quot;i/o failure occurred creating new directory&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ITEM_FOUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-13070&quot;</span><span class="p">,</span>
				 <span class="s">&quot;object with this key exists (%k)&quot;</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* insert item, that is empty directory item */</span>
	<span class="k">return</span> <span class="n">reiserfs_insert_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* stat data of object has been inserted, this inserts the item</span>
<span class="cm">   containing the body of symlink */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_new_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>	<span class="cm">/* Inode of symlink */</span>
				<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">treepath</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">item_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">_make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">,</span>
		      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">),</span>
		      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">),</span>
		      <span class="mi">1</span><span class="p">,</span> <span class="n">TYPE_DIRECT</span><span class="p">,</span> <span class="mi">3</span> <span class="cm">/*key length */</span> <span class="p">);</span>

	<span class="n">make_le_item_head</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TYPE_DIRECT</span><span class="p">,</span> <span class="n">item_len</span><span class="p">,</span>
			  <span class="mi">0</span> <span class="cm">/*free_space */</span> <span class="p">);</span>

	<span class="cm">/* look for place in the tree for new item */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">search_item</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-13080&quot;</span><span class="p">,</span>
			       <span class="s">&quot;i/o failure occurred creating new symlink&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ITEM_FOUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-13080&quot;</span><span class="p">,</span>
				 <span class="s">&quot;object with this key exists (%k)&quot;</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* insert item, that is body of symlink */</span>
	<span class="k">return</span> <span class="n">reiserfs_insert_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">symname</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* inserts the stat data into the tree, and then calls</span>
<span class="cm">   reiserfs_new_directory (to insert &quot;.&quot;, &quot;..&quot; item if new object is</span>
<span class="cm">   directory) or reiserfs_new_symlink (to insert symlink body if new</span>
<span class="cm">   object is symlink) or nothing (if new object is regular file)</span>

<span class="cm">   NOTE! uid and gid must already be set in the inode.  If we return</span>
<span class="cm">   non-zero due to an error, we have to drop the quota previously allocated</span>
<span class="cm">   for the fresh inode.  This can only be done outside a transaction, so</span>
<span class="cm">   if we return non-zero, we also end the transaction.  */</span>
<span class="kt">int</span> <span class="nf">reiserfs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span>
		       <span class="cm">/* 0 for regular, EMTRY_DIR_SIZE for dirs,</span>
<span class="cm">		          strlen (symname) for symlinks) */</span>
		       <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">reiserfs_security_handle</span> <span class="o">*</span><span class="n">security</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_iget_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">path_to_key</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stat_data</span> <span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dquot_alloc_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_bad_inode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="cm">/* item head of new item */</span>
	<span class="n">ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_dir_id</span> <span class="o">=</span> <span class="n">reiserfs_choose_packing</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">reiserfs_get_unused_objectid</span><span class="p">(</span><span class="n">th</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_bad_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">args</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_format_only</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
		<span class="n">make_le_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ih</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="n">SD_OFFSET</span><span class="p">,</span>
				  <span class="n">TYPE_STAT_DATA</span><span class="p">,</span> <span class="n">SD_V1_SIZE</span><span class="p">,</span> <span class="n">MAX_US_INT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">make_le_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ih</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_6</span><span class="p">,</span> <span class="n">SD_OFFSET</span><span class="p">,</span>
				  <span class="n">TYPE_STAT_DATA</span><span class="p">,</span> <span class="n">SD_SIZE</span><span class="p">,</span> <span class="n">MAX_US_INT</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
	<span class="n">args</span><span class="p">.</span><span class="n">dirid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert_inode_locked4</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
			     <span class="n">reiserfs_find_actor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_bad_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_format_only</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
		<span class="cm">/* not a perfect generation count, as object ids can be reused, but</span>
<span class="cm">		 ** this is as good as reiserfs can do right now.</span>
<span class="cm">		 ** note that the private part of inode isn&#39;t filled in yet, we have</span>
<span class="cm">		 ** to use the directory.</span>
<span class="cm">		 */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#if defined( USE_INODE_GENERATION_COUNTER )</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rs</span><span class="o">-&gt;</span><span class="n">s_inode_generation</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="o">++</span><span class="n">event</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* fill stat data */</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* uid and gid must already be set by the caller for quota init */</span>

	<span class="cm">/* symlink cannot be immutable or append only, right? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">S_IMMUTABLE</span> <span class="o">|</span> <span class="n">S_APPEND</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_first_direct_byte</span> <span class="o">=</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span>
	    <span class="n">U32_MAX</span> <span class="cm">/*NO_BYTES_IN_DIRECT_ITEM */</span> <span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_list</span><span class="p">));</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_jl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_attrs</span> <span class="o">=</span>
	    <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_attrs</span> <span class="o">&amp;</span> <span class="n">REISERFS_INHERIT_MASK</span><span class="p">;</span>
	<span class="n">sd_attrs_to_i_attrs</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_attrs</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">reiserfs_init_xattr_rwsem</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/* key to search for correct place for new stat data */</span>
	<span class="n">_make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_6</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_dir_id</span><span class="p">),</span>
		      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">.</span><span class="n">k_objectid</span><span class="p">),</span> <span class="n">SD_OFFSET</span><span class="p">,</span>
		      <span class="n">TYPE_STAT_DATA</span><span class="p">,</span> <span class="mi">3</span> <span class="cm">/*key length */</span> <span class="p">);</span>

	<span class="cm">/* find proper place for inserting of stat data */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">search_item</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IO_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_bad_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ITEM_FOUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_bad_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_format_only</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span> <span class="o">||</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">);</span>
			<span class="cm">/* i_uid or i_gid is too big to be stored in stat data v3.5 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_bad_inode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inode2sd_v1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode2sd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>store in in-core inode the key of stat data and version all
object items will have (directory items will have old offset
format, other new objects will consist of new items)</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">old_format_only</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">set_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_format_only</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
		<span class="n">set_inode_sd_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">STAT_DATA_V1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_inode_sd_version</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">STAT_DATA_V2</span><span class="p">);</span>

	<span class="cm">/* insert the stat data into the tree */</span>
<span class="cp">#ifdef DISPLACE_NEW_PACKING_LOCALITIES</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">new_packing_locality</span><span class="p">)</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">displace_new_blocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">retval</span> <span class="o">=</span>
	    <span class="n">reiserfs_insert_item</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ih</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">sd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_bad_inode</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef DISPLACE_NEW_PACKING_LOCALITIES</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">displace_new_blocks</span><span class="p">)</span>
		<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">new_packing_locality</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* insert item with &quot;.&quot; and &quot;..&quot; */</span>
		<span class="n">retval</span> <span class="o">=</span>
		    <span class="n">reiserfs_new_directory</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* insert body of symlink */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_format_only</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
			<span class="n">i_size</span> <span class="o">=</span> <span class="n">ROUND_UP</span><span class="p">(</span><span class="n">i_size</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span>
		    <span class="n">reiserfs_new_symlink</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span>
					 <span class="n">i_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">);</span>
		<span class="n">journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_inserted_sd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_posixacl</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">reiserfs_inherit_default_acl</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
			<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">);</span>
			<span class="n">journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_inserted_sd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_POSIXACL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;jdm-13090&quot;</span><span class="p">,</span>
				 <span class="s">&quot;ACLs aren&#39;t enabled in the fs, &quot;</span>
				 <span class="s">&quot;but vfs thinks they are!&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_PRIVATE</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_PRIVATE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">security</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">reiserfs_security_write</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">security</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
			<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span>
					     <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_inserted_sd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">reiserfs_check_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path_to_key</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* it looks like you can easily compress these two goto targets into</span>
<span class="cm"> * one.  Keeping it like this doesn&#39;t actually hurt anything, and they</span>
<span class="cm"> * are place holders for what the quota code actually needs.</span>
<span class="cm"> */</span>
      <span class="nl">out_bad_inode:</span>
	<span class="cm">/* Invalidate the object, nothing was inserted yet */</span>
	<span class="n">INODE_PKEY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">k_objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Quota change must be inside a transaction for journaling */</span>
	<span class="n">dquot_free_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

      <span class="nl">out_end_trans:</span>
	<span class="n">journal_end</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_blocks_allocated</span><span class="p">);</span>
	<span class="cm">/* Drop can be outside and it needs more credits so it&#39;s better to have it outside */</span>
	<span class="n">dquot_drop</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOQUOTA</span><span class="p">;</span>
	<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

      <span class="nl">out_inserted_sd:</span>
	<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* so the caller can&#39;t use this handle later */</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span> <span class="cm">/* OK to do even if we hadn&#39;t locked it */</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** finds the tail page in the page cache,</span>
<span class="cm">** reads the last block in.</span>
<span class="cm">**</span>
<span class="cm">** On success, page_result is set to a locked, pinned page, and bh_result</span>
<span class="cm">** is set to an up to date buffer for the last block in the file.  returns 0.</span>
<span class="cm">**</span>
<span class="cm">** tail conversion is not done, so bh_result might not be valid for writing</span>
<span class="cm">** check buffer_mapped(bh_result) and bh_result-&gt;b_blocknr != 0 before</span>
<span class="cm">** trying to write the block.</span>
<span class="cm">**</span>
<span class="cm">** on failure, nonzero is returned, page_result and bh_result are untouched.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">grab_tail_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">page_result</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bh_result</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* we want the page with the last byte in the file,</span>
<span class="cm">	 ** not the page that will hold the next byte for appending</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* we know that we are only called with inode-&gt;i_size &gt; 0.</span>
<span class="cm">	 ** we also know that a file tail can never be as big as a block</span>
<span class="cm">	 ** If i_size % blocksize == 0, our file is currently block aligned</span>
<span class="cm">	 ** and it won&#39;t need converting or zeroing after a truncate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* start within the page of the last block in the file */</span>
	<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">/</span> <span class="n">blocksize</span><span class="p">)</span> <span class="o">*</span> <span class="n">blocksize</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
				    <span class="n">reiserfs_get_block_create_0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* note, this should never happen, prepare_write should</span>
<span class="cm">		 ** be taking care of this for us.  If the buffer isn&#39;t up to date,</span>
<span class="cm">		 ** I&#39;ve screwed up the code to find the buffer, or the code to</span>
<span class="cm">		 ** call prepare_write</span>
<span class="cm">		 */</span>
		<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;clm-6000&quot;</span><span class="p">,</span>
			       <span class="s">&quot;error reading block %lu&quot;</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">bh_result</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="o">*</span><span class="n">page_result</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

      <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

      <span class="nl">unlock:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">** vfs version of truncate file.  Must NOT be called with</span>
<span class="cm">** a transaction already started.</span>
<span class="cm">**</span>
<span class="cm">** some code taken from block_truncate_page</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="nf">reiserfs_truncate_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">update_timestamps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="cm">/* we want the offset for the first byte after the end of the file */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lock_depth</span><span class="p">;</span>

	<span class="n">lock_depth</span> <span class="o">=</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">grab_tail_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>-ENOENT means we truncated past the end of the file,
and get<em>block</em>create_0 could not find a block to read in,
which is ok.</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;clm-6001&quot;</span><span class="p">,</span>
					       <span class="s">&quot;grab_tail_page failed %d&quot;</span><span class="p">,</span>
					       <span class="n">error</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* so, if page != NULL, we have a buffer head for the offset at</span>
<span class="cm">	 ** the end of the file. if the bh is mapped, and bh-&gt;b_blocknr != 0,</span>
<span class="cm">	 ** then we have an unformatted node.  Otherwise, we have a direct item,</span>
<span class="cm">	 ** and no zeroing is required on disk.  We zero after the truncate,</span>
<span class="cm">	 ** because the truncate might pack the item anyway</span>
<span class="cm">	 ** (it will unmap bh if it packs).</span>
<span class="cm">	 */</span>
	<span class="cm">/* it is enough to reserve space in transaction for 2 balancings:</span>
<span class="cm">	   one for &quot;save&quot; link adding and another for the first</span>
<span class="cm">	   cut_from_item. 1 is for update_sd */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			      <span class="n">JOURNAL_PER_BALANCE_CNT</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_timestamps</span><span class="p">)</span>
		<span class="cm">/* we are doing real truncate: if the system crashes before the last</span>
<span class="cm">		   transaction of truncating gets committed - on reboot the file</span>
<span class="cm">		   either appears truncated properly or not truncated at all */</span>
		<span class="n">add_save_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err2</span> <span class="o">=</span> <span class="n">reiserfs_do_truncate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">update_timestamps</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span>
	    <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">JOURNAL_PER_BALANCE_CNT</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* check reiserfs_do_truncate after ending the transaction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">err2</span><span class="p">;</span>
  		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">update_timestamps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">remove_save_link</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/* truncate */</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* if we are not on a block boundary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">map_block_for_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fs_gen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="n">tmp_ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">INITIALIZE_PATH</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jbegin_count</span> <span class="o">=</span> <span class="n">JOURNAL_PER_BALANCE_CNT</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">byte_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_get_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copy_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trans_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* catch places below that try to log something without starting a trans */</span>
	<span class="n">th</span><span class="p">.</span><span class="n">t_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kmap</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>
      <span class="nl">start_over:</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">make_cpu_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">byte_offset</span><span class="p">,</span> <span class="n">TYPE_ANY</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

      <span class="nl">research:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">search_for_position_by_key</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">POSITION_FOUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">use_get_block</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">get_last_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">get_ih</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">get_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">pos_in_item</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">pos_in_item</span><span class="p">;</span>

	<span class="cm">/* we&#39;ve found an unformatted node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">indirect_item_found</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_copied</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;clm-6002&quot;</span><span class="p">,</span>
					 <span class="s">&quot;bytes_copied %d&quot;</span><span class="p">,</span> <span class="n">bytes_copied</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_block_num</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* crap, we are writing to a hole */</span>
			<span class="n">use_get_block</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_block_dev_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span>
				     <span class="n">get_block_num</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">),</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="p">(</span><span class="n">byte_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">copy_size</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos_in_item</span><span class="p">;</span>

		<span class="n">fs_gen</span> <span class="o">=</span> <span class="n">get_generation</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">copy_item_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_running</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* vs-3050 is gone, no need to drop the path */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">trans_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fs_changed</span><span class="p">(</span><span class="n">fs_gen</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="n">item_moved</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
								 <span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">research</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fs_changed</span><span class="p">(</span><span class="n">fs_gen</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">item_moved</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ih</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">research</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">pos_in_item</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">bytes_copied</span><span class="p">,</span>
		       <span class="n">copy_size</span><span class="p">);</span>

		<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">bytes_copied</span> <span class="o">+=</span> <span class="n">copy_size</span><span class="p">;</span>
		<span class="n">set_block_dev_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="cm">/* are there still bytes left? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_copied</span> <span class="o">&lt;</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">byte_offset</span> <span class="o">+</span> <span class="n">bytes_copied</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
					     <span class="n">cpu_key_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span>
					     <span class="n">copy_size</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">research</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;clm-6003&quot;</span><span class="p">,</span>
				 <span class="s">&quot;bad item inode %lu&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="nl">out:</span>
	<span class="n">pathrelse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">trans_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="cm">/* this is where we fill in holes in the file. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_get_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">reiserfs_get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span>
					    <span class="n">GET_BLOCK_CREATE</span> <span class="o">|</span> <span class="n">GET_BLOCK_NO_IMUX</span>
					    <span class="o">|</span> <span class="n">GET_BLOCK_NO_DANGLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">)</span>
			    <span class="o">||</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* get_block failed to find a mapped unformatted node. */</span>
				<span class="n">use_get_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">start_over</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we&#39;ve copied data from the page into the direct item, so the</span>
<span class="cm">		 * buffer in the page is now clean, mark it to reflect that.</span>
<span class="cm">		 */</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mason@suse.com: updated in 2.5.54 to follow the same general io</span>
<span class="cm"> * start/recovery path as __block_write_full_page, along with special</span>
<span class="cm"> * code to handle reiserfs tails.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_write_full_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">partial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">checked</span> <span class="o">=</span> <span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bh_per_page</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">th</span><span class="p">.</span><span class="n">t_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* no logging allowed when nonblocking or from PF_MEMALLOC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checked</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The page dirty bit is cleared before writepage is called, which</span>
<span class="cm">	 * means we have to tell create_empty_buffers to make dirty buffers</span>
<span class="cm">	 * The page really should be up to date at this point, so tossing</span>
<span class="cm">	 * in the BH_Uptodate is just a sanity check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">,</span>
				     <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Dirty</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Uptodate</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/* last page in the file, zero out any contents past the</span>
<span class="cm">	 ** last byte in the file</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">last_offset</span><span class="p">;</span>

		<span class="n">last_offset</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* no file contents in this page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">last_offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">last_offset</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
	<span class="n">last_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="cm">/* first map all the buffers, logging any direct items we find */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;</span> <span class="n">last_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This can happen when the block size is less than</span>
<span class="cm">			 * the page size.  The corresponding bytes in the page</span>
<span class="cm">			 * were zero filled above</span>
<span class="cm">			 */</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">checked</span> <span class="o">||</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		           <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span>
						       <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span>
						       <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* not mapped yet, or it points to a direct item, search</span>
<span class="cm">			 * the btree for the mapping info, and log any direct</span>
<span class="cm">			 * items found</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">map_block_for_writepage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">block</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">block</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we start the transaction after map_block_for_writepage,</span>
<span class="cm">	 * because it can create holes in the file (an unbounded operation).</span>
<span class="cm">	 * starting it here, we can make a reliable estimate for how many</span>
<span class="cm">	 * blocks we&#39;re going to log</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bh_per_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* now go through and lock any dirty buffers on the page */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">checked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* from this point on, we know the buffer is mapped to a</span>
<span class="cm">		 * real block and not a direct item</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mark_buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">checked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bh_per_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * since any buffer might be the only dirty buffer on the page,</span>
<span class="cm">	 * the first submit_bh can bring the page out of writeback.</span>
<span class="cm">	 * be careful with the buffers.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">submit_bh</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if this page only had a direct item, it is very possible for</span>
<span class="cm">		 * no io to be required without there being an error.  Or,</span>
<span class="cm">		 * someone else could have locked them and sent them down the</span>
<span class="cm">		 * pipe without locking the page</span>
<span class="cm">		 */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">partial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

      <span class="nl">fail:</span>
	<span class="cm">/* catches various errors, we need to make sure any valid dirty blocks</span>
<span class="cm">	 * get to the media.  The page is currently locked and not marked for</span>
<span class="cm">	 * writeback</span>
<span class="cm">	 */</span>
	<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">mark_buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * clear any dirty bits that might have come from getting</span>
<span class="cm">			 * attached to a dirty page</span>
<span class="cm">			 */</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">submit_bh</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">block_read_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">reiserfs_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">reiserfs_wait_on_write_block</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">reiserfs_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reiserfs_truncate_failed_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">reiserfs_truncate_file</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 	<span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="o">*</span><span class="n">fsdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AOP_FLAG_CONT_EXPAND</span> <span class="o">&amp;&amp;</span>
 	    <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 		<span class="n">pos</span> <span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">fsdata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="n">reiserfs_wait_on_write_block</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">fix_tail_page_for_writing</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_transaction_running</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
		<span class="n">th</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span>
		    <span class="n">journal_info</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
		<span class="n">old_ref</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">;</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">reiserfs_get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">reiserfs_transaction_running</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
		<span class="cm">/* this gets a little ugly.  If reiserfs_get_block returned an</span>
<span class="cm">		 * error and left a transacstion running, we&#39;ve got to close it,</span>
<span class="cm">		 * and we&#39;ve got to free handle if it was a persistent transaction.</span>
<span class="cm">		 *</span>
<span class="cm">		 * But, if we had nested into an existing transaction, we need</span>
<span class="cm">		 * to just drop the ref count on the handle.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If old_ref == 0, the transaction is from reiserfs_get_block,</span>
<span class="cm">		 * and it was a persistent trans.  Otherwise, it was nested above.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="n">old_ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old_ref</span><span class="p">)</span>
				<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">--</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
				<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
				<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/* Truncate allocated blocks */</span>
		<span class="n">reiserfs_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__reiserfs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">reiserfs_wait_on_write_block</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">fix_tail_page_for_writing</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_transaction_running</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
		<span class="n">th</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span>
		    <span class="n">journal_info</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>
		<span class="n">old_ref</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="p">;</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">reiserfs_get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">reiserfs_transaction_running</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
		<span class="cm">/* this gets a little ugly.  If reiserfs_get_block returned an</span>
<span class="cm">		 * error and left a transacstion running, we&#39;ve got to close it,</span>
<span class="cm">		 * and we&#39;ve got to free handle if it was a persistent transaction.</span>
<span class="cm">		 *</span>
<span class="cm">		 * But, if we had nested into an existing transaction, we need</span>
<span class="cm">		 * to just drop the ref count on the handle.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If old_ref == 0, the transaction is from reiserfs_get_block,</span>
<span class="cm">		 * and it was a persistent trans.  Otherwise, it was nested above.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span> <span class="o">&gt;</span> <span class="n">old_ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old_ref</span><span class="p">)</span>
				<span class="n">th</span><span class="o">-&gt;</span><span class="n">t_refcount</span><span class="o">--</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
				<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
				<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">reiserfs_aop_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">generic_block_bmap</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">reiserfs_bmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			      <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">update_sd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lock_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">locked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fsdata</span> <span class="o">&amp;</span> <span class="n">AOP_FLAG_CONT_EXPAND</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">++</span><span class="p">;</span>

	<span class="n">reiserfs_wait_on_write_block</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_transaction_running</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">th</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">page_zero_new_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">copied</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">reiserfs_commit_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">copied</span><span class="p">);</span>

	<span class="cm">/* generic_commit_write does this for us, but does not update the</span>
<span class="cm">	 ** transaction tracking stuff when the size changes.  So, we have</span>
<span class="cm">	 ** to do the i_size updates here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">myth</span><span class="p">;</span>
		<span class="n">lock_depth</span> <span class="o">=</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">locked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* If the file have grown beyond the border where it</span>
<span class="cm">		   can have a tail, unmark it as needing a tail</span>
<span class="cm">		   packing */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">have_large_tails</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
		     <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">i_block_size</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">have_small_tails</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">i_block_size</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
			<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">i_pack_on_close_mask</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>

		<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * this will just nest into our transaction.  It&#39;s important</span>
<span class="cm">		 * to use mark_inode_dirty so the inode gets pushed around on the</span>
<span class="cm">		 * dirty lists, and so that O_SYNC works as expected</span>
<span class="cm">		 */</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">update_sd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock_depth</span> <span class="o">=</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
			<span class="n">locked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">update_sd</span><span class="p">)</span>
			<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">reiserfs_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">copied</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>

      <span class="nl">journal_error:</span>
	<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">lock_depth</span><span class="p">);</span>
	<span class="n">locked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">update_sd</span><span class="p">)</span>
			<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_commit_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">update_sd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">reiserfs_wait_on_write_block</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_transaction_running</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reiserfs_commit_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="cm">/* generic_commit_write does this for us, but does not update the</span>
<span class="cm">	 ** transaction tracking stuff when the size changes.  So, we have</span>
<span class="cm">	 ** to do the i_size updates here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">myth</span><span class="p">;</span>
		<span class="cm">/* If the file have grown beyond the border where it</span>
<span class="cm">		   can have a tail, unmark it as needing a tail</span>
<span class="cm">		   packing */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">have_large_tails</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
		     <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">i_block_size</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">have_small_tails</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">i_block_size</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
			<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">i_pack_on_close_mask</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>

		<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * this will just nest into our transaction.  It&#39;s important</span>
<span class="cm">		 * to use mark_inode_dirty so the inode gets pushed around on the</span>
<span class="cm">		 * dirty lists, and so that O_SYNC works as expected</span>
<span class="cm">		 */</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">update_sd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myth</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">update_sd</span><span class="p">)</span>
			<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

      <span class="nl">journal_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">update_sd</span><span class="p">)</span>
			<span class="n">reiserfs_update_sd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">reiserfs_end_persistent_transaction</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sd_attrs_to_i_attrs</span><span class="p">(</span><span class="n">__u16</span> <span class="n">sd_attrs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_attrs</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd_attrs</span> <span class="o">&amp;</span> <span class="n">REISERFS_SYNC_FL</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_SYNC</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_SYNC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd_attrs</span> <span class="o">&amp;</span> <span class="n">REISERFS_IMMUTABLE_FL</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_IMMUTABLE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_IMMUTABLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd_attrs</span> <span class="o">&amp;</span> <span class="n">REISERFS_APPEND_FL</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_APPEND</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_APPEND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd_attrs</span> <span class="o">&amp;</span> <span class="n">REISERFS_NOATIME_FL</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOATIME</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_NOATIME</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd_attrs</span> <span class="o">&amp;</span> <span class="n">REISERFS_NOTAIL_FL</span><span class="p">)</span>
			<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">i_nopack_mask</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">i_nopack_mask</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">i_attrs_to_sd_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">__u16</span> <span class="o">*</span> <span class="n">sd_attrs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_attrs</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">S_IMMUTABLE</span><span class="p">)</span>
			<span class="o">*</span><span class="n">sd_attrs</span> <span class="o">|=</span> <span class="n">REISERFS_IMMUTABLE_FL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">sd_attrs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REISERFS_IMMUTABLE_FL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">S_SYNC</span><span class="p">)</span>
			<span class="o">*</span><span class="n">sd_attrs</span> <span class="o">|=</span> <span class="n">REISERFS_SYNC_FL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">sd_attrs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REISERFS_SYNC_FL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">S_NOATIME</span><span class="p">)</span>
			<span class="o">*</span><span class="n">sd_attrs</span> <span class="o">|=</span> <span class="n">REISERFS_NOATIME_FL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">sd_attrs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REISERFS_NOATIME_FL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">i_nopack_mask</span><span class="p">)</span>
			<span class="o">*</span><span class="n">sd_attrs</span> <span class="o">|=</span> <span class="n">REISERFS_NOTAIL_FL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">sd_attrs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REISERFS_NOTAIL_FL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* decide if this buffer needs to stay around for data logging or ordered</span>
<span class="cm">** write purposes</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">invalidatepage_can_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">free_jh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* the page is locked, and the only places that log a data buffer</span>
<span class="cm">	 * also lock the page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_file_data_log</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * very conservative, leave the buffer pinned if</span>
<span class="cm">		 * anyone might need it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_journal_list</span> <span class="o">*</span><span class="n">jl</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">reiserfs_jh</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>

		<span class="cm">/* why is this safe?</span>
<span class="cm">		 * reiserfs_setattr updates i_size in the on disk</span>
<span class="cm">		 * stat data before allowing vmtruncate to be called.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If buffer was put onto the ordered list for this</span>
<span class="cm">		 * transaction, we know for sure either this transaction</span>
<span class="cm">		 * or an older one already has updated i_size on disk,</span>
<span class="cm">		 * and this ordered data won&#39;t be referenced in the file</span>
<span class="cm">		 * if we crash.</span>
<span class="cm">		 *</span>
<span class="cm">		 * if the buffer was put onto the ordered list for an older</span>
<span class="cm">		 * transaction, we need to leave it around</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">jl</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">jl</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">jl</span> <span class="o">!=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">j_current_jl</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="nl">free_jh:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_free_jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* clm -- taken from fs/buffer.c:block_invalidate_page */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reiserfs_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">curr_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_off</span> <span class="o">=</span> <span class="n">curr_off</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * is this block fully invalidated?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">curr_off</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">invalidatepage_can_drop</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
				<span class="n">reiserfs_unmap_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">curr_off</span> <span class="o">=</span> <span class="n">next_off</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We release buffers only if the entire page is being invalidated.</span>
<span class="cm">	 * The get_block cached value has been unconditionally invalidated,</span>
<span class="cm">	 * so real IO is not possible anymore.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_release_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* maybe should BUG_ON(!ret); - neilb */</span>
	<span class="p">}</span>
      <span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_file_data_log</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">__set_page_dirty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns 1 if the page&#39;s buffers were dropped.  The page is locked.</span>
<span class="cm"> *</span>
<span class="cm"> * Takes j_dirty_buffers_lock to protect the b_assoc_buffers list_heads</span>
<span class="cm"> * in the buffers at page_buffers(page).</span>
<span class="cm"> *</span>
<span class="cm"> * even in -o notail mode, we can&#39;t be sure an old mount without -o notail</span>
<span class="cm"> * didn&#39;t create files with tails.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_releasepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">unused_gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_journal</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="n">SB_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">reiserfs_free_jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_dirty_buffers_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We thank Mingming Cao for helping us understand in great detail what</span>
<span class="cm">   to do in this section of the code. */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reiserfs_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
				  <span class="n">reiserfs_get_blocks_direct_io</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of error extending write may have instantiated a few</span>
<span class="cm">	 * blocks outside i_size. Trim these off again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
			<span class="n">vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ia_valid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* must be turned off for recursive notify_change calls */</span>
	<span class="n">ia_valid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ATTR_KILL_SUID</span><span class="o">|</span><span class="n">ATTR_KILL_SGID</span><span class="p">);</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_quota_modification</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* version 2 items will be caught by the s_maxbytes check</span>
<span class="cm">		 ** done for us in vmtruncate</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_inode_item_key_version</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">KEY_FORMAT_3_5</span> <span class="o">&amp;&amp;</span>
		    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&gt;</span> <span class="n">MAX_NON_LFS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="cm">/* fill in hole pointers in the expanding truncate case. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">generic_cont_expand_simple</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
				<span class="cm">/* we&#39;re changing at most 2 bitmaps, inode + super */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">reiserfs_discard_prealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="n">error</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * file size is changed, ctime and mtime are</span>
<span class="cm">			 * to be updated</span>
<span class="cm">			 */</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ATTR_MTIME</span> <span class="o">|</span> <span class="n">ATTR_CTIME</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">get_inode_sd_version</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">STAT_DATA_V1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* stat data of format v3.5 has 16 bit uid and gid */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">jbegin_count</span> <span class="o">=</span>
		    <span class="mi">2</span> <span class="o">*</span>
		    <span class="p">(</span><span class="n">REISERFS_QUOTA_INIT_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">REISERFS_QUOTA_DEL_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="o">+</span>
		    <span class="mi">2</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">reiserfs_chown_xattrs</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="cm">/* (user+group)*(old+new) structure - we count quota info and , inode write (sb, inode) */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dquot_transfer</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Update corresponding info in inode so that everything is in</span>
<span class="cm">		 * one transaction */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">;</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">jbegin_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Relax the lock here, as it might truncate the</span>
<span class="cm">	 * inode pages and wait for inode pages locks.</span>
<span class="cm">	 * To release such page lock, the owner needs the</span>
<span class="cm">	 * reiserfs lock</span>
<span class="cm">	 */</span>
	<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">!=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">reiserfs_write_lock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">reiserfs_posixacl</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">reiserfs_acl_chmod</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="n">reiserfs_write_unlock_once</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">reiserfs_address_space_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">writepage</span> <span class="o">=</span> <span class="n">reiserfs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpage</span> <span class="o">=</span> <span class="n">reiserfs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span> <span class="o">=</span> <span class="n">reiserfs_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span> <span class="o">=</span> <span class="n">reiserfs_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span> <span class="o">=</span> <span class="n">reiserfs_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span> <span class="o">=</span> <span class="n">reiserfs_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span> <span class="o">=</span> <span class="n">reiserfs_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span> <span class="o">=</span> <span class="n">reiserfs_aop_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span> <span class="o">=</span> <span class="n">reiserfs_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span> <span class="o">=</span> <span class="n">reiserfs_set_page_dirty</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
