<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › objectid.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>objectid.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>find where objectid map starts</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define objectid_map(s,rs) (old_format_only (s) ? \</span>
<span class="cp">                         (__le32 *)((struct reiserfs_super_block_v1 *)(rs) + 1) :\</span>
<span class="cp">			 (__le32 *)((rs) + 1))</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_objectid_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span> <span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-15010&quot;</span><span class="p">,</span> <span class="s">&quot;map corrupted: %lx&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>FIXME: add something else here</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_objectid_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span> <span class="n">map</span><span class="p">)</span>
<span class="p">{;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* When we allocate objectids we allocate the first unused objectid.</span>
<span class="cm">   Each sequence of objectids in use (the odd sequences) is followed</span>
<span class="cm">   by a sequence of objectids not in use (the even sequences).  We</span>
<span class="cm">   only need to record the last objectid in each of these sequences</span>
<span class="cm">   (both the odd and even sequences) in order to fully define the</span>
<span class="cm">   boundaries of the sequences.  A consequence of allocating the first</span>
<span class="cm">   objectid not in use is that under most conditions this scheme is</span>
<span class="cm">   extremely compact.  The exception is immediately after a sequence</span>
<span class="cm">   of operations which deletes a large number of objects of</span>
<span class="cm">   non-sequential objectids, and even then it will become compact</span>
<span class="cm">   again as soon as more objects are created.  Note that many</span>
<span class="cm">   interesting optimizations of layout could result from complicating</span>
<span class="cm">   objectid assignment, but we have deferred making them for now. */</span>

<span class="cm">/* get unique object identifier */</span>
<span class="n">__u32</span> <span class="nf">reiserfs_get_unused_objectid</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">rs</span> <span class="o">=</span> <span class="n">SB_DISK_SUPER_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">objectid_map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rs</span><span class="p">);</span>
	<span class="n">__u32</span> <span class="n">unused_objectid</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span>

	<span class="n">check_objectid_map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>

	<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* comment needed -Hans */</span>
	<span class="n">unused_objectid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unused_objectid</span> <span class="o">==</span> <span class="n">U32_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;reiserfs-15100&quot;</span><span class="p">,</span> <span class="s">&quot;no more object ids&quot;</span><span class="p">);</span>
		<span class="n">reiserfs_restore_prepared_buffer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This incrementation allocates the first unused objectid. That</span>
<span class="cm">	   is to say, the first entry on the objectid map is the first</span>
<span class="cm">	   unused objectid, and by incrementing it we use it.  See below</span>
<span class="cm">	   where we check to see if we eliminated a sequence of unused</span>
<span class="cm">	   objectids.... */</span>
	<span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">unused_objectid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Now we check to see if we eliminated the last remaining member of</span>
<span class="cm">	   the first even sequence (and can eliminate the sequence by</span>
<span class="cm">	   eliminating its last objectid from oids), and can collapse the</span>
<span class="cm">	   first two odd sequences into one sequence.  If so, then the net</span>
<span class="cm">	   result is to eliminate a pair of objectids from oids.  We do this</span>
<span class="cm">	   by shifting the entire map to the left. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">map</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">map</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">map</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>
			<span class="p">(</span><span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">));</span>
		<span class="n">set_sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">unused_objectid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* makes object identifier unused */</span>
<span class="kt">void</span> <span class="nf">reiserfs_release_objectid</span><span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
			       <span class="n">__u32</span> <span class="n">objectid_to_release</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">t_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">rs</span> <span class="o">=</span> <span class="n">SB_DISK_SUPER_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">objectid_map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">t_trans_id</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>return;</p></td><td class="code"><div class="highlight"><pre>	<span class="n">check_objectid_map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>

	<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>

	<span class="cm">/* start at the beginning of the objectid map (i = 0) and go to</span>
<span class="cm">	   the end of it (i = disk_sb-&gt;s_oid_cursize).  Linear search is</span>
<span class="cm">	   what we use, though it is possible that binary search would be</span>
<span class="cm">	   more efficient after performing lots of deletions (which is</span>
<span class="cm">	   when oids is large.)  We only check even i&#39;s. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">objectid_to_release</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="cm">/* This incrementation unallocates the objectid. */</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>map[i]++;</p></td><td class="code"><div class="highlight"><pre>			<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* Did we unallocate the last member of an odd sequence, and can shrink oids? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="cm">/* shrink objectid map */</span>
				<span class="n">memmove</span><span class="p">(</span><span class="n">map</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">map</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
					<span class="p">(</span><span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span>
					 <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>disk<em>sb->s</em>oid_cursize -= 2;</p></td><td class="code"><div class="highlight"><pre>				<span class="n">set_sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

				<span class="n">RFALSE</span><span class="p">(</span><span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span>
				       <span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sb_oid_maxsize</span><span class="p">(</span><span class="n">rs</span><span class="p">),</span>
				       <span class="s">&quot;vs-15005: objectid map corrupted cur_size == %d (max == %d)&quot;</span><span class="p">,</span>
				       <span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">),</span> <span class="n">sb_oid_maxsize</span><span class="p">(</span><span class="n">rs</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">objectid_to_release</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="n">objectid_to_release</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
			<span class="cm">/* size of objectid map is not changed */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">objectid_to_release</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>objectid_map[i+1]--;</p></td><td class="code"><div class="highlight"><pre>				<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* JDM comparing two little-endian values for equality -- safe */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">==</span> <span class="n">sb_oid_maxsize</span><span class="p">(</span><span class="n">rs</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* objectid map must be expanded, but there is no space */</span>
				<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">leaked_oid</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* expand the objectid map */</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">map</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">map</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				<span class="p">(</span><span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">));</span>
			<span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">objectid_to_release</span><span class="p">);</span>
			<span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">objectid_to_release</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">set_sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;vs-15011&quot;</span><span class="p">,</span> <span class="s">&quot;tried to free free object id (%lu)&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span><span class="p">)</span><span class="n">objectid_to_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">reiserfs_convert_objectid_map_v1</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">reiserfs_super_block</span> <span class="o">*</span><span class="n">disk_sb</span> <span class="o">=</span> <span class="n">SB_DISK_SUPER_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cur_size</span> <span class="o">=</span> <span class="n">sb_oid_cursize</span><span class="p">(</span><span class="n">disk_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">new_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="n">SB_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_max</span> <span class="o">=</span> <span class="n">sb_oid_maxsize</span><span class="p">(</span><span class="n">disk_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">reiserfs_super_block_v1</span> <span class="o">*</span><span class="n">disk_sb_v1</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">objectid_map</span><span class="p">,</span> <span class="o">*</span><span class="n">new_objectid_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">disk_sb_v1</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_super_block_v1</span> <span class="o">*</span><span class="p">)(</span><span class="n">SB_BUFFER_WITH_SB</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
	<span class="n">objectid_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">disk_sb_v1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">new_objectid_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">disk_sb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_size</span> <span class="o">&gt;</span> <span class="n">new_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* mark everyone used that was listed as free at the end of the objectid</span>
<span class="cm">		 ** map</span>
<span class="cm">		 */</span>
		<span class="n">objectid_map</span><span class="p">[</span><span class="n">new_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">objectid_map</span><span class="p">[</span><span class="n">cur_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">set_sb_oid_cursize</span><span class="p">(</span><span class="n">disk_sb</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* move the smaller objectid map past the end of the new super */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">objectid_map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">old_max</span> <span class="o">-</span> <span class="n">new_size</span><span class="p">)]</span> <span class="o">=</span> <span class="n">objectid_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* set the max size so we don&#39;t overflow later */</span>
	<span class="n">set_sb_oid_maxsize</span><span class="p">(</span><span class="n">disk_sb</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>

	<span class="cm">/* Zero out label and generate random UUID */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">disk_sb</span><span class="o">-&gt;</span><span class="n">s_label</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">disk_sb</span><span class="o">-&gt;</span><span class="n">s_label</span><span class="p">));</span>
	<span class="n">generate_random_uuid</span><span class="p">(</span><span class="n">disk_sb</span><span class="o">-&gt;</span><span class="n">s_uuid</span><span class="p">);</span>

	<span class="cm">/* finally, zero out the unused chunk of the new super */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">disk_sb</span><span class="o">-&gt;</span><span class="n">s_unused</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">disk_sb</span><span class="o">-&gt;</span><span class="n">s_unused</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
