<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › lbalance.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lbalance.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>

<span class="cm">/* these are used in do_balance.c */</span>

<span class="cm">/* leaf_move_items</span>
<span class="cm">   leaf_shift_left</span>
<span class="cm">   leaf_shift_right</span>
<span class="cm">   leaf_delete_items</span>
<span class="cm">   leaf_insert_into_buf</span>
<span class="cm">   leaf_paste_in_buffer</span>
<span class="cm">   leaf_cut_from_buffer</span>
<span class="cm">   leaf_paste_entries</span>
<span class="cm">   */</span>

<span class="cm">/* copy copy_count entries from source directory item to dest buffer (creating new item if needed) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">leaf_copy_dir_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">item_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copy_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">item_num_in_dest</span><span class="p">;</span>	<span class="cm">/* either the number of target item,</span>
<span class="cm">				   or if we must create a new item,</span>
<span class="cm">				   the number of the item we will</span>
<span class="cm">				   create it next to */</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="o">*</span><span class="n">deh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copy_records_len</span><span class="p">;</span>	<span class="cm">/* length of all records in item to be copied */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">records</span><span class="p">;</span>

	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">item_num</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="s">&quot;vs-10000: item must be directory item&quot;</span><span class="p">);</span>

	<span class="cm">/* length of all record to be copied and first byte of the last of them */</span>
	<span class="n">deh</span> <span class="o">=</span> <span class="n">B_I_DEH</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy_records_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">from</span> <span class="o">?</span> <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">:</span>
				    <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="o">-</span>
		    <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">from</span> <span class="o">+</span> <span class="n">copy_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
		<span class="n">records</span> <span class="o">=</span>
		    <span class="n">source</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
		    <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">from</span> <span class="o">+</span> <span class="n">copy_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">copy_records_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">records</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* when copy last to first, dest buffer can contain 0 items */</span>
	<span class="n">item_num_in_dest</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span>
	     <span class="n">LAST_TO_FIRST</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
							       <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* if there are no items in dest or the first/last item in dest is not item of the same directory */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">item_num_in_dest</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">FIRST_TO_LAST</span> <span class="o">&amp;&amp;</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">==</span> <span class="n">DOT_OFFSET</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">LAST_TO_FIRST</span>
	     <span class="o">&amp;&amp;</span> <span class="n">comp_short_le_keys</span> <span class="cm">/*COMP_SHORT_KEYS */</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">,</span>
							 <span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span>
								  <span class="n">item_num_in_dest</span><span class="p">))))</span>
	<span class="p">{</span>
		<span class="cm">/* create new item in dest */</span>
		<span class="k">struct</span> <span class="n">item_head</span> <span class="n">new_ih</span><span class="p">;</span>

		<span class="cm">/* form item header */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">,</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
		<span class="n">put_ih_version</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ih</span><span class="p">,</span> <span class="n">KEY_FORMAT_3_5</span><span class="p">);</span>
		<span class="cm">/* calculate item len */</span>
		<span class="n">put_ih_item_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ih</span><span class="p">,</span>
				<span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">copy_count</span> <span class="o">+</span> <span class="n">copy_records_len</span><span class="p">);</span>
		<span class="n">put_ih_entry_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ih</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">LAST_TO_FIRST</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* form key by the following way */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ih</span><span class="p">,</span>
						   <span class="n">deh_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">from</span><span class="p">])));</span>
				<span class="cm">/*memcpy (&amp;new_ih.ih_key.k_offset, &amp;deh[from].deh_offset, SHORT_KEY_SIZE); */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* no entries will be copied to this item in this function */</span>
				<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ih</span><span class="p">,</span> <span class="n">U32_MAX</span><span class="p">);</span>
				<span class="cm">/* this item is not yet valid, but we want I_IS_DIRECTORY_ITEM to return 1 for it, so we -1 */</span>
			<span class="p">}</span>
			<span class="n">set_le_key_k_type</span><span class="p">(</span><span class="n">KEY_FORMAT_3_5</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">new_ih</span><span class="p">.</span><span class="n">ih_key</span><span class="p">),</span>
					  <span class="n">TYPE_DIRENTRY</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* insert item into dest buffer */</span>
		<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span>
				      <span class="n">LAST_TO_FIRST</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span>
				     <span class="o">&amp;</span><span class="n">new_ih</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* prepare space for entries */</span>
		<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span>
				      <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">-</span>
							<span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_US_INT</span><span class="p">,</span>
				     <span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">copy_count</span> <span class="o">+</span> <span class="n">copy_records_len</span><span class="p">,</span>
				     <span class="n">records</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">item_num_in_dest</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">leaf_paste_entries</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">item_num_in_dest</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span>
			    <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="o">?</span> <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span>
									  <span class="n">item_num_in_dest</span><span class="p">))</span>
			   <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy_count</span><span class="p">,</span> <span class="n">deh</span> <span class="o">+</span> <span class="n">from</span><span class="p">,</span> <span class="n">records</span><span class="p">,</span>
			   <span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">copy_count</span> <span class="o">+</span> <span class="n">copy_records_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Copy the first (if last_first == FIRST_TO_LAST) or last (last_first == LAST_TO_FIRST) item or</span>
<span class="cm">   part of it or nothing (see the return 0 below) from SOURCE to the end</span>
<span class="cm">   (if last_first) or beginning (!last_first) of the DEST */</span>
<span class="cm">/* returns 1 if anything was copied, else 0 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">leaf_copy_boundary_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">bytes_or_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dest_nr_item</span><span class="p">,</span> <span class="n">src_nr_item</span><span class="p">;</span>	<span class="cm">/* number of items in the source and destination buffers */</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">dih</span><span class="p">;</span>

	<span class="n">dest_nr_item</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if ( DEST is empty or first item of SOURCE and last item of DEST are the items of different objects</span>
<span class="cm">		   or of different types ) then there is no need to treat this item differently from the other items</span>
<span class="cm">		   that we copy, so we return */</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">dest_nr_item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dest_nr_item</span>
		    <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)))</span>
			<span class="cm">/* there is nothing to merge */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
		       <span class="s">&quot;vs-10010: item can not have empty length&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_or_entries</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="cm">/* copy all entries to dest */</span>
				<span class="n">bytes_or_entries</span> <span class="o">=</span> <span class="n">ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
			<span class="n">leaf_copy_dir_entries</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					      <span class="n">bytes_or_entries</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* copy part of the body of the first item of SOURCE to the end of the body of the last item of the DEST</span>
<span class="cm">		   part defined by &#39;bytes_or_entries&#39;; if bytes_or_entries == -1 copy whole body; don&#39;t create new item header</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_or_entries</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">bytes_or_entries</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_or_entries</span> <span class="o">==</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
					<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb_from_bi</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">),</span>
						       <span class="s">&quot;vs-10020&quot;</span><span class="p">,</span>
						       <span class="s">&quot;last unformatted node &quot;</span>
						       <span class="s">&quot;must be filled &quot;</span>
						       <span class="s">&quot;entirely (%h)&quot;</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="cm">/* merge first item (or its part) of src buffer with the last</span>
<span class="cm">		   item of dest buffer. Both are of the same file */</span>
		<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span>
				     <span class="n">dest_nr_item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">dih</span><span class="p">),</span>
				     <span class="n">bytes_or_entries</span><span class="p">,</span> <span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">ih</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">dih</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">dih</span><span class="p">),</span>
			       <span class="s">&quot;vs-10030: merge to left: last unformatted node of non-last indirect item %h must have zerto free space&quot;</span><span class="p">,</span>
			       <span class="n">ih</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_or_entries</span> <span class="o">==</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
				<span class="n">set_ih_free_space</span><span class="p">(</span><span class="n">dih</span><span class="p">,</span> <span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy boundary item to right (last_first == LAST_TO_FIRST) */</span>

	<span class="cm">/* ( DEST is empty or last item of SOURCE and first item of DEST</span>
<span class="cm">	   are the items of different object or of different types )</span>
<span class="cm">	 */</span>
	<span class="n">src_nr_item</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_nr_item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dest_nr_item</span> <span class="o">||</span> <span class="o">!</span><span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_or_entries</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* bytes_or_entries = entries number in last item body of SOURCE */</span>
			<span class="n">bytes_or_entries</span> <span class="o">=</span> <span class="n">ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

		<span class="n">leaf_copy_dir_entries</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
				      <span class="n">src_nr_item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="n">ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">bytes_or_entries</span><span class="p">,</span>
				      <span class="n">bytes_or_entries</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy part of the body of the last item of SOURCE to the begin of the body of the first item of the DEST;</span>
<span class="cm">	   part defined by &#39;bytes_or_entries&#39;; if byte_or_entriess == -1 copy whole body; change first item key of the DEST;</span>
<span class="cm">	   don&#39;t create new item header</span>
<span class="cm">	 */</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
	       <span class="s">&quot;vs-10040: merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)&quot;</span><span class="p">,</span>
	       <span class="n">ih</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_or_entries</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* bytes_or_entries = length of last item body of SOURCE */</span>
		<span class="n">bytes_or_entries</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">dih</span><span class="p">)</span> <span class="o">!=</span>
		       <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">op_bytes_number</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">),</span>
		       <span class="s">&quot;vs-10050: items %h and %h do not match&quot;</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">dih</span><span class="p">);</span>

		<span class="cm">/* change first item key of the DEST */</span>
		<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">dih</span><span class="p">,</span> <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>

		<span class="cm">/* item becomes non-mergeable */</span>
		<span class="cm">/* or mergeable if left item was */</span>
		<span class="n">set_le_ih_k_type</span><span class="p">(</span><span class="n">dih</span><span class="p">,</span> <span class="n">le_ih_k_type</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* merge to right only part of item */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bytes_or_entries</span><span class="p">,</span>
		       <span class="s">&quot;vs-10060: no so much bytes %lu (needed %lu)&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytes_or_entries</span><span class="p">);</span>

		<span class="cm">/* change first item key of the DEST */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">dih</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">dih</span><span class="p">)</span> <span class="o">&lt;=</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytes_or_entries</span><span class="p">,</span>
			       <span class="s">&quot;vs-10070: dih %h, bytes_or_entries(%d)&quot;</span><span class="p">,</span> <span class="n">dih</span><span class="p">,</span>
			       <span class="n">bytes_or_entries</span><span class="p">);</span>
			<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">dih</span><span class="p">,</span>
					   <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">dih</span><span class="p">)</span> <span class="o">-</span>
					   <span class="n">bytes_or_entries</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">dih</span><span class="p">)</span> <span class="o">&lt;=</span>
			       <span class="p">(</span><span class="n">bytes_or_entries</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span>
			       <span class="s">&quot;vs-10080: dih %h, bytes_or_entries(%d)&quot;</span><span class="p">,</span>
			       <span class="n">dih</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">bytes_or_entries</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
			<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">dih</span><span class="p">,</span>
					   <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">dih</span><span class="p">)</span> <span class="o">-</span>
					   <span class="p">((</span><span class="n">bytes_or_entries</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span><span class="p">)</span> <span class="o">*</span>
					    <span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">leaf_paste_in_buffer</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes_or_entries</span><span class="p">,</span>
			     <span class="n">B_I_PITEM</span><span class="p">(</span><span class="n">src</span><span class="p">,</span>
				       <span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">bytes_or_entries</span><span class="p">,</span>
			     <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* copy cpy_mun items from buffer src to buffer dest</span>
<span class="cm"> * last_first == FIRST_TO_LAST means, that we copy cpy_num  items beginning from first-th item in src to tail of dest</span>
<span class="cm"> * last_first == LAST_TO_FIRST means, that we copy cpy_num  items beginning from first-th item in src to head of dest</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">leaf_copy_items_entirely</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpy_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="n">free_space</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dest_before</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_loc</span><span class="p">,</span> <span class="n">last_inserted_loc</span><span class="p">,</span> <span class="n">location</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">last_first</span> <span class="o">!=</span> <span class="n">LAST_TO_FIRST</span> <span class="o">&amp;&amp;</span> <span class="n">last_first</span> <span class="o">!=</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span>
	       <span class="s">&quot;vs-10090: bad last_first parameter %d&quot;</span><span class="p">,</span> <span class="n">last_first</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">-</span> <span class="n">first</span> <span class="o">&lt;</span> <span class="n">cpy_num</span><span class="p">,</span>
	       <span class="s">&quot;vs-10100: too few items in source %d, required %d from %d&quot;</span><span class="p">,</span>
	       <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">cpy_num</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">cpy_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;vs-10110: can not copy negative amount of items&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">dest_bi</span><span class="p">,</span> <span class="s">&quot;vs-10120: can not copy negative amount of items&quot;</span><span class="p">);</span>

	<span class="n">dest</span> <span class="o">=</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">dest</span><span class="p">,</span> <span class="s">&quot;vs-10130: can not copy negative amount of items&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>
	<span class="n">free_space</span> <span class="o">=</span> <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="cm">/* we will insert items before 0-th or nr-th item in dest buffer. It depends of last_first parameter */</span>
	<span class="n">dest_before</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">LAST_TO_FIRST</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">nr</span><span class="p">;</span>

	<span class="cm">/* location of head of first new item */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">dest_before</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cpy_num</span> <span class="o">*</span> <span class="n">IH_SIZE</span><span class="p">,</span>
	       <span class="s">&quot;vs-10140: not enough free space for headers %d (needed %d)&quot;</span><span class="p">,</span>
	       <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="n">cpy_num</span> <span class="o">*</span> <span class="n">IH_SIZE</span><span class="p">);</span>

	<span class="cm">/* prepare space for headers */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">ih</span> <span class="o">+</span> <span class="n">cpy_num</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">dest_before</span><span class="p">)</span> <span class="o">*</span> <span class="n">IH_SIZE</span><span class="p">);</span>

	<span class="cm">/* copy item headers */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="n">cpy_num</span> <span class="o">*</span> <span class="n">IH_SIZE</span><span class="p">);</span>

	<span class="n">free_space</span> <span class="o">-=</span> <span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">*</span> <span class="n">cpy_num</span><span class="p">);</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">free_space</span><span class="p">);</span>

	<span class="cm">/* location of unmovable item */</span>
	<span class="n">j</span> <span class="o">=</span> <span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="n">dest_before</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">:</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">dest_before</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span> <span class="o">+</span> <span class="n">cpy_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">location</span> <span class="o">-=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">dest_before</span><span class="p">);</span>
		<span class="n">put_ih_location</span><span class="p">(</span><span class="n">ih</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">dest_before</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* prepare space for items */</span>
	<span class="n">last_loc</span> <span class="o">=</span> <span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">nr</span> <span class="o">+</span> <span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dest_before</span><span class="p">]));</span>
	<span class="n">last_inserted_loc</span> <span class="o">=</span> <span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>

	<span class="cm">/* check free space */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">-</span> <span class="n">last_inserted_loc</span><span class="p">,</span>
	       <span class="s">&quot;vs-10150: not enough free space for items %d (needed %d)&quot;</span><span class="p">,</span>
	       <span class="n">free_space</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">last_inserted_loc</span><span class="p">);</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span><span class="p">,</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">last_inserted_loc</span><span class="p">,</span>
		<span class="n">last_inserted_loc</span> <span class="o">-</span> <span class="n">last_loc</span><span class="p">);</span>

	<span class="cm">/* copy items */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_inserted_loc</span><span class="p">,</span>
	       <span class="n">B_N_PITEM</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">j</span> <span class="o">-</span> <span class="n">last_inserted_loc</span><span class="p">);</span>

	<span class="cm">/* sizes, item number */</span>
	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">nr</span> <span class="o">+</span> <span class="n">cpy_num</span><span class="p">);</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">free_space</span> <span class="o">-</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">last_inserted_loc</span><span class="p">));</span>

	<span class="n">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span><span class="p">;</span>
		<span class="n">t_dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">dc_block_number</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span>
		       <span class="s">&quot;vs-10160: block number in bh does not match to field in disk_child structure %lu and %lu&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span><span class="p">)</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span><span class="p">)</span><span class="n">dc_block_number</span><span class="p">(</span><span class="n">t_dc</span><span class="p">));</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span>
			    <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">last_inserted_loc</span> <span class="o">+</span>
					     <span class="n">IH_SIZE</span> <span class="o">*</span> <span class="n">cpy_num</span><span class="p">));</span>

		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span>
					       <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This function splits the (liquid) item into two items (useful when</span>
<span class="cm">   shifting part of an item into another node.) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">leaf_item_bottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">item_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpy_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">cpy_bytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	       <span class="s">&quot;vs-10170: bytes == - 1 means: do not split item&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if ( if item in position item_num in buffer SOURCE is directory item ) */</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">item_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
			<span class="n">leaf_copy_dir_entries</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span>
					      <span class="n">item_num</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpy_bytes</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">item_head</span> <span class="n">n_ih</span><span class="p">;</span>

			<span class="cm">/* copy part of the body of the item number &#39;item_num&#39; of SOURCE to the end of the DEST</span>
<span class="cm">			   part defined by &#39;cpy_bytes&#39;; create new item header; change old item_header (????);</span>
<span class="cm">			   n_ih = new item_header;</span>
<span class="cm">			 */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">IH_SIZE</span><span class="p">);</span>
			<span class="n">put_ih_item_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="n">cpy_bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">RFALSE</span><span class="p">(</span><span class="n">cpy_bytes</span> <span class="o">==</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span>
				       <span class="o">&amp;&amp;</span> <span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
				       <span class="s">&quot;vs-10180: when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span><span class="p">)</span><span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
				<span class="n">set_ih_free_space</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">RFALSE</span><span class="p">(</span><span class="n">op_is_left_mergeable</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_key</span><span class="p">),</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">),</span>
			       <span class="s">&quot;vs-10190: bad mergeability of item %h&quot;</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
			<span class="n">n_ih</span><span class="p">.</span><span class="n">ih_version</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_version</span><span class="p">;</span>	<span class="cm">/* JDM Endian safe, both le */</span>
			<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span>
					     <span class="n">B_N_PITEM</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">item_num</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*  if ( if item in position item_num in buffer SOURCE is directory item ) */</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">item_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
			<span class="n">leaf_copy_dir_entries</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
					      <span class="n">item_num</span><span class="p">,</span>
					      <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">cpy_bytes</span><span class="p">,</span>
					      <span class="n">cpy_bytes</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">item_head</span> <span class="n">n_ih</span><span class="p">;</span>

			<span class="cm">/* copy part of the body of the item number &#39;item_num&#39; of SOURCE to the begin of the DEST</span>
<span class="cm">			   part defined by &#39;cpy_bytes&#39;; create new item header;</span>
<span class="cm">			   n_ih = new item_header;</span>
<span class="cm">			 */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">SHORT_KEY_SIZE</span><span class="p">);</span>

			<span class="n">n_ih</span><span class="p">.</span><span class="n">ih_version</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_version</span><span class="p">;</span>	<span class="cm">/* JDM Endian safe, both le */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span>
						   <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
						   <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">cpy_bytes</span><span class="p">);</span>
				<span class="n">set_le_ih_k_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="n">TYPE_DIRECT</span><span class="p">);</span>
				<span class="n">set_ih_free_space</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="n">MAX_US_INT</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* indirect item */</span>
				<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">cpy_bytes</span> <span class="o">&amp;&amp;</span> <span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
				       <span class="s">&quot;vs-10200: ih-&gt;ih_free_space must be 0 when indirect item will be appended&quot;</span><span class="p">);</span>
				<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span>
						   <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
						   <span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span>
						    <span class="n">cpy_bytes</span><span class="p">)</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span> <span class="o">*</span>
						   <span class="n">dest</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
				<span class="n">set_le_ih_k_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="n">TYPE_INDIRECT</span><span class="p">);</span>
				<span class="n">set_ih_free_space</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="cm">/* set item length */</span>
			<span class="n">put_ih_item_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span> <span class="n">cpy_bytes</span><span class="p">);</span>

			<span class="n">n_ih</span><span class="p">.</span><span class="n">ih_version</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">ih_version</span><span class="p">;</span>	<span class="cm">/* JDM Endian safe, both le */</span>

			<span class="n">leaf_insert_into_buf</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_ih</span><span class="p">,</span>
					     <span class="n">B_N_PITEM</span><span class="p">(</span><span class="n">src</span><span class="p">,</span>
						       <span class="n">item_num</span><span class="p">)</span> <span class="o">+</span>
					     <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">cpy_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* If cpy_bytes equals minus one than copy cpy_num whole items from SOURCE to DEST.</span>
<span class="cm">   If cpy_bytes not equal to minus one than copy cpy_num-1 whole items from SOURCE to DEST.</span>
<span class="cm">   From last item copy cpy_num bytes for regular item and cpy_num directory entries for</span>
<span class="cm">   directory item. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">leaf_copy_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpy_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpy_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">src_nr_item</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="n">dest</span> <span class="o">=</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">dest</span> <span class="o">||</span> <span class="o">!</span><span class="n">src</span><span class="p">,</span> <span class="s">&quot;vs-10210: !dest || !src&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">last_first</span> <span class="o">!=</span> <span class="n">FIRST_TO_LAST</span> <span class="o">&amp;&amp;</span> <span class="n">last_first</span> <span class="o">!=</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
	       <span class="s">&quot;vs-10220:last_first != FIRST_TO_LAST &amp;&amp; last_first != LAST_TO_FIRST&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cpy_num</span><span class="p">,</span>
	       <span class="s">&quot;vs-10230: No enough items: %d, req. %d&quot;</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">),</span>
	       <span class="n">cpy_num</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">cpy_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;vs-10240: cpy_num &lt; 0 (%d)&quot;</span><span class="p">,</span> <span class="n">cpy_num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* copy items to left */</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">cpy_bytes</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* copy the first item or it part or nothing to the end of the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,0,bytes)) */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">leaf_copy_boundary_item</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">cpy_num</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpy_bytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* copy first cpy_num items starting from position &#39;pos&#39; of SOURCE to end of DEST */</span>
			<span class="n">leaf_copy_items_entirely</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span>
						 <span class="n">pos</span><span class="p">,</span> <span class="n">cpy_num</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* copy first cpy_num-1 items starting from position &#39;pos-1&#39; of the SOURCE to the end of the DEST */</span>
			<span class="n">leaf_copy_items_entirely</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span>
						 <span class="n">pos</span><span class="p">,</span> <span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* copy part of the item which number is cpy_num+pos-1 to the end of the DEST */</span>
			<span class="n">leaf_item_bottle</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span>
					 <span class="n">cpy_num</span> <span class="o">+</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cpy_bytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* copy items to right */</span>
		<span class="n">src_nr_item</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">cpy_bytes</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* copy the last item or it part or nothing to the begin of the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,1,bytes)); */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">leaf_copy_boundary_item</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

		<span class="n">cpy_num</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">src_nr_item</span> <span class="o">-</span> <span class="n">cpy_num</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpy_bytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* starting from position &#39;pos&#39; copy last cpy_num items of SOURCE to begin of DEST */</span>
			<span class="n">leaf_copy_items_entirely</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
						 <span class="n">pos</span><span class="p">,</span> <span class="n">cpy_num</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* copy last cpy_num-1 items starting from position &#39;pos+1&#39; of the SOURCE to the begin of the DEST; */</span>
			<span class="n">leaf_copy_items_entirely</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
						 <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* copy part of the item which number is pos to the begin of the DEST */</span>
			<span class="n">leaf_item_bottle</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
					 <span class="n">cpy_bytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* there are types of coping: from S[0] to L[0], from S[0] to R[0],</span>
<span class="cm">   from R[0] to L[0]. for each of these we have to define parent and</span>
<span class="cm">   positions of destination and source buffers */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">leaf_define_dest_src_infos</span><span class="p">(</span><span class="kt">int</span> <span class="n">shift_mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">src_bi</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="o">*</span><span class="n">first_last</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">Snew</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">src_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span><span class="p">));</span>

	<span class="cm">/* define dest, src, dest parent, dest position */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">shift_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LEAF_FROM_S_TO_L</span>:	<span class="cm">/* it is used in leaf_shift_left */</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* src-&gt;b_item_order */</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">first_last</span> <span class="o">=</span> <span class="n">FIRST_TO_LAST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LEAF_FROM_S_TO_R</span>:	<span class="cm">/* it is used in leaf_shift_right */</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">first_last</span> <span class="o">=</span> <span class="n">LAST_TO_FIRST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LEAF_FROM_R_TO_L</span>:	<span class="cm">/* it is used in balance_leaf_when_delete */</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">first_last</span> <span class="o">=</span> <span class="n">FIRST_TO_LAST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LEAF_FROM_L_TO_R</span>:	<span class="cm">/* it is used in balance_leaf_when_delete */</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">first_last</span> <span class="o">=</span> <span class="n">LAST_TO_FIRST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">LEAF_FROM_S_TO_SNEW</span>:
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_B_ITEM_ORDER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">Snew</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">first_last</span> <span class="o">=</span> <span class="n">LAST_TO_FIRST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb_from_bi</span><span class="p">(</span><span class="n">src_bi</span><span class="p">),</span> <span class="s">&quot;vs-10250&quot;</span><span class="p">,</span>
			       <span class="s">&quot;shift type is unknown (%d)&quot;</span><span class="p">,</span> <span class="n">shift_mode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">||</span> <span class="o">!</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">,</span>
	       <span class="s">&quot;vs-10260: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly&quot;</span><span class="p">,</span>
	       <span class="n">shift_mode</span><span class="p">,</span> <span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">,</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* copy mov_num items and mov_bytes of the (mov_num-1)th item to</span>
<span class="cm">   neighbor. Delete them from source */</span>
<span class="kt">int</span> <span class="nf">leaf_move_items</span><span class="p">(</span><span class="kt">int</span> <span class="n">shift_mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mov_num</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">mov_bytes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">Snew</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">dest_bi</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_last</span><span class="p">;</span>

	<span class="n">leaf_define_dest_src_infos</span><span class="p">(</span><span class="n">shift_mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">first_last</span><span class="p">,</span> <span class="n">Snew</span><span class="p">);</span>

	<span class="n">ret_value</span> <span class="o">=</span>
	    <span class="n">leaf_copy_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">,</span> <span class="n">first_last</span><span class="p">,</span> <span class="n">mov_num</span><span class="p">,</span>
			    <span class="n">mov_bytes</span><span class="p">);</span>

	<span class="n">leaf_delete_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span> <span class="n">first_last</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">first_last</span> <span class="o">==</span>
			   <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">)</span> <span class="o">-</span>
						 <span class="n">mov_num</span><span class="p">),</span> <span class="n">mov_num</span><span class="p">,</span> <span class="n">mov_bytes</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Shift shift_num items (and shift_bytes of last shifted item if shift_bytes != -1)</span>
<span class="cm">   from S[0] to L[0] and replace the delimiting key */</span>
<span class="kt">int</span> <span class="nf">leaf_shift_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">S0</span> <span class="o">=</span> <span class="n">PATH_PLAST_BUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* move shift_num (and shift_bytes bytes) items from S[0] to left neighbor L[0] */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_L</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">shift_num</span><span class="p">,</span> <span class="n">shift_bytes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shift_num</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* number of items in S[0] == 0 */</span>

			<span class="n">RFALSE</span><span class="p">(</span><span class="n">shift_bytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			       <span class="s">&quot;vs-10270: S0 is empty now, but shift_bytes != -1 (%d)&quot;</span><span class="p">,</span>
			       <span class="n">shift_bytes</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_mode</span> <span class="o">==</span> <span class="n">M_PASTE</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_mode</span> <span class="o">==</span> <span class="n">M_INSERT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;vs-10275&quot;</span><span class="p">);</span>
				<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;vs-10275&quot;</span><span class="p">,</span>
					       <span class="s">&quot;balance condition corrupted &quot;</span>
					       <span class="s">&quot;(%c)&quot;</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_mode</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					    <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* replace lkey in CFL[0] by 0-th key from S[0]; */</span>
			<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">RFALSE</span><span class="p">((</span><span class="n">shift_bytes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
				  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span> <span class="o">&amp;&amp;</span>
			       <span class="p">(</span><span class="o">!</span><span class="n">op_is_left_mergeable</span>
				<span class="p">(</span><span class="n">B_N_PKEY</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">S0</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)),</span>
			       <span class="s">&quot;vs-10280: item must be mergeable&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* CLEANING STOPPED HERE */</span>

<span class="cm">/* Shift shift_num (shift_bytes) items from S[0] to the right neighbor, and replace the delimiting key */</span>
<span class="kt">int</span> <span class="nf">leaf_shift_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift_bytes</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>struct buffer<em>head * S0 = PATH</em>PLAST<em>BUFFER (tb->tb</em>path);</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">int</span> <span class="n">ret_value</span><span class="p">;</span>

	<span class="cm">/* move shift_num (and shift_bytes) items from S[0] to right neighbor R[0] */</span>
	<span class="n">ret_value</span> <span class="o">=</span>
	    <span class="n">leaf_move_items</span><span class="p">(</span><span class="n">LEAF_FROM_S_TO_R</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">shift_num</span><span class="p">,</span> <span class="n">shift_bytes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* replace rkey in CFR[0] by the 0-th key from R[0] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shift_num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">leaf_delete_items_entirely</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">del_num</span><span class="p">);</span>
<span class="cm">/*  If del_bytes == -1, starting from position &#39;first&#39; delete del_num items in whole in buffer CUR.</span>
<span class="cm">    If not.</span>
<span class="cm">    If last_first == 0. Starting from position &#39;first&#39; delete del_num-1 items in whole. Delete part of body of</span>
<span class="cm">    the first item. Part defined by del_bytes. Don&#39;t delete first item header</span>
<span class="cm">    If last_first == 1. Starting from position &#39;first+1&#39; delete del_num-1 items in whole. Delete part of body of</span>
<span class="cm">    the last item . Part defined by del_bytes. Don&#39;t delete last item header.</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">leaf_delete_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">cur_bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">del_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">del_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">item_amount</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;10155: bh is not defined&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">del_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;10160: del_num can not be &lt; 0. del_num==%d&quot;</span><span class="p">,</span>
	       <span class="n">del_num</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">first</span> <span class="o">&lt;</span> <span class="mi">0</span>
	       <span class="o">||</span> <span class="n">first</span> <span class="o">+</span> <span class="n">del_num</span> <span class="o">&gt;</span> <span class="n">item_amount</span><span class="p">,</span>
	       <span class="s">&quot;10165: invalid number of first item to be deleted (%d) or &quot;</span>
	       <span class="s">&quot;no so much items (%d) to delete (only %d)&quot;</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span>
	       <span class="n">first</span> <span class="o">+</span> <span class="n">del_num</span><span class="p">,</span> <span class="n">item_amount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">del_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">del_num</span> <span class="o">==</span> <span class="n">item_amount</span> <span class="o">&amp;&amp;</span> <span class="n">del_bytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">make_empty_node</span><span class="p">(</span><span class="n">cur_bi</span><span class="p">);</span>
		<span class="n">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">del_bytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* delete del_num items beginning from item in position first */</span>
		<span class="n">leaf_delete_items_entirely</span><span class="p">(</span><span class="n">cur_bi</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">del_num</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* delete del_num-1 items beginning from item in position first  */</span>
			<span class="n">leaf_delete_items_entirely</span><span class="p">(</span><span class="n">cur_bi</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">del_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* delete the part of the first item of the bh</span>
<span class="cm">			   do not delete item header</span>
<span class="cm">			 */</span>
			<span class="n">leaf_cut_from_buffer</span><span class="p">(</span><span class="n">cur_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">del_bytes</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

			<span class="cm">/* delete del_num-1 items beginning from item in position first+1  */</span>
			<span class="n">leaf_delete_items_entirely</span><span class="p">(</span><span class="n">cur_bi</span><span class="p">,</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
						   <span class="n">del_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
				<span class="cm">/* the last item is directory  */</span>
				<span class="cm">/* len = numbers of directory entries in this item */</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="cm">/* len = body len of item */</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

			<span class="cm">/* delete the part of the last item of the bh</span>
<span class="cm">			   do not delete item header</span>
<span class="cm">			 */</span>
			<span class="n">leaf_cut_from_buffer</span><span class="p">(</span><span class="n">cur_bi</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					     <span class="n">len</span> <span class="o">-</span> <span class="n">del_bytes</span><span class="p">,</span> <span class="n">del_bytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* insert item into the leaf node in position before */</span>
<span class="kt">void</span> <span class="nf">leaf_insert_into_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">before</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">inserted_item_ih</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inserted_item_body</span><span class="p">,</span> <span class="kt">int</span> <span class="n">zeros_number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="n">free_space</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_loc</span><span class="p">,</span> <span class="n">unmoved_loc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>
	<span class="n">free_space</span> <span class="o">=</span> <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="cm">/* check free space */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">IH_SIZE</span><span class="p">,</span>
	       <span class="s">&quot;vs-10170: not enough free space in block %z, new item %h&quot;</span><span class="p">,</span>
	       <span class="n">bh</span><span class="p">,</span> <span class="n">inserted_item_ih</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">zeros_number</span> <span class="o">&gt;</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">),</span>
	       <span class="s">&quot;vs-10172: zero number == %d, item length == %d&quot;</span><span class="p">,</span>
	       <span class="n">zeros_number</span><span class="p">,</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">));</span>

	<span class="cm">/* get item new item must be inserted before */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">before</span><span class="p">);</span>

	<span class="cm">/* prepare space for the body of new item */</span>
	<span class="n">last_loc</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">?</span> <span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">nr</span> <span class="o">-</span> <span class="n">before</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">:</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
	<span class="n">unmoved_loc</span> <span class="o">=</span> <span class="n">before</span> <span class="o">?</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span> <span class="o">-</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">),</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span><span class="p">,</span> <span class="n">unmoved_loc</span> <span class="o">-</span> <span class="n">last_loc</span><span class="p">);</span>

	<span class="n">to</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">unmoved_loc</span> <span class="o">-</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zeros_number</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">+=</span> <span class="n">zeros_number</span><span class="p">;</span>

	<span class="cm">/* copy body to prepared space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inserted_item_body</span><span class="p">)</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">inserted_item_body</span><span class="p">,</span>
			<span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">zeros_number</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">zeros_number</span><span class="p">);</span>

	<span class="cm">/* insert item header */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">ih</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">IH_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">before</span><span class="p">));</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">inserted_item_ih</span><span class="p">,</span> <span class="n">IH_SIZE</span><span class="p">);</span>

	<span class="cm">/* change locations */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">before</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unmoved_loc</span> <span class="o">-=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">before</span><span class="p">]));</span>
		<span class="n">put_ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">before</span><span class="p">]),</span> <span class="n">unmoved_loc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* sizes, free space, item number */</span>
	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span>
			    <span class="n">free_space</span> <span class="o">-</span> <span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span>
					  <span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">)));</span>
	<span class="n">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span><span class="p">;</span>
		<span class="n">t_dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span>
			    <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">IH_SIZE</span> <span class="o">+</span>
					     <span class="n">ih_item_len</span><span class="p">(</span><span class="n">inserted_item_ih</span><span class="p">)));</span>
		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* paste paste_size bytes to affected_item_num-th item.</span>
<span class="cm">   When item is a directory, this only prepare space for new entries */</span>
<span class="kt">void</span> <span class="nf">leaf_paste_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">affected_item_num</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paste_size</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span> <span class="kt">int</span> <span class="n">zeros_number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="n">free_space</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_loc</span><span class="p">,</span> <span class="n">unmoved_loc</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>
	<span class="n">free_space</span> <span class="o">=</span> <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="cm">/* check free space */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="n">paste_size</span><span class="p">,</span>
	       <span class="s">&quot;vs-10175: not enough free space: needed %d, available %d&quot;</span><span class="p">,</span>
	       <span class="n">paste_size</span><span class="p">,</span> <span class="n">free_space</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zeros_number</span> <span class="o">&gt;</span> <span class="n">paste_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bi</span> <span class="o">&amp;&amp;</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">)</span>
			<span class="n">sb</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">;</span>
		<span class="n">print_cur_tb</span><span class="p">(</span><span class="s">&quot;10177&quot;</span><span class="p">);</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;vs-10177&quot;</span><span class="p">,</span>
			       <span class="s">&quot;zeros_number == %d, paste_size == %d&quot;</span><span class="p">,</span>
			       <span class="n">zeros_number</span><span class="p">,</span> <span class="n">paste_size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_REISERFS_CHECK */</span><span class="cp"></span>

	<span class="cm">/* item to be appended */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">affected_item_num</span><span class="p">);</span>

	<span class="n">last_loc</span> <span class="o">=</span> <span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">nr</span> <span class="o">-</span> <span class="n">affected_item_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
	<span class="n">unmoved_loc</span> <span class="o">=</span> <span class="n">affected_item_num</span> <span class="o">?</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

	<span class="cm">/* prepare space */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span> <span class="o">-</span> <span class="n">paste_size</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span><span class="p">,</span>
		<span class="n">unmoved_loc</span> <span class="o">-</span> <span class="n">last_loc</span><span class="p">);</span>

	<span class="cm">/* change locations */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">affected_item_num</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">put_ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">affected_item_num</span><span class="p">]),</span>
				<span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">affected_item_num</span><span class="p">]))</span> <span class="o">-</span>
				<span class="n">paste_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos_in_item</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* shift data to right */</span>
				<span class="n">memmove</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">paste_size</span><span class="p">,</span>
					<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
					<span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
				<span class="cm">/* paste data in the head of item */</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="n">zeros_number</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
				       <span class="n">zeros_number</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span>
				       <span class="n">paste_size</span> <span class="o">-</span> <span class="n">zeros_number</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">unmoved_loc</span> <span class="o">-</span> <span class="n">paste_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="n">zeros_number</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">unmoved_loc</span> <span class="o">-</span> <span class="n">paste_size</span> <span class="o">+</span>
				       <span class="n">zeros_number</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span>
				       <span class="n">paste_size</span> <span class="o">-</span> <span class="n">zeros_number</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">unmoved_loc</span> <span class="o">-</span> <span class="n">paste_size</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">paste_size</span><span class="p">);</span>

	<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">paste_size</span><span class="p">);</span>

	<span class="cm">/* change free space */</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">free_space</span> <span class="o">-</span> <span class="n">paste_size</span><span class="p">);</span>

	<span class="n">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span> <span class="o">=</span>
		    <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">+</span> <span class="n">paste_size</span><span class="p">);</span>
		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* cuts DEL_COUNT entries beginning from FROM-th entry. Directory item</span>
<span class="cm">   does not have free space, so it moves DEHs and remaining records as</span>
<span class="cm">   necessary. Return value is size of removed part of directory item</span>
<span class="cm">   in bytes. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">leaf_cut_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">del_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="o">*</span><span class="n">deh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prev_record_offset</span><span class="p">;</span>	<span class="cm">/* offset of record, that is (from-1)th */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">prev_record</span><span class="p">;</span>	<span class="cm">/* */</span>
	<span class="kt">int</span> <span class="n">cut_records_len</span><span class="p">;</span>	<span class="cm">/* length of all removed records */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* make sure, that item is directory and there are enough entries to</span>
<span class="cm">	   remove */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="s">&quot;10180: item is not directory item&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">from</span> <span class="o">+</span> <span class="n">del_count</span><span class="p">,</span>
	       <span class="s">&quot;10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d&quot;</span><span class="p">,</span>
	       <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="n">from</span><span class="p">,</span> <span class="n">del_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">del_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* first byte of item */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

	<span class="cm">/* entry head array */</span>
	<span class="n">deh</span> <span class="o">=</span> <span class="n">B_I_DEH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>

	<span class="cm">/* first byte of remaining entries, those are BEFORE cut entries</span>
<span class="cm">	   (prev_record) and length of all removed records (cut_records_len) */</span>
	<span class="n">prev_record_offset</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">from</span> <span class="o">?</span> <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">:</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>
	<span class="n">cut_records_len</span> <span class="o">=</span> <span class="n">prev_record_offset</span> <span class="cm">/*from_record */</span>  <span class="o">-</span>
	    <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">from</span> <span class="o">+</span> <span class="n">del_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
	<span class="n">prev_record</span> <span class="o">=</span> <span class="n">item</span> <span class="o">+</span> <span class="n">prev_record_offset</span><span class="p">;</span>

	<span class="cm">/* adjust locations of remaining entries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">from</span> <span class="o">+</span> <span class="n">del_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">put_deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
				 <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span>
				 <span class="p">(</span><span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">del_count</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">from</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">put_deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
				 <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">del_count</span> <span class="o">+</span>
							  <span class="n">cut_records_len</span><span class="p">));</span>

	<span class="n">put_ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">del_count</span><span class="p">);</span>

	<span class="cm">/* shift entry head array and entries those are AFTER removed entries */</span>
	<span class="n">memmove</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">deh</span> <span class="o">+</span> <span class="n">from</span><span class="p">),</span>
		<span class="n">deh</span> <span class="o">+</span> <span class="n">from</span> <span class="o">+</span> <span class="n">del_count</span><span class="p">,</span>
		<span class="n">prev_record</span> <span class="o">-</span> <span class="n">cut_records_len</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">deh</span> <span class="o">+</span> <span class="n">from</span> <span class="o">+</span>
							 <span class="n">del_count</span><span class="p">));</span>

	<span class="cm">/* shift records, those are BEFORE removed entries */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">prev_record</span> <span class="o">-</span> <span class="n">cut_records_len</span> <span class="o">-</span> <span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">del_count</span><span class="p">,</span>
		<span class="n">prev_record</span><span class="p">,</span> <span class="n">item</span> <span class="o">+</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">prev_record</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">del_count</span> <span class="o">+</span> <span class="n">cut_records_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  when cut item is part of regular file</span>
<span class="cm">        pos_in_item - first byte that must be cut</span>
<span class="cm">        cut_size - number of bytes to be cut beginning from pos_in_item</span>

<span class="cm">   when cut item is part of directory</span>
<span class="cm">        pos_in_item - number of first deleted entry</span>
<span class="cm">        cut_size - count of deleted entries</span>
<span class="cm">    */</span>
<span class="kt">void</span> <span class="nf">leaf_cut_from_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cut_item_num</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">pos_in_item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cut_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_loc</span><span class="p">,</span> <span class="n">unmoved_loc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="cm">/* item head of truncated item */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">cut_item_num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* first cut entry () */</span>
		<span class="n">cut_size</span> <span class="o">=</span> <span class="n">leaf_cut_entries</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span> <span class="n">pos_in_item</span><span class="p">,</span> <span class="n">cut_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_item</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* change key */</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">cut_item_num</span><span class="p">,</span>
			       <span class="s">&quot;when 0-th enrty of item is cut, that item must be first in the node, not %d-th&quot;</span><span class="p">,</span>
			       <span class="n">cut_item_num</span><span class="p">);</span>
			<span class="cm">/* change item key by key of first entry in the item */</span>
			<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">deh_offset</span><span class="p">(</span><span class="n">B_I_DEH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">)));</span>
			<span class="cm">/*memcpy (&amp;ih-&gt;ih_key.k_offset, &amp;(B_I_DEH (bh, ih)-&gt;deh_offset), SHORT_KEY_SIZE); */</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* item is direct or indirect */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">is_statdata_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="s">&quot;10195: item is stat data&quot;</span><span class="p">);</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">pos_in_item</span> <span class="o">&amp;&amp;</span> <span class="n">pos_in_item</span> <span class="o">+</span> <span class="n">cut_size</span> <span class="o">!=</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
		       <span class="s">&quot;10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span><span class="p">)</span><span class="n">pos_in_item</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span><span class="p">)</span><span class="n">cut_size</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span><span class="p">)</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">));</span>

		<span class="cm">/* shift item body to left if cut is from the head of item */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_item</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">cut_size</span><span class="p">,</span>
				<span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">cut_size</span><span class="p">);</span>

			<span class="cm">/* change key of item */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_direct_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span>
				<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span>
						   <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
						   <span class="n">cut_size</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span>
						   <span class="n">le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span>
						   <span class="p">(</span><span class="n">cut_size</span> <span class="o">/</span> <span class="n">UNFM_P_SIZE</span><span class="p">)</span> <span class="o">*</span>
						   <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
				<span class="n">RFALSE</span><span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">==</span> <span class="n">cut_size</span>
				       <span class="o">&amp;&amp;</span> <span class="n">get_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span>
				       <span class="s">&quot;10205: invalid ih_free_space (%h)&quot;</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* location of the last item */</span>
	<span class="n">last_loc</span> <span class="o">=</span> <span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">nr</span> <span class="o">-</span> <span class="n">cut_item_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>

	<span class="cm">/* location of the item, which is remaining at the same place */</span>
	<span class="n">unmoved_loc</span> <span class="o">=</span> <span class="n">cut_item_num</span> <span class="o">?</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

	<span class="cm">/* shift */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span> <span class="o">+</span> <span class="n">cut_size</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span><span class="p">,</span>
		<span class="n">unmoved_loc</span> <span class="o">-</span> <span class="n">last_loc</span> <span class="o">-</span> <span class="n">cut_size</span><span class="p">);</span>

	<span class="cm">/* change item length */</span>
	<span class="n">put_ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">cut_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_indirect_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_item</span><span class="p">)</span>
			<span class="n">set_ih_free_space</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* change locations */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">cut_item_num</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">put_ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">cut_item_num</span><span class="p">]),</span>
				<span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ih</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">cut_item_num</span><span class="p">])</span> <span class="o">+</span> <span class="n">cut_size</span><span class="p">);</span>

	<span class="cm">/* size, free space */</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">+</span> <span class="n">cut_size</span><span class="p">);</span>

	<span class="n">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span><span class="p">;</span>
		<span class="n">t_dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">-</span> <span class="n">cut_size</span><span class="p">);</span>
		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* delete del_num items from buffer starting from the first&#39;th item */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">leaf_delete_items_entirely</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">del_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_loc</span><span class="p">,</span> <span class="n">last_removed_loc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;10210: buffer is 0&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">del_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;10215: del_num less than 0 (%d)&quot;</span><span class="p">,</span> <span class="n">del_num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">del_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">first</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">first</span> <span class="o">+</span> <span class="n">del_num</span> <span class="o">&gt;</span> <span class="n">nr</span><span class="p">,</span>
	       <span class="s">&quot;10220: first=%d, number=%d, there is %d items&quot;</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">del_num</span><span class="p">,</span>
	       <span class="n">nr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">del_num</span> <span class="o">==</span> <span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this does not work */</span>
		<span class="n">make_empty_node</span><span class="p">(</span><span class="n">bi</span><span class="p">);</span>

		<span class="n">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>

	<span class="cm">/* location of unmovable item */</span>
	<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">:</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* delete items */</span>
	<span class="n">last_loc</span> <span class="o">=</span> <span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">first</span><span class="p">]));</span>
	<span class="n">last_removed_loc</span> <span class="o">=</span> <span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">del_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">last_removed_loc</span><span class="p">,</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">last_loc</span><span class="p">,</span> <span class="n">last_removed_loc</span> <span class="o">-</span> <span class="n">last_loc</span><span class="p">);</span>

	<span class="cm">/* delete item headers */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">ih</span> <span class="o">+</span> <span class="n">del_num</span><span class="p">,</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">first</span> <span class="o">-</span> <span class="n">del_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">IH_SIZE</span><span class="p">);</span>

	<span class="cm">/* change item location */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span> <span class="o">-</span> <span class="n">del_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">put_ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">first</span><span class="p">]),</span>
				<span class="n">ih_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ih</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">first</span><span class="p">]))</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span>
								 <span class="n">last_removed_loc</span><span class="p">));</span>

	<span class="cm">/* sizes, item number */</span>
	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">-</span> <span class="n">del_num</span><span class="p">);</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span>
			    <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">last_removed_loc</span> <span class="o">+</span>
						     <span class="n">IH_SIZE</span> <span class="o">*</span> <span class="n">del_num</span><span class="p">));</span>

	<span class="n">do_balance_mark_leaf_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span> <span class="o">=</span>
		    <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span>
			    <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">last_removed_loc</span> <span class="o">+</span>
					     <span class="n">IH_SIZE</span> <span class="o">*</span> <span class="n">del_num</span><span class="p">));</span>
		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* paste new_entry_count entries (new_dehs, records) into position before to item_num-th item */</span>
<span class="kt">void</span> <span class="nf">leaf_paste_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">item_num</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">before</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">new_entry_count</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="o">*</span><span class="n">new_dehs</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">records</span><span class="p">,</span> <span class="kt">int</span> <span class="n">paste_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="o">*</span><span class="n">deh</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">insert_point</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">old_entry_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_entry_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PITEM_HEAD</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">item_num</span><span class="p">);</span>

	<span class="cm">/* make sure, that item is directory, and there are enough records in it */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">is_direntry_le_ih</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="s">&quot;10225: item is not directory item&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">before</span><span class="p">,</span>
	       <span class="s">&quot;10230: there are no entry we paste entries before. entry_count = %d, before = %d&quot;</span><span class="p">,</span>
	       <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">),</span> <span class="n">before</span><span class="p">);</span>

	<span class="cm">/* first byte of dest item */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ih_location</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>

	<span class="cm">/* entry head array */</span>
	<span class="n">deh</span> <span class="o">=</span> <span class="n">B_I_DEH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>

	<span class="cm">/* new records will be pasted at this point */</span>
	<span class="n">insert_point</span> <span class="o">=</span>
	    <span class="n">item</span> <span class="o">+</span>
	    <span class="p">(</span><span class="n">before</span> <span class="o">?</span> <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">before</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
	     <span class="o">:</span> <span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">paste_size</span><span class="p">));</span>

	<span class="cm">/* adjust locations of records that will be AFTER new records */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">before</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">put_deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
				 <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span>
				 <span class="p">(</span><span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">new_entry_count</span><span class="p">));</span>

	<span class="cm">/* adjust locations of records that will be BEFORE new records */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">before</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">put_deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
				 <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span> <span class="n">paste_size</span><span class="p">);</span>

	<span class="n">old_entry_num</span> <span class="o">=</span> <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span>
	<span class="n">put_ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">ih_entry_count</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">+</span> <span class="n">new_entry_count</span><span class="p">);</span>

	<span class="cm">/* prepare space for pasted records */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">insert_point</span> <span class="o">+</span> <span class="n">paste_size</span><span class="p">,</span> <span class="n">insert_point</span><span class="p">,</span>
		<span class="n">item</span> <span class="o">+</span> <span class="p">(</span><span class="n">ih_item_len</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span> <span class="n">paste_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">insert_point</span><span class="p">);</span>

	<span class="cm">/* copy new records */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">insert_point</span> <span class="o">+</span> <span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">new_entry_count</span><span class="p">,</span> <span class="n">records</span><span class="p">,</span>
	       <span class="n">paste_size</span> <span class="o">-</span> <span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">new_entry_count</span><span class="p">);</span>

	<span class="cm">/* prepare space for new entry heads */</span>
	<span class="n">deh</span> <span class="o">+=</span> <span class="n">before</span><span class="p">;</span>
	<span class="n">memmove</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">deh</span> <span class="o">+</span> <span class="n">new_entry_count</span><span class="p">),</span> <span class="n">deh</span><span class="p">,</span>
		<span class="n">insert_point</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">deh</span><span class="p">);</span>

	<span class="cm">/* copy new entry heads */</span>
	<span class="n">deh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">reiserfs_de_head</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">deh</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">deh</span><span class="p">,</span> <span class="n">new_dehs</span><span class="p">,</span> <span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">new_entry_count</span><span class="p">);</span>

	<span class="cm">/* set locations of new records */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">new_entry_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
				 <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span>
				 <span class="p">(</span><span class="o">-</span><span class="n">deh_location</span>
				  <span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">new_dehs</span><span class="p">[</span><span class="n">new_entry_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">+</span>
				  <span class="n">insert_point</span> <span class="o">+</span> <span class="n">DEH_SIZE</span> <span class="o">*</span> <span class="n">new_entry_count</span> <span class="o">-</span>
				  <span class="n">item</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* change item key if necessary (when we paste before 0-th entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_le_ih_k_offset</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">deh_offset</span><span class="p">(</span><span class="n">new_dehs</span><span class="p">));</span>
<span class="cm">/*      memcpy (&amp;ih-&gt;ih_key.k_offset,</span>
<span class="cm">		       &amp;new_dehs-&gt;deh_offset, SHORT_KEY_SIZE);*/</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_REISERFS_CHECK</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
		<span class="cm">/* check record locations */</span>
		<span class="n">deh</span> <span class="o">=</span> <span class="n">B_I_DEH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">ih</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span>
			     <span class="n">I_ENTRY_COUNT</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span> <span class="o">-</span>
			     <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span> <span class="o">&lt;=</span> <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
				<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">sb_from_bi</span><span class="p">(</span><span class="n">bi</span><span class="p">),</span> <span class="s">&quot;vs-10240&quot;</span><span class="p">,</span>
					       <span class="s">&quot;directory item (%h) &quot;</span>
					       <span class="s">&quot;corrupted (prev %a, &quot;</span>
					       <span class="s">&quot;cur(%d) %a)&quot;</span><span class="p">,</span>
					       <span class="n">ih</span><span class="p">,</span> <span class="n">deh</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">deh</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">&gt;=</span> <span class="n">deh_location</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">deh</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
				<span class="n">reiserfs_error</span><span class="p">(</span><span class="n">sb_from_bi</span><span class="p">(</span><span class="n">bi</span><span class="p">),</span> <span class="s">&quot;vs-10250&quot;</span><span class="p">,</span>
					       <span class="s">&quot;directory item (%h) &quot;</span>
					       <span class="s">&quot;corrupted (cur(%d) %a, &quot;</span>
					       <span class="s">&quot;next %a)&quot;</span><span class="p">,</span>
					       <span class="n">ih</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">deh</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">deh</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
