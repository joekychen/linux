<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › ibalance.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ibalance.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>

<span class="cm">/* this is one and only function that is used outside (do_balance.c) */</span>
<span class="kt">int</span> <span class="n">balance_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="p">,</span>
		     <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="p">);</span>

<span class="cm">/* modes of internal_shift_left, internal_shift_right and internal_insert_childs */</span>
<span class="cp">#define INTERNAL_SHIFT_FROM_S_TO_L 0</span>
<span class="cp">#define INTERNAL_SHIFT_FROM_R_TO_S 1</span>
<span class="cp">#define INTERNAL_SHIFT_FROM_L_TO_S 2</span>
<span class="cp">#define INTERNAL_SHIFT_FROM_S_TO_R 3</span>
<span class="cp">#define INTERNAL_INSERT_TO_S 4</span>
<span class="cp">#define INTERNAL_INSERT_TO_L 5</span>
<span class="cp">#define INTERNAL_INSERT_TO_R 6</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_define_dest_src_infos</span><span class="p">(</span><span class="kt">int</span> <span class="n">shift_mode</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">h</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">src_bi</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="o">*</span><span class="n">d_key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">cf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">src_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span><span class="p">));</span>
	<span class="cm">/* define dest, src, dest parent, dest position */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">shift_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INTERNAL_SHIFT_FROM_S_TO_L</span>:	<span class="cm">/* used in internal_shift_left */</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="o">*</span><span class="n">d_key</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="o">*</span><span class="n">cf</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INTERNAL_SHIFT_FROM_L_TO_S</span>:
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* dest position is analog of dest-&gt;b_item_order */</span>
		<span class="o">*</span><span class="n">d_key</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="o">*</span><span class="n">cf</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INTERNAL_SHIFT_FROM_R_TO_S</span>:	<span class="cm">/* used in internal_shift_left */</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="o">*</span><span class="n">d_key</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="o">*</span><span class="n">cf</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INTERNAL_SHIFT_FROM_S_TO_R</span>:
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="o">*</span><span class="n">d_key</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="o">*</span><span class="n">cf</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INTERNAL_INSERT_TO_L</span>:
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INTERNAL_INSERT_TO_S</span>:
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INTERNAL_INSERT_TO_R</span>:
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;ibalance-1&quot;</span><span class="p">,</span>
			       <span class="s">&quot;shift type is unknown (%d)&quot;</span><span class="p">,</span>
			       <span class="n">shift_mode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Insert count node pointers into buffer cur before position to + 1.</span>
<span class="cm"> * Insert count items into buffer cur before position to.</span>
<span class="cm"> * Items and node pointers are specified by inserted and bh respectively.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_insert_childs</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">cur_bi</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">inserted</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_child</span> <span class="n">new_dc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">dc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;too many children (%d) are to be inserted&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="n">DC_SIZE</span><span class="p">),</span>
	       <span class="s">&quot;no enough free space (%d), needed %d bytes&quot;</span><span class="p">,</span>
	       <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">cur</span><span class="p">),</span> <span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="n">DC_SIZE</span><span class="p">));</span>

	<span class="cm">/* prepare space for count disk_child */</span>
	<span class="n">dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">to</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">dc</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="p">(</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">to</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">DC_SIZE</span><span class="p">);</span>

	<span class="cm">/* copy to_be_insert disk children */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">new_dc</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
			    <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">bh</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">bh</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="n">put_dc_block_number</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">new_dc</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">bh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">new_dc</span><span class="p">,</span> <span class="n">DC_SIZE</span> <span class="o">*</span> <span class="n">count</span><span class="p">);</span>

	<span class="cm">/* prepare space for count items  */</span>
	<span class="n">ih</span> <span class="o">=</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="p">((</span><span class="n">to</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">to</span><span class="p">));</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">ih</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span> <span class="n">ih</span><span class="p">,</span>
		<span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">to</span><span class="p">)</span> <span class="o">*</span> <span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="n">DC_SIZE</span><span class="p">);</span>

	<span class="cm">/* copy item headers (keys) */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">inserted</span><span class="p">,</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ih</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inserted</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">KEY_SIZE</span><span class="p">);</span>

	<span class="cm">/* sizes, item number */</span>
	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">+</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span>
			    <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span>
							     <span class="n">KEY_SIZE</span><span class="p">));</span>

	<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
	<span class="n">check_internal</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
	<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span> <span class="o">=</span>
		    <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span>
			    <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">DC_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">)));</span>
		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span>
					       <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
		<span class="n">check_internal</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">);</span>
		<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/* Delete del_num items and node pointers from buffer cur starting from *</span>
<span class="cm"> * the first_i&#39;th item and first_p&#39;th pointers respectively.		*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_delete_pointers_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">cur_bi</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">first_p</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">first_i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">del_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">dc</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;buffer is 0&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">del_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="s">&quot;negative number of items (%d) can not be deleted&quot;</span><span class="p">,</span> <span class="n">del_num</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">first_p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">first_p</span> <span class="o">+</span> <span class="n">del_num</span> <span class="o">&gt;</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
	       <span class="o">||</span> <span class="n">first_i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="s">&quot;first pointer order (%d) &lt; 0 or &quot;</span>
	       <span class="s">&quot;no so many pointers (%d), only (%d) or &quot;</span>
	       <span class="s">&quot;first key order %d &lt; 0&quot;</span><span class="p">,</span> <span class="n">first_p</span><span class="p">,</span> <span class="n">first_p</span> <span class="o">+</span> <span class="n">del_num</span><span class="p">,</span>
	       <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">first_i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first_p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">del_num</span> <span class="o">==</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">first_i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="s">&quot;1st deleted key must have order 0, not %d&quot;</span><span class="p">,</span> <span class="n">first_i</span><span class="p">);</span>
		<span class="n">make_empty_node</span><span class="p">(</span><span class="n">cur_bi</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">first_i</span> <span class="o">+</span> <span class="n">del_num</span> <span class="o">&gt;</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">cur</span><span class="p">),</span>
	       <span class="s">&quot;first_i = %d del_num = %d &quot;</span>
	       <span class="s">&quot;no so many keys (%d) in the node (%b)(%z)&quot;</span><span class="p">,</span>
	       <span class="n">first_i</span><span class="p">,</span> <span class="n">del_num</span><span class="p">,</span> <span class="n">first_i</span> <span class="o">+</span> <span class="n">del_num</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>

	<span class="cm">/* deleting */</span>
	<span class="n">dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">first_p</span><span class="p">);</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dc</span> <span class="o">+</span> <span class="n">del_num</span><span class="p">,</span> <span class="p">(</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">first_p</span> <span class="o">-</span> <span class="n">del_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">DC_SIZE</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">first_i</span><span class="p">);</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="n">del_num</span><span class="p">,</span>
		<span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">first_i</span> <span class="o">-</span> <span class="n">del_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span>
						       <span class="n">del_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">DC_SIZE</span><span class="p">);</span>

	<span class="cm">/* sizes, item number */</span>
	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">-</span> <span class="n">del_num</span><span class="p">);</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span>
			    <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">+</span>
			    <span class="p">(</span><span class="n">del_num</span> <span class="o">*</span> <span class="p">(</span><span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="n">DC_SIZE</span><span class="p">)));</span>

	<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
	<span class="n">check_internal</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
	<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span><span class="p">;</span>
		<span class="n">t_dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span>
			    <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">del_num</span> <span class="o">*</span> <span class="p">(</span><span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="n">DC_SIZE</span><span class="p">)));</span>

		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span>
					       <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
		<span class="n">check_internal</span><span class="p">(</span><span class="n">cur_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">);</span>
		<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* delete n node pointers and items starting from given position */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_delete_childs</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">cur_bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i_from</span><span class="p">;</span>

	<span class="n">i_from</span> <span class="o">=</span> <span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">from</span> <span class="o">:</span> <span class="n">from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* delete n pointers starting from `from&#39; position in CUR;</span>
<span class="cm">	   delete n keys starting from &#39;i_from&#39; position in CUR;</span>
<span class="cm">	 */</span>
	<span class="n">internal_delete_pointers_items</span><span class="p">(</span><span class="n">cur_bi</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">i_from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* copy cpy_num node pointers and cpy_num - 1 items from buffer src to buffer dest</span>
<span class="cm">* last_first == FIRST_TO_LAST means, that we copy first items from src to tail of dest</span>
<span class="cm"> * last_first == LAST_TO_FIRST means, that we copy last items from src to head of dest</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_copy_pointers_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpy_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ATTENTION! Number of node pointers in DEST is equal to number of items in DEST *</span>
<span class="cm">	 * as delimiting key have already inserted to buffer dest.*/</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_dest</span><span class="p">,</span> <span class="n">nr_src</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dest_order</span><span class="p">,</span> <span class="n">src_order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">dc</span><span class="p">;</span>

	<span class="n">nr_src</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">dest</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">src</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
	       <span class="s">&quot;src (%p) or dest (%p) buffer is 0&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">last_first</span> <span class="o">!=</span> <span class="n">FIRST_TO_LAST</span> <span class="o">&amp;&amp;</span> <span class="n">last_first</span> <span class="o">!=</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
	       <span class="s">&quot;invalid last_first parameter (%d)&quot;</span><span class="p">,</span> <span class="n">last_first</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">nr_src</span> <span class="o">&lt;</span> <span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	       <span class="s">&quot;no so many items (%d) in src (%d)&quot;</span><span class="p">,</span> <span class="n">cpy_num</span><span class="p">,</span> <span class="n">nr_src</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">cpy_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;cpy_num less than 0 (%d)&quot;</span><span class="p">,</span> <span class="n">cpy_num</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span>
	       <span class="s">&quot;cpy_num (%d) + item number in dest (%d) can not be &gt; MAX_NR_KEY(%d)&quot;</span><span class="p">,</span>
	       <span class="n">cpy_num</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span> <span class="n">MAX_NR_KEY</span><span class="p">(</span><span class="n">dest</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* coping */</span>
	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">nr_dest</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="cm">/*dest_order = (last_first == LAST_TO_FIRST) ? 0 : nr_dest; */</span>
	<span class="cm">/*src_order = (last_first == LAST_TO_FIRST) ? (nr_src - cpy_num + 1) : 0; */</span>
	<span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">LAST_TO_FIRST</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">dest_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">src_order</span> <span class="o">=</span>
					 <span class="n">nr_src</span> <span class="o">-</span> <span class="n">cpy_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">dest_order</span> <span class="o">=</span>
								  <span class="n">nr_dest</span><span class="p">,</span>
								  <span class="n">src_order</span> <span class="o">=</span>
								  <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* prepare space for cpy_num pointers */</span>
	<span class="n">dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">dest_order</span><span class="p">);</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">dc</span> <span class="o">+</span> <span class="n">cpy_num</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="p">(</span><span class="n">nr_dest</span> <span class="o">-</span> <span class="n">dest_order</span><span class="p">)</span> <span class="o">*</span> <span class="n">DC_SIZE</span><span class="p">);</span>

	<span class="cm">/* insert pointers */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_order</span><span class="p">),</span> <span class="n">DC_SIZE</span> <span class="o">*</span> <span class="n">cpy_num</span><span class="p">);</span>

	<span class="cm">/* prepare space for cpy_num - 1 item headers */</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">dest_order</span><span class="p">);</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
		<span class="n">KEY_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">nr_dest</span> <span class="o">-</span> <span class="n">dest_order</span><span class="p">)</span> <span class="o">+</span> <span class="n">DC_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">nr_dest</span> <span class="o">+</span>
							       <span class="n">cpy_num</span><span class="p">));</span>

	<span class="cm">/* insert headers */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_order</span><span class="p">),</span> <span class="n">KEY_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* sizes, item number */</span>
	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span>
			    <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">KEY_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
						     <span class="n">DC_SIZE</span> <span class="o">*</span> <span class="n">cpy_num</span><span class="p">));</span>

	<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
	<span class="n">check_internal</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span><span class="p">;</span>
		<span class="n">t_dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span>
			    <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">KEY_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
					     <span class="n">DC_SIZE</span> <span class="o">*</span> <span class="n">cpy_num</span><span class="p">));</span>

		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span>
					       <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
		<span class="n">check_internal</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">);</span>
		<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/* Copy cpy_num node pointers and cpy_num - 1 items from buffer src to buffer dest.</span>
<span class="cm"> * Delete cpy_num - del_par items and node pointers from buffer src.</span>
<span class="cm"> * last_first == FIRST_TO_LAST means, that we copy/delete first items from src.</span>
<span class="cm"> * last_first == LAST_TO_FIRST means, that we copy/delete last items from src.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_move_pointers_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">src_bi</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">last_first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpy_num</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">del_par</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">first_pointer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_item</span><span class="p">;</span>

	<span class="n">internal_copy_pointers_items</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">,</span> <span class="n">last_first</span><span class="p">,</span>
				     <span class="n">cpy_num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_first</span> <span class="o">==</span> <span class="n">FIRST_TO_LAST</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* shift_left occurs */</span>
		<span class="n">first_pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">first_item</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* delete cpy_num - del_par pointers and keys starting for pointers with first_pointer,</span>
<span class="cm">		   for key - with first_item */</span>
		<span class="n">internal_delete_pointers_items</span><span class="p">(</span><span class="n">src_bi</span><span class="p">,</span> <span class="n">first_pointer</span><span class="p">,</span>
					       <span class="n">first_item</span><span class="p">,</span> <span class="n">cpy_num</span> <span class="o">-</span> <span class="n">del_par</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* shift_right occurs */</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpy_num</span> <span class="o">-</span> <span class="n">del_par</span> <span class="o">==</span>
		     <span class="p">(</span><span class="n">j</span> <span class="o">=</span>
		      <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">j</span> <span class="o">-</span> <span class="n">cpy_num</span> <span class="o">+</span>
		    <span class="n">del_par</span><span class="p">;</span>

		<span class="n">internal_delete_pointers_items</span><span class="p">(</span><span class="n">src_bi</span><span class="p">,</span>
					       <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cpy_num</span> <span class="o">+</span> <span class="n">del_par</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					       <span class="n">cpy_num</span> <span class="o">-</span> <span class="n">del_par</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Insert n_src&#39;th key of buffer src before n_dest&#39;th key of buffer dest. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_insert_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_info</span> <span class="o">*</span><span class="n">dest_bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest_position_before</span><span class="p">,</span>	<span class="cm">/* insert key before key with n_dest number */</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src_position</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">dest</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">src</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
	       <span class="s">&quot;source(%p) or dest(%p) buffer is 0&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">dest_position_before</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">src_position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="s">&quot;source(%d) or dest(%d) key number less than 0&quot;</span><span class="p">,</span>
	       <span class="n">src_position</span><span class="p">,</span> <span class="n">dest_position_before</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">dest_position_before</span> <span class="o">&gt;</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">src_position</span> <span class="o">&gt;=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">),</span>
	       <span class="s">&quot;invalid position in dest (%d (key number %d)) or in src (%d (key number %d))&quot;</span><span class="p">,</span>
	       <span class="n">dest_position_before</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest</span><span class="p">),</span>
	       <span class="n">src_position</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src</span><span class="p">));</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">KEY_SIZE</span><span class="p">,</span>
	       <span class="s">&quot;no enough free space (%d) in dest buffer&quot;</span><span class="p">,</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">dest</span><span class="p">));</span>

	<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">);</span>

	<span class="cm">/* prepare space for inserting key */</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">dest_position_before</span><span class="p">);</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
		<span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">dest_position_before</span><span class="p">)</span> <span class="o">*</span> <span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">DC_SIZE</span><span class="p">);</span>

	<span class="cm">/* insert key */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_position</span><span class="p">),</span> <span class="n">KEY_SIZE</span><span class="p">);</span>

	<span class="cm">/* Change dirt, free space, item number fields. */</span>

	<span class="n">set_blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_nr_item</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">-</span> <span class="n">KEY_SIZE</span><span class="p">);</span>

	<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">t_dc</span><span class="p">;</span>
		<span class="n">t_dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_position</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">,</span> <span class="n">dc_size</span><span class="p">(</span><span class="n">t_dc</span><span class="p">)</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">);</span>

		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">,</span> <span class="n">dest_bi</span><span class="o">-&gt;</span><span class="n">bi_parent</span><span class="p">,</span>
					       <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Insert d_key&#39;th (delimiting) key from buffer cfl to tail of dest.</span>
<span class="cm"> * Copy pointer_amount node pointers and pointer_amount - 1 items from buffer src to buffer dest.</span>
<span class="cm"> * Replace  d_key&#39;th key in buffer cfl.</span>
<span class="cm"> * Delete pointer_amount items and node pointers from buffer src.</span>
<span class="cm"> */</span>
<span class="cm">/* this can be invoked both to shift from S to L and from R to S */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_shift_left</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>	<span class="cm">/* INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S */</span>
				<span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pointer_amount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">dest_bi</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">cf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">d_key_position</span><span class="p">;</span>

	<span class="n">internal_define_dest_src_infos</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">d_key_position</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cf</span><span class="p">);</span>

	<span class="cm">/*printk(&quot;pointer_amount = %d\n&quot;,pointer_amount); */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pointer_amount</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* insert delimiting key from common father of dest and src to node dest into position B_NR_ITEM(dest) */</span>
		<span class="n">internal_insert_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">),</span> <span class="n">cf</span><span class="p">,</span>
				    <span class="n">d_key_position</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">)</span> <span class="o">==</span> <span class="n">pointer_amount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">src_bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="cm">/*src-&gt;b_item_order */</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">cf</span><span class="p">,</span> <span class="n">d_key_position</span><span class="p">,</span>
					    <span class="n">src_bi</span><span class="p">.</span>
					    <span class="n">bi_parent</span> <span class="cm">/*src-&gt;b_parent */</span> <span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">cf</span><span class="p">,</span> <span class="n">d_key_position</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">,</span>
				    <span class="n">pointer_amount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* last parameter is del_parameter */</span>
	<span class="n">internal_move_pointers_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span>
				     <span class="n">pointer_amount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* Insert delimiting key to L[h].</span>
<span class="cm"> * Copy n node pointers and n - 1 items from buffer S[h] to L[h].</span>
<span class="cm"> * Delete n - 1 items and node pointers from buffer S[h].</span>
<span class="cm"> */</span>
<span class="cm">/* it always shifts from S[h] to L[h] */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_shift1_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pointer_amount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">dest_bi</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">cf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">d_key_position</span><span class="p">;</span>

	<span class="n">internal_define_dest_src_infos</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_L</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_key_position</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pointer_amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* insert lkey[h]-th key  from CFL[h] to left neighbor L[h] */</span>
		<span class="n">internal_insert_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">dest_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">),</span> <span class="n">cf</span><span class="p">,</span>
				    <span class="n">d_key_position</span><span class="p">);</span>
	<span class="cm">/*            internal_insert_key (tb-&gt;L[h], B_NR_ITEM(tb-&gt;L[h]), tb-&gt;CFL[h], tb-&gt;lkey[h]); */</span>

	<span class="cm">/* last parameter is del_parameter */</span>
	<span class="n">internal_move_pointers_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span> <span class="n">FIRST_TO_LAST</span><span class="p">,</span>
				     <span class="n">pointer_amount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*    internal_move_pointers_items (tb-&gt;L[h], tb-&gt;S[h], FIRST_TO_LAST, pointer_amount, 1); */</span>
<span class="p">}</span>

<span class="cm">/* Insert d_key&#39;th (delimiting) key from buffer cfr to head of dest.</span>
<span class="cm"> * Copy n node pointers and n - 1 items from buffer src to buffer dest.</span>
<span class="cm"> * Replace  d_key&#39;th key in buffer cfr.</span>
<span class="cm"> * Delete n items and node pointers from buffer src.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_shift_right</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>	<span class="cm">/* INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S */</span>
				 <span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pointer_amount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">dest_bi</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">cf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">d_key_position</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">internal_define_dest_src_infos</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">d_key_position</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cf</span><span class="p">);</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pointer_amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* insert delimiting key from common father of dest and src to dest node into position 0 */</span>
		<span class="n">internal_insert_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cf</span><span class="p">,</span> <span class="n">d_key_position</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="n">pointer_amount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">!=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="cm">/*tb-&gt;S[h] */</span> <span class="o">||</span>
			       <span class="n">dest_bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">!=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">],</span>
			       <span class="s">&quot;src (%p) must be == tb-&gt;S[h](%p) when it disappears&quot;</span><span class="p">,</span>
			       <span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">,</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">));</span>
			<span class="cm">/* when S[h] disappers replace left delemiting key as well */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">])</span>
				<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">cf</span><span class="p">,</span> <span class="n">d_key_position</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span>
					    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">replace_key</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">cf</span><span class="p">,</span> <span class="n">d_key_position</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span><span class="p">,</span>
				    <span class="n">nr</span> <span class="o">-</span> <span class="n">pointer_amount</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* last parameter is del_parameter */</span>
	<span class="n">internal_move_pointers_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
				     <span class="n">pointer_amount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Insert delimiting key to R[h].</span>
<span class="cm"> * Copy n node pointers and n - 1 items from buffer S[h] to R[h].</span>
<span class="cm"> * Delete n - 1 items and node pointers from buffer S[h].</span>
<span class="cm"> */</span>
<span class="cm">/* it always shift from S[h] to R[h] */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_shift1_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pointer_amount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">dest_bi</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">cf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">d_key_position</span><span class="p">;</span>

	<span class="n">internal_define_dest_src_infos</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_R</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_key_position</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pointer_amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* insert rkey from CFR[h] to right neighbor R[h] */</span>
		<span class="n">internal_insert_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cf</span><span class="p">,</span> <span class="n">d_key_position</span><span class="p">);</span>
	<span class="cm">/*            internal_insert_key (tb-&gt;R[h], 0, tb-&gt;CFR[h], tb-&gt;rkey[h]); */</span>

	<span class="cm">/* last parameter is del_parameter */</span>
	<span class="n">internal_move_pointers_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span> <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
				     <span class="n">pointer_amount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*    internal_move_pointers_items (tb-&gt;R[h], tb-&gt;S[h], LAST_TO_FIRST, pointer_amount, 1); */</span>
<span class="p">}</span>

<span class="cm">/* Delete insert_num node pointers together with their left items</span>
<span class="cm"> * and balance current node.*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">balance_internal_when_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">child_pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">insert_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbSh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">bi</span><span class="p">;</span>

	<span class="n">insert_num</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">/</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">DC_SIZE</span> <span class="o">+</span> <span class="n">KEY_SIZE</span><span class="p">));</span>

	<span class="cm">/* delete child-node-pointer(s) together with their left item(s) */</span>
	<span class="n">bi</span><span class="p">.</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
	<span class="n">bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tbSh</span><span class="p">;</span>
	<span class="n">bi</span><span class="p">.</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="n">bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">internal_delete_childs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span> <span class="n">child_pos</span><span class="p">,</span> <span class="o">-</span><span class="n">insert_num</span><span class="p">);</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>
	       <span class="s">&quot;tb-&gt;blknum[%d]=%d when insert_size &lt; 0&quot;</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbSh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* node S[h] (root of the tree) is empty now */</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">new_root</span><span class="p">;</span>

			<span class="n">RFALSE</span><span class="p">(</span><span class="n">n</span>
			       <span class="o">||</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">tbSh</span><span class="p">)</span> <span class="o">!=</span>
			       <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">tbSh</span><span class="p">)</span> <span class="o">-</span> <span class="n">DC_SIZE</span><span class="p">,</span>
			       <span class="s">&quot;buffer must have only 0 keys (%d)&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="n">RFALSE</span><span class="p">(</span><span class="n">bi</span><span class="p">.</span><span class="n">bi_parent</span><span class="p">,</span> <span class="s">&quot;root has parent (%p)&quot;</span><span class="p">,</span>
			       <span class="n">bi</span><span class="p">.</span><span class="n">bi_parent</span><span class="p">);</span>

			<span class="cm">/* choose a new root */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
				<span class="n">new_root</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">else</span>
				<span class="n">new_root</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
			<span class="cm">/* switch super block&#39;s tree root block number to the new value */</span>
			<span class="n">PUT_SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">new_root</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>REISERFS<em>SB(tb->tb</em>sb)->s<em>rs->s</em>tree_height --;</p></td><td class="code"><div class="highlight"><pre>			<span class="n">PUT_SB_TREE_HEIGHT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span>
					   <span class="n">SB_TREE_HEIGHT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">do_balance_mark_sb_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
						 <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">,</span>
						 <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="cm">/* use check_internal if new root is an internal node */</span>
				<span class="n">check_internal</span><span class="p">(</span><span class="n">new_root</span><span class="p">);</span>
			<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>

			<span class="cm">/* do what is needed for buffer thrown from tree */</span>
			<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbSh</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* join S[h] with L[h] */</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="s">&quot;invalid tb-&gt;rnum[%d]==%d when joining S[h] with L[h]&quot;</span><span class="p">,</span>
		       <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

		<span class="n">internal_shift_left</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_L</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbSh</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* join S[h] with R[h] */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="s">&quot;invalid tb-&gt;lnum[%d]==%d when joining S[h] with R[h]&quot;</span><span class="p">,</span>
		       <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

		<span class="n">internal_shift_right</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_R</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbSh</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* borrow from left neighbor L[h] */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="s">&quot;wrong tb-&gt;rnum[%d]==%d when borrow from L[h]&quot;</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
		       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="cm">/*internal_shift_right (tb, h, tb-&gt;L[h], tb-&gt;CFL[h], tb-&gt;lkey[h], tb-&gt;S[h], -tb-&gt;lnum[h]); */</span>
		<span class="n">internal_shift_right</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_L_TO_S</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
				     <span class="o">-</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* borrow from right neighbor R[h] */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="s">&quot;invalid tb-&gt;lnum[%d]==%d when borrow from R[h]&quot;</span><span class="p">,</span>
		       <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="n">internal_shift_left</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_R_TO_S</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>	<span class="cm">/*tb-&gt;S[h], tb-&gt;CFR[h], tb-&gt;rkey[h], tb-&gt;R[h], -tb-&gt;rnum[h]); */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* split S[h] into two parts and put them into neighbors */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="s">&quot;invalid tb-&gt;lnum[%d]==%d or tb-&gt;rnum[%d]==%d when S[h](item number == %d) is split between them&quot;</span><span class="p">,</span>
		       <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>

		<span class="n">internal_shift_left</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_L</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>	<span class="cm">/*tb-&gt;L[h], tb-&gt;CFL[h], tb-&gt;lkey[h], tb-&gt;S[h], tb-&gt;lnum[h]); */</span>
		<span class="n">internal_shift_right</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_R</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
				     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

		<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbSh</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reiserfs_panic</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="s">&quot;ibalance-2&quot;</span><span class="p">,</span>
		       <span class="s">&quot;unexpected tb-&gt;lnum[%d]==%d or tb-&gt;rnum[%d]==%d&quot;</span><span class="p">,</span>
		       <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Replace delimiting key of buffers L[h] and S[h] by the given key.*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">replace_lkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
	       <span class="s">&quot;L[h](%p) and CFL[h](%p) must exist in replace_lkey&quot;</span><span class="p">,</span>
	       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lkey</span><span class="p">[</span><span class="n">h</span><span class="p">]),</span> <span class="n">key</span><span class="p">,</span> <span class="n">KEY_SIZE</span><span class="p">);</span>

	<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFL</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Replace delimiting key of buffers S[h] and R[h] by the given key.*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">replace_rkey</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span>
	       <span class="s">&quot;R[h](%p) and CFR[h](%p) must exist in replace_rkey&quot;</span><span class="p">,</span>
	       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="s">&quot;R[h] can not be empty if it exists (item number=%d)&quot;</span><span class="p">,</span>
	       <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">]));</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rkey</span><span class="p">[</span><span class="n">h</span><span class="p">]),</span> <span class="n">key</span><span class="p">,</span> <span class="n">KEY_SIZE</span><span class="p">);</span>

	<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">CFR</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">balance_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">tree_balance</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>	<span class="cm">/* tree_balance structure               */</span>
		     <span class="kt">int</span> <span class="n">h</span><span class="p">,</span>	<span class="cm">/* level of the tree                    */</span>
		     <span class="kt">int</span> <span class="n">child_pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">insert_key</span><span class="p">,</span>	<span class="cm">/* key for insertion on higher level    */</span>
		     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">insert_ptr</span>	<span class="cm">/* node for insertion on higher level */</span>
    <span class="p">)</span>
    <span class="cm">/* if inserting/pasting</span>
<span class="cm">       {</span>
<span class="cm">       child_pos is the position of the node-pointer in S[h] that        *</span>
<span class="cm">       pointed to S[h-1] before balancing of the h-1 level;              *</span>
<span class="cm">       this means that new pointers and items must be inserted AFTER *</span>
<span class="cm">       child_pos</span>
<span class="cm">       }</span>
<span class="cm">       else</span>
<span class="cm">       {</span>
<span class="cm">       it is the position of the leftmost pointer that must be deleted (together with</span>
<span class="cm">       its corresponding key to the left of the pointer)</span>
<span class="cm">       as a result of the previous level&#39;s balancing.</span>
<span class="cm">       }</span>
<span class="cm">     */</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbSh</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">bi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>		<span class="cm">/* we return this: it is 0 if there is no S[h], else it is tb-&gt;S[h]-&gt;b_item_order */</span>
	<span class="kt">int</span> <span class="n">insert_num</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">S_new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="n">new_insert_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">new_insert_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">item_head</span> <span class="o">*</span><span class="n">new_insert_key_addr</span> <span class="o">=</span> <span class="n">insert_key</span><span class="p">;</span>

	<span class="n">RFALSE</span><span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;h (%d) can not be &lt; 1 on internal level&quot;</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="n">PROC_INFO_INC</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">balance_at</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>

	<span class="n">order</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">tbSh</span><span class="p">)</span> <span class="o">?</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span>
				     <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/*tb-&gt;S[h]-&gt;b_item_order */</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Using insert_size[h] calculate the number insert_num of items</span>
<span class="cm">	   that must be inserted to or deleted from S[h]. */</span>
	<span class="n">insert_num</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">/</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">KEY_SIZE</span> <span class="o">+</span> <span class="n">DC_SIZE</span><span class="p">));</span>

	<span class="cm">/* Check whether insert_num is proper * */</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">insert_num</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="o">||</span> <span class="n">insert_num</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span>
	       <span class="s">&quot;incorrect number of items inserted to the internal node (%d)&quot;</span><span class="p">,</span>
	       <span class="n">insert_num</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">insert_num</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">insert_num</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
	       <span class="s">&quot;incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level&quot;</span><span class="p">,</span>
	       <span class="n">insert_num</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

	<span class="cm">/* Make balance in case insert_num &lt; 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">balance_internal_when_delete</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">child_pos</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* shift lnum[h] items from S[h] to the left neighbor L[h].</span>
<span class="cm">		   check how many of new items fall into L[h] or CFL[h] after</span>
<span class="cm">		   shifting */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>	<span class="cm">/* number of items in L[h] */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">child_pos</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* new items don&#39;t fall into L[h] or CFL[h] */</span>
			<span class="n">internal_shift_left</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_L</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
			<span class="cm">/*internal_shift_left (tb-&gt;L[h],tb-&gt;CFL[h],tb-&gt;lkey[h],tbSh,tb-&gt;lnum[h]); */</span>
			<span class="n">child_pos</span> <span class="o">-=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">child_pos</span> <span class="o">+</span> <span class="n">insert_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* all new items fall into L[h] */</span>
			<span class="n">internal_shift_left</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_L</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					    <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="n">insert_num</span><span class="p">);</span>
			<span class="cm">/*                  internal_shift_left(tb-&gt;L[h],tb-&gt;CFL[h],tb-&gt;lkey[h],tbSh,</span>
<span class="cm">			   tb-&gt;lnum[h]-insert_num);</span>
<span class="cm">			 */</span>
			<span class="cm">/* insert insert_num keys and node-pointers into L[h] */</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
			<span class="n">internal_insert_childs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
					       <span class="cm">/*tb-&gt;L[h], tb-&gt;S[h-1]-&gt;b_next */</span>
					       <span class="n">n</span> <span class="o">+</span> <span class="n">child_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					       <span class="n">insert_num</span><span class="p">,</span> <span class="n">insert_key</span><span class="p">,</span>
					       <span class="n">insert_ptr</span><span class="p">);</span>

			<span class="n">insert_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">dc</span><span class="p">;</span>

			<span class="cm">/* some items fall into L[h] or CFL[h], but some don&#39;t fall */</span>
			<span class="n">internal_shift1_left</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">child_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/* calculate number of new items that fall into L[h] */</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="n">child_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FL</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_left_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
			<span class="n">internal_insert_childs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
					       <span class="cm">/*tb-&gt;L[h], tb-&gt;S[h-1]-&gt;b_next, */</span>
					       <span class="n">n</span> <span class="o">+</span> <span class="n">child_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span>
					       <span class="n">insert_key</span><span class="p">,</span> <span class="n">insert_ptr</span><span class="p">);</span>

			<span class="n">replace_lkey</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">insert_key</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>

			<span class="cm">/* replace the first node-ptr in S[h] by node-ptr to insert_ptr[k] */</span>
			<span class="n">dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tbSh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">put_dc_size</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span>
				    <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">insert_ptr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">-</span>
				    <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">insert_ptr</span><span class="p">[</span><span class="n">k</span><span class="p">]));</span>
			<span class="n">put_dc_block_number</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">insert_ptr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>

			<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbSh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">k</span><span class="o">++</span><span class="p">;</span>
			<span class="n">insert_key</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
			<span class="n">insert_ptr</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
			<span class="n">insert_num</span> <span class="o">-=</span> <span class="n">k</span><span class="p">;</span>
			<span class="n">child_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* tb-&gt;lnum[h] &gt; 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*shift rnum[h] items from S[h] to the right neighbor R[h] */</span>
		<span class="cm">/* check how many of new items fall into R or CFR after shifting */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbSh</span><span class="p">);</span>	<span class="cm">/* number of items in S[h] */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">child_pos</span><span class="p">)</span>
			<span class="cm">/* new items fall into S[h] */</span>
			<span class="cm">/*internal_shift_right(tb,h,tbSh,tb-&gt;CFR[h],tb-&gt;rkey[h],tb-&gt;R[h],tb-&gt;rnum[h]); */</span>
			<span class="n">internal_shift_right</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_R</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]);</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">insert_num</span> <span class="o">-</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">child_pos</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* all new items fall into R[h] */</span>
			<span class="cm">/*internal_shift_right(tb,h,tbSh,tb-&gt;CFR[h],tb-&gt;rkey[h],tb-&gt;R[h],</span>
<span class="cm">			   tb-&gt;rnum[h] - insert_num); */</span>
			<span class="n">internal_shift_right</span><span class="p">(</span><span class="n">INTERNAL_SHIFT_FROM_S_TO_R</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
					     <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="n">insert_num</span><span class="p">);</span>

			<span class="cm">/* insert insert_num keys and node-pointers into R[h] */</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
			<span class="n">internal_insert_childs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
					       <span class="cm">/*tb-&gt;R[h],tb-&gt;S[h-1]-&gt;b_next */</span>
					       <span class="n">child_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">insert_num</span> <span class="o">+</span>
					       <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					       <span class="n">insert_num</span><span class="p">,</span> <span class="n">insert_key</span><span class="p">,</span>
					       <span class="n">insert_ptr</span><span class="p">);</span>
			<span class="n">insert_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">dc</span><span class="p">;</span>

			<span class="cm">/* one of the items falls into CFR[h] */</span>
			<span class="n">internal_shift1_right</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">child_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/* calculate number of new items that fall into R[h] */</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">rnum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="n">child_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">FR</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">get_right_neighbor_position</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
			<span class="n">internal_insert_childs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>
					       <span class="cm">/*tb-&gt;R[h], tb-&gt;R[h]-&gt;b_child, */</span>
					       <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">insert_key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					       <span class="n">insert_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">replace_rkey</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">insert_key</span> <span class="o">+</span> <span class="n">insert_num</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* replace the first node-ptr in R[h] by node-ptr insert_ptr[insert_num-k-1] */</span>
			<span class="n">dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">put_dc_size</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span>
				    <span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">insert_ptr</span>
						   <span class="p">[</span><span class="n">insert_num</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
				    <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">insert_ptr</span>
						 <span class="p">[</span><span class="n">insert_num</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
			<span class="n">put_dc_block_number</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span>
					    <span class="n">insert_ptr</span><span class="p">[</span><span class="n">insert_num</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span>
						       <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>

			<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">insert_num</span> <span class="o">-=</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="cm">/** Fill new node that appears instead of S[h] **/</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;blknum can not be &gt; 2 for internal level&quot;</span><span class="p">);</span>
	<span class="n">RFALSE</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;blknum can not be &lt; 0&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="p">{</span>	<span class="cm">/* node S[h] is empty now */</span>
		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">tbSh</span><span class="p">,</span> <span class="s">&quot;S[h] is equal NULL&quot;</span><span class="p">);</span>

		<span class="cm">/* do what is needed for buffer thrown from tree */</span>
		<span class="n">reiserfs_invalidate_buffer</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbSh</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbSh</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* create new root */</span>
		<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">dc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbSh_1</span> <span class="o">=</span> <span class="n">PATH_H_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">block_head</span> <span class="o">*</span><span class="n">blkh</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">reiserfs_panic</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;ibalance-3&quot;</span><span class="p">,</span> <span class="s">&quot;One new node &quot;</span>
				       <span class="s">&quot;required for creating the new root&quot;</span><span class="p">);</span>
		<span class="cm">/* S[h] = empty buffer from the list FEB. */</span>
		<span class="n">tbSh</span> <span class="o">=</span> <span class="n">get_FEB</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
		<span class="n">blkh</span> <span class="o">=</span> <span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">tbSh</span><span class="p">);</span>
		<span class="n">set_blkh_level</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Put the unique node-pointer to S[h] that points to S[h-1]. */</span>

		<span class="n">dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">tbSh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">put_dc_block_number</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">tbSh_1</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="n">put_dc_size</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">MAX_CHILD_SIZE</span><span class="p">(</span><span class="n">tbSh_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">tbSh_1</span><span class="p">)));</span>

		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">insert_size</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-=</span> <span class="n">DC_SIZE</span><span class="p">;</span>
		<span class="n">set_blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">,</span> <span class="n">blkh_free_space</span><span class="p">(</span><span class="n">blkh</span><span class="p">)</span> <span class="o">-</span> <span class="n">DC_SIZE</span><span class="p">);</span>

		<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tbSh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>
		<span class="n">check_internal</span><span class="p">(</span><span class="n">tbSh</span><span class="p">);</span>
		<span class="cm">/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; */</span>

		<span class="cm">/* put new root into path structure */</span>
		<span class="n">PATH_OFFSET_PBUFFER</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">ILLEGAL_PATH_ELEMENT_OFFSET</span><span class="p">)</span> <span class="o">=</span>
		    <span class="n">tbSh</span><span class="p">;</span>

		<span class="cm">/* Change root in structure super block. */</span>
		<span class="n">PUT_SB_ROOT_BLOCK</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">tbSh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="n">PUT_SB_TREE_HEIGHT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">,</span> <span class="n">SB_TREE_HEIGHT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">do_balance_mark_sb_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">REISERFS_SB</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">blknum</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">snum</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_info</span> <span class="n">dest_bi</span><span class="p">,</span> <span class="n">src_bi</span><span class="p">;</span>

		<span class="cm">/* S_new = free buffer from list FEB */</span>
		<span class="n">S_new</span> <span class="o">=</span> <span class="n">get_FEB</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>

		<span class="n">set_blkh_level</span><span class="p">(</span><span class="n">B_BLK_HEAD</span><span class="p">(</span><span class="n">S_new</span><span class="p">),</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">dest_bi</span><span class="p">.</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">S_new</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="p">.</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dest_bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="p">.</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tbSh</span><span class="p">;</span>
		<span class="n">src_bi</span><span class="p">.</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">src_bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbSh</span><span class="p">);</span>	<span class="cm">/* number of items in S[h] */</span>
		<span class="n">snum</span> <span class="o">=</span> <span class="p">(</span><span class="n">insert_num</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">snum</span> <span class="o">&gt;=</span> <span class="n">child_pos</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* new items don&#39;t fall into S_new */</span>
			<span class="cm">/*  store the delimiting key for the next level */</span>
			<span class="cm">/* new_insert_key = (n - snum)&#39;th key in S[h] */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_insert_key</span><span class="p">,</span> <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tbSh</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">snum</span><span class="p">),</span>
			       <span class="n">KEY_SIZE</span><span class="p">);</span>
			<span class="cm">/* last parameter is del_par */</span>
			<span class="n">internal_move_pointers_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span>
						     <span class="n">LAST_TO_FIRST</span><span class="p">,</span> <span class="n">snum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/*            internal_move_pointers_items(S_new, tbSh, LAST_TO_FIRST, snum, 0); */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">insert_num</span> <span class="o">-</span> <span class="n">snum</span> <span class="o">&lt;</span> <span class="n">child_pos</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* all new items fall into S_new */</span>
			<span class="cm">/*  store the delimiting key for the next level */</span>
			<span class="cm">/* new_insert_key = (n + insert_item - snum)&#39;th key in S[h] */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_insert_key</span><span class="p">,</span>
			       <span class="n">B_N_PDELIM_KEY</span><span class="p">(</span><span class="n">tbSh</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">insert_num</span> <span class="o">-</span> <span class="n">snum</span><span class="p">),</span>
			       <span class="n">KEY_SIZE</span><span class="p">);</span>
			<span class="cm">/* last parameter is del_par */</span>
			<span class="n">internal_move_pointers_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span>
						     <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
						     <span class="n">snum</span> <span class="o">-</span> <span class="n">insert_num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/*                  internal_move_pointers_items(S_new,tbSh,1,snum - insert_num,0); */</span>

			<span class="cm">/* insert insert_num keys and node-pointers into S_new */</span>
			<span class="n">internal_insert_childs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span>
					       <span class="cm">/*S_new,tb-&gt;S[h-1]-&gt;b_next, */</span>
					       <span class="n">child_pos</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">insert_num</span> <span class="o">+</span>
					       <span class="n">snum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					       <span class="n">insert_num</span><span class="p">,</span> <span class="n">insert_key</span><span class="p">,</span>
					       <span class="n">insert_ptr</span><span class="p">);</span>

			<span class="n">insert_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">disk_child</span> <span class="o">*</span><span class="n">dc</span><span class="p">;</span>

			<span class="cm">/* some items fall into S_new, but some don&#39;t fall */</span>
			<span class="cm">/* last parameter is del_par */</span>
			<span class="n">internal_move_pointers_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">src_bi</span><span class="p">,</span>
						     <span class="n">LAST_TO_FIRST</span><span class="p">,</span>
						     <span class="n">n</span> <span class="o">-</span> <span class="n">child_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/*                  internal_move_pointers_items(S_new,tbSh,1,n - child_pos + 1,1); */</span>
			<span class="cm">/* calculate number of new items that fall into S_new */</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">snum</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="n">child_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">internal_insert_childs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest_bi</span><span class="p">,</span> <span class="cm">/*S_new, */</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span>
					       <span class="n">insert_key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">insert_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* new_insert_key = insert_key[insert_num - k - 1] */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_insert_key</span><span class="p">,</span> <span class="n">insert_key</span> <span class="o">+</span> <span class="n">insert_num</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="n">KEY_SIZE</span><span class="p">);</span>
			<span class="cm">/* replace first node-ptr in S_new by node-ptr to insert_ptr[insert_num-k-1] */</span>

			<span class="n">dc</span> <span class="o">=</span> <span class="n">B_N_CHILD</span><span class="p">(</span><span class="n">S_new</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">put_dc_size</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">MAX_CHILD_SIZE</span>
				     <span class="p">(</span><span class="n">insert_ptr</span><span class="p">[</span><span class="n">insert_num</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
				     <span class="n">B_FREE_SPACE</span><span class="p">(</span><span class="n">insert_ptr</span>
						  <span class="p">[</span><span class="n">insert_num</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])));</span>
			<span class="n">put_dc_block_number</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span>
					    <span class="n">insert_ptr</span><span class="p">[</span><span class="n">insert_num</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span>
						       <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>

			<span class="n">do_balance_mark_internal_dirty</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">S_new</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">insert_num</span> <span class="o">-=</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* new_insert_ptr = node_pointer to S_new */</span>
		<span class="n">new_insert_ptr</span> <span class="o">=</span> <span class="n">S_new</span><span class="p">;</span>

		<span class="n">RFALSE</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_journaled</span><span class="p">(</span><span class="n">S_new</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_journal_dirty</span><span class="p">(</span><span class="n">S_new</span><span class="p">)</span>
		       <span class="o">||</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">S_new</span><span class="p">),</span> <span class="s">&quot;cm-00001: bad S_new (%b)&quot;</span><span class="p">,</span>
		       <span class="n">S_new</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>S<em>new is released in unfix</em>nodes</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">B_NR_ITEMS</span><span class="p">(</span><span class="n">tbSh</span><span class="p">);</span>	<span class="cm">/*number of items in S[h] */</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">child_pos</span> <span class="o">&amp;&amp;</span> <span class="n">child_pos</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">insert_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bi</span><span class="p">.</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
		<span class="n">bi</span><span class="p">.</span><span class="n">bi_bh</span> <span class="o">=</span> <span class="n">tbSh</span><span class="p">;</span>
		<span class="n">bi</span><span class="p">.</span><span class="n">bi_parent</span> <span class="o">=</span> <span class="n">PATH_H_PPARENT</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">bi</span><span class="p">.</span><span class="n">bi_position</span> <span class="o">=</span> <span class="n">PATH_H_POSITION</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">internal_insert_childs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="p">,</span>	<span class="cm">/*tbSh, */</span>
				       <span class="cm">/*          ( tb-&gt;S[h-1]-&gt;b_parent == tb-&gt;S[h] ) ? tb-&gt;S[h-1]-&gt;b_next :  tb-&gt;S[h]-&gt;b_child-&gt;b_next, */</span>
				       <span class="n">child_pos</span><span class="p">,</span> <span class="n">insert_num</span><span class="p">,</span> <span class="n">insert_key</span><span class="p">,</span>
				       <span class="n">insert_ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">new_insert_key_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_insert_key</span><span class="p">,</span> <span class="n">KEY_SIZE</span><span class="p">);</span>
	<span class="n">insert_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_insert_ptr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
