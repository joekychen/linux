<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › reiserfs › file.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>file.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &quot;reiserfs.h&quot;</span>
<span class="cp">#include &quot;acl.h&quot;</span>
<span class="cp">#include &quot;xattr.h&quot;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>

<span class="cm">/*</span>
<span class="cm">** We pack the tails of files on file close, not at the time they are written.</span>
<span class="cm">** This implies an unnecessary copy of the tail and an unnecessary indirect item</span>
<span class="cm">** insertion/balancing, for files that are written in one write.</span>
<span class="cm">** It avoids unnecessary tail packings (balances) for files that are written in</span>
<span class="cm">** multiple writes and are small enough to have tails.</span>
<span class="cm">**</span>
<span class="cm">** file_release is called by the VFS layer when the file is closed.  If</span>
<span class="cm">** this is the last open file descriptor, and the file</span>
<span class="cm">** small enough to have a tail, and the tail is currently in an</span>
<span class="cm">** unformatted node, the tail is converted back into a direct item.</span>
<span class="cm">**</span>
<span class="cm">** We use reiserfs_truncate_file to pack the tail, since it already has</span>
<span class="cm">** all the conditions coded.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_file_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jbegin_failure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">openers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tailpack</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">openers</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tailpack</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fast out for when nothing needs to be done */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">i_pack_on_close_mask</span><span class="p">)</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">tail_has_to_be_packed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_prealloc_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tailpack</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="cm">/* freeing preallocation only involves relogging blocks that</span>
<span class="cm">	 * are already in the current transaction.  preallocation gets</span>
<span class="cm">	 * freed at the end of each transaction, so it is impossible for</span>
<span class="cm">	 * us to log any additional blocks (including quota blocks)</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* uh oh, we can&#39;t allow the inode to go away while there</span>
<span class="cm">		 * is still preallocation blocks pending.  Try to join the</span>
<span class="cm">		 * aborted transaction</span>
<span class="cm">		 */</span>
		<span class="n">jbegin_failure</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_join_abort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* hmpf, our choices here aren&#39;t good.  We can pin the inode</span>
<span class="cm">			 * which will disallow unmount from every happening, we can</span>
<span class="cm">			 * do nothing, which will corrupt random memory on unmount,</span>
<span class="cm">			 * or we can forcibly remove the file from the preallocation</span>
<span class="cm">			 * list, which will leak blocks on disk.  Lets pin the inode</span>
<span class="cm">			 * and let the admin know what is going on.</span>
<span class="cm">			 */</span>
			<span class="n">igrab</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">reiserfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;clm-9001&quot;</span><span class="p">,</span>
					 <span class="s">&quot;pinning inode %lu because the &quot;</span>
					 <span class="s">&quot;preallocation can&#39;t be freed&quot;</span><span class="p">,</span>
					 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

<span class="cp">#ifdef REISERFS_PREALLOCATE</span>
	<span class="n">reiserfs_discard_prealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* copy back the error code from journal_begin */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">jbegin_failure</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">i_pack_on_close_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tail_has_to_be_packed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* if regular file is released by last holder and it has been</span>
<span class="cm">		   appended (we append by unformatted node only) or its direct</span>
<span class="cm">		   item(s) had to be converted, then it may have to be</span>
<span class="cm">		   indirect2direct converted */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">reiserfs_truncate_file</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
      <span class="nl">out:</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tailpack</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">dquot_file_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">openers</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* somebody might be tailpacking on final close; wait for it */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tailpack</span><span class="p">));</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">openers</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tailpack</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reiserfs_vfs_truncate_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tailpack</span><span class="p">));</span>
	<span class="n">reiserfs_truncate_file</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REISERFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tailpack</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Sync a reiserfs file. */</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: sync_mapping_buffers() never has anything to sync.  Can</span>
<span class="cm"> * be removed...</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reiserfs_sync_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">barrier_done</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sync_mapping_buffers</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">barrier_done</span> <span class="o">=</span> <span class="n">reiserfs_commit_for_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">barrier_done</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">reiserfs_barrier_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span>
		<span class="n">blkdev_issue_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">barrier_done</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">barrier_done</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* taken fs/buffer.c:__block_commit_write */</span>
<span class="kt">int</span> <span class="nf">reiserfs_commit_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">partial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i_size_index</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">logit</span> <span class="o">=</span> <span class="n">reiserfs_file_data_log</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bh_per_page</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">th</span><span class="p">.</span><span class="n">t_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">logit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reiserfs_write_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bh_per_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop_write_lock</span><span class="p">;</span>
		<span class="n">reiserfs_update_inode_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">block_start</span><span class="p">;</span>
	     <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">new</span> <span class="o">=</span> <span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&lt;=</span> <span class="n">from</span> <span class="o">||</span> <span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">partial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">logit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">reiserfs_prepare_for_journal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">journal_mark_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="cm">/* do data=ordered on any page past the end</span>
<span class="cm">				 * of file and any buffer marked BH_New.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">reiserfs_data_ordered</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">new</span> <span class="o">||</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">i_size_index</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">reiserfs_add_ordered_list</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">logit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bh_per_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	      <span class="nl">drop_write_lock:</span>
		<span class="n">reiserfs_write_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is a partial write which happened to make all buffers</span>
<span class="cm">	 * uptodate then we can optimize away a bogus readpage() for</span>
<span class="cm">	 * the next read(). Here we &#39;discover&#39; whether the page went</span>
<span class="cm">	 * uptodate as a result of this (potentially partial) write.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Write @count bytes at position @ppos in a file indicated by @file</span>
<span class="cm">   from the buffer @buf.</span>

<span class="cm">   generic_file_write() is only appropriate for filesystems that are not seeking to optimize performance and want</span>
<span class="cm">   something simple that works.  It is not for serious use by general purpose filesystems, excepting the one that it was</span>
<span class="cm">   written for (ext2/3).  This is for several reasons:</span>

<span class="cm">   * It has no understanding of any filesystem specific optimizations.</span>

<span class="cm">   * It enters the filesystem repeatedly for each page that is written.</span>

<span class="cm">   * It depends on reiserfs_get_block() function which if implemented by reiserfs performs costly search_by_key</span>
<span class="cm">   * operation for each page it is supplied with. By contrast reiserfs_file_write() feeds as much as possible at a time</span>
<span class="cm">   * to reiserfs which allows for fewer tree traversals.</span>

<span class="cm">   * Each indirect pointer insertion takes a lot of cpu, because it involves memory moves inside of blocks.</span>

<span class="cm">   * Asking the block allocation code for blocks one at a time is slightly less efficient.</span>

<span class="cm">   All of these reasons for not using only generic file write were understood back when reiserfs was first miscoded to</span>
<span class="cm">   use it, but we were in a hurry to make code freeze, and so it couldn&#39;t be revised then.  This new code should make</span>
<span class="cm">   things right finally.</span>

<span class="cm">   Future Features: providing search_by_key with hints.</span>

<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reiserfs_file_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>	<span class="cm">/* the file we are going to write into */</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>	<span class="cm">/*  pointer to user supplied data</span>
<span class="cm">								   (in userspace) */</span>
				   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>	<span class="cm">/* amount of bytes to write */</span>
				   <span class="n">loff_t</span> <span class="o">*</span> <span class="n">ppos</span>	<span class="cm">/* pointer to position in file that we start writing at. Should be updated to</span>
<span class="cm">							 * new current position before returning. */</span>
				   <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>	<span class="c1">// Inode of the file that we are writing to.</span>
	<span class="cm">/* To simplify coding at this time, we store</span>
<span class="cm">	   locked pages in array for now */</span>
	<span class="k">struct</span> <span class="n">reiserfs_transaction_handle</span> <span class="n">th</span><span class="p">;</span>
	<span class="n">th</span><span class="p">.</span><span class="n">t_trans_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If a filesystem is converted from 3.5 to 3.6, we&#39;ll have v3.5 items</span>
<span class="cm">	* lying around (most of the disk, in fact). Despite the filesystem</span>
<span class="cm">	* now being a v3.6 format, the old items still can&#39;t support large</span>
<span class="cm">	* file sizes. Catch this case here, as the rest of the VFS layer is</span>
<span class="cm">	* oblivious to the different limitations between old and new items.</span>
<span class="cm">	* reiserfs_setattr catches this for truncates. This chunk is lifted</span>
<span class="cm">	* from generic_write_checks. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_inode_item_key_version</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">KEY_FORMAT_3_5</span> <span class="o">&amp;&amp;</span>
	    <span class="o">*</span><span class="n">ppos</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_NON_LFS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">&gt;=</span> <span class="n">MAX_NON_LFS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_NON_LFS</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">MAX_NON_LFS</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">do_sync_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">reiserfs_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">reiserfs_file_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">reiserfs_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span> <span class="n">reiserfs_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">generic_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">reiserfs_file_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">reiserfs_file_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span> <span class="o">=</span> <span class="n">reiserfs_sync_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span> <span class="o">=</span> <span class="n">generic_file_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span> <span class="n">generic_file_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span> <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_write</span> <span class="o">=</span> <span class="n">generic_file_splice_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">reiserfs_file_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">truncate</span> <span class="o">=</span> <span class="n">reiserfs_vfs_truncate_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span> <span class="o">=</span> <span class="n">reiserfs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span> <span class="o">=</span> <span class="n">reiserfs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span> <span class="o">=</span> <span class="n">reiserfs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span> <span class="o">=</span> <span class="n">reiserfs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span> <span class="o">=</span> <span class="n">reiserfs_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span> <span class="o">=</span> <span class="n">reiserfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span> <span class="o">=</span> <span class="n">reiserfs_get_acl</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
