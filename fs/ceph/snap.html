<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ceph › snap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>snap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/ceph/ceph_debug.h&gt;</span>

<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;super.h&quot;</span>
<span class="cp">#include &quot;mds_client.h&quot;</span>

<span class="cp">#include &lt;linux/ceph/decode.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Snapshots in ceph are driven in large part by cooperation from the</span>
<span class="cm"> * client.  In contrast to local file systems or file servers that</span>
<span class="cm"> * implement snapshots at a single point in the system, ceph&#39;s</span>
<span class="cm"> * distributed access to storage requires clients to help decide</span>
<span class="cm"> * whether a write logically occurs before or after a recently created</span>
<span class="cm"> * snapshot.</span>
<span class="cm"> *</span>
<span class="cm"> * This provides a perfect instantanous client-wide snapshot.  Between</span>
<span class="cm"> * clients, however, snapshots may appear to be applied at slightly</span>
<span class="cm"> * different points in time, depending on delays in delivering the</span>
<span class="cm"> * snapshot notification.</span>
<span class="cm"> *</span>
<span class="cm"> * Snapshots are _not_ file system-wide.  Instead, each snapshot</span>
<span class="cm"> * applies to the subdirectory nested beneath some directory.  This</span>
<span class="cm"> * effectively divides the hierarchy into multiple &quot;realms,&quot; where all</span>
<span class="cm"> * of the files contained by each realm share the same set of</span>
<span class="cm"> * snapshots.  An individual realm&#39;s snap set contains snapshots</span>
<span class="cm"> * explicitly created on that realm, as well as any snaps in its</span>
<span class="cm"> * parent&#39;s snap set _after_ the point at which the parent became it&#39;s</span>
<span class="cm"> * parent (due to, say, a rename).  Similarly, snaps from prior parents</span>
<span class="cm"> * during the time intervals during which they were the parent are included.</span>
<span class="cm"> *</span>
<span class="cm"> * The client is spared most of this detail, fortunately... it must only</span>
<span class="cm"> * maintains a hierarchy of realms reflecting the current parent/child</span>
<span class="cm"> * realm relationship, and for each realm has an explicit list of snaps</span>
<span class="cm"> * inherited from prior parents.</span>
<span class="cm"> *</span>
<span class="cm"> * A snap_realm struct is maintained for realms containing every inode</span>
<span class="cm"> * with an open cap in the system.  (The needed snap realm information is</span>
<span class="cm"> * provided by the MDS whenever a cap is issued, i.e., on open.)  A &#39;seq&#39;</span>
<span class="cm"> * version number is used to ensure that as realm parameters change (new</span>
<span class="cm"> * snapshot, new parent, etc.) the client&#39;s realm hierarchy is updated.</span>
<span class="cm"> *</span>
<span class="cm"> * The realm hierarchy drives the generation of a &#39;snap context&#39; for each</span>
<span class="cm"> * realm, which simply lists the resulting set of snaps for the realm.  This</span>
<span class="cm"> * is attached to any writes sent to OSDs.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Unfortunately error handling is a bit mixed here.  If we get a snap</span>
<span class="cm"> * update, but don&#39;t have enough memory to update our realm hierarchy,</span>
<span class="cm"> * it&#39;s not clear what we can do about it (besides complaining to the</span>
<span class="cm"> * console).</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * increase ref count for the realm</span>
<span class="cm"> *</span>
<span class="cm"> * caller must hold snap_rwsem for write.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_get_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_realm %p %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span>
	     <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">),</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * since we _only_ increment realm refs or empty the empty</span>
<span class="cm">	 * list with snap_rwsem held, adjusting the empty list here is</span>
<span class="cm">	 * safe.  we do need to protect against concurrent empty list</span>
<span class="cm">	 * additions, however.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">empty_item</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__insert_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_snap_realm</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * create and get the realm rooted at @ino and bump its ref count.</span>
<span class="cm"> *</span>
<span class="cm"> * caller must hold snap_rwsem for write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="nf">ceph_create_snap_realm</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">;</span>

	<span class="n">realm</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">realm</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>    <span class="cm">/* tree does not take a ref */</span>
	<span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">child_item</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">empty_item</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">dirty_item</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
	<span class="n">__insert_snap_realm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_realms</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;create_snap_realm %llx %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">realm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lookup the realm rooted at @ino.</span>
<span class="cm"> *</span>
<span class="cm"> * caller must hold snap_rwsem for write.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="nf">ceph_lookup_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
					       <span class="n">u64</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_realms</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_snap_realm</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;lookup_snap_realm %llx %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__put_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * called with snap_rwsem (write)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__destroy_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__destroy_snap_realm %p %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>

	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_realms</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">child_item</span><span class="p">);</span>
		<span class="n">__put_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">prior_parent_snaps</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">snaps</span><span class="p">);</span>
	<span class="n">ceph_put_snap_context</span><span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">realm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * caller holds snap_rwsem (write)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__put_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__put_snap_realm %llx %p %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span>
	     <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">),</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">))</span>
		<span class="n">__destroy_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * caller needn&#39;t hold any locks</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_put_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;put_snap_realm %llx %p %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span>
	     <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">),</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">down_write_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__destroy_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">empty_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up any realms whose ref counts have dropped to zero.  Note</span>
<span class="cm"> * that this does not include realms who were created but not yet</span>
<span class="cm"> * used.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under snap_rwsem (write)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cleanup_empty_realms</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">realm</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ceph_snap_realm</span><span class="p">,</span> <span class="n">empty_item</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">empty_item</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty_lock</span><span class="p">);</span>
		<span class="n">__destroy_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_empty_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_cleanup_empty_realms</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
	<span class="n">__cleanup_empty_realms</span><span class="p">(</span><span class="n">mdsc</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * adjust the parent realm of a given @realm.  adjust child list, and parent</span>
<span class="cm"> * pointers, and ref counts appropriately.</span>
<span class="cm"> *</span>
<span class="cm"> * return true if parent was changed, 0 if unchanged, &lt;0 on error.</span>
<span class="cm"> *</span>
<span class="cm"> * caller must hold snap_rwsem for write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">adjust_snap_realm_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">,</span>
				    <span class="n">u64</span> <span class="n">parentino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent_ino</span> <span class="o">==</span> <span class="n">parentino</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">ceph_lookup_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">parentino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">ceph_create_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">parentino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;adjust_snap_realm_parent %llx %p: %llx %p -&gt; %llx %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent_ino</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
	     <span class="n">parentino</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">child_item</span><span class="p">);</span>
		<span class="n">ceph_put_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent_ino</span> <span class="o">=</span> <span class="n">parentino</span><span class="p">;</span>
	<span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">ceph_get_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">child_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmpu64_rev</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">&gt;</span> <span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * build the snap context for a given realm.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">build_snap_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_snap_context</span> <span class="o">*</span><span class="n">snapc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_prior_parent_snaps</span> <span class="o">+</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * build parent context, if it hasn&#39;t been built.</span>
<span class="cm">	 * conservatively estimate that all parent snaps might be</span>
<span class="cm">	 * included by us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">build_snap_context</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">num</span> <span class="o">+=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do i actually need to update?  not if my context seq</span>
<span class="cm">	   matches realm seq, and my parents&#39; does to.  (this works</span>
<span class="cm">	   because we rebuild_snap_realms() works _downward_ in</span>
<span class="cm">	   hierarchy after each update.) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span> <span class="o">&amp;&amp;</span>
	    <span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">parent</span> <span class="o">||</span>
	     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&gt;=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;build_snap_context %llx %p: %p seq %lld (%d snaps)&quot;</span>
		     <span class="s">&quot; (unchanged)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">,</span>
		     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
		     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* alloc new snap context */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">SIZE_MAX</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">snapc</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">snapc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">snapc</span><span class="p">)</span> <span class="o">+</span> <span class="n">num</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snapc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snapc</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* build (reverse sorted) snap vector */</span>
	<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">snapc</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* include any of parent&#39;s snaps occurring _after_ my</span>
<span class="cm">		   parent became my parent */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">snaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span>
			    <span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent_since</span><span class="p">)</span>
				<span class="n">snapc</span><span class="o">-&gt;</span><span class="n">snaps</span><span class="p">[</span><span class="n">num</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">parent</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">snaps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&gt;</span> <span class="n">snapc</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span>
			<span class="n">snapc</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">snapc</span><span class="o">-&gt;</span><span class="n">snaps</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">snaps</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">snapc</span><span class="o">-&gt;</span><span class="n">snaps</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">prior_parent_snaps</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_prior_parent_snaps</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_prior_parent_snaps</span><span class="p">;</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">snapc</span><span class="o">-&gt;</span><span class="n">snaps</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="n">cmpu64_rev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">snapc</span><span class="o">-&gt;</span><span class="n">num_snaps</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;build_snap_context %llx %p: %p seq %lld (%d snaps)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">snapc</span><span class="p">,</span> <span class="n">snapc</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">snapc</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">)</span>
		<span class="n">ceph_put_snap_context</span><span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">);</span>
	<span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span> <span class="o">=</span> <span class="n">snapc</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="cm">/*</span>
<span class="cm">	 * if we fail, clear old (incorrect) cached_context... hopefully</span>
<span class="cm">	 * we&#39;ll have better luck building it later</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceph_put_snap_context</span><span class="p">(</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">);</span>
		<span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;build_snap_context %llx %p fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span>
	       <span class="n">realm</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rebuild snap context for the given realm and all of its children.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rebuild_snap_realms</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;rebuild_snap_realms %llx %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
	<span class="n">build_snap_context</span><span class="p">(</span><span class="n">realm</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_item</span><span class="p">)</span>
		<span class="n">rebuild_snap_realms</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * helper to allocate and decode an array of snapids.  free prior</span>
<span class="cm"> * instance, if any.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dup_array</span><span class="p">(</span><span class="n">u64</span> <span class="o">**</span><span class="n">dst</span><span class="p">,</span> <span class="n">__le64</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">dst</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_unaligned_le64</span><span class="p">(</span><span class="n">src</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * When a snapshot is applied, the size/mtime inode metadata is queued</span>
<span class="cm"> * in a ceph_cap_snap (one for each snapshot) until writeback</span>
<span class="cm"> * completes and the metadata can be flushed back to the MDS.</span>
<span class="cm"> *</span>
<span class="cm"> * However, if a (sync) write is currently in-progress when we apply</span>
<span class="cm"> * the snapshot, we have to wait until the write succeeds or fails</span>
<span class="cm"> * (and a final size/mtime is known).  In this case the</span>
<span class="cm"> * cap_snap-&gt;writing = 1, and is said to be &quot;pending.&quot;  When the write</span>
<span class="cm"> * finishes, we __ceph_finish_cap_snap().</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold snap_rwsem for read (i.e., the realm topology won&#39;t</span>
<span class="cm"> * change).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_queue_cap_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">,</span> <span class="n">dirty</span><span class="p">;</span>

	<span class="n">capsnap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">capsnap</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capsnap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ENOMEM allocating ceph_cap_snap on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="n">dirty</span> <span class="o">=</span> <span class="n">__ceph_caps_dirty</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is a write in progress, treat that as a dirty Fw,</span>
<span class="cm">	 * even though it hasn&#39;t completed yet; by the time we finish</span>
<span class="cm">	 * up this capsnap it will be.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">)</span>
		<span class="n">dirty</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__ceph_have_pending_cap_snap</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* there is no point in queuing multiple &quot;pending&quot; cap_snaps,</span>
<span class="cm">		   as no new writes are allowed to start when pending, so any</span>
<span class="cm">		   writes in progress now were started before the previous</span>
<span class="cm">		   cap_snap.  lucky us. */</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;queue_cap_snap %p already pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">capsnap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_AUTH_EXCL</span><span class="o">|</span><span class="n">CEPH_CAP_XATTR_EXCL</span><span class="o">|</span>
			    <span class="n">CEPH_CAP_FILE_EXCL</span><span class="o">|</span><span class="n">CEPH_CAP_FILE_WR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_snap_context</span> <span class="o">*</span><span class="n">snapc</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if we are a sync write, we may need to go to the snaprealm</span>
<span class="cm">		 * to get the current snapc.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snapc</span><span class="p">)</span>
			<span class="n">snapc</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">;</span>

		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;queue_cap_snap %p cap_snap %p queuing under %p %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">,</span> <span class="n">snapc</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">dirty</span><span class="p">));</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">ci_item</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flushing_item</span><span class="p">);</span>

		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">follows</span> <span class="o">=</span> <span class="n">snapc</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="n">dirty</span><span class="p">;</span>

		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>
		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">;</span>
		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_XATTR_EXCL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__ceph_build_xattrs_blob</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
			<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">xattr_blob</span> <span class="o">=</span>
				<span class="n">ceph_buffer_get</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="p">);</span>
			<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">xattr_version</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">version</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">xattr_blob</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">xattr_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* dirty page count moved from _head to this cap_snap;</span>
<span class="cm">		   all subsequent writes page dirties occur _after_ this</span>
<span class="cm">		   snapshot. */</span>
		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span><span class="p">;</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">snapc</span><span class="p">;</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span> <span class="o">=</span>
			<span class="n">ceph_get_snap_context</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; new snapc is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">ci_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;queue_cap_snap %p cap_snap %p snapc %p&quot;</span>
			     <span class="s">&quot; seq %llu used WR, now pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
			     <span class="n">capsnap</span><span class="p">,</span> <span class="n">snapc</span><span class="p">,</span> <span class="n">snapc</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
			<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* note mtime, size NOW. */</span>
			<span class="n">__ceph_finish_cap_snap</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;queue_cap_snap %p nothing dirty|writing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">capsnap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finalize the size, mtime for a cap_snap.. that is, settle on final values</span>
<span class="cm"> * to be used for the snapshot, to be flushed back to the mds.</span>
<span class="cm"> *</span>
<span class="cm"> * If capsnap can now be flushed, add to snap_flush list, and return 1.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold i_ceph_lock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ceph_finish_cap_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">writing</span><span class="p">);</span>
	<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">;</span>
	<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">;</span>
	<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">time_warp_seq</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu &quot;</span>
		     <span class="s">&quot;still has %d dirty pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">,</span>
		     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">),</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
		     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span>
	     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">),</span>
	     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_flush_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* caller may want to ceph_flush_snaps */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue cap_snaps for snap writeback for this realm and its children.</span>
<span class="cm"> * Called under snap_rwsem, so realm topology won&#39;t change.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_realm_cap_snaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">lastinode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;queue_realm_cap_snaps %p %llx inodes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps</span><span class="p">,</span>
			    <span class="n">i_snap_realm_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastinode</span><span class="p">)</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">lastinode</span><span class="p">);</span>
		<span class="n">lastinode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
		<span class="n">ceph_queue_cap_snap</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastinode</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">lastinode</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">child_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;queue_realm_cap_snaps %p %llx queue child %p %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">dirty_item</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">dirty_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">dirty_item</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">dirty_item</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;queue_realm_cap_snaps %p %llx done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse and apply a snapblob &quot;snap trace&quot; from the MDS.  This specifies</span>
<span class="cm"> * the snap realm parameters from a given realm and all of its ancestors,</span>
<span class="cm"> * up to the root.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold snap_rwsem for write.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_update_snap_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="n">bool</span> <span class="n">deletion</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_snap_realm</span> <span class="o">*</span><span class="n">ri</span><span class="p">;</span>    <span class="cm">/* encoded */</span>
	<span class="n">__le64</span> <span class="o">*</span><span class="n">snaps</span><span class="p">;</span>                     <span class="cm">/* encoded */</span>
	<span class="n">__le64</span> <span class="o">*</span><span class="n">prior_parent_snaps</span><span class="p">;</span>        <span class="cm">/* encoded */</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">invalidate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dirty_realms</span><span class="p">);</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;update_snap_trace deletion=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">deletion</span><span class="p">);</span>
<span class="nl">more:</span>
	<span class="n">ceph_decode_need</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ri</span><span class="p">),</span> <span class="n">bad</span><span class="p">);</span>
	<span class="n">ri</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ri</span><span class="p">);</span>
	<span class="n">ceph_decode_need</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">)</span> <span class="o">+</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">num_prior_parent_snaps</span><span class="p">)),</span> <span class="n">bad</span><span class="p">);</span>
	<span class="n">snaps</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">);</span>
	<span class="n">prior_parent_snaps</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">num_prior_parent_snaps</span><span class="p">);</span>

	<span class="n">realm</span> <span class="o">=</span> <span class="n">ceph_lookup_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">realm</span> <span class="o">=</span> <span class="n">ceph_create_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">realm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">realm</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* ensure the parent is correct */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">adjust_snap_realm_parent</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">invalidate</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;update_snap_trace updating %llx %p %lld -&gt; %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">));</span>
		<span class="cm">/* update realm parameters, snap lists */</span>
		<span class="n">realm</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
		<span class="n">realm</span><span class="o">-&gt;</span><span class="n">created</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">created</span><span class="p">);</span>
		<span class="n">realm</span><span class="o">-&gt;</span><span class="n">parent_since</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">parent_since</span><span class="p">);</span>

		<span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_snaps</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dup_array</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">snaps</span><span class="p">,</span> <span class="n">snaps</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_snaps</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_prior_parent_snaps</span> <span class="o">=</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">num_prior_parent_snaps</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dup_array</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">prior_parent_snaps</span><span class="p">,</span> <span class="n">prior_parent_snaps</span><span class="p">,</span>
				<span class="n">realm</span><span class="o">-&gt;</span><span class="n">num_prior_parent_snaps</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="cm">/* queue realm for cap_snap creation */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">dirty_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirty_realms</span><span class="p">);</span>

		<span class="n">invalidate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;update_snap_trace %llx %p seq %lld new</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
		<span class="n">invalidate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;update_snap_trace %llx %p seq %lld unchanged</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;done with %llx %p, invalidated=%d, %p %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span>
	     <span class="n">realm</span><span class="p">,</span> <span class="n">invalidate</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">more</span><span class="p">;</span>

	<span class="cm">/* invalidate when we reach the _end_ (root) of the trace */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">invalidate</span><span class="p">)</span>
		<span class="n">rebuild_snap_realms</span><span class="p">(</span><span class="n">realm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue cap snaps _after_ we&#39;ve built the new snap contexts,</span>
<span class="cm">	 * so that i_head_snapc can be set appropriately.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirty_realms</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">realm</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirty_realms</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_snap_realm</span><span class="p">,</span>
					 <span class="n">dirty_item</span><span class="p">);</span>
		<span class="n">queue_realm_cap_snaps</span><span class="p">(</span><span class="n">realm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">__cleanup_empty_realms</span><span class="p">(</span><span class="n">mdsc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;update_snap_trace error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Send any cap_snaps that are queued for flush.  Try to carry</span>
<span class="cm"> * s_mutex across multiple snap flushes to avoid locking overhead.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller holds no locks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_snaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;flush_snaps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ci</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_list</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_inode_info</span><span class="p">,</span> <span class="n">i_snap_flush_item</span><span class="p">);</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="n">__ceph_flush_snaps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
		<span class="n">ceph_put_mds_session</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;flush_snaps done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Handle a snap notification from the MDS.</span>
<span class="cm"> *</span>
<span class="cm"> * This can take two basic forms: the simplest is just a snap creation</span>
<span class="cm"> * or deletion notification on an existing realm.  This should update the</span>
<span class="cm"> * realm and its children.</span>
<span class="cm"> *</span>
<span class="cm"> * The more difficult case is realm creation, due to snap creation at a</span>
<span class="cm"> * new point in the file hierarchy, or due to a rename that moves a file or</span>
<span class="cm"> * directory into another realm.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_handle_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ceph_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">fsc</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">split</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trace_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_snap_head</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_split_inos</span><span class="p">,</span> <span class="n">num_split_realms</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="o">*</span><span class="n">split_inos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">split_realms</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked_rwsem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* decode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
	<span class="n">split</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">split</span><span class="p">);</span>   <span class="cm">/* non-zero if we are splitting an</span>
<span class="cm">					  * existing realm */</span>
	<span class="n">num_split_inos</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">num_split_inos</span><span class="p">);</span>
	<span class="n">num_split_realms</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">num_split_realms</span><span class="p">);</span>
	<span class="n">trace_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">trace_len</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">);</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_snap from mds%d op %s split %llx tracelen %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span>
	     <span class="n">ceph_snap_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">split</span><span class="p">,</span> <span class="n">trace_len</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">s_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
	<span class="n">locked_rwsem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">CEPH_SNAP_OP_SPLIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_mds_snap_realm</span> <span class="o">*</span><span class="n">ri</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * A &quot;split&quot; breaks part of an existing realm off into</span>
<span class="cm">		 * a new realm.  The MDS provides a list of inodes</span>
<span class="cm">		 * (with caps) and child realms that belong to the new</span>
<span class="cm">		 * child.</span>
<span class="cm">		 */</span>
		<span class="n">split_inos</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_split_inos</span><span class="p">;</span>
		<span class="n">split_realms</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_split_realms</span><span class="p">;</span>
		<span class="n">ceph_decode_need</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ri</span><span class="p">),</span> <span class="n">bad</span><span class="p">);</span>
		<span class="cm">/* we will peek at realm info here, but will _not_</span>
<span class="cm">		 * advance p, as the realm update will occur below in</span>
<span class="cm">		 * ceph_update_snap_trace. */</span>
		<span class="n">ri</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

		<span class="n">realm</span> <span class="o">=</span> <span class="n">ceph_lookup_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">split</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">realm</span> <span class="o">=</span> <span class="n">ceph_create_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">split</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">realm</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ceph_get_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>

		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;splitting snap_realm %llx %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_split_inos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">split_inos</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
				<span class="p">.</span><span class="n">snap</span> <span class="o">=</span> <span class="n">CEPH_NOSNAP</span><span class="p">,</span>
			<span class="p">};</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ceph_find_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">vino</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">oldrealm</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">skip_inode</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this inode belongs to a realm that was</span>
<span class="cm">			 * created after our new realm, we experienced</span>
<span class="cm">			 * a race (due to another split notifications</span>
<span class="cm">			 * arriving from a different MDS).  So skip</span>
<span class="cm">			 * this inode.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="o">-&gt;</span><span class="n">created</span> <span class="o">&gt;</span>
			    <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">created</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot; leaving %p in newer realm %llx %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">inode</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span>
				     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">skip_inode</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; will move %p to split realm %llx %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">inode</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Move the inode to the new realm</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm_item</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm_item</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps</span><span class="p">);</span>
			<span class="n">oldrealm</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="p">;</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span> <span class="o">=</span> <span class="n">realm</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

			<span class="n">ceph_get_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
			<span class="n">ceph_put_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">oldrealm</span><span class="p">);</span>

			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="nl">skip_inode:</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* we may have taken some of the old realm&#39;s children. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_split_realms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span>
				<span class="n">ceph_lookup_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span>
					   <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">split_realms</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">adjust_snap_realm_parent</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">realm</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * update using the provided snap trace. if we are deleting a</span>
<span class="cm">	 * snap, we can avoid queueing cap_snaps.</span>
<span class="cm">	 */</span>
	<span class="n">ceph_update_snap_trace</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span>
			       <span class="n">op</span> <span class="o">==</span> <span class="n">CEPH_SNAP_OP_DESTROY</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">CEPH_SNAP_OP_SPLIT</span><span class="p">)</span>
		<span class="cm">/* we took a reference when we created the realm, above */</span>
		<span class="n">ceph_put_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>

	<span class="n">__cleanup_empty_realms</span><span class="p">(</span><span class="n">mdsc</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>

	<span class="n">flush_snaps</span><span class="p">(</span><span class="n">mdsc</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;corrupt snap message from mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mds</span><span class="p">);</span>
	<span class="n">ceph_msg_dump</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked_rwsem</span><span class="p">)</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
