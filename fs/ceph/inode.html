<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ceph › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/ceph/ceph_debug.h&gt;</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>

<span class="cp">#include &quot;super.h&quot;</span>
<span class="cp">#include &quot;mds_client.h&quot;</span>
<span class="cp">#include &lt;linux/ceph/decode.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Ceph inode operations</span>
<span class="cm"> *</span>
<span class="cm"> * Implement basic inode helpers (get, alloc) and inode ops (getattr,</span>
<span class="cm"> * setattr, etc.), xattr helpers, and helpers for assimilating</span>
<span class="cm"> * metadata returned by the MDS into our cache.</span>
<span class="cm"> *</span>
<span class="cm"> * Also define helpers for doing asynchronous writeback, invalidation,</span>
<span class="cm"> * and truncation for the benefit of those who can&#39;t afford to block</span>
<span class="cm"> * (typically because they are in the message handler path).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ceph_symlink_iops</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ceph_invalidate_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ceph_writeback_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ceph_vmtruncate_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * find or create an inode, given the ceph ino number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ceph_set_ino_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_vino</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_vino</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">ceph_vino_to_ino</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_vino</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ceph_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ceph_vino_to_ino</span><span class="p">(</span><span class="n">vino</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget5_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ceph_ino_compare</span><span class="p">,</span> <span class="n">ceph_set_ino_cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_inode created new inode %p %llx.%llx ino %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_inode on %lu=%llx.%llx got %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">,</span>
	     <span class="n">vino</span><span class="p">.</span><span class="n">snap</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get/constuct snapdir inode for a given directory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ceph_get_snapdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ceph_ino</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span>
		<span class="p">.</span><span class="n">snap</span> <span class="o">=</span> <span class="n">CEPH_SNAPDIR</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ceph_get_inode</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">vino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_dir_iops</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_dir_fops</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_caps</span> <span class="o">=</span> <span class="n">CEPH_CAP_PIN</span><span class="p">;</span> <span class="cm">/* so we can open */</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ceph_file_iops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">permission</span> <span class="o">=</span> <span class="n">ceph_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span> <span class="o">=</span> <span class="n">ceph_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span> <span class="o">=</span> <span class="n">ceph_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span> <span class="o">=</span> <span class="n">ceph_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span> <span class="o">=</span> <span class="n">ceph_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span> <span class="o">=</span> <span class="n">ceph_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span> <span class="o">=</span> <span class="n">ceph_removexattr</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * We use a &#39;frag tree&#39; to keep track of the MDS&#39;s directory fragments</span>
<span class="cm"> * for a given inode (usually there is just a single fragment).  We</span>
<span class="cm"> * need to know when a child frag is delegated to a new MDS, or when</span>
<span class="cm"> * it is flagged as replicated, so we can direct our requests</span>
<span class="cm"> * accordingly.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * find/create a frag in the tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="nf">__get_or_create_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
						    <span class="n">u32</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_inode_frag</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">ceph_frag_compare</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">frag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">frag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">frag</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">frag</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;__get_or_create_frag ENOMEM on %p %llx.%llx &quot;</span>
		       <span class="s">&quot;frag %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
		       <span class="n">ceph_vinop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">),</span> <span class="n">f</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">frag</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">split_by</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">mds</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">ndist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree</span><span class="p">);</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_or_create_frag added %llx.%llx frag %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ceph_vinop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">),</span> <span class="n">f</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">frag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find a specific frag @f</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="nf">__ceph_find_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span>
			<span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_inode_frag</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ceph_frag_compare</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">frag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">frag</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Choose frag containing the given value @v.  If @pfrag is</span>
<span class="cm"> * specified, copy the frag delegation info to the caller if</span>
<span class="cm"> * it is present.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">ceph_choose_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">pfrag</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="o">*</span><span class="n">found</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ceph_frag_make</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nway</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
		<span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree_mutex</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ceph_frag_contains_value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">__ceph_find_frag</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* t is a leaf */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">split_by</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pfrag</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">pfrag</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pfrag</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
				<span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* choose child */</span>
		<span class="n">nway</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">split_by</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;choose_frag(%x) %x splits by %d (%d ways)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
		     <span class="n">frag</span><span class="o">-&gt;</span><span class="n">split_by</span><span class="p">,</span> <span class="n">nway</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nway</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">ceph_frag_make_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">split_by</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ceph_frag_contains_value</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">t</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nway</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;choose_frag(%x) = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process dirfrag (delegation) info from the mds.  Include leaf</span>
<span class="cm"> * fragment in tree ONLY if ndist &gt; 0.  Otherwise, only</span>
<span class="cm"> * branches/splits are included in i_fragtree)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ceph_fill_dirfrag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_mds_reply_dirfrag</span> <span class="o">*</span><span class="n">dirinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dirinfo</span><span class="o">-&gt;</span><span class="n">frag</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dirinfo</span><span class="o">-&gt;</span><span class="n">auth</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ndist</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dirinfo</span><span class="o">-&gt;</span><span class="n">ndist</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no delegation info needed. */</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">__ceph_find_frag</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">split_by</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* tree leaf, remove */</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_dirfrag removed %llx.%llx frag %x&quot;</span>
			     <span class="s">&quot; (no ref)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">id</span><span class="p">);</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* tree branch, keep and clear */</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_dirfrag cleared %llx.%llx frag %x&quot;</span>
			     <span class="s">&quot; referral</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">id</span><span class="p">);</span>
			<span class="n">frag</span><span class="o">-&gt;</span><span class="n">mds</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">frag</span><span class="o">-&gt;</span><span class="n">ndist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* find/add this frag to store mds delegation info */</span>
	<span class="n">frag</span> <span class="o">=</span> <span class="n">__get_or_create_frag</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* this is not the end of the world; we can continue</span>
<span class="cm">		   with bad/inaccurate delegation info */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dirinfo</span><span class="o">-&gt;</span><span class="n">frag</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">mds</span> <span class="o">=</span> <span class="n">mds</span><span class="p">;</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">ndist</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">ndist</span><span class="p">,</span> <span class="n">CEPH_MAX_DIRFRAG_REP</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ndist</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dirinfo</span><span class="o">-&gt;</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_dirfrag %llx.%llx frag %x ndist=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">frag</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ndist</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * initialize a newly allocated inode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ceph_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ci</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ceph_inode_cachep</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;alloc_inode %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_release_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_symlink</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dir_layout</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dir_layout</span><span class="p">));</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree_mutex</span><span class="p">);</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">prealloc_blob</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">names_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">vals_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">index_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_item</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_last_tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_tid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_tid</span><span class="p">));</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mseq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_issued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_caps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CEPH_FILE_MODE_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_nr_by_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_reported_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_requested_max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_pin_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rd_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wr_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_shared_gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_unsafe_writes</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_unsafe_dirops</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_unsafe_lock</span><span class="p">);</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm_item</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_flush_item</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_work</span><span class="p">,</span> <span class="n">ceph_writeback_work</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_pg_inv_work</span><span class="p">,</span> <span class="n">ceph_invalidate_work</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_vmtruncate_work</span><span class="p">,</span> <span class="n">ceph_vmtruncate_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ceph_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ceph_inode_cachep</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;destroy_inode %p ino %llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

	<span class="n">ceph_queue_caps_release</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we may still have a snap_realm reference if there are stray</span>
<span class="cm">	 * caps in i_cap_exporting_issued or i_snap_caps.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span>
			<span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="p">;</span>

		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; dropping residual ref to snap realm %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm_item</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
		<span class="n">ceph_put_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_symlink</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_inode_frag</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">__ceph_destroy_xattrs</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="p">)</span>
		<span class="n">ceph_buffer_put</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">prealloc_blob</span><span class="p">)</span>
		<span class="n">ceph_buffer_put</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">prealloc_blob</span><span class="p">);</span>

	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">ceph_i_callback</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Helpers to fill in size, ctime, mtime, and atime.  We have to be</span>
<span class="cm"> * careful because either the client or MDS may have more up to date</span>
<span class="cm"> * info, depending on which capabilities are held, and whether</span>
<span class="cm"> * time_warp_seq or truncate_seq have increased.  (Ordinarily, mtime</span>
<span class="cm"> * and size are monotonically increasing, except when utimes() or</span>
<span class="cm"> * truncate() increments the corresponding _seq values.)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_fill_file_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">issued</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">truncate_seq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">truncate_size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">queue_trunc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ceph_seq_cmp</span><span class="p">(</span><span class="n">truncate_seq</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">truncate_seq</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_seq</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;size %lld -&gt; %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_reported_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">truncate_seq</span> <span class="o">!=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;truncate_seq %u -&gt; %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_seq</span><span class="p">,</span> <span class="n">truncate_seq</span><span class="p">);</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_seq</span> <span class="o">=</span> <span class="n">truncate_seq</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we hold relevant caps, or in the case where we&#39;re</span>
<span class="cm">			 * not the only client referencing this file and we</span>
<span class="cm">			 * don&#39;t hold those caps, then we need to check whether</span>
<span class="cm">			 * the file is either opened or mmaped</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_FILE_CACHE</span><span class="o">|</span><span class="n">CEPH_CAP_FILE_RD</span><span class="o">|</span>
				       <span class="n">CEPH_CAP_FILE_WR</span><span class="o">|</span><span class="n">CEPH_CAP_FILE_BUFFER</span><span class="o">|</span>
				       <span class="n">CEPH_CAP_FILE_EXCL</span><span class="o">|</span>
				       <span class="n">CEPH_CAP_FILE_LAZYIO</span><span class="p">))</span> <span class="o">||</span>
			    <span class="n">mapping_mapped</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">__ceph_caps_file_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_pending</span><span class="o">++</span><span class="p">;</span>
				<span class="n">queue_trunc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceph_seq_cmp</span><span class="p">(</span><span class="n">truncate_seq</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_seq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_size</span> <span class="o">!=</span> <span class="n">truncate_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;truncate_size %lld -&gt; %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_size</span><span class="p">,</span>
		     <span class="n">truncate_size</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_size</span> <span class="o">=</span> <span class="n">truncate_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">queue_trunc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_fill_file_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">issued</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">time_warp_seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ctime</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">mtime</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">atime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">warn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_FILE_EXCL</span><span class="o">|</span>
		      <span class="n">CEPH_CAP_FILE_WR</span><span class="o">|</span>
		      <span class="n">CEPH_CAP_FILE_BUFFER</span><span class="o">|</span>
		      <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="o">|</span>
		      <span class="n">CEPH_CAP_XATTR_EXCL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timespec_compare</span><span class="p">(</span><span class="n">ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;ctime %ld.%09ld -&gt; %ld.%09ld inc w/ cap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
			     <span class="n">ctime</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">ctime</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="o">*</span><span class="n">ctime</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ceph_seq_cmp</span><span class="p">(</span><span class="n">time_warp_seq</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* the MDS did a utimes() */</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;mtime %ld.%09ld -&gt; %ld.%09ld &quot;</span>
			     <span class="s">&quot;tw %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
			     <span class="n">mtime</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">mtime</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">,</span>
			     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">time_warp_seq</span><span class="p">);</span>

			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="o">*</span><span class="n">mtime</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="o">*</span><span class="n">atime</span><span class="p">;</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span> <span class="o">=</span> <span class="n">time_warp_seq</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_warp_seq</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* nobody did utimes(); take the max */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timespec_compare</span><span class="p">(</span><span class="n">mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;mtime %ld.%09ld -&gt; %ld.%09ld inc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
				     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
				     <span class="n">mtime</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">mtime</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">);</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="o">*</span><span class="n">mtime</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timespec_compare</span><span class="p">(</span><span class="n">atime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;atime %ld.%09ld -&gt; %ld.%09ld inc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
				     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
				     <span class="n">atime</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">atime</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">);</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="o">*</span><span class="n">atime</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we did a utimes(); ignore mds values */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">warn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* we have no write|excl caps; whatever the MDS says is true */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ceph_seq_cmp</span><span class="p">(</span><span class="n">time_warp_seq</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="o">*</span><span class="n">ctime</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="o">*</span><span class="n">mtime</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="o">*</span><span class="n">atime</span><span class="p">;</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span> <span class="o">=</span> <span class="n">time_warp_seq</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">warn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">warn</span><span class="p">)</span> <span class="cm">/* time_warp_seq shouldn&#39;t go backwards */</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;%p mds time_warp_seq %llu &lt; %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">time_warp_seq</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Populate an inode based on info from mds.  May be called on new or</span>
<span class="cm"> * existing inodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ceph_mds_reply_info_in</span> <span class="o">*</span><span class="n">iinfo</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ceph_mds_reply_dirfrag</span> <span class="o">*</span><span class="n">dirinfo</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttl_from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap_fmode</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="o">*</span><span class="n">caps_reservation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_reply_inode</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">issued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">implemented</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">updating_inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">mtime</span><span class="p">,</span> <span class="n">atime</span><span class="p">,</span> <span class="n">ctime</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nsplits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_buffer</span> <span class="o">*</span><span class="n">xattr_blob</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queue_trunc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_inode %p ino %llx.%llx v %llu had %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">),</span>
	     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * prealloc xattr data, if it looks like we&#39;ll need it.  only</span>
<span class="cm">	 * if len &gt; 4 (meaning there are actually xattrs; the first 4</span>
<span class="cm">	 * bytes are the xattr count).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">xattr_len</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xattr_blob</span> <span class="o">=</span> <span class="n">ceph_buffer_new</span><span class="p">(</span><span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">xattr_len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xattr_blob</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fill_inode ENOMEM xattr blob %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">xattr_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * provided version will be odd if inode value is projected,</span>
<span class="cm">	 * even if stable.  skip the update if we have newer stable</span>
<span class="cm">	 * info (ours&gt;=theirs, e.g. due to racing mds replies), unless</span>
<span class="cm">	 * we are getting projected (unstable) info (in which case the</span>
<span class="cm">	 * version is odd, and we want ours&gt;theirs).</span>
<span class="cm">	 *   us   them</span>
<span class="cm">	 *   2    2     skip</span>
<span class="cm">	 *   3    2     skip</span>
<span class="cm">	 *   3    3     update</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>
	
	<span class="n">updating_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">issued</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">implemented</span><span class="p">);</span>
	<span class="n">issued</span> <span class="o">|=</span> <span class="n">implemented</span> <span class="o">|</span> <span class="n">__ceph_caps_dirty</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>

	<span class="cm">/* update inode */</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="o">++</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;%p mode 0%o uid.gid %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
		     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_LINK_EXCL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">));</span>

	<span class="cm">/* be careful with mtime, atime, size */</span>
	<span class="n">ceph_decode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">);</span>
	<span class="n">ceph_decode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">);</span>
	<span class="n">ceph_decode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">);</span>
	<span class="n">queue_trunc</span> <span class="o">=</span> <span class="n">ceph_fill_file_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">issued</span><span class="p">,</span>
					  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">truncate_seq</span><span class="p">),</span>
					  <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">truncate_size</span><span class="p">),</span>
					  <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
	<span class="n">ceph_fill_file_time</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">issued</span><span class="p">,</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">time_warp_seq</span><span class="p">),</span>
			    <span class="o">&amp;</span><span class="n">ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atime</span><span class="p">);</span>

	<span class="cm">/* only update max_size on auth cap */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FLAG_AUTH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">!=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;max_size %lld -&gt; %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span><span class="p">,</span>
		     <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">));</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_layout</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">.</span><span class="n">fl_stripe_unit</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* xattrs */</span>
	<span class="cm">/* note that if i_xattrs.len &lt;= 4, i_xattrs.data will still be NULL. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_XATTR_EXCL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_version</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">version</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="p">)</span>
			<span class="n">ceph_buffer_put</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span> <span class="o">=</span> <span class="n">xattr_blob</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xattr_blob</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="o">-&gt;</span><span class="n">vec</span><span class="p">.</span><span class="n">iov_base</span><span class="p">,</span>
			       <span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">xattr_data</span><span class="p">,</span> <span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">xattr_len</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xattr_version</span><span class="p">);</span>
		<span class="n">xattr_blob</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_aops</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_file_iops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_file_iops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_file_fops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_symlink_iops</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_symlink</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">symlen</span> <span class="o">=</span> <span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">symlink_len</span><span class="p">;</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">symlen</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">sym</span> <span class="o">=</span> <span class="n">kstrndup</span><span class="p">(</span><span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">symlink</span><span class="p">,</span> <span class="n">symlen</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_symlink</span><span class="p">)</span>
				<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_symlink</span> <span class="o">=</span> <span class="n">sym</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">sym</span><span class="p">);</span> <span class="cm">/* lost a race */</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_dir_iops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ceph_dir_fops</span><span class="p">;</span>

		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dir_layout</span> <span class="o">=</span> <span class="n">iinfo</span><span class="o">-&gt;</span><span class="n">dir_layout</span><span class="p">;</span>

		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_files</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_subdirs</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">subdirs</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rbytes</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rbytes</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rfiles</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rfiles</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rsubdirs</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rsubdirs</span><span class="p">);</span>
		<span class="n">ceph_decode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rctime</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fill_inode %llx.%llx BAD mode 0%o</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">no_change:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="cm">/* queue truncate if we saw i_size decrease */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_trunc</span><span class="p">)</span>
		<span class="n">ceph_queue_vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/* populate frag tree */</span>
	<span class="cm">/* FIXME: move me up, if/when version reflects fragtree changes */</span>
	<span class="n">nsplits</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">.</span><span class="n">nsplits</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsplits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">.</span><span class="n">splits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">frag</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="n">__get_or_create_frag</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">split_by</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">.</span><span class="n">splits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">by</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; frag %x split by %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">frag</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">split_by</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_fragtree_mutex</span><span class="p">);</span>

	<span class="cm">/* were we issued a capability? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">caps</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ceph_snap</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">CEPH_NOSNAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ceph_add_cap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span>
				     <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">cap_id</span><span class="p">),</span>
				     <span class="n">cap_fmode</span><span class="p">,</span>
				     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">caps</span><span class="p">),</span>
				     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">wanted</span><span class="p">),</span>
				     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">seq</span><span class="p">),</span>
				     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">mseq</span><span class="p">),</span>
				     <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">realm</span><span class="p">),</span>
				     <span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span>
				     <span class="n">caps_reservation</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; %p got snap_caps %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">caps</span><span class="p">)));</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_caps</span> <span class="o">|=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">caps</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cap_fmode</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">__ceph_get_fmode</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">cap_fmode</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cap_fmode</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;mds issued no caps on %llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="n">__ceph_get_fmode</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">cap_fmode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set dir completion flag? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">updating_inode</span> <span class="o">&amp;&amp;</span>                 <span class="cm">/* didn&#39;t jump to no_change */</span>
	    <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_files</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_subdirs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ceph_snap</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">CEPH_NOSNAP</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">caps</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_SHARED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ceph_dir_test_complete</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; marking %p complete (empty)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ceph_dir_set_complete</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_offset</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* update delegation info? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirinfo</span><span class="p">)</span>
		<span class="n">ceph_fill_dirfrag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dirinfo</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xattr_blob</span><span class="p">)</span>
		<span class="n">ceph_buffer_put</span><span class="p">(</span><span class="n">xattr_blob</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * caller should hold session s_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_dentry_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_mds_reply_lease</span> <span class="o">*</span><span class="n">lease</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_dentry_info</span> <span class="o">*</span><span class="n">di</span> <span class="o">=</span> <span class="n">ceph_dentry</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">long</span> <span class="kt">unsigned</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lease</span><span class="o">-&gt;</span><span class="n">duration_ms</span><span class="p">);</span>
	<span class="kt">long</span> <span class="kt">unsigned</span> <span class="n">ttl</span> <span class="o">=</span> <span class="n">from_time</span> <span class="o">+</span> <span class="p">(</span><span class="n">duration</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">unsigned</span> <span class="n">half_ttl</span> <span class="o">=</span> <span class="n">from_time</span> <span class="o">+</span> <span class="p">(</span><span class="n">duration</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>

	<span class="cm">/* only track leases on regular dentries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ceph_dentry_ops</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;update_dentry_lease %p duration %lu ms ttl %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dentry</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">ttl</span><span class="p">);</span>

	<span class="cm">/* make lease_rdcache_gen match directory */</span>
	<span class="n">dir</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_shared_gen</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_shared_gen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">duration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_gen</span> <span class="o">==</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_gen</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_before</span><span class="p">(</span><span class="n">ttl</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_time</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>  <span class="cm">/* we already have a newer lease. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_session</span> <span class="o">&amp;&amp;</span> <span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_session</span> <span class="o">!=</span> <span class="n">session</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">ceph_dentry_lru_touch</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_session</span><span class="p">)</span>
		<span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_session</span> <span class="o">=</span> <span class="n">ceph_get_mds_session</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_gen</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_gen</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_seq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lease</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_renew_after</span> <span class="o">=</span> <span class="n">half_ttl</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_renew_from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_time</span> <span class="o">=</span> <span class="n">ttl</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set dentry&#39;s directory position based on the current dir&#39;s max, and</span>
<span class="cm"> * order it in d_subdirs, so that dcache_readdir behaves.</span>
<span class="cm"> *</span>
<span class="cm"> * Always called under directory&#39;s i_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ceph_set_dentry_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_dentry_info</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">di</span> <span class="o">=</span> <span class="n">ceph_dentry</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ceph_dir_test_complete</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_max_offset</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;set_dentry_offset %p %lld (%p %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">di</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
	     <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * splice a dentry to an inode.</span>
<span class="cm"> * caller must hold directory i_mutex for this to be safe.</span>
<span class="cm"> *</span>
<span class="cm"> * we will only rehash the resulting dentry if @prehash is</span>
<span class="cm"> * true; @prehash will be set to false (for the benefit of</span>
<span class="cm"> * the caller) if we fail.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">splice_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="o">*</span><span class="n">prehash</span><span class="p">,</span> <span class="n">bool</span> <span class="n">set_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">realdn</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="cm">/* dn must be unhashed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span>
		<span class="n">d_drop</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
	<span class="n">realdn</span> <span class="o">=</span> <span class="n">d_materialise_unique</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">realdn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;splice_dentry error %ld %p inode %p ino %llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">realdn</span><span class="p">),</span> <span class="n">dn</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">in</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prehash</span><span class="p">)</span>
			<span class="o">*</span><span class="n">prehash</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* don&#39;t rehash on error */</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">realdn</span><span class="p">;</span> <span class="cm">/* note realdn contains the error */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">realdn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;dn %p (%d) spliced with %p (%d) &quot;</span>
		     <span class="s">&quot;inode %p ino %llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dn</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">,</span>
		     <span class="n">realdn</span><span class="p">,</span> <span class="n">realdn</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">,</span>
		     <span class="n">realdn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">realdn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">));</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">realdn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ceph_dentry</span><span class="p">(</span><span class="n">dn</span><span class="p">));</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;dn %p attached to %p ino %llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dn</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">prehash</span> <span class="o">||</span> <span class="o">*</span><span class="n">prehash</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">d_unhashed</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span>
		<span class="n">d_rehash</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_offset</span><span class="p">)</span>
		<span class="n">ceph_set_dentry_offset</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">dn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Incorporate results into the local cache.  This is either just</span>
<span class="cm"> * one inode, or a directory, dentry, and possibly linked-to inode (e.g.,</span>
<span class="cm"> * after a lookup).</span>
<span class="cm"> *</span>
<span class="cm"> * A reply may contain</span>
<span class="cm"> *         a directory inode along with a dentry.</span>
<span class="cm"> *  and/or a target inode</span>
<span class="cm"> *</span>
<span class="cm"> * Called with snap_rwsem (read).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_fill_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_reply_info_parsed</span> <span class="o">*</span><span class="n">rinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_reply_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_reply_inode</span> <span class="o">*</span><span class="n">ininfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="n">fsc</span> <span class="o">=</span> <span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_trace %p is_dentry %d is_target %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span>
	     <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_dentry</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_target</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/*</span>
<span class="c">	 * Debugging hook:</span>
<span class="c">	 *</span>
<span class="c">	 * If we resend completed ops to a recovering mds, we get no</span>
<span class="c">	 * trace.  Since that is very rare, pretend this is the case</span>
<span class="c">	 * to ensure the &#39;no trace&#39; handlers in the callers behave.</span>
<span class="c">	 *</span>
<span class="c">	 * Fill in inodes unconditionally to avoid breaking cap</span>
<span class="c">	 * invariants.</span>
<span class="c">	 */</span>
<span class="c">	if (rinfo-&gt;head-&gt;op &amp; CEPH_MDS_OP_WRITE) {</span>
<span class="c">		pr_info(&quot;fill_trace faking empty trace on %lld %s\n&quot;,</span>
<span class="c">			req-&gt;r_tid, ceph_mds_op_name(rinfo-&gt;head-&gt;op));</span>
<span class="c">		if (rinfo-&gt;head-&gt;is_dentry) {</span>
<span class="c">			rinfo-&gt;head-&gt;is_dentry = 0;</span>
<span class="c">			err = fill_inode(req-&gt;r_locked_dir,</span>
<span class="c">					 &amp;rinfo-&gt;diri, rinfo-&gt;dirfrag,</span>
<span class="c">					 session, req-&gt;r_request_started, -1);</span>
<span class="c">		}</span>
<span class="c">		if (rinfo-&gt;head-&gt;is_target) {</span>
<span class="c">			rinfo-&gt;head-&gt;is_target = 0;</span>
<span class="c">			ininfo = rinfo-&gt;targeti.in;</span>
<span class="c">			vino.ino = le64_to_cpu(ininfo-&gt;ino);</span>
<span class="c">			vino.snap = le64_to_cpu(ininfo-&gt;snapid);</span>
<span class="c">			in = ceph_get_inode(sb, vino);</span>
<span class="c">			err = fill_inode(in, &amp;rinfo-&gt;targeti, NULL,</span>
<span class="c">					 session, req-&gt;r_request_started,</span>
<span class="c">					 req-&gt;r_fmode);</span>
<span class="c">			iput(in);</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_target</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_trace reply is empty!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_locked_dir</span><span class="p">)</span>
			<span class="n">ceph_invalidate_dir_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_locked_dir</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">fill_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">diri</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dirfrag</span><span class="p">,</span>
				 <span class="n">session</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_request_started</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_caps_reservation</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * ignore null lease/binding on snapdir ENOENT, or else we</span>
<span class="cm">	 * will have trouble splicing in the virtual snapdir later</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_dentry</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_aborted</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_target</span> <span class="o">||</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					       <span class="n">fsc</span><span class="o">-&gt;</span><span class="n">mount_options</span><span class="o">-&gt;</span><span class="n">snapdir_name</span><span class="p">,</span>
					       <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * lookup link rename   : null -&gt; possibly existing inode</span>
<span class="cm">		 * mknod symlink mkdir  : null -&gt; new inode</span>
<span class="cm">		 * unlink               : linked -&gt; null</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_locked_dir</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_dentry</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">have_dir_cap</span><span class="p">,</span> <span class="n">have_lease</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dn</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ceph_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="o">!=</span>
		       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">diri</span><span class="p">.</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ceph_snap</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="o">!=</span>
		       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">diri</span><span class="p">.</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">snapid</span><span class="p">));</span>

		<span class="cm">/* do we have a lease on the whole dir? */</span>
		<span class="n">have_dir_cap</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">diri</span><span class="p">.</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">caps</span><span class="p">)</span> <span class="o">&amp;</span>
			 <span class="n">CEPH_CAP_FILE_SHARED</span><span class="p">);</span>

		<span class="cm">/* do we have a dn lease? */</span>
		<span class="n">have_lease</span> <span class="o">=</span> <span class="n">have_dir_cap</span> <span class="o">||</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dlease</span><span class="o">-&gt;</span><span class="n">duration_ms</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lease</span><span class="p">)</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_trace  no dentry lease or dir cap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* rename? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span> <span class="o">&amp;&amp;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_op</span> <span class="o">==</span> <span class="n">CEPH_MDS_OP_RENAME</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; src %p &#39;%.*s&#39; dst %p &#39;%.*s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="p">,</span>
			     <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			     <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">dn</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_trace doing d_move %p -&gt; %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>

			<span class="n">d_move</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; src %p &#39;%.*s&#39; dst %p &#39;%.*s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="p">,</span>
			     <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			     <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">dn</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

			<span class="cm">/* ensure target dentry is invalidated, despite</span>
<span class="cm">			   rehashing bug in vfs_rename_dir */</span>
			<span class="n">ceph_invalidate_dentry_lease</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * d_move() puts the renamed dentry at the end of</span>
<span class="cm">			 * d_subdirs.  We need to assign it an appropriate</span>
<span class="cm">			 * directory offset so we can behave when holding</span>
<span class="cm">			 * D_COMPLETE.</span>
<span class="cm">			 */</span>
			<span class="n">ceph_set_dentry_offset</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="p">);</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;dn %p gets new offset %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="p">,</span> 
			     <span class="n">ceph_dentry</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

			<span class="n">dn</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_old_dentry</span><span class="p">;</span>  <span class="cm">/* use old_dentry */</span>
			<span class="n">in</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* null dentry? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_target</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_trace null dentry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;d_delete %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
				<span class="n">d_delete</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;d_instantiate %p NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
				<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">have_lease</span> <span class="o">&amp;&amp;</span> <span class="n">d_unhashed</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span>
					<span class="n">d_rehash</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
				<span class="n">update_dentry_lease</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dlease</span><span class="p">,</span>
						    <span class="n">session</span><span class="p">,</span>
						    <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_request_started</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* attach proper inode */</span>
		<span class="n">ininfo</span> <span class="o">=</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">targeti</span><span class="p">.</span><span class="n">in</span><span class="p">;</span>
		<span class="n">vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ininfo</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="n">vino</span><span class="p">.</span><span class="n">snap</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ininfo</span><span class="o">-&gt;</span><span class="n">snapid</span><span class="p">);</span>
		<span class="n">in</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">in</span> <span class="o">=</span> <span class="n">ceph_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">vino</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">in</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fill_trace bad get_inode &quot;</span>
				       <span class="s">&quot;%llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">,</span> <span class="n">vino</span><span class="p">.</span><span class="n">snap</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
				<span class="n">d_delete</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dn</span> <span class="o">=</span> <span class="n">splice_dentry</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">have_lease</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_dentry</span> <span class="o">=</span> <span class="n">dn</span><span class="p">;</span>  <span class="cm">/* may have spliced */</span>
			<span class="n">ihold</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ceph_ino</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">==</span> <span class="n">vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">&amp;&amp;</span>
			   <span class="n">ceph_snap</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">==</span> <span class="n">vino</span><span class="p">.</span><span class="n">snap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ihold</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; %p links to %p %llx.%llx, not %llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dn</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">ceph_ino</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="n">ceph_snap</span><span class="p">(</span><span class="n">in</span><span class="p">),</span>
			     <span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">,</span> <span class="n">vino</span><span class="p">.</span><span class="n">snap</span><span class="p">);</span>
			<span class="n">have_lease</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">in</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">have_lease</span><span class="p">)</span>
			<span class="n">update_dentry_lease</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dlease</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span>
					    <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_request_started</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; final dn %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_op</span> <span class="o">==</span> <span class="n">CEPH_MDS_OP_LOOKUPSNAP</span> <span class="o">||</span>
		   <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_op</span> <span class="o">==</span> <span class="n">CEPH_MDS_OP_MKSNAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_dentry</span><span class="p">;</span>

		<span class="cm">/* fill out a snapdir LOOKUPSNAP dentry */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dn</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_locked_dir</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ceph_snap</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_locked_dir</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CEPH_SNAPDIR</span><span class="p">);</span>
		<span class="n">ininfo</span> <span class="o">=</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">targeti</span><span class="p">.</span><span class="n">in</span><span class="p">;</span>
		<span class="n">vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ininfo</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="n">vino</span><span class="p">.</span><span class="n">snap</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ininfo</span><span class="o">-&gt;</span><span class="n">snapid</span><span class="p">);</span>
		<span class="n">in</span> <span class="o">=</span> <span class="n">ceph_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">vino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">in</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fill_inode get_inode badness %llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">,</span> <span class="n">vino</span><span class="p">.</span><span class="n">snap</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
			<span class="n">d_delete</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; linking snapped dir %p to dn %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">splice_dentry</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_dentry</span> <span class="o">=</span> <span class="n">dn</span><span class="p">;</span>  <span class="cm">/* may have spliced */</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
		<span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_dentry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* fool notrace handlers */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_target</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">targeti</span><span class="p">.</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="n">vino</span><span class="p">.</span><span class="n">snap</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">targeti</span><span class="p">.</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">snapid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ceph_ino</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">||</span>
		    <span class="n">ceph_snap</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vino</span><span class="p">.</span><span class="n">snap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">in</span> <span class="o">=</span> <span class="n">ceph_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">vino</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">in</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_target_inode</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">fill_inode</span><span class="p">(</span><span class="n">in</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">targeti</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">session</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_request_started</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
				 <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_fmode</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_caps_reservation</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fill_inode badness %p %llx.%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">in</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">in</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fill_trace done err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prepopulate our cache with readdir results, leases, etc.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_readdir_prepopulate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_reply_info_parsed</span> <span class="o">*</span><span class="n">rinfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_reply_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">dname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">snapdir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_request_head</span> <span class="o">*</span><span class="n">rhead</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_request</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">frag</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">readdir</span><span class="p">.</span><span class="n">frag</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_dentry_info</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="o">==</span> <span class="n">CEPH_MDS_OP_LSSNAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snapdir</span> <span class="o">=</span> <span class="n">ceph_get_snapdir</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">d_find_alias</span><span class="p">(</span><span class="n">snapdir</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;readdir_prepopulate %d items under SNAPDIR dn %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_nr</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;readdir_prepopulate %d items under dn %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_nr</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_dir</span><span class="p">)</span>
			<span class="n">ceph_fill_dirfrag</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_dir</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span><span class="p">;</span>

		<span class="n">dname</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_dname</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dname</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_dname_len</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dname</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">dname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dname</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

		<span class="n">vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="n">vino</span><span class="p">.</span><span class="n">snap</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">snapid</span><span class="p">);</span>

<span class="nl">retry_lookup:</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="n">d_lookup</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dname</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;d_lookup on parent=%p name=%.*s got %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">parent</span><span class="p">,</span> <span class="n">dname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dn</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dname</span><span class="p">);</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;d_alloc %p &#39;%.*s&#39; = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
			     <span class="n">dname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;d_alloc badness</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ceph_init_dentry</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">ceph_ino</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">||</span>
			    <span class="n">ceph_snap</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vino</span><span class="p">.</span><span class="n">snap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; dn %p points to wrong inode %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dn</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
			<span class="n">d_delete</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry_lookup</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* reorder parent&#39;s d_subdirs */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">di</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
		<span class="n">di</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ceph_make_fpos</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_readdir_offset</span><span class="p">);</span>

		<span class="cm">/* inode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">in</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">in</span> <span class="o">=</span> <span class="n">ceph_get_inode</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">vino</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">in</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;new_inode badness</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">d_delete</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dn</span> <span class="o">=</span> <span class="n">splice_dentry</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span>
				<span class="n">dn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fill_inode</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span>
			       <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_request_started</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_caps_reservation</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fill_inode badness on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_item</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="p">)</span>
			<span class="n">update_dentry_lease</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">rinfo</span><span class="o">-&gt;</span><span class="n">dir_dlease</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					    <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_session</span><span class="p">,</span>
					    <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_request_started</span><span class="p">);</span>
<span class="nl">next_item:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="p">)</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_did_prepopulate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snapdir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">snapdir</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;readdir_prepopulate done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ceph_inode_set_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;set_size %p %llu -&gt; %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>

	<span class="cm">/* tell the MDS if we are approaching max_size */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_reported_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write back inode data in a worker thread.  (This can&#39;t be done</span>
<span class="cm"> * in the message handler context.)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_queue_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_work</span><span class="p">(</span><span class="n">ceph_inode_to_client</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wb_wq</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_wb_work</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;ceph_queue_writeback %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;ceph_queue_writeback %p failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ceph_writeback_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_inode_info</span><span class="p">,</span>
						  <span class="n">i_wb_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;writeback %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">filemap_fdatawrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * queue an async invalidation</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_queue_invalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_work</span><span class="p">(</span><span class="n">ceph_inode_to_client</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pg_inv_wq</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_pg_inv_work</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;ceph_queue_invalidate %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;ceph_queue_invalidate %p failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate inode pages in a worker thread.  (This can&#39;t be done</span>
<span class="cm"> * in the message handler context.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ceph_invalidate_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_inode_info</span><span class="p">,</span>
						  <span class="n">i_pg_inv_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">orig_gen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;invalidate_pages %p gen %d revoking %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
	     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span> <span class="o">!=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* nevermind! */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">orig_gen</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_gen</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span> <span class="o">&amp;&amp;</span>
	    <span class="n">orig_gen</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;invalidate_pages %p gen %d successful</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span><span class="o">--</span><span class="p">;</span>
		<span class="n">check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;invalidate_pages %p gen %d raced, now %d revoking %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">orig_gen</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">)</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * called by trunc_wq; take i_mutex ourselves</span>
<span class="cm"> *</span>
<span class="cm"> * We also truncate in a separate thread as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ceph_vmtruncate_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_inode_info</span><span class="p">,</span>
						  <span class="n">i_vmtruncate_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;vmtruncate_work %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">__ceph_do_pending_vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue an async vmtruncate.  If we fail to queue work, we will handle</span>
<span class="cm"> * the truncation the next time we call __ceph_do_pending_vmtruncate.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_queue_vmtruncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_work</span><span class="p">(</span><span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">trunc_wq</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_vmtruncate_work</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;ceph_queue_vmtruncate %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;ceph_queue_vmtruncate %p failed, pending=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_pending</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called with i_mutex held.</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure any pending truncation is applied before doing anything</span>
<span class="cm"> * that may depend on it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__ceph_do_pending_vmtruncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wrbuffer_refs</span><span class="p">,</span> <span class="n">wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__do_pending_vmtruncate %p none pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure any dirty snapped pages are flushed before we</span>
<span class="cm">	 * possibly truncate them.. so write AND block!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span> <span class="o">&lt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__do_pending_vmtruncate %p flushing snaps first</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">to</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_size</span><span class="p">;</span>
	<span class="n">wrbuffer_refs</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="p">;</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__do_pending_vmtruncate %p (%d) to %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
	     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_pending</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_pending</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wrbuffer_refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">CHECK_CAPS_AUTHONLY</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * symlinks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ceph_sym_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_symlink</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ceph_symlink_iops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span> <span class="o">=</span> <span class="n">generic_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span> <span class="o">=</span> <span class="n">ceph_sym_follow_link</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * setattr</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent_inode</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ia_valid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">issued</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">release</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dirtied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inode_dirty_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ceph_snap</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CEPH_NOSNAP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">__ceph_do_pending_vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">ceph_mdsc_create_request</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">CEPH_MDS_OP_SETATTR</span><span class="p">,</span>
				       <span class="n">USE_AUTH_MDS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">req</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">issued</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p issued %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">issued</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p uid %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">;</span>
			<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			   <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">setattr</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">CEPH_SETATTR_UID</span><span class="p">;</span>
			<span class="n">release</span> <span class="o">|=</span> <span class="n">CEPH_CAP_AUTH_SHARED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p gid %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">;</span>
			<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			   <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">setattr</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">CEPH_SETATTR_GID</span><span class="p">;</span>
			<span class="n">release</span> <span class="o">|=</span> <span class="n">CEPH_CAP_AUTH_SHARED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p mode 0%o -&gt; 0%o</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
		     <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">;</span>
			<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			   <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">setattr</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">CEPH_SETATTR_MODE</span><span class="p">;</span>
			<span class="n">release</span> <span class="o">|=</span> <span class="n">CEPH_CAP_AUTH_SHARED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_ATIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p atime %ld.%ld -&gt; %ld.%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
		     <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="o">++</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">;</span>
			<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">timespec_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">;</span>
			<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			   <span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ceph_encode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">setattr</span><span class="p">.</span><span class="n">atime</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">CEPH_SETATTR_ATIME</span><span class="p">;</span>
			<span class="n">release</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_CACHE</span> <span class="o">|</span> <span class="n">CEPH_CAP_FILE_RD</span> <span class="o">|</span>
				<span class="n">CEPH_CAP_FILE_WR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p mtime %ld.%ld -&gt; %ld.%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
		     <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="o">++</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">;</span>
			<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">timespec_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">;</span>
			<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			   <span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ceph_encode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">setattr</span><span class="p">.</span><span class="n">mtime</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">CEPH_SETATTR_MTIME</span><span class="p">;</span>
			<span class="n">release</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_SHARED</span> <span class="o">|</span> <span class="n">CEPH_CAP_FILE_RD</span> <span class="o">|</span>
				<span class="n">CEPH_CAP_FILE_WR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p size %lld -&gt; %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">;</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_reported_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>
			<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			   <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">setattr</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">setattr</span><span class="p">.</span><span class="n">old_size</span> <span class="o">=</span>
				<span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">CEPH_SETATTR_SIZE</span><span class="p">;</span>
			<span class="n">release</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_SHARED</span> <span class="o">|</span> <span class="n">CEPH_CAP_FILE_RD</span> <span class="o">|</span>
				<span class="n">CEPH_CAP_FILE_WR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* these do nothing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_CTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">only</span> <span class="o">=</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_SIZE</span><span class="o">|</span><span class="n">ATTR_MTIME</span><span class="o">|</span><span class="n">ATTR_ATIME</span><span class="o">|</span>
					 <span class="n">ATTR_MODE</span><span class="o">|</span><span class="n">ATTR_UID</span><span class="o">|</span><span class="n">ATTR_GID</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p ctime %ld.%ld -&gt; %ld.%ld (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
		     <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">,</span>
		     <span class="n">only</span> <span class="o">?</span> <span class="s">&quot;ctime only&quot;</span> <span class="o">:</span> <span class="s">&quot;ignored&quot;</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">only</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if kernel wants to dirty ctime but nothing else,</span>
<span class="cm">			 * we need to choose a cap to dirty under, or do</span>
<span class="cm">			 * a almost-no-op setattr</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">)</span>
				<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">)</span>
				<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_XATTR_EXCL</span><span class="p">)</span>
				<span class="n">dirtied</span> <span class="o">|=</span> <span class="n">CEPH_CAP_XATTR_EXCL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">mask</span> <span class="o">|=</span> <span class="n">CEPH_SETATTR_CTIME</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_FILE</span><span class="p">)</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p ATTR_FILE ... hrm!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dirtied</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode_dirty_flags</span> <span class="o">=</span> <span class="n">__ceph_mark_dirty_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">dirtied</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release</span> <span class="o">&amp;=</span> <span class="n">issued</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode_dirty_flags</span><span class="p">)</span>
		<span class="n">__mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode_dirty_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_inode_drop</span> <span class="o">=</span> <span class="n">release</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">setattr</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_num_caps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">parent_inode</span> <span class="o">=</span> <span class="n">ceph_get_dentry_parent_inode</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ceph_mdsc_do_request</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">parent_inode</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">parent_inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;setattr %p result=%d (%s locally, %d remote)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">dirtied</span><span class="p">),</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">ceph_mdsc_put_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">__ceph_do_pending_vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">ceph_mdsc_put_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Verify that we have a lease on the given mask.  If not,</span>
<span class="cm"> * do a getattr against an mds.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_do_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="n">fsc</span> <span class="o">=</span> <span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">fsc</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ceph_snap</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">CEPH_SNAPDIR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;do_getattr inode %p SNAPDIR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;do_getattr inode %p mask %s mode 0%o</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceph_caps_issued_mask</span><span class="p">(</span><span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">ceph_mdsc_create_request</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">CEPH_MDS_OP_GETATTR</span><span class="p">,</span> <span class="n">USE_ANY_MDS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">req</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_num_caps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">r_args</span><span class="p">.</span><span class="n">getattr</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ceph_mdsc_do_request</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">ceph_mdsc_put_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;do_getattr result=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Check inode permissions.  We verify we have a valid value for</span>
<span class="cm"> * the AUTH cap, then call the generic handler.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_NOT_BLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ceph_do_getattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">CEPH_CAP_AUTH_SHARED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">generic_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get all attributes.  Hopefully somedata we&#39;ll have a statlite()</span>
<span class="cm"> * and can limit the fields we require to be accurate.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ceph_do_getattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">CEPH_STAT_CAP_INODE_ALL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">generic_fillattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ceph_translate_ino</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ceph_snap</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CEPH_NOSNAP</span><span class="p">)</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ceph_snap</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ceph_test_mount_opt</span><span class="p">(</span><span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span>
						<span class="n">RBYTES</span><span class="p">))</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rbytes</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">stat</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_files</span> <span class="o">+</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_subdirs</span><span class="p">;</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blksize</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
