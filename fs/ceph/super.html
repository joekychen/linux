<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ceph › super.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>super.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _FS_CEPH_SUPER_H</span>
<span class="cp">#define _FS_CEPH_SUPER_H</span>

<span class="cp">#include &lt;linux/ceph/ceph_debug.h&gt;</span>

<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/exportfs.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;linux/ceph/libceph.h&gt;</span>

<span class="cm">/* f_type in struct statfs */</span>
<span class="cp">#define CEPH_SUPER_MAGIC 0x00c36400</span>

<span class="cm">/* large granularity for statfs utilization stats to facilitate</span>
<span class="cm"> * large volume sizes on 32-bit machines. */</span>
<span class="cp">#define CEPH_BLOCK_SHIFT   20  </span><span class="cm">/* 1 MB */</span><span class="cp"></span>
<span class="cp">#define CEPH_BLOCK         (1 &lt;&lt; CEPH_BLOCK_SHIFT)</span>

<span class="cp">#define CEPH_MOUNT_OPT_DIRSTAT         (1&lt;&lt;4) </span><span class="cm">/* `cat dirname` for stats */</span><span class="cp"></span>
<span class="cp">#define CEPH_MOUNT_OPT_RBYTES          (1&lt;&lt;5) </span><span class="cm">/* dir st_bytes = rbytes */</span><span class="cp"></span>
<span class="cp">#define CEPH_MOUNT_OPT_NOASYNCREADDIR  (1&lt;&lt;7) </span><span class="cm">/* no dcache readdir */</span><span class="cp"></span>
<span class="cp">#define CEPH_MOUNT_OPT_INO32           (1&lt;&lt;8) </span><span class="cm">/* 32 bit inos */</span><span class="cp"></span>
<span class="cp">#define CEPH_MOUNT_OPT_DCACHE          (1&lt;&lt;9) </span><span class="cm">/* use dcache for readdir etc */</span><span class="cp"></span>

<span class="cp">#define CEPH_MOUNT_OPT_DEFAULT    (CEPH_MOUNT_OPT_RBYTES)</span>

<span class="cp">#define ceph_set_mount_opt(fsc, opt) \</span>
<span class="cp">	(fsc)-&gt;mount_options-&gt;flags |= CEPH_MOUNT_OPT_##opt;</span>
<span class="cp">#define ceph_test_mount_opt(fsc, opt) \</span>
<span class="cp">	(!!((fsc)-&gt;mount_options-&gt;flags &amp; CEPH_MOUNT_OPT_##opt))</span>

<span class="cp">#define CEPH_RSIZE_DEFAULT             0           </span><span class="cm">/* max read size */</span><span class="cp"></span>
<span class="cp">#define CEPH_RASIZE_DEFAULT            (8192*1024) </span><span class="cm">/* readahead */</span><span class="cp"></span>
<span class="cp">#define CEPH_MAX_READDIR_DEFAULT        1024</span>
<span class="cp">#define CEPH_MAX_READDIR_BYTES_DEFAULT  (512*1024)</span>
<span class="cp">#define CEPH_SNAPDIRNAME_DEFAULT        &quot;.snap&quot;</span>

<span class="k">struct</span> <span class="n">ceph_mount_options</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sb_flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">wsize</span><span class="p">;</span>            <span class="cm">/* max write size */</span>
	<span class="kt">int</span> <span class="n">rsize</span><span class="p">;</span>            <span class="cm">/* max read size */</span>
	<span class="kt">int</span> <span class="n">rasize</span><span class="p">;</span>           <span class="cm">/* max readahead */</span>
	<span class="kt">int</span> <span class="n">congestion_kb</span><span class="p">;</span>    <span class="cm">/* max writeback in flight */</span>
	<span class="kt">int</span> <span class="n">caps_wanted_delay_min</span><span class="p">,</span> <span class="n">caps_wanted_delay_max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cap_release_safety</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_readdir</span><span class="p">;</span>       <span class="cm">/* max readdir result (entires) */</span>
	<span class="kt">int</span> <span class="n">max_readdir_bytes</span><span class="p">;</span> <span class="cm">/* max readdir result (bytes) */</span>

	<span class="cm">/*</span>
<span class="cm">	 * everything above this point can be memcmp&#39;d; everything below</span>
<span class="cm">	 * is handled in compare_mount_options()</span>
<span class="cm">	 */</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">snapdir_name</span><span class="p">;</span>   <span class="cm">/* default &quot;.snap&quot; */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ceph_mount_options</span> <span class="o">*</span><span class="n">mount_options</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_client</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mount_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_caps</span><span class="p">;</span>                  <span class="cm">/* min caps i added */</span>

	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">;</span>

	<span class="cm">/* writeback */</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">wb_pagevec_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wb_wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">pg_inv_wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">trunc_wq</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">writeback_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">backing_dev_info</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dentry_lru</span><span class="p">,</span> <span class="o">*</span><span class="n">debugfs_caps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_congestion_kb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_bdi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_mdsc</span><span class="p">,</span> <span class="o">*</span><span class="n">debugfs_mdsmap</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * File i/o capability.  This tracks shared state with the metadata</span>
<span class="cm"> * server that allows us to cache or writeback attributes or to read</span>
<span class="cm"> * and write data.  For any given inode, we should have one or more</span>
<span class="cm"> * capabilities, one issued by each metadata server, and our</span>
<span class="cm"> * cumulative access is the OR of all issued capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> * Each cap is referenced by the inode&#39;s i_caps rbtree and by per-mds</span>
<span class="cm"> * session capability lists.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">ci_node</span><span class="p">;</span>          <span class="cm">/* per-ci cap tree */</span>
	<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">session_caps</span><span class="p">;</span>   <span class="cm">/* per-session caplist */</span>
	<span class="kt">int</span> <span class="n">mds</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cap_id</span><span class="p">;</span>       <span class="cm">/* unique cap id (mds provided) */</span>
	<span class="kt">int</span> <span class="n">issued</span><span class="p">;</span>       <span class="cm">/* latest, from the mds */</span>
	<span class="kt">int</span> <span class="n">implemented</span><span class="p">;</span>  <span class="cm">/* implemented superset of issued (for revocation) */</span>
	<span class="kt">int</span> <span class="n">mds_wanted</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">issue_seq</span><span class="p">,</span> <span class="n">mseq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cap_gen</span><span class="p">;</span>      <span class="cm">/* active/stale cycle */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_used</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">caps_item</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define CHECK_CAPS_NODELAY    1  </span><span class="cm">/* do not delay any further */</span><span class="cp"></span>
<span class="cp">#define CHECK_CAPS_AUTHONLY   2  </span><span class="cm">/* only check auth cap */</span><span class="cp"></span>
<span class="cp">#define CHECK_CAPS_FLUSH      4  </span><span class="cm">/* flush any dirty caps */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Snapped cap state that is pending flush to mds.  When a snapshot occurs,</span>
<span class="cm"> * we first complete any in-process sync writes and writeback any dirty</span>
<span class="cm"> * data before flushing the snapped state (tracked here) back to the MDS.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">nref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ci_item</span><span class="p">,</span> <span class="n">flushing_item</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">follows</span><span class="p">,</span> <span class="n">flush_tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">issued</span><span class="p">,</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_snap_context</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>

	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ceph_buffer</span> <span class="o">*</span><span class="n">xattr_blob</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">xattr_version</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">mtime</span><span class="p">,</span> <span class="n">atime</span><span class="p">,</span> <span class="n">ctime</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">time_warp_seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">writing</span><span class="p">;</span>   <span class="cm">/* a sync write is still in progress */</span>
	<span class="kt">int</span> <span class="n">dirty_pages</span><span class="p">;</span>     <span class="cm">/* dirty pages awaiting writeback */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ceph_put_cap_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">xattr_blob</span><span class="p">)</span>
			<span class="n">ceph_buffer_put</span><span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">xattr_blob</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">capsnap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The frag tree describes how a directory is fragmented, potentially across</span>
<span class="cm"> * multiple metadata servers.  It is also used to indicate points where</span>
<span class="cm"> * metadata authority is delegated, and whether/where metadata is replicated.</span>
<span class="cm"> *</span>
<span class="cm"> * A _leaf_ frag will be present in the i_fragtree IFF there is</span>
<span class="cm"> * delegation info.  That is, if mds &gt;= 0 || ndist &gt; 0.</span>
<span class="cm"> */</span>
<span class="cp">#define CEPH_MAX_DIRFRAG_REP 4</span>

<span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* fragtree state */</span>
	<span class="n">u32</span> <span class="n">frag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">split_by</span><span class="p">;</span>         <span class="cm">/* i.e. 2^(split_by) children */</span>

	<span class="cm">/* delegation and replication info */</span>
	<span class="kt">int</span> <span class="n">mds</span><span class="p">;</span>              <span class="cm">/* -1 if same authority as parent */</span>
	<span class="kt">int</span> <span class="n">ndist</span><span class="p">;</span>            <span class="cm">/* &gt;0 if replicated */</span>
	<span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">CEPH_MAX_DIRFRAG_REP</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We cache inode xattrs as an encoded blob until they are first used,</span>
<span class="cm"> * at which point we parse them into an rbtree.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ceph_inode_xattr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">should_free_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">should_free_val</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Ceph dentry state</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ceph_dentry_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">lease_session</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lease_gen</span><span class="p">,</span> <span class="n">lease_shared_gen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lease_seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lease_renew_after</span><span class="p">,</span> <span class="n">lease_renew_from</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * dentry flags</span>
<span class="cm"> *</span>
<span class="cm"> * The locking for D_COMPLETE is a bit odd:</span>
<span class="cm"> *  - we can clear it at almost any time (see ceph_d_prune)</span>
<span class="cm"> *  - it is only meaningful if:</span>
<span class="cm"> *    - we hold dir inode i_ceph_lock</span>
<span class="cm"> *    - we hold dir FILE_SHARED caps</span>
<span class="cm"> *    - the dentry D_COMPLETE is set</span>
<span class="cm"> */</span>
<span class="cp">#define CEPH_D_COMPLETE 1  </span><span class="cm">/* if set, d_u.d_subdirs is complete directory */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ceph_inode_xattrs_info</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * (still encoded) xattr blob. we avoid the overhead of parsing</span>
<span class="cm">	 * this until someone actually calls getxattr, etc.</span>
<span class="cm">	 *</span>
<span class="cm">	 * blob-&gt;vec.iov_len == 4 implies there are no xattrs; blob ==</span>
<span class="cm">	 * NULL means we don&#39;t know.</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="n">ceph_buffer</span> <span class="o">*</span><span class="n">blob</span><span class="p">,</span> <span class="o">*</span><span class="n">prealloc_blob</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">names_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vals_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">version</span><span class="p">,</span> <span class="n">index_version</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Ceph inode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">i_vino</span><span class="p">;</span>   <span class="cm">/* ceph ino + snap */</span>

	<span class="n">spinlock_t</span> <span class="n">i_ceph_lock</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">i_version</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i_time_warp_seq</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">i_ceph_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i_release_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ceph_dir_layout</span> <span class="n">i_dir_layout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_file_layout</span> <span class="n">i_layout</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">i_symlink</span><span class="p">;</span>

	<span class="cm">/* for dirs */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">i_rctime</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">i_rbytes</span><span class="p">,</span> <span class="n">i_rfiles</span><span class="p">,</span> <span class="n">i_rsubdirs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">i_files</span><span class="p">,</span> <span class="n">i_subdirs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">i_max_offset</span><span class="p">;</span>  <span class="cm">/* largest readdir offset, set with D_COMPLETE */</span>

	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">i_fragtree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">i_fragtree_mutex</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ceph_inode_xattrs_info</span> <span class="n">i_xattrs</span><span class="p">;</span>

	<span class="cm">/* capabilities.  protected _both_ by i_ceph_lock and cap-&gt;session&#39;s</span>
<span class="cm">	 * s_mutex. */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">i_caps</span><span class="p">;</span>           <span class="cm">/* cap list */</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">i_auth_cap</span><span class="p">;</span>     <span class="cm">/* authoritative cap, if any */</span>
	<span class="kt">unsigned</span> <span class="n">i_dirty_caps</span><span class="p">,</span> <span class="n">i_flushing_caps</span><span class="p">;</span>     <span class="cm">/* mask of dirtied fields */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_dirty_item</span><span class="p">,</span> <span class="n">i_flushing_item</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">i_cap_flush_seq</span><span class="p">;</span>
	<span class="cm">/* we need to track cap writeback on a per-cap-bit basis, to allow</span>
<span class="cm">	 * overlapping, pipelined cap flushes to the mds.  we can probably</span>
<span class="cm">	 * reduce the tid to 8 bits if we&#39;re concerned about inode size. */</span>
	<span class="n">u16</span> <span class="n">i_cap_flush_last_tid</span><span class="p">,</span> <span class="n">i_cap_flush_tid</span><span class="p">[</span><span class="n">CEPH_CAP_BITS</span><span class="p">];</span>
	<span class="n">wait_queue_head_t</span> <span class="n">i_cap_wq</span><span class="p">;</span>      <span class="cm">/* threads waiting on a capability */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i_hold_caps_min</span><span class="p">;</span> <span class="cm">/* jiffies */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i_hold_caps_max</span><span class="p">;</span> <span class="cm">/* jiffies */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_cap_delay_list</span><span class="p">;</span>  <span class="cm">/* for delayed cap release to mds */</span>
	<span class="kt">int</span> <span class="n">i_cap_exporting_mds</span><span class="p">;</span>         <span class="cm">/* to handle cap migration between */</span>
	<span class="kt">unsigned</span> <span class="n">i_cap_exporting_mseq</span><span class="p">;</span>   <span class="cm">/*  mds&#39;s. */</span>
	<span class="kt">unsigned</span> <span class="n">i_cap_exporting_issued</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="n">i_cap_migration_resv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_cap_snaps</span><span class="p">;</span>   <span class="cm">/* snapped state pending flush to mds */</span>
	<span class="k">struct</span> <span class="n">ceph_snap_context</span> <span class="o">*</span><span class="n">i_head_snapc</span><span class="p">;</span>  <span class="cm">/* set if wr_buffer_head &gt; 0 or</span>
<span class="cm">						    dirty|flushing caps */</span>
	<span class="kt">unsigned</span> <span class="n">i_snap_caps</span><span class="p">;</span>           <span class="cm">/* cap bits for snapped files */</span>

	<span class="kt">int</span> <span class="n">i_nr_by_mode</span><span class="p">[</span><span class="n">CEPH_FILE_MODE_NUM</span><span class="p">];</span>  <span class="cm">/* open file counts */</span>

	<span class="n">u32</span> <span class="n">i_truncate_seq</span><span class="p">;</span>        <span class="cm">/* last truncate to smaller size */</span>
	<span class="n">u64</span> <span class="n">i_truncate_size</span><span class="p">;</span>       <span class="cm">/*  and the size we last truncated down to */</span>
	<span class="kt">int</span> <span class="n">i_truncate_pending</span><span class="p">;</span>    <span class="cm">/*  still need to call vmtruncate */</span>

	<span class="n">u64</span> <span class="n">i_max_size</span><span class="p">;</span>            <span class="cm">/* max file size authorized by mds */</span>
	<span class="n">u64</span> <span class="n">i_reported_size</span><span class="p">;</span> <span class="cm">/* (max_)size reported to or requested of mds */</span>
	<span class="n">u64</span> <span class="n">i_wanted_max_size</span><span class="p">;</span>     <span class="cm">/* offset we&#39;d like to write too */</span>
	<span class="n">u64</span> <span class="n">i_requested_max_size</span><span class="p">;</span>  <span class="cm">/* max_size we&#39;ve requested */</span>

	<span class="cm">/* held references to caps */</span>
	<span class="kt">int</span> <span class="n">i_pin_ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i_rd_ref</span><span class="p">,</span> <span class="n">i_rdcache_ref</span><span class="p">,</span> <span class="n">i_wr_ref</span><span class="p">,</span> <span class="n">i_wb_ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i_wrbuffer_ref</span><span class="p">,</span> <span class="n">i_wrbuffer_ref_head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i_shared_gen</span><span class="p">;</span>       <span class="cm">/* increment each time we get FILE_SHARED */</span>
	<span class="n">u32</span> <span class="n">i_rdcache_gen</span><span class="p">;</span>      <span class="cm">/* incremented each time we get FILE_CACHE. */</span>
	<span class="n">u32</span> <span class="n">i_rdcache_revoking</span><span class="p">;</span> <span class="cm">/* RDCACHE gen to async invalidate, if any */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_unsafe_writes</span><span class="p">;</span> <span class="cm">/* uncommitted sync writes */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_unsafe_dirops</span><span class="p">;</span> <span class="cm">/* uncommitted mds dir ops */</span>
	<span class="n">spinlock_t</span> <span class="n">i_unsafe_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">i_snap_realm</span><span class="p">;</span> <span class="cm">/* snap realm (if caps) */</span>
	<span class="kt">int</span> <span class="n">i_snap_realm_counter</span><span class="p">;</span> <span class="cm">/* snap realm (if caps) */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_snap_realm_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_snap_flush_item</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">i_wb_work</span><span class="p">;</span>  <span class="cm">/* writeback work */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">i_pg_inv_work</span><span class="p">;</span>  <span class="cm">/* page invalidation work */</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">i_vmtruncate_work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span> <span class="cm">/* at end */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="nf">ceph_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="nf">ceph_inode_to_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="nf">ceph_sb_to_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="p">)</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ceph_vino</span> <span class="nf">ceph_vino</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_vino</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ino_t is &lt;64 bits on many architectures, blech.</span>
<span class="cm"> *</span>
<span class="cm"> *               i_ino (kernel inode)   st_ino (userspace)</span>
<span class="cm"> * i386          32                     32</span>
<span class="cm"> * x86_64+ino32  64                     32</span>
<span class="cm"> * x86_64        64                     64</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ceph_ino_to_ino32</span><span class="p">(</span><span class="n">__u64</span> <span class="n">vino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">vino</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">ino</span> <span class="o">^=</span> <span class="n">vino</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="n">ino</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ino</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kernel i_ino value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ino_t</span> <span class="nf">ceph_vino_to_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if BITS_PER_LONG == 32</span>
	<span class="k">return</span> <span class="n">ceph_ino_to_ino32</span><span class="p">(</span><span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ino_t</span><span class="p">)</span><span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * user-visible ino (stat, filldir)</span>
<span class="cm"> */</span>
<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ino_t</span> <span class="nf">ceph_translate_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ino</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ino_t</span> <span class="nf">ceph_translate_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ceph_test_mount_opt</span><span class="p">(</span><span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">INO32</span><span class="p">))</span>
		<span class="n">ino</span> <span class="o">=</span> <span class="n">ceph_ino_to_ino32</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ino</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/* for printf-style formatting */</span>
<span class="cp">#define ceph_vinop(i) ceph_inode(i)-&gt;i_vino.ino, ceph_inode(i)-&gt;i_vino.snap</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ceph_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_vino</span><span class="p">.</span><span class="n">ino</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ceph_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_vino</span><span class="p">.</span><span class="n">snap</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ceph_ino_compare</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_vino</span> <span class="o">*</span><span class="n">pvino</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ceph_vino</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">==</span> <span class="n">pvino</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">&amp;&amp;</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_vino</span><span class="p">.</span><span class="n">snap</span> <span class="o">==</span> <span class="n">pvino</span><span class="o">-&gt;</span><span class="n">snap</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ceph_find_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ino_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ceph_vino_to_ino</span><span class="p">(</span><span class="n">vino</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ilookup5</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ceph_ino_compare</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vino</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Ceph inode.</span>
<span class="cm"> */</span>
<span class="cp">#define CEPH_I_NODELAY   4  </span><span class="cm">/* do not delay cap release */</span><span class="cp"></span>
<span class="cp">#define CEPH_I_FLUSH     8  </span><span class="cm">/* do not delay flush of dirty metadata */</span><span class="cp"></span>
<span class="cp">#define CEPH_I_NOFLUSH  16  </span><span class="cm">/* do not flush dirty caps */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ceph_i_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ceph_i_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ceph_i_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* find a specific frag @f */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">__ceph_find_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">f</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * choose fragment for value @v.  copy frag content to pfrag, if leaf</span>
<span class="cm"> * exists</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">ceph_choose_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">v</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ceph_inode_frag</span> <span class="o">*</span><span class="n">pfrag</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="o">*</span><span class="n">found</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ceph_dentry_info</span> <span class="o">*</span><span class="nf">ceph_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ceph_dentry_info</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">ceph_make_fpos</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">frag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">frag</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">off</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set/clear directory D_COMPLETE flag</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ceph_dir_set_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ceph_dir_clear_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">ceph_dir_test_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * caps helpers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__ceph_is_any_real_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">implemented</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ceph_caps_issued_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ceph_caps_issued_other</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ceph_caps_issued</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">issued</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">issued</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">issued</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ceph_caps_issued_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">touch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">__ceph_caps_issued_mask</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">touch</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ceph_caps_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span> <span class="o">|</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ceph_mark_dirty_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_caps_revoking</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ceph_caps_file_wanted</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * wanted, by virtue of open file modes AND cap refs (buffered/cached data)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ceph_caps_wanted</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">__ceph_caps_file_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">|</span> <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_BUFFER</span><span class="p">)</span>
		<span class="n">w</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">;</span>  <span class="cm">/* we want EXCL if dirty data */</span>
	<span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* what the mds thinks we want */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ceph_caps_mds_wanted</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_caps_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_caps_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_adjust_min_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_reserve_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">need</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_unreserve_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_reservation_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="o">*</span><span class="n">total</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">avail</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">used</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="o">*</span><span class="n">reserved</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">min</span><span class="p">);</span>



<span class="cm">/*</span>
<span class="cm"> * we keep buffered readdir results attached to file-&gt;private_data</span>
<span class="cm"> */</span>
<span class="cp">#define CEPH_F_SYNC     1</span>
<span class="cp">#define CEPH_F_ATEND    2</span>

<span class="k">struct</span> <span class="n">ceph_file_info</span> <span class="p">{</span>
	<span class="kt">short</span> <span class="n">fmode</span><span class="p">;</span>     <span class="cm">/* initialized on open */</span>
	<span class="kt">short</span> <span class="n">flags</span><span class="p">;</span>     <span class="cm">/* CEPH_F_* */</span>

	<span class="cm">/* readdir: position within the dir */</span>
	<span class="n">u32</span> <span class="n">frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">last_readdir</span><span class="p">;</span>

	<span class="cm">/* readdir: position within a frag */</span>
	<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">;</span>       <span class="cm">/* offset of last chunk, adjusted for . and .. */</span>
	<span class="n">u64</span> <span class="n">next_offset</span><span class="p">;</span>       <span class="cm">/* offset of next chunk (last_name&#39;s + 1) */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">last_name</span><span class="p">;</span>       <span class="cm">/* last entry in previous chunk */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span> <span class="cm">/* next dentry (for dcache readdir) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dir_release_count</span><span class="p">;</span>

	<span class="cm">/* used for -o dirstat read() on directory thing */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dir_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dir_info_len</span><span class="p">;</span>
<span class="p">};</span>



<span class="cm">/*</span>
<span class="cm"> * A &quot;snap realm&quot; describes a subset of the file hierarchy sharing</span>
<span class="cm"> * the same set of snapshots that apply to it.  The realms themselves</span>
<span class="cm"> * are organized into a hierarchy, such that children inherit (some of)</span>
<span class="cm"> * the snapshots of their parents.</span>
<span class="cm"> *</span>
<span class="cm"> * All inodes within the realm that have capabilities are linked into a</span>
<span class="cm"> * per-realm list.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">nref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">created</span><span class="p">,</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent_ino</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent_since</span><span class="p">;</span>   <span class="cm">/* snapid when our current parent became so */</span>

	<span class="n">u64</span> <span class="o">*</span><span class="n">prior_parent_snaps</span><span class="p">;</span>      <span class="cm">/* snaps inherited from any parents we */</span>
	<span class="kt">int</span> <span class="n">num_prior_parent_snaps</span><span class="p">;</span>   <span class="cm">/*  had prior to parent_since */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">snaps</span><span class="p">;</span>                   <span class="cm">/* snaps specific to this realm */</span>
	<span class="kt">int</span> <span class="n">num_snaps</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>       <span class="cm">/* list of child realms */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">child_item</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">empty_item</span><span class="p">;</span>     <span class="cm">/* if i have ref==0 */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dirty_item</span><span class="p">;</span>     <span class="cm">/* if realm needs new context */</span>

	<span class="cm">/* the current set of snaps for this realm */</span>
	<span class="k">struct</span> <span class="n">ceph_snap_context</span> <span class="o">*</span><span class="n">cached_context</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">inodes_with_caps</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">inodes_with_caps_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">default_congestion_kb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">congestion_kb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copied from NFS</span>
<span class="cm">	 *</span>
<span class="cm">	 * congestion size, scale with available memory.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  64MB:    8192k</span>
<span class="cm">	 * 128MB:   11585k</span>
<span class="cm">	 * 256MB:   16384k</span>
<span class="cm">	 * 512MB:   23170k</span>
<span class="cm">	 *   1GB:   32768k</span>
<span class="cm">	 *   2GB:   46340k</span>
<span class="cm">	 *   4GB:   65536k</span>
<span class="cm">	 *   8GB:   92681k</span>
<span class="cm">	 *  16GB:  131072k</span>
<span class="cm">	 *</span>
<span class="cm">	 * This allows larger machines to have larger/more transfers.</span>
<span class="cm">	 * Limit the default to 256M</span>
<span class="cm">	 */</span>
	<span class="n">congestion_kb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="n">int_sqrt</span><span class="p">(</span><span class="n">totalram_pages</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">congestion_kb</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
		<span class="n">congestion_kb</span> <span class="o">=</span> <span class="mi">256</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">congestion_kb</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* snap.c */</span>
<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">ceph_lookup_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
					       <span class="n">u64</span> <span class="n">ino</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_get_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_put_snap_realm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_update_snap_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="n">bool</span> <span class="n">deletion</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_handle_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_queue_cap_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ceph_finish_cap_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_cleanup_empty_realms</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * a cap_snap is &quot;pending&quot; if it is still awaiting an in-progress</span>
<span class="cm"> * sync write (that may/may not still update size, mtime, etc.).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__ceph_have_pending_cap_snap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">list_entry</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap_snap</span><span class="p">,</span>
			   <span class="n">ci_item</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">writing</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* inode.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ceph_file_iops</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ceph_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ceph_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ceph_get_snapdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_fill_file_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">issued</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">truncate_seq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">truncate_size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_fill_file_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">issued</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">time_warp_seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ctime</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">mtime</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">atime</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_fill_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_readdir_prepopulate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_inode_holds_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_inode_set_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ceph_do_pending_vmtruncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_queue_vmtruncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_queue_invalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_queue_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_do_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">);</span>

<span class="cm">/* xattr.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
			 <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">ceph_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">ceph_listxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ceph_build_xattrs_blob</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ceph_destroy_xattrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">ceph_xattr_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_xattr_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* caps.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ceph_cap_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_handle_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_add_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cap_id</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">fmode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">issued</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">wanted</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">realmino</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="o">*</span><span class="n">caps_reservation</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ceph_remove_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ceph_remove_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">__ceph_remove_cap</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_put_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_queue_caps_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_kick_flushing_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">ceph_get_cap_for_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">mds</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_get_cap_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_get_cap_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">caps</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_put_cap_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">had</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_put_wrbuffer_cap_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ceph_snap_context</span> <span class="o">*</span><span class="n">snapc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ceph_flush_snaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">**</span><span class="n">psession</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">again</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_check_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_check_delayed_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_flush_dirty_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_encode_inode_release</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">mds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">drop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unless</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_encode_dentry_release</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">mds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">drop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unless</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_get_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">need</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="o">*</span><span class="n">got</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">endoff</span><span class="p">);</span>

<span class="cm">/* for counting open files by mode */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ceph_get_fmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_nr_by_mode</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_put_fmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/* addr.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ceph_aops</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>

<span class="cm">/* file.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ceph_file_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ceph_aops</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_copy_to_page_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				    <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_copy_from_page_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				    <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ceph_alloc_page_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_pages</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ceph_lookup_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">locked_dir</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ceph_dir_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ceph_dir_iops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">ceph_dentry_ops</span><span class="p">,</span> <span class="n">ceph_snap_dentry_ops</span><span class="p">,</span>
	<span class="n">ceph_snapdir_dentry_ops</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_handle_notrace_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_handle_snapdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ceph_finish_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_dentry_lru_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_dentry_lru_touch</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_dentry_lru_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_invalidate_dentry_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">ceph_dentry_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dn</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ceph_get_dentry_parent_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * our d_ops vary depending on whether the inode is live,</span>
<span class="cm"> * snapshotted (read-only), or a virtual &quot;.snap&quot; directory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ceph_init_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>


<span class="cm">/* ioctl.c */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ceph_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* export.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">export_operations</span> <span class="n">ceph_export_ops</span><span class="p">;</span>

<span class="cm">/* locks.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_flock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_count_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p_num</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">f_num</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_encode_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_pagelist</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">p_locks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f_locks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lock_to_ceph_filelock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_filelock</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* debugfs.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ceph_fs_debugfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ceph_fs_debugfs_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _FS_CEPH_SUPER_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
