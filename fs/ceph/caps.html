<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ceph › caps.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>caps.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/ceph/ceph_debug.h&gt;</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>

<span class="cp">#include &quot;super.h&quot;</span>
<span class="cp">#include &quot;mds_client.h&quot;</span>
<span class="cp">#include &lt;linux/ceph/decode.h&gt;</span>
<span class="cp">#include &lt;linux/ceph/messenger.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Capability management</span>
<span class="cm"> *</span>
<span class="cm"> * The Ceph metadata servers control client access to inode metadata</span>
<span class="cm"> * and file data by issuing capabilities, granting clients permission</span>
<span class="cm"> * to read and/or write both inode field and file data to OSDs</span>
<span class="cm"> * (storage nodes).  Each capability consists of a set of bits</span>
<span class="cm"> * indicating which operations are allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * If the client holds a *_SHARED cap, the client has a coherent value</span>
<span class="cm"> * that can be safely read from the cached inode.</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of a *_EXCL (exclusive) or FILE_WR capabilities, the</span>
<span class="cm"> * client is allowed to change inode attributes (e.g., file size,</span>
<span class="cm"> * mtime), note its dirty state in the ceph_cap, and asynchronously</span>
<span class="cm"> * flush that metadata change to the MDS.</span>
<span class="cm"> *</span>
<span class="cm"> * In the event of a conflicting operation (perhaps by another</span>
<span class="cm"> * client), the MDS will revoke the conflicting client capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> * In order for a client to cache an inode, it must hold a capability</span>
<span class="cm"> * with at least one MDS server.  When inodes are released, release</span>
<span class="cm"> * notifications are batched and periodically sent en masse to the MDS</span>
<span class="cm"> * cluster to release server state.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Generate readable cap strings for debugging output.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_CAP_STR 20</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">cap_str</span><span class="p">[</span><span class="n">MAX_CAP_STR</span><span class="p">][</span><span class="mi">40</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cap_str_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">last_cap_str</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">gcap_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_GSHARED</span><span class="p">)</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;s&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_GEXCL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_GCACHE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;c&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_GRD</span><span class="p">)</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;r&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_GWR</span><span class="p">)</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;w&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_GBUFFER</span><span class="p">)</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_GLAZYIO</span><span class="p">)</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;l&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ceph_cap_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">caps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap_str_lock</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">last_cap_str</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_cap_str</span> <span class="o">==</span> <span class="n">MAX_CAP_STR</span><span class="p">)</span>
		<span class="n">last_cap_str</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap_str_lock</span><span class="p">);</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">cap_str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_PIN</span><span class="p">)</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;p&#39;</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&gt;&gt;</span> <span class="n">CEPH_CAP_SAUTH</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">gcap_string</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&gt;&gt;</span> <span class="n">CEPH_CAP_SLINK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;L&#39;</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">gcap_string</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&gt;&gt;</span> <span class="n">CEPH_CAP_SXATTR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;X&#39;</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">gcap_string</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">caps</span> <span class="o">&gt;&gt;</span> <span class="n">CEPH_CAP_SFILE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;F&#39;</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">gcap_string</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">cap_str</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cap_str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_caps_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_caps_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">caps_item</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">caps_item</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ceph_cap_cachep</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_min_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_adjust_min_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_min_count</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_min_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ceph_reserve_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">need</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">newcaps</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;reserve caps ctx=%p need=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">need</span><span class="p">);</span>

	<span class="cm">/* first reserve any caps that are already allocated */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span> <span class="o">&gt;=</span> <span class="n">need</span><span class="p">)</span>
		<span class="n">have</span> <span class="o">=</span> <span class="n">need</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">have</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span> <span class="o">-=</span> <span class="n">have</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">+=</span> <span class="n">have</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span> <span class="o">!=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span> <span class="o">+</span>
					 <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">+</span>
					 <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">have</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">need</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ceph_cap_cachep</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_alloc_count</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">caps_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newcaps</span><span class="p">);</span>
		<span class="n">alloc</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">have</span> <span class="o">+</span> <span class="n">alloc</span> <span class="o">!=</span> <span class="n">need</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span> <span class="o">+=</span> <span class="n">alloc</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">+=</span> <span class="n">alloc</span><span class="p">;</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newcaps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span> <span class="o">!=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span> <span class="o">+</span>
					 <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">+</span>
					 <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">need</span><span class="p">;</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;reserve caps ctx=%p %d = %d used + %d resv + %d avail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ctx</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span><span class="p">,</span>
	     <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_alloc_count:</span>
	<span class="cm">/* we didn&#39;t manage to reserve as much as we needed */</span>
	<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;reserve caps ctx=%p ENOMEM need=%d got=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">ctx</span><span class="p">,</span> <span class="n">need</span><span class="p">,</span> <span class="n">have</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ceph_unreserve_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;unreserve caps ctx=%p count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">-=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span> <span class="o">+=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;unreserve caps %d = %d used + %d resv + %d avail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span><span class="p">,</span>
		     <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span> <span class="o">!=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span> <span class="o">+</span>
						 <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">+</span>
						 <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="nf">get_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* temporary, until we do something about cap import/export */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ceph_cap_cachep</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">cap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_cap ctx=%p (%d) %d = %d used + %d resv + %d avail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span><span class="p">,</span>
	     <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list</span><span class="p">));</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">caps_item</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">caps_item</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span> <span class="o">!=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span> <span class="o">+</span>
	       <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">+</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cap</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_put_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;put_cap %p %d = %d used + %d resv + %d avail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">cap</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span><span class="p">,</span>
	     <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span><span class="p">,</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
	<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Keep some preallocated caps around (ceph_min_count), to</span>
<span class="cm">	 * avoid lots of free/alloc churn.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span> <span class="o">&gt;=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">+</span>
				      <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_min_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ceph_cap_cachep</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">caps_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span> <span class="o">!=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span> <span class="o">+</span>
	       <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span> <span class="o">+</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_reservation_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="n">fsc</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">total</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">avail</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">used</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">reserved</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">fsc</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total</span><span class="p">)</span>
		<span class="o">*</span><span class="n">total</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_total_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avail</span><span class="p">)</span>
		<span class="o">*</span><span class="n">avail</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_avail_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used</span><span class="p">)</span>
		<span class="o">*</span><span class="n">used</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_use_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserved</span><span class="p">)</span>
		<span class="o">*</span><span class="n">reserved</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_reserve_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min</span><span class="p">)</span>
		<span class="o">*</span><span class="n">min</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">caps_min_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find ceph_cap for given mds, if any.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with i_ceph_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="nf">__get_cap_for_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mds</span> <span class="o">&lt;</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mds</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">cap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="nf">ceph_get_cap_for_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="n">__get_cap_for_mds</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">mds</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cap</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return id of any MDS with a cap, preferably FILE_WR|BUFFER|EXCL, else -1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ceph_get_cap_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* prefer mds with WR|BUFFER|EXCL caps */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="n">mds</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_FILE_WR</span> <span class="o">|</span>
				   <span class="n">CEPH_CAP_FILE_BUFFER</span> <span class="o">|</span>
				   <span class="n">CEPH_CAP_FILE_EXCL</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mds</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ceph_get_cap_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mds</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">mds</span> <span class="o">=</span> <span class="n">__ceph_get_cap_mds</span><span class="p">(</span><span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mds</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called under i_ceph_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__insert_cap_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">mds</span> <span class="o">&lt;</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">mds</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">ci_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">ci_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * (re)set cap hold timeouts, which control the delayed release</span>
<span class="cm"> * of unused caps back to the MDS.  Should be called on cap use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cap_set_timeouts</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mount_options</span> <span class="o">*</span><span class="n">ma</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">fsc</span><span class="o">-&gt;</span><span class="n">mount_options</span><span class="p">;</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_min</span> <span class="o">=</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span>
					    <span class="n">ma</span><span class="o">-&gt;</span><span class="n">caps_wanted_delay_min</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_max</span> <span class="o">=</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span>
					    <span class="n">ma</span><span class="o">-&gt;</span><span class="n">caps_wanted_delay_max</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__cap_set_timeouts %p min %lu max %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
	     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_min</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_max</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * (Re)queue cap at the end of the delayed cap release list.</span>
<span class="cm"> *</span>
<span class="cm"> * If I_FLUSH is set, leave the inode at the front of the list.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller holds i_ceph_lock</span>
<span class="cm"> *    -&gt; we take mdsc-&gt;cap_delay_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cap_delay_requeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__cap_set_timeouts</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__cap_delay_requeue %p flags %d at %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
	     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_max</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">stopping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">CEPH_I_FLUSH</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_change</span><span class="p">;</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_list</span><span class="p">);</span>
<span class="nl">no_change:</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue an inode for immediate writeback.  Mark inode with I_FLUSH,</span>
<span class="cm"> * indicating we should send a cap message to flush dirty metadata</span>
<span class="cm"> * asap, and move to the front of the delayed cap list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cap_delay_requeue_front</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__cap_delay_requeue_front %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">|=</span> <span class="n">CEPH_I_FLUSH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cancel delayed work on cap.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold i_ceph_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__cap_delay_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__cap_delay_cancel %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common issue checks for add_cap, handle_cap_grant.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__check_cap_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="n">issued</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">had</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each time we receive FILE_CACHE anew, we increment</span>
<span class="cm">	 * i_rdcache_gen.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_FILE_CACHE</span><span class="o">|</span><span class="n">CEPH_CAP_FILE_LAZYIO</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">had</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_FILE_CACHE</span><span class="o">|</span><span class="n">CEPH_CAP_FILE_LAZYIO</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we are newly issued FILE_SHARED, clear D_COMPLETE; we</span>
<span class="cm">	 * don&#39;t know what happened to this directory while we didn&#39;t</span>
<span class="cm">	 * have the cap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_SHARED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">had</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_SHARED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_shared_gen</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">ceph_dir_clear_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a capability under the given MDS session.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller should hold session snap_rwsem (read) and s_mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * @fmode is the open file mode, if we are opening a file, otherwise</span>
<span class="cm"> * it is &lt; 0.  (This is so we can atomically add the cap and add an</span>
<span class="cm"> * open file reference to it.)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_add_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cap_id</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">fmode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">issued</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">wanted</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="n">seq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mseq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">realmino</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">ceph_cap_reservation</span> <span class="o">*</span><span class="n">caps_reservation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">ceph_inode_to_client</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">new_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">actual_wanted</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;add_cap %p mds%d cap %llx %s seq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
	     <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">,</span> <span class="n">cap_id</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">issued</span><span class="p">),</span> <span class="n">seq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are opening the file, include file mode wanted bits</span>
<span class="cm">	 * in wanted.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmode</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wanted</span> <span class="o">|=</span> <span class="n">ceph_caps_for_mode</span><span class="p">(</span><span class="n">fmode</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="n">__get_cap_for_mds</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">mds</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_cap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cap</span> <span class="o">=</span> <span class="n">new_cap</span><span class="p">;</span>
			<span class="n">new_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="n">new_cap</span> <span class="o">=</span> <span class="n">get_cap</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">caps_reservation</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_cap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span> <span class="o">=</span> <span class="n">mds</span><span class="p">;</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
		<span class="n">__insert_cap_node</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

		<span class="cm">/* clear out old exporting info?  (i.e. on cap import) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mds</span> <span class="o">==</span> <span class="n">mds</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_issued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mseq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mds</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* add to session cap list */</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">session_caps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_caps</span><span class="p">);</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">s_nr_caps</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_cap</span><span class="p">)</span>
		<span class="n">ceph_put_cap</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">new_cap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * add this inode to the appropriate snap realm</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span> <span class="o">=</span> <span class="n">ceph_lookup_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span>
							       <span class="n">realmino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">realm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ceph_get_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span> <span class="o">=</span> <span class="n">realm</span><span class="p">;</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm_item</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ceph_add_cap: couldn&#39;t find snap realm %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">realmino</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">realm</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">__check_cap_issue</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">issued</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are issued caps we don&#39;t want, or the mds&#39; wanted</span>
<span class="cm">	 * value appears to be off, queue a check so we&#39;ll release</span>
<span class="cm">	 * later and/or update the mds wanted value.</span>
<span class="cm">	 */</span>
	<span class="n">actual_wanted</span> <span class="o">=</span> <span class="n">__ceph_caps_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">wanted</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">actual_wanted</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">actual_wanted</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_ANY_WR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; issued %s, mds wanted %s, actual %s, queueing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">issued</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">wanted</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">actual_wanted</span><span class="p">));</span>
		<span class="n">__cap_delay_requeue</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FLAG_AUTH</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">==</span> <span class="n">cap</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_vinop</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">cap</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">issued</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">issued</span><span class="o">|</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span> <span class="n">seq</span><span class="p">,</span> <span class="n">mds</span><span class="p">);</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_id</span> <span class="o">=</span> <span class="n">cap_id</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">=</span> <span class="n">issued</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">|=</span> <span class="n">issued</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span> <span class="o">|=</span> <span class="n">wanted</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">issue_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">mseq</span> <span class="o">=</span> <span class="n">mseq</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_gen</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_gen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fmode</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">__ceph_get_fmode</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">fmode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if cap has not timed out and belongs to the current</span>
<span class="cm"> * generation of the MDS session (i.e. has not gone &#39;stale&#39; due to</span>
<span class="cm"> * us losing touch with the mds).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cap_is_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gen</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_gen_ttl_lock</span><span class="p">);</span>
	<span class="n">gen</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_gen</span><span class="p">;</span>
	<span class="n">ttl</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_ttl</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_gen_ttl_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_gen</span> <span class="o">&lt;</span> <span class="n">gen</span> <span class="o">||</span> <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">ttl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__cap_is_valid %p cap %p issued %s &quot;</span>
		     <span class="s">&quot;but STALE (gen %u vs %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
		     <span class="n">cap</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_gen</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return set of valid cap bits issued to us.  Note that caps time</span>
<span class="cm"> * out, and may be invalidated in bulk if the client session times out</span>
<span class="cm"> * and session-&gt;s_cap_gen is bumped.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ceph_caps_issued</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">implemented</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">have</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_caps</span> <span class="o">|</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_issued</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">implemented</span><span class="p">)</span>
		<span class="o">*</span><span class="n">implemented</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__cap_is_valid</span><span class="p">(</span><span class="n">cap</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__ceph_caps_issued %p cap %p issued %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">));</span>
		<span class="n">have</span> <span class="o">|=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">implemented</span><span class="p">)</span>
			<span class="o">*</span><span class="n">implemented</span> <span class="o">|=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">have</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get cap bits issued by caps other than @ocap</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ceph_caps_issued_other</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">ocap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">have</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_caps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">ocap</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__cap_is_valid</span><span class="p">(</span><span class="n">cap</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">have</span> <span class="o">|=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">have</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move a cap to the end of the LRU (oldest caps at list head, newest</span>
<span class="cm"> * at list tail).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__touch_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_cap_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_cap_iterator</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__touch_cap %p cap %p mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span>
		     <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">session_caps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_caps</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__touch_cap %p cap %p mds%d NOP, iterating over caps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_cap_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if we hold the given mask.  If so, move the cap(s) to the</span>
<span class="cm"> * front of their respective LRUs.  (This is the preferred way for</span>
<span class="cm"> * callers to check for caps they want.)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ceph_caps_issued_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">touch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_caps</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">have</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__ceph_caps_issued_mask %p snap issued %s&quot;</span>
		     <span class="s">&quot; (mask %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">have</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">mask</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__cap_is_valid</span><span class="p">(</span><span class="n">cap</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__ceph_caps_issued_mask %p cap %p issued %s&quot;</span>
			     <span class="s">&quot; (mask %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">mask</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">touch</span><span class="p">)</span>
				<span class="n">__touch_cap</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* does a combination of caps satisfy mask? */</span>
		<span class="n">have</span> <span class="o">|=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">have</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__ceph_caps_issued_mask %p combo issued %s&quot;</span>
			     <span class="s">&quot; (mask %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">mask</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">touch</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

				<span class="cm">/* touch this + preceding caps */</span>
				<span class="n">__touch_cap</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">q</span> <span class="o">!=</span> <span class="n">p</span><span class="p">;</span>
				     <span class="n">q</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span>
						       <span class="n">ci_node</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__cap_is_valid</span><span class="p">(</span><span class="n">cap</span><span class="p">))</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="n">__touch_cap</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if mask caps are currently being revoked by an MDS.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_caps_revoking</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__cap_is_valid</span><span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;ceph_caps_revoking %p %s = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__ceph_caps_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_pin_ref</span><span class="p">)</span>
		<span class="n">used</span> <span class="o">|=</span> <span class="n">CEPH_CAP_PIN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rd_ref</span><span class="p">)</span>
		<span class="n">used</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_RD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_ref</span> <span class="o">||</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span><span class="p">)</span>
		<span class="n">used</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_CACHE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wr_ref</span><span class="p">)</span>
		<span class="n">used</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span> <span class="o">||</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="p">)</span>
		<span class="n">used</span> <span class="o">|=</span> <span class="n">CEPH_CAP_FILE_BUFFER</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wanted, by virtue of open file modes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ceph_caps_file_wanted</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">want</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mode</span> <span class="o">&lt;</span> <span class="n">CEPH_FILE_MODE_NUM</span><span class="p">;</span> <span class="n">mode</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_nr_by_mode</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
			<span class="n">want</span> <span class="o">|=</span> <span class="n">ceph_caps_for_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">want</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return caps we have registered with the MDS(s) as &#39;wanted&#39;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ceph_caps_mds_wanted</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mds_wanted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__cap_is_valid</span><span class="p">(</span><span class="n">cap</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">mds_wanted</span> <span class="o">|=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mds_wanted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called under i_ceph_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ceph_is_any_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">)</span> <span class="o">||</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mds</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a cap.  Take steps to deal with a racing iterate_session_caps.</span>
<span class="cm"> *</span>
<span class="cm"> * caller should hold i_ceph_lock.</span>
<span class="cm"> * caller will not hold session s_mutex if called from destroy_inode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__ceph_remove_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span>
		<span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__ceph_remove_cap %p from %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>

	<span class="cm">/* remove from session list */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_iterator</span> <span class="o">==</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not yet, we are iterating over this very cap */</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__ceph_remove_cap  delaying %p removal from session %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">cap</span><span class="p">,</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">session_caps</span><span class="p">);</span>
		<span class="n">session</span><span class="o">-&gt;</span><span class="n">s_nr_caps</span><span class="o">--</span><span class="p">;</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">removed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* protect backpointer with s_cap_lock: see iterate_session_caps */</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_lock</span><span class="p">);</span>

	<span class="cm">/* remove from inode list */</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">==</span> <span class="n">cap</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">removed</span><span class="p">)</span>
		<span class="n">ceph_put_cap</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__ceph_is_any_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_snap_realm</span> <span class="o">*</span><span class="n">realm</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm_item</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm_counter</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realm</span><span class="o">-&gt;</span><span class="n">inodes_with_caps_lock</span><span class="p">);</span>
		<span class="n">ceph_put_snap_realm</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">realm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__ceph_is_any_real_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span>
		<span class="n">__cap_delay_cancel</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build and send a cap message to the given MDS.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller should be holding s_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_cap_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">caps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wanted</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flush_tid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">issue_seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mseq</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">max_size</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">mtime</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">atime</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">time_warp_seq</span><span class="p">,</span>
			<span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">xattr_version</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ceph_buffer</span> <span class="o">*</span><span class="n">xattrs_buf</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">follows</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_caps</span> <span class="o">*</span><span class="n">fc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;send_cap_msg %s %llx %llx caps %s wanted %s dirty %s&quot;</span>
	     <span class="s">&quot; seq %u/%u mseq %u follows %lld size %llu/%llu&quot;</span>
	     <span class="s">&quot; xattr_ver %llu xattr_len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ceph_cap_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">),</span>
	     <span class="n">cid</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">caps</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">wanted</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">dirty</span><span class="p">),</span>
	     <span class="n">seq</span><span class="p">,</span> <span class="n">issue_seq</span><span class="p">,</span> <span class="n">mseq</span><span class="p">,</span> <span class="n">follows</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span>
	     <span class="n">xattr_version</span><span class="p">,</span> <span class="n">xattrs_buf</span> <span class="o">?</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">xattrs_buf</span><span class="o">-&gt;</span><span class="n">vec</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">ceph_msg_new</span><span class="p">(</span><span class="n">CEPH_MSG_CLIENT_CAPS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fc</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">flush_tid</span><span class="p">);</span>

	<span class="n">fc</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fc</span><span class="p">));</span>

	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">cap_id</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">cid</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">issue_seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">issue_seq</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">migrate_seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mseq</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">caps</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">wanted</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">wanted</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dirty</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">snap_follows</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">follows</span><span class="p">);</span>

	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">max_size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">max_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtime</span><span class="p">)</span>
		<span class="n">ceph_encode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">,</span> <span class="n">mtime</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atime</span><span class="p">)</span>
		<span class="n">ceph_encode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">,</span> <span class="n">atime</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">time_warp_seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">time_warp_seq</span><span class="p">);</span>

	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">uid</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">gid</span><span class="p">);</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>

	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">xattr_version</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">xattr_version</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xattrs_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">middle</span> <span class="o">=</span> <span class="n">ceph_buffer_get</span><span class="p">(</span><span class="n">xattrs_buf</span><span class="p">);</span>
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">xattr_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">xattrs_buf</span><span class="o">-&gt;</span><span class="n">vec</span><span class="p">.</span><span class="n">iov_len</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">middle_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">xattrs_buf</span><span class="o">-&gt;</span><span class="n">vec</span><span class="p">.</span><span class="n">iov_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ceph_con_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_con</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__queue_cap_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cap_id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">migrate_seq</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">issue_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_cap_release</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_cap_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_num_cap_releases</span><span class="p">);</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_releases</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ceph_msg</span><span class="p">,</span> <span class="n">list_head</span><span class="p">);</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot; adding %llx release to mds%d msg %p (%d left)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ino</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_num_cap_releases</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">cap_id</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">cap_id</span><span class="p">);</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">migrate_seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">migrate_seq</span><span class="p">);</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">issue_seq</span><span class="p">);</span>

	<span class="n">session</span><span class="o">-&gt;</span><span class="n">s_num_cap_releases</span><span class="o">--</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span> <span class="o">==</span> <span class="n">CEPH_CAPS_PER_RELEASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; release msg %p full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">list_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_releases_done</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; release msg %p at %d/%d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">),</span>
		     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">CEPH_CAPS_PER_RELEASE</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue cap releases when an inode is dropped from our cache.  Since</span>
<span class="cm"> * inode is about to be destroyed, there is no need for i_ceph_lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_queue_caps_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

		<span class="n">__queue_cap_release</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">ceph_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_id</span><span class="p">,</span>
				    <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mseq</span><span class="p">,</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issue_seq</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">__ceph_remove_cap</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send a cap msg on the given inode.  Update our caps state, then</span>
<span class="cm"> * drop i_ceph_lock and send the message.</span>
<span class="cm"> *</span>
<span class="cm"> * Make note of max_size reported/requested from mds, revoked caps</span>
<span class="cm"> * that have now been implemented.</span>
<span class="cm"> *</span>
<span class="cm"> * Make half-hearted attempt ot to invalidate page cache if we are</span>
<span class="cm"> * dropping RDCACHE.  Note that this will leave behind locked pages</span>
<span class="cm"> * that we&#39;ll then need to deal with elsewhere.</span>
<span class="cm"> *</span>
<span class="cm"> * Return non-zero if delayed release, or we experienced an error</span>
<span class="cm"> * such that the caller should requeue + retry later.</span>
<span class="cm"> *</span>
<span class="cm"> * called with i_ceph_lock, then drops it.</span>
<span class="cm"> * caller should hold snap_rwsem (read), s_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__send_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">used</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want</span><span class="p">,</span> <span class="kt">int</span> <span class="n">retain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flushing</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="o">*</span><span class="n">pflush_tid</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cap_id</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">held</span><span class="p">,</span> <span class="n">revoking</span><span class="p">,</span> <span class="n">dropping</span><span class="p">,</span> <span class="n">keep</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">seq</span><span class="p">,</span> <span class="n">issue_seq</span><span class="p">,</span> <span class="n">mseq</span><span class="p">,</span> <span class="n">time_warp_seq</span><span class="p">,</span> <span class="n">follows</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">mtime</span><span class="p">,</span> <span class="n">atime</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">xattr_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_buffer</span> <span class="o">*</span><span class="n">xattr_blob</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delayed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flush_tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">held</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">|</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span><span class="p">;</span>
	<span class="n">revoking</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">;</span>
	<span class="n">retain</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">revoking</span><span class="p">;</span>
	<span class="n">dropping</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">retain</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__send_cap %p cap %p session %p %s -&gt; %s (revoking %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">held</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">held</span> <span class="o">&amp;</span> <span class="n">retain</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">revoking</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">retain</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_PIN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">session</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="cm">/* don&#39;t release wanted unless we&#39;ve waited a bit. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">CEPH_I_NODELAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_min</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; delaying issued %s -&gt; %s, wanted %s -&gt; %s on send</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">retain</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">want</span><span class="p">));</span>
		<span class="n">want</span> <span class="o">|=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span><span class="p">;</span>
		<span class="n">retain</span> <span class="o">|=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">;</span>
		<span class="n">delayed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CEPH_I_NODELAY</span> <span class="o">|</span> <span class="n">CEPH_I_FLUSH</span><span class="p">);</span>

	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;=</span> <span class="n">retain</span><span class="p">;</span>  <span class="cm">/* drop bits we don&#39;t want */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wake up any waiters on wanted -&gt; needed transition.</span>
<span class="cm">		 * This is due to the weird transition from buffered</span>
<span class="cm">		 * to sync IO... we need to flush dirty pages _before_</span>
<span class="cm">		 * allowing sync writes to avoid reordering.</span>
<span class="cm">		 */</span>
		<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">&amp;=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">|</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span> <span class="o">=</span> <span class="n">want</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flushing</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * assign a tid for flush operations so we can avoid</span>
<span class="cm">		 * flush1 -&gt; dirty1 -&gt; flush2 -&gt; flushack1 -&gt; mark</span>
<span class="cm">		 * clean type races.  track latest tid for every bit</span>
<span class="cm">		 * so we can handle flush AxFw, flush Fw, and have the</span>
<span class="cm">		 * first ack clean Ax.</span>
<span class="cm">		 */</span>
		<span class="n">flush_tid</span> <span class="o">=</span> <span class="o">++</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_last_tid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pflush_tid</span><span class="p">)</span>
			<span class="o">*</span><span class="n">pflush_tid</span> <span class="o">=</span> <span class="n">flush_tid</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; cap_flush_tid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">flush_tid</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CEPH_CAP_BITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flushing</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_tid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">flush_tid</span><span class="p">;</span>

		<span class="n">follows</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">follows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">keep</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span><span class="p">;</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">issue_seq</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issue_seq</span><span class="p">;</span>
	<span class="n">mseq</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mseq</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_reported_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">max_size</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_requested_max_size</span> <span class="o">=</span> <span class="n">max_size</span><span class="p">;</span>
	<span class="n">mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">;</span>
	<span class="n">atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">;</span>
	<span class="n">time_warp_seq</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_time_warp_seq</span><span class="p">;</span>
	<span class="n">uid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">;</span>
	<span class="n">gid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">;</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flushing</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_XATTR_EXCL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__ceph_build_xattrs_blob</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
		<span class="n">xattr_blob</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="p">;</span>
		<span class="n">xattr_version</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">version</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">send_cap_msg</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">ceph_vino</span><span class="p">(</span><span class="n">inode</span><span class="p">).</span><span class="n">ino</span><span class="p">,</span> <span class="n">cap_id</span><span class="p">,</span>
		<span class="n">op</span><span class="p">,</span> <span class="n">keep</span><span class="p">,</span> <span class="n">want</span><span class="p">,</span> <span class="n">flushing</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">flush_tid</span><span class="p">,</span> <span class="n">issue_seq</span><span class="p">,</span> <span class="n">mseq</span><span class="p">,</span>
		<span class="n">size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atime</span><span class="p">,</span> <span class="n">time_warp_seq</span><span class="p">,</span>
		<span class="n">uid</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">xattr_version</span><span class="p">,</span> <span class="n">xattr_blob</span><span class="p">,</span>
		<span class="n">follows</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;error sending cap msg, must requeue %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">delayed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">delayed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a snapshot is taken, clients accumulate dirty metadata on</span>
<span class="cm"> * inodes with capabilities in ceph_cap_snaps to describe the file</span>
<span class="cm"> * state at the time the snapshot was taken.  This must be flushed</span>
<span class="cm"> * asynchronously back to the MDS once sync writes complete and dirty</span>
<span class="cm"> * data is written out.</span>
<span class="cm"> *</span>
<span class="cm"> * Unless @again is true, skip cap_snaps that were already sent to</span>
<span class="cm"> * the MDS (i.e., during this session).</span>
<span class="cm"> *</span>
<span class="cm"> * Called under i_ceph_lock.  Takes s_mutex as needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__ceph_flush_snaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">**</span><span class="n">psession</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">again</span><span class="p">)</span>
		<span class="n">__releases</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">)</span>
		<span class="n">__acquires</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mseq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">ceph_inode_to_client</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* if session != NULL, we hold</span>
<span class="cm">						    session-&gt;s_mutex */</span>
	<span class="n">u64</span> <span class="n">next_follows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* keep track of how far we&#39;ve gotten through the</span>
<span class="cm">			     i_cap_snaps list, and skip these entries next time</span>
<span class="cm">			     around to avoid an infinite loop */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psession</span><span class="p">)</span>
		<span class="n">session</span> <span class="o">=</span> <span class="o">*</span><span class="n">psession</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__flush_snaps %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="nl">retry:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">capsnap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">,</span> <span class="n">ci_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* avoid an infiniute loop after retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">follows</span> <span class="o">&lt;</span> <span class="n">next_follows</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * we need to wait for sync writes to complete and for dirty</span>
<span class="cm">		 * pages to be written out.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span> <span class="o">||</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">writing</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if cap writeback already occurred, we should have dropped</span>
<span class="cm">		 * the capsnap in ceph_put_wrbuffer_cap_refs.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* pick mds, take s_mutex */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;no auth cap (migrating?), doing nothing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* only flush each capsnap once */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">again</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flushing_item</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;already flushed %p, skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mds</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">;</span>
		<span class="n">mseq</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="o">-&gt;</span><span class="n">mseq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">session</span> <span class="o">&amp;&amp;</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span> <span class="o">!=</span> <span class="n">mds</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;oops, wrong session %p mutex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
			<span class="n">ceph_put_mds_session</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
			<span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">session</span> <span class="o">=</span> <span class="n">__ceph_lookup_mds_session</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">mds</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;inverting session/ino locks on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">session</span><span class="p">);</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * if session == NULL, we raced against a cap</span>
<span class="cm">			 * deletion or migration.  retry, and we&#39;ll</span>
<span class="cm">			 * get a better @mds value next time.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flush_tid</span> <span class="o">=</span> <span class="o">++</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_last_tid</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">nref</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flushing_item</span><span class="p">))</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flushing_item</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flushing_item</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_snaps_flushing</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;flush_snaps %p cap_snap %p follows %lld tid %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">follows</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flush_tid</span><span class="p">);</span>
		<span class="n">send_cap_msg</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">ceph_vino</span><span class="p">(</span><span class="n">inode</span><span class="p">).</span><span class="n">ino</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">CEPH_CAP_OP_FLUSHSNAP</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flush_tid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mseq</span><span class="p">,</span>
			     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">,</span>
			     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">time_warp_seq</span><span class="p">,</span>
			     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span>
			     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">xattr_version</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">xattr_blob</span><span class="p">,</span>
			     <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">follows</span><span class="p">);</span>

		<span class="n">next_follows</span> <span class="o">=</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">follows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ceph_put_cap_snap</span><span class="p">(</span><span class="n">capsnap</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we flushed them all; remove this inode from the queue */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_flush_item</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_flush_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psession</span><span class="p">)</span>
		<span class="o">*</span><span class="n">psession</span> <span class="o">=</span> <span class="n">session</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
		<span class="n">ceph_put_mds_session</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ceph_flush_snaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">__ceph_flush_snaps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark caps dirty.  If inode is newly dirty, return the dirty flags.</span>
<span class="cm"> * Caller is then responsible for calling __mark_inode_dirty with the</span>
<span class="cm"> * returned flags value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ceph_mark_dirty_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span>
		<span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__mark_dirty_caps %p %s dirty %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">was</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">was</span> <span class="o">|</span> <span class="n">mask</span><span class="p">));</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">was</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="p">)</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span> <span class="o">=</span> <span class="n">ceph_get_snap_context</span><span class="p">(</span>
				<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_snap_realm</span><span class="o">-&gt;</span><span class="n">cached_context</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; inode %p now dirty snapc %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">));</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">dirty</span> <span class="o">|=</span> <span class="n">I_DIRTY_SYNC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">was</span> <span class="o">|</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_BUFFER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_BUFFER</span><span class="p">))</span>
		<span class="n">dirty</span> <span class="o">|=</span> <span class="n">I_DIRTY_DATASYNC</span><span class="p">;</span>
	<span class="n">__cap_delay_requeue</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dirty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add dirty inode to the flushing list.  Assigned a seq number so we</span>
<span class="cm"> * can wait for caps to flush without starving.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under i_ceph_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__mark_caps_flushing</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">flushing</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">));</span>

	<span class="n">flushing</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span><span class="p">;</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__mark_caps_flushing flushing %s, flushing_caps %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">flushing</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">|</span> <span class="n">flushing</span><span class="p">));</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">|=</span> <span class="n">flushing</span><span class="p">;</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot; inode %p now !dirty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">);</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_seq</span> <span class="o">=</span> <span class="o">++</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_flush_seq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_item</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_flushing</span><span class="p">);</span>
		<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">num_cap_flushing</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; inode %p now flushing seq %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_seq</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_flushing</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; inode %p now flushing (more) seq %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_seq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">flushing</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * try to invalidate mapping pages without blocking.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_nonblocking_invalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">invalidating_gen</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">invalidate_mapping_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">invalidating_gen</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* success. */</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;try_nonblocking_invalidate %p success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="cm">/* save any racing async invalidate some trouble */</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;try_nonblocking_invalidate %p failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Swiss army knife function to examine currently used and wanted</span>
<span class="cm"> * versus held caps.  Release, flush, ack revoked caps to mds as</span>
<span class="cm"> * appropriate.</span>
<span class="cm"> *</span>
<span class="cm"> *  CHECK_CAPS_NODELAY - caller is delayed work and we should not delay</span>
<span class="cm"> *    cap release further.</span>
<span class="cm"> *  CHECK_CAPS_AUTHONLY - we should only check the auth cap</span>
<span class="cm"> *  CHECK_CAPS_FLUSH - we should flush any dirty caps immediately, without</span>
<span class="cm"> *    further delay.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_check_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_fs_client</span> <span class="o">*</span><span class="n">fsc</span> <span class="o">=</span> <span class="n">ceph_inode_to_client</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">fsc</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">file_wanted</span><span class="p">,</span> <span class="n">used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">took_snap_rwsem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>             <span class="cm">/* true if mdsc-&gt;snap_rwsem held */</span>
	<span class="kt">int</span> <span class="n">issued</span><span class="p">,</span> <span class="n">implemented</span><span class="p">,</span> <span class="n">want</span><span class="p">,</span> <span class="n">retain</span><span class="p">,</span> <span class="n">revoking</span><span class="p">,</span> <span class="n">flushing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/* keep track of how far we&#39;ve gone through i_caps list</span>
<span class="cm">			   to avoid an infinite loop on retry */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tried_invalidate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delayed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">force_requeue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queue_invalidate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_delayed</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CHECK_CAPS_NODELAY</span><span class="p">;</span>

	<span class="cm">/* if we are unmounting, flush any unused caps immediately. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">stopping</span><span class="p">)</span>
		<span class="n">is_delayed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">CEPH_I_FLUSH</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">CHECK_CAPS_FLUSH</span><span class="p">;</span>

	<span class="cm">/* flush snaps first time around only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">))</span>
		<span class="n">__ceph_flush_snaps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry_locked</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="nl">retry_locked:</span>
	<span class="n">file_wanted</span> <span class="o">=</span> <span class="n">__ceph_caps_file_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="n">want</span> <span class="o">=</span> <span class="n">file_wanted</span> <span class="o">|</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">issued</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">implemented</span><span class="p">);</span>
	<span class="n">revoking</span> <span class="o">=</span> <span class="n">implemented</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">issued</span><span class="p">;</span>

	<span class="n">retain</span> <span class="o">=</span> <span class="n">want</span> <span class="o">|</span> <span class="n">CEPH_CAP_PIN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">stopping</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retain</span> <span class="o">|=</span> <span class="n">CEPH_CAP_ANY</span><span class="p">;</span>       <span class="cm">/* be greedy */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">retain</span> <span class="o">|=</span> <span class="n">CEPH_CAP_ANY_SHARED</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * keep RD only if we didn&#39;t have the file open RW,</span>
<span class="cm">			 * because then the mds would revoke it anyway to</span>
<span class="cm">			 * journal max_size=0.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">retain</span> <span class="o">|=</span> <span class="n">CEPH_CAP_ANY_RD</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;check_caps %p file_want %s used %s dirty %s flushing %s&quot;</span>
	     <span class="s">&quot; issued %s revoking %s retain %s %s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">file_wanted</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">used</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">issued</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">revoking</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">retain</span><span class="p">),</span>
	     <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CHECK_CAPS_AUTHONLY</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; AUTHONLY&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	     <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CHECK_CAPS_NODELAY</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; NODELAY&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	     <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CHECK_CAPS_FLUSH</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; FLUSH&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we no longer need to hold onto old our caps, and we may</span>
<span class="cm">	 * have cached pages, but don&#39;t want them, then try to invalidate.</span>
<span class="cm">	 * If we fail, it&#39;s because pages are locked.... try again later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">is_delayed</span> <span class="o">||</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">stopping</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>               <span class="cm">/* no dirty pages... */</span>
	    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span> <span class="o">&amp;&amp;</span>                 <span class="cm">/* have cached pages */</span>
	    <span class="p">(</span><span class="n">file_wanted</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>                     <span class="cm">/* no open files */</span>
	     <span class="p">(</span><span class="n">revoking</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_FILE_CACHE</span><span class="o">|</span>
			  <span class="n">CEPH_CAP_FILE_LAZYIO</span><span class="p">)))</span> <span class="o">&amp;&amp;</span> <span class="cm">/*  or revoking cache */</span>
	    <span class="o">!</span><span class="n">tried_invalidate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;check_caps trying to invalidate on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">try_nonblocking_invalidate</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">revoking</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CEPH_CAP_FILE_CACHE</span><span class="o">|</span>
					<span class="n">CEPH_CAP_FILE_LAZYIO</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;check_caps queuing invalidate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">queue_invalidate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;check_caps failed to invalidate pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="cm">/* we failed to invalidate pages.  check these</span>
<span class="cm">				   caps again later. */</span>
				<span class="n">force_requeue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">__cap_set_timeouts</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">tried_invalidate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry_locked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* avoid looping forever */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mds</span> <span class="o">&gt;=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CHECK_CAPS_AUTHONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cap</span> <span class="o">!=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* NOTE: no side-effects allowed, until we take s_mutex */</span>

		<span class="n">revoking</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; mds%d cap %p issued %s implemented %s revoking %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">revoking</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* request larger max_size from MDS? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span> <span class="o">&gt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span> <span class="o">&gt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_requested_max_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;requesting new max_size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* approaching file_max? */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_reported_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;i_size approaching max_size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* flush anything dirty? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CHECK_CAPS_FLUSH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;flushing dirty caps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* completed revocation? going down and there are no caps? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revoking</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">revoking</span> <span class="o">&amp;</span> <span class="n">used</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;completed revocation of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* want more caps from mds? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span> <span class="o">|</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>

		<span class="cm">/* things we might delay */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">retain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span> <span class="o">==</span> <span class="n">want</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>     <span class="cm">/* nope, all good */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_delayed</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>

		<span class="cm">/* delay? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">CEPH_I_NODELAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_max</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; delaying issued %s -&gt; %s, wanted %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">retain</span><span class="p">),</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span><span class="p">),</span>
			     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">want</span><span class="p">));</span>
			<span class="n">delayed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">ack:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">CEPH_I_NOFLUSH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; skipping %p I_NOFLUSH set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">session</span> <span class="o">&amp;&amp;</span> <span class="n">session</span> <span class="o">!=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;oops, wrong session %p mutex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
			<span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">session</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;inverting session/ino locks on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">session</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">took_snap_rwsem</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
					<span class="n">took_snap_rwsem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* take snap_rwsem after session mutex */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">took_snap_rwsem</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;inverting snap/in locks on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">inode</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
				<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
				<span class="n">took_snap_rwsem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">took_snap_rwsem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span> <span class="o">&amp;&amp;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span><span class="p">)</span>
			<span class="n">flushing</span> <span class="o">=</span> <span class="n">__mark_caps_flushing</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">flushing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">mds</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds</span><span class="p">;</span>  <span class="cm">/* remember mds, so we don&#39;t repeat */</span>
		<span class="n">sent</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* __send_cap drops i_ceph_lock */</span>
		<span class="n">delayed</span> <span class="o">+=</span> <span class="n">__send_cap</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">CEPH_CAP_OP_UPDATE</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">want</span><span class="p">,</span>
				      <span class="n">retain</span><span class="p">,</span> <span class="n">flushing</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span> <span class="cm">/* retake i_ceph_lock and restart our cap scan. */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reschedule delayed caps release if we delayed anything,</span>
<span class="cm">	 * otherwise cancel.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delayed</span> <span class="o">&amp;&amp;</span> <span class="n">is_delayed</span><span class="p">)</span>
		<span class="n">force_requeue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* __send_cap delayed release; requeue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delayed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_delayed</span><span class="p">)</span>
		<span class="n">__cap_delay_cancel</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_delayed</span> <span class="o">||</span> <span class="n">force_requeue</span><span class="p">)</span>
		<span class="n">__cap_delay_requeue</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue_invalidate</span><span class="p">)</span>
		<span class="n">ceph_queue_invalidate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">session</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">took_snap_rwsem</span><span class="p">)</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to flush dirty caps back to the auth mds.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_flush_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="o">*</span><span class="n">flush_tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">unlock_session</span> <span class="o">=</span> <span class="n">session</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flushing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">CEPH_I_NOFLUSH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;try_flush_caps skipping %p I_NOFLUSH set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span> <span class="o">&amp;&amp;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">used</span> <span class="o">=</span> <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">want</span> <span class="o">=</span> <span class="n">__ceph_caps_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">delayed</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="n">session</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">session</span> <span class="o">!=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">&lt;</span> <span class="n">CEPH_MDS_SESSION_OPEN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">flushing</span> <span class="o">=</span> <span class="n">__mark_caps_flushing</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>

		<span class="cm">/* __send_cap drops i_ceph_lock */</span>
		<span class="n">delayed</span> <span class="o">=</span> <span class="n">__send_cap</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">CEPH_CAP_OP_FLUSH</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">want</span><span class="p">,</span>
				     <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">|</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span><span class="p">,</span> <span class="n">flushing</span><span class="p">,</span>
				     <span class="n">flush_tid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delayed</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlocked</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="n">__cap_delay_requeue</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="nl">out_unlocked:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session</span> <span class="o">&amp;&amp;</span> <span class="n">unlock_session</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">flushing</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if we&#39;ve flushed caps through the given flush_tid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">caps_are_flushed</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CEPH_CAP_BITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_tid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tid</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* still flushing this bit */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait on any unsafe replies for the given inode.  First wait on the</span>
<span class="cm"> * newest request, and make that the upper bound.  Then, if there are</span>
<span class="cm"> * more requests, keep waiting on the oldest as long as it is still older</span>
<span class="cm"> * than the original request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_write_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_unsafe_writes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_osd_request</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_tid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_unsafe_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* set upper bound as _last_ entry in chain */</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_osd_request</span><span class="p">,</span>
			 <span class="n">r_unsafe_item</span><span class="p">);</span>
	<span class="n">last_tid</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_tid</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ceph_osdc_get_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_unsafe_lock</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;sync_write_wait on tid %llu (until %llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">req</span><span class="o">-&gt;</span><span class="n">r_tid</span><span class="p">,</span> <span class="n">last_tid</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_safe_completion</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_unsafe_lock</span><span class="p">);</span>
		<span class="n">ceph_osdc_put_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * from here on look at first entry in chain, since we</span>
<span class="cm">		 * only want to wait for anything older than last_tid</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_osd_request</span><span class="p">,</span>
				 <span class="n">r_unsafe_item</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">r_tid</span> <span class="o">&lt;</span> <span class="n">last_tid</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_unsafe_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ceph_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">flush_tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fsync %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">datasync</span> <span class="o">?</span> <span class="s">&quot; datasync&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">sync_write_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">dirty</span> <span class="o">=</span> <span class="n">try_flush_caps</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_tid</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fsync dirty caps are %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">dirty</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * only wait on non-file metadata writeback (the mds</span>
<span class="cm">	 * can recover size and mtime, so we don&#39;t need to</span>
<span class="cm">	 * wait for that)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">datasync</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CEPH_CAP_ANY_FILE_WR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fsync waiting for flush_tid %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">flush_tid</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">,</span>
				       <span class="n">caps_are_flushed</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">flush_tid</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;fsync %p%s done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">datasync</span> <span class="o">?</span> <span class="s">&quot; datasync&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush any dirty caps back to the mds.  If we aren&#39;t asked to wait,</span>
<span class="cm"> * queue inode for flush but don&#39;t do so immediately, because we can</span>
<span class="cm"> * get by with fewer MDS messages if we wait for data writeback to</span>
<span class="cm"> * complete first.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">flush_tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;write_inode %p wait=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="n">try_flush_caps</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flush_tid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">,</span>
				       <span class="n">caps_are_flushed</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">flush_tid</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span>
			<span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ceph_caps_dirty</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span>
			<span class="n">__cap_delay_requeue_front</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After a recovering MDS goes active, we need to resend any caps</span>
<span class="cm"> * we were flushing.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller holds session-&gt;s_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kick_flushing_capsnaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;kick_flushing_capsnaps mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">capsnap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_snaps_flushing</span><span class="p">,</span>
			    <span class="n">flushing_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">ci</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;&amp;</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">==</span> <span class="n">session</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;kick_flushing_caps %p cap %p capsnap %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
			     <span class="n">cap</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">);</span>
			<span class="n">__ceph_flush_snaps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%p auth cap %p not mds%d ???</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
			       <span class="n">cap</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ceph_kick_flushing_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>

	<span class="n">kick_flushing_capsnaps</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;kick_flushing_caps mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_flushing</span><span class="p">,</span> <span class="n">i_flushing_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">delayed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="n">cap</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;&amp;</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">==</span> <span class="n">session</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;kick_flushing_caps %p cap %p %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
			     <span class="n">cap</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">));</span>
			<span class="n">delayed</span> <span class="o">=</span> <span class="n">__send_cap</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">CEPH_CAP_OP_FLUSH</span><span class="p">,</span>
					     <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="n">ci</span><span class="p">),</span>
					     <span class="n">__ceph_caps_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">),</span>
					     <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">|</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span><span class="p">,</span>
					     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delayed</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
				<span class="n">__cap_delay_requeue</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%p auth cap %p not mds%d ???</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
			       <span class="n">cap</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kick_flushing_inode_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delayed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="p">;</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;kick_flushing_inode_caps %p flushing %s flush_seq %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">),</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_seq</span><span class="p">);</span>
	<span class="n">__ceph_flush_snaps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delayed</span> <span class="o">=</span> <span class="n">__send_cap</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">CEPH_CAP_OP_FLUSH</span><span class="p">,</span>
				     <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="n">ci</span><span class="p">),</span>
				     <span class="n">__ceph_caps_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">),</span>
				     <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">|</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span><span class="p">,</span>
				     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delayed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
			<span class="n">__cap_delay_requeue</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">ci</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Take references to capabilities we hold, so that we don&#39;t release</span>
<span class="cm"> * them to the MDS prematurely.</span>
<span class="cm"> *</span>
<span class="cm"> * Protected by i_ceph_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__take_cap_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">got</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">got</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_PIN</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_pin_ref</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">got</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_RD</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rd_ref</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">got</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_CACHE</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_ref</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">got</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wr_ref</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">got</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_BUFFER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ihold</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;__take_cap_refs %p wb %d -&gt; %d (?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to grab cap references.  Specify those refs we @want, and the</span>
<span class="cm"> * minimal set we @need.  Also include the larger offset we are writing</span>
<span class="cm"> * to (when applicable), and check against max_size here as well.</span>
<span class="cm"> * Note that caller is responsible for ensuring max_size increases are</span>
<span class="cm"> * requested from the MDS.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_get_cap_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">need</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="o">*</span><span class="n">got</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">endoff</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">check_max</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">have</span><span class="p">,</span> <span class="n">implemented</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">file_wanted</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_cap_refs %p need %s want %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">need</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">want</span><span class="p">));</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="cm">/* make sure file is actually open */</span>
	<span class="n">file_wanted</span> <span class="o">=</span> <span class="n">__ceph_caps_file_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">file_wanted</span> <span class="o">&amp;</span> <span class="n">need</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;try_get_cap_refs need %s file_wanted %s, EBADF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">need</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">file_wanted</span><span class="p">));</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endoff</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">endoff</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_cap_refs %p endoff %llu &gt; maxsize %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">inode</span><span class="p">,</span> <span class="n">endoff</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">endoff</span> <span class="o">&gt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">check_max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If a sync write is in progress, we must wait, so that we</span>
<span class="cm">		 * can get a final snapshot value for size+mtime.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ceph_have_pending_cap_snap</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_cap_refs %p cap_snap_pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">have</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">implemented</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * disallow writes while a truncate is pending</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_truncate_pending</span><span class="p">)</span>
		<span class="n">have</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CEPH_CAP_FILE_WR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">have</span> <span class="o">&amp;</span> <span class="n">need</span><span class="p">)</span> <span class="o">==</span> <span class="n">need</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Look at (implemented &amp; ~have &amp; not) so that we keep waiting</span>
<span class="cm">		 * on transition from wanted -&gt; needed caps.  This is needed</span>
<span class="cm">		 * for WRBUFFER|WR -&gt; WR to avoid a new WR sync write from</span>
<span class="cm">		 * going before a prior buffered writeback happens.</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">not</span> <span class="o">=</span> <span class="n">want</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">have</span> <span class="o">&amp;</span> <span class="n">need</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">revoking</span> <span class="o">=</span> <span class="n">implemented</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">have</span><span class="p">;</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_cap_refs %p have %s but not %s (revoking %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">have</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">not</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">revoking</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">revoking</span> <span class="o">&amp;</span> <span class="n">not</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">got</span> <span class="o">=</span> <span class="n">need</span> <span class="o">|</span> <span class="p">(</span><span class="n">have</span> <span class="o">&amp;</span> <span class="n">want</span><span class="p">);</span>
			<span class="n">__take_cap_refs</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">*</span><span class="n">got</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_cap_refs %p have %s needed %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">have</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">need</span><span class="p">));</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;get_cap_refs %p ret %d got %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
	     <span class="n">ret</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="o">*</span><span class="n">got</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check the offset we are writing up to against our current</span>
<span class="cm"> * max_size.  If necessary, tell the MDS we want to write to</span>
<span class="cm"> * a larger offset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_max_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">endoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* do we need to explicitly request a larger max_size? */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">endoff</span> <span class="o">&gt;=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">||</span>
	     <span class="n">endoff</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">endoff</span> <span class="o">&gt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;write %p at large endoff %llu, req max_size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">endoff</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span> <span class="o">=</span> <span class="n">endoff</span><span class="p">;</span>
		<span class="n">check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">)</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">CHECK_CAPS_AUTHONLY</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for caps, and take cap references.  If we can&#39;t get a WR cap</span>
<span class="cm"> * due to a small max_size, make sure we check_max_size (and possibly</span>
<span class="cm"> * ask the mds) so we don&#39;t get hung up indefinitely.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_get_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">need</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">got</span><span class="p">,</span>
		  <span class="n">loff_t</span> <span class="n">endoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">check_max</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">endoff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">check_max_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span> <span class="n">endoff</span><span class="p">);</span>
	<span class="n">check_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">,</span>
				       <span class="n">try_get_cap_refs</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">need</span><span class="p">,</span> <span class="n">want</span><span class="p">,</span>
							<span class="n">got</span><span class="p">,</span> <span class="n">endoff</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">check_max</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_max</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take cap refs.  Caller must already know we hold at least one ref</span>
<span class="cm"> * on the caps in question or we don&#39;t know this is safe.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_get_cap_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">caps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">__take_cap_refs</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">caps</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release cap refs.</span>
<span class="cm"> *</span>
<span class="cm"> * If we released the last ref on any given cap, call ceph_check_caps</span>
<span class="cm"> * to release (or schedule a release).</span>
<span class="cm"> *</span>
<span class="cm"> * If we are releasing a WR cap (from a sync write), finalize any affected</span>
<span class="cm"> * cap_snap, and wake up any waiters.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_put_cap_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">had</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">put</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flushsnaps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">had</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_PIN</span><span class="p">)</span>
		<span class="o">--</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_pin_ref</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">had</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_RD</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rd_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">last</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">had</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_CACHE</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">last</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">had</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_BUFFER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last</span><span class="o">++</span><span class="p">;</span>
			<span class="n">put</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;put_cap_refs %p wb %d -&gt; %d (?)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wb_ref</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">had</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_WR</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wr_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">capsnap</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">ceph_cap_snap</span><span class="p">,</span>
						     <span class="n">ci_item</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">writing</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">flushsnaps</span> <span class="o">=</span>
						<span class="n">__ceph_finish_cap_snap</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span>
								       <span class="n">capsnap</span><span class="p">);</span>
					<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;put_cap_refs %p had %s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">had</span><span class="p">),</span>
	     <span class="n">last</span> <span class="o">?</span> <span class="s">&quot; last&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">put</span> <span class="o">?</span> <span class="s">&quot; put&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">flushsnaps</span><span class="p">)</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flushsnaps</span><span class="p">)</span>
		<span class="n">ceph_flush_snaps</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release @nr WRBUFFER refs on dirty pages for the given @snapc snap</span>
<span class="cm"> * context.  Adjust per-snap dirty page accounting as appropriate.</span>
<span class="cm"> * Once all dirty data for a cap_snap is flushed, flush snapped file</span>
<span class="cm"> * metadata back to the MDS.  If we dropped the last ref, call</span>
<span class="cm"> * ceph_check_caps.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_put_wrbuffer_cap_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ceph_snap_context</span> <span class="o">*</span><span class="n">snapc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">complete_capsnap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_capsnap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span> <span class="o">-=</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">last</span> <span class="o">=</span> <span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span> <span class="o">==</span> <span class="n">snapc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span> <span class="o">-=</span> <span class="n">nr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="p">);</span>
			<span class="n">ceph_put_snap_context</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="p">);</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;put_wrbuffer_cap_refs on %p head %d/%d -&gt; %d/%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="o">+</span><span class="n">nr</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span><span class="o">+</span><span class="n">nr</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span><span class="p">,</span>
		     <span class="n">last</span> <span class="o">?</span> <span class="s">&quot; LAST&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">capsnap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">,</span> <span class="n">ci_item</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">==</span> <span class="n">snapc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">);</span>
		<span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span> <span class="o">-=</span> <span class="n">nr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">complete_capsnap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="cm">/* cap writeback completed before we created</span>
<span class="cm">				 * the cap_snap; no FLUSHSNAP is needed */</span>
				<span class="n">drop_capsnap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;put_wrbuffer_cap_refs on %p cap_snap %p &quot;</span>
		     <span class="s">&quot; snap %lld %d/%d -&gt; %d/%d %s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="o">+</span><span class="n">nr</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span> <span class="o">+</span> <span class="n">nr</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span><span class="p">,</span>
		     <span class="n">last</span> <span class="o">?</span> <span class="s">&quot; (wrbuffer last)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		     <span class="n">complete_capsnap</span> <span class="o">?</span> <span class="s">&quot; (complete capsnap)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		     <span class="n">drop_capsnap</span> <span class="o">?</span> <span class="s">&quot; (drop capsnap)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drop_capsnap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ceph_put_snap_context</span><span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">ci_item</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flushing_item</span><span class="p">);</span>
			<span class="n">ceph_put_cap_snap</span><span class="p">(</span><span class="n">capsnap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">CHECK_CAPS_AUTHONLY</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">complete_capsnap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ceph_flush_snaps</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_capsnap</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a cap GRANT message from the MDS.  (Note that a GRANT may</span>
<span class="cm"> * actually be a revocation if it specifies a smaller cap set.)</span>
<span class="cm"> *</span>
<span class="cm"> * caller holds s_mutex and i_ceph_lock, we drop both.</span>
<span class="cm"> *</span>
<span class="cm"> * return value:</span>
<span class="cm"> *  0 - ok</span>
<span class="cm"> *  1 - check_caps on auth cap only (writeback)</span>
<span class="cm"> *  2 - check_caps (ack revoke)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_cap_grant</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_mds_caps</span> <span class="o">*</span><span class="n">grant</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_buffer</span> <span class="o">*</span><span class="n">xattr_buf</span><span class="p">)</span>
		<span class="n">__releases</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">newcaps</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">caps</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">issued</span><span class="p">,</span> <span class="n">implemented</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">wanted</span><span class="p">,</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">max_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">mtime</span><span class="p">,</span> <span class="n">atime</span><span class="p">,</span> <span class="n">ctime</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">check_caps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">writeback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">revoked_rdcache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queue_invalidate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_cap_grant inode %p cap %p mds%d seq %d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">newcaps</span><span class="p">));</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot; size %llu max_size %llu, i_size %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If CACHE is being revoked, and we have no dirty buffers,</span>
<span class="cm">	 * try to invalidate (once).  (If there are dirty buffers, we</span>
<span class="cm">	 * will invalidate _after_ writeback.)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">newcaps</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_CACHE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">newcaps</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_LAZYIO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">try_nonblocking_invalidate</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">revoked_rdcache</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* there were locked pages.. invalidate later</span>
<span class="cm">			   in a separate thread. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span> <span class="o">!=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">queue_invalidate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_revoking</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_rdcache_gen</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* side effects now are allowed */</span>

	<span class="n">issued</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">implemented</span><span class="p">);</span>
	<span class="n">issued</span> <span class="o">|=</span> <span class="n">implemented</span> <span class="o">|</span> <span class="n">__ceph_caps_dirty</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>

	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_gen</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_gen</span><span class="p">;</span>

	<span class="n">__check_cap_issue</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">newcaps</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_AUTH_EXCL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;%p mode 0%o uid.gid %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
		     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_LINK_EXCL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_XATTR_EXCL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">grant</span><span class="o">-&gt;</span><span class="n">xattr_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">xattr_len</span><span class="p">);</span>
		<span class="n">u64</span> <span class="n">version</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">xattr_version</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">&gt;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">version</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; got new xattrs v%llu on %p len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">version</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="p">)</span>
				<span class="n">ceph_buffer_put</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span><span class="p">);</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">blob</span> <span class="o">=</span> <span class="n">ceph_buffer_get</span><span class="p">(</span><span class="n">xattr_buf</span><span class="p">);</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_xattrs</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* size/ctime/mtime/atime? */</span>
	<span class="n">ceph_fill_file_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">issued</span><span class="p">,</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">truncate_seq</span><span class="p">),</span>
			    <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">truncate_size</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">ceph_decode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">);</span>
	<span class="n">ceph_decode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">);</span>
	<span class="n">ceph_decode_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">);</span>
	<span class="n">ceph_fill_file_time</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">issued</span><span class="p">,</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">time_warp_seq</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtime</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">atime</span><span class="p">);</span>

	<span class="cm">/* max size increase? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_size</span> <span class="o">!=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;max_size %lld -&gt; %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_max_size</span> <span class="o">=</span> <span class="n">max_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_size</span> <span class="o">&gt;=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wanted_max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* reset */</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_requested_max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check cap bits */</span>
	<span class="n">wanted</span> <span class="o">=</span> <span class="n">__ceph_caps_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="n">dirty</span> <span class="o">=</span> <span class="n">__ceph_caps_dirty</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot; my wanted = %s, used = %s, dirty %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">wanted</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">used</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">dirty</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wanted</span> <span class="o">!=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">wanted</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;mds wanted %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">grant</span><span class="o">-&gt;</span><span class="n">wanted</span><span class="p">)),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">wanted</span><span class="p">));</span>
		<span class="n">grant</span><span class="o">-&gt;</span><span class="n">wanted</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">wanted</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>

	<span class="cm">/* file layout may have changed */</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_layout</span> <span class="o">=</span> <span class="n">grant</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>

	<span class="cm">/* revocation, grant, or no-op? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">newcaps</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">revoking</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">newcaps</span><span class="p">;</span>

		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;revocation: %s -&gt; %s (revoking %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">newcaps</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">revoking</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revoking</span> <span class="o">&amp;</span> <span class="n">used</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_BUFFER</span><span class="p">)</span>
			<span class="n">writeback</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* initiate writeback; will delay ack */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">revoking</span> <span class="o">==</span> <span class="n">CEPH_CAP_FILE_CACHE</span> <span class="o">&amp;&amp;</span>
			 <span class="p">(</span><span class="n">newcaps</span> <span class="o">&amp;</span> <span class="n">CEPH_CAP_FILE_LAZYIO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			 <span class="n">queue_invalidate</span><span class="p">)</span>
			<span class="p">;</span> <span class="cm">/* do nothing yet, invalidation will be queued */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_auth_cap</span><span class="p">)</span>
			<span class="n">check_caps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* check auth cap only */</span>
		<span class="k">else</span>
			<span class="n">check_caps</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* check all caps */</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">=</span> <span class="n">newcaps</span><span class="p">;</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">|=</span> <span class="n">newcaps</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">==</span> <span class="n">newcaps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;caps unchanged: %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">newcaps</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;grant: %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span>
		     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">newcaps</span><span class="p">));</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">=</span> <span class="n">newcaps</span><span class="p">;</span>
		<span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">|=</span> <span class="n">newcaps</span><span class="p">;</span> <span class="cm">/* add bits only, to</span>
<span class="cm">					      * avoid stepping on a</span>
<span class="cm">					      * pending revocation */</span>
		<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">writeback</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * queue inode for writeback: we can&#39;t actually call</span>
<span class="cm">		 * filemap_write_and_wait, etc. from message handler</span>
<span class="cm">		 * context.</span>
<span class="cm">		 */</span>
		<span class="n">ceph_queue_writeback</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_invalidate</span><span class="p">)</span>
		<span class="n">ceph_queue_invalidate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_caps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">CHECK_CAPS_NODELAY</span><span class="o">|</span><span class="n">CHECK_CAPS_AUTHONLY</span><span class="p">,</span>
				<span class="n">session</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">check_caps</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">CHECK_CAPS_NODELAY</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle FLUSH_ACK from MDS, indicating that metadata we sent to the</span>
<span class="cm"> * MDS has been safely committed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_cap_flush_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flush_tid</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ceph_mds_caps</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">ceph_sb_to_client</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CEPH_CAP_BITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dirty</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">flush_tid</span> <span class="o">==</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_flush_tid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">cleaned</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_cap_flush_ack inode %p mds%d seq %d on %s cleaned %s,&quot;</span>
	     <span class="s">&quot; flushing %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">dirty</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cleaned</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cleaned</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">==</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cleaned</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cleaned</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_caps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_flushing_item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_flushing</span><span class="p">))</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; mds%d still flushing cap on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">list_entry</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_cap_flushing</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ceph_inode_info</span><span class="p">,</span>
					 <span class="n">i_flushing_item</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
		<span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">num_cap_flushing</span><span class="o">--</span><span class="p">;</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_flushing_wq</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; inode %p now !flushing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_caps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; inode %p now clean</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">));</span>
			<span class="n">drop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_wrbuffer_ref_head</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="p">);</span>
				<span class="n">ceph_put_snap_context</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span><span class="p">);</span>
				<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_head_snapc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_wq</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle FLUSHSNAP_ACK.  MDS has flushed snap data to disk and we can</span>
<span class="cm"> * throw away our cap_snap.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller hold s_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_cap_flushsnap_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flush_tid</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ceph_mds_caps</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">follows</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">snap_follows</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_cap_snap</span> <span class="o">*</span><span class="n">capsnap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_cap_flushsnap_ack inode %p ci %p mds%d follows %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">,</span> <span class="n">follows</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">capsnap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_snaps</span><span class="p">,</span> <span class="n">ci_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">follows</span> <span class="o">==</span> <span class="n">follows</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flush_tid</span> <span class="o">!=</span> <span class="n">flush_tid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot; cap_snap %p follows %lld tid %lld !=&quot;</span>
				     <span class="s">&quot; %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">,</span> <span class="n">follows</span><span class="p">,</span>
				     <span class="n">flush_tid</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flush_tid</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">dirty_pages</span> <span class="o">||</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">writing</span><span class="p">);</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; removing %p cap_snap %p follows %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">inode</span><span class="p">,</span> <span class="n">capsnap</span><span class="p">,</span> <span class="n">follows</span><span class="p">);</span>
			<span class="n">ceph_put_snap_context</span><span class="p">(</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">ci_item</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">flushing_item</span><span class="p">);</span>
			<span class="n">ceph_put_cap_snap</span><span class="p">(</span><span class="n">capsnap</span><span class="p">);</span>
			<span class="n">drop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; skipping cap_snap %p follows %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">capsnap</span><span class="p">,</span> <span class="n">capsnap</span><span class="o">-&gt;</span><span class="n">follows</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle TRUNC from MDS, indicating file truncation.</span>
<span class="cm"> *</span>
<span class="cm"> * caller hold s_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_cap_trunc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_mds_caps</span> <span class="o">*</span><span class="n">trunc</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trunc</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">truncate_seq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trunc</span><span class="o">-&gt;</span><span class="n">truncate_seq</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">truncate_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">trunc</span><span class="o">-&gt;</span><span class="n">truncate_size</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">trunc</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">implemented</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">__ceph_caps_dirty</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">issued</span> <span class="o">=</span> <span class="n">__ceph_caps_issued</span><span class="p">(</span><span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">implemented</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">queue_trunc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">issued</span> <span class="o">|=</span> <span class="n">implemented</span> <span class="o">|</span> <span class="n">dirty</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_cap_trunc inode %p mds%d seq %d to %lld seq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">truncate_size</span><span class="p">,</span> <span class="n">truncate_seq</span><span class="p">);</span>
	<span class="n">queue_trunc</span> <span class="o">=</span> <span class="n">ceph_fill_file_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">issued</span><span class="p">,</span>
					  <span class="n">truncate_seq</span><span class="p">,</span> <span class="n">truncate_size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue_trunc</span><span class="p">)</span>
		<span class="n">ceph_queue_vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle EXPORT from MDS.  Cap is being migrated _from_ this mds to a</span>
<span class="cm"> * different one.  If we are the most recent migration we&#39;ve seen (as</span>
<span class="cm"> * indicated by mseq), make note of the migrating cap bits for the</span>
<span class="cm"> * duration (until we see the corresponding IMPORT).</span>
<span class="cm"> *</span>
<span class="cm"> * caller holds s_mutex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_cap_export</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_mds_caps</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="o">*</span><span class="n">open_target_sessions</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">ceph_inode_to_client</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">mseq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">migrate_seq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remember</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_cap_export inode %p ci %p mds%d mseq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span> <span class="n">mseq</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="cm">/* make sure we haven&#39;t seen a higher mseq */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_caps</span><span class="p">);</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_cap</span><span class="p">,</span> <span class="n">ci_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ceph_seq_cmp</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">mseq</span><span class="p">,</span> <span class="n">mseq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; higher mseq on cap from mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">t</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">);</span>
			<span class="n">remember</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span> <span class="o">==</span> <span class="n">mds</span><span class="p">)</span>
			<span class="n">cap</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remember</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* make note */</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mds</span> <span class="o">=</span> <span class="n">mds</span><span class="p">;</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mseq</span> <span class="o">=</span> <span class="n">mseq</span><span class="p">;</span>
			<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_issued</span> <span class="o">=</span> <span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * make sure we have open sessions with all possible</span>
<span class="cm">			 * export targets, so that we get the matching IMPORT</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">open_target_sessions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * we can&#39;t flush dirty caps that we&#39;ve seen the</span>
<span class="cm">			 * EXPORT but no IMPORT for</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot; moving %p to cap_dirty_migrating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">inode</span><span class="p">);</span>
				<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_migrating</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">__ceph_remove_cap</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* else, we already released it */</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle cap IMPORT.  If there are temp bits from an older EXPORT,</span>
<span class="cm"> * clean them up.</span>
<span class="cm"> *</span>
<span class="cm"> * caller holds s_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_cap_import</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_mds_caps</span> <span class="o">*</span><span class="n">im</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">snaptrace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">snaptrace_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">issued</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">caps</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">wanted</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">wanted</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">mseq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">migrate_seq</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">realmino</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">realm</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">cap_id</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">cap_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mds</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ceph_seq_cmp</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mseq</span><span class="p">,</span> <span class="n">mseq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_cap_import inode %p ci %p mds%d mseq %d&quot;</span>
		     <span class="s">&quot; - cleared exporting from mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span> <span class="n">mseq</span><span class="p">,</span>
		     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mds</span><span class="p">);</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_issued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mseq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_exporting_mds</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot; moving %p back to cap_dirty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_dirty_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_cap_import inode %p ci %p mds%d mseq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span> <span class="n">mseq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
	<span class="n">ceph_update_snap_trace</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">snaptrace</span><span class="p">,</span> <span class="n">snaptrace</span><span class="o">+</span><span class="n">snaptrace_len</span><span class="p">,</span>
			       <span class="nb">false</span><span class="p">);</span>
	<span class="n">downgrade_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>
	<span class="n">ceph_add_cap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">cap_id</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		     <span class="n">issued</span><span class="p">,</span> <span class="n">wanted</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">mseq</span><span class="p">,</span> <span class="n">realmino</span><span class="p">,</span> <span class="n">CEPH_CAP_FLAG_AUTH</span><span class="p">,</span>
		     <span class="nb">NULL</span> <span class="cm">/* no caps context */</span><span class="p">);</span>
	<span class="n">kick_flushing_inode_caps</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">snap_rwsem</span><span class="p">);</span>

	<span class="cm">/* make sure we re-request max_size, if necessary */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_requested_max_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a caps message from the MDS.</span>
<span class="cm"> *</span>
<span class="cm"> * Identify the appropriate session, inode, and call the right handler</span>
<span class="cm"> * based on the cap op.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_handle_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ceph_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mdsc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">fsc</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_caps</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mds</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">mseq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_vino</span> <span class="n">vino</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cap_id</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tid</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">snaptrace</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">snaptrace_len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">flock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flock_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">open_target_sessions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;handle_caps from mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mds</span><span class="p">);</span>

	<span class="cm">/* decode */</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">tid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
	<span class="n">vino</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">vino</span><span class="p">.</span><span class="n">snap</span> <span class="o">=</span> <span class="n">CEPH_NOSNAP</span><span class="p">;</span>
	<span class="n">cap_id</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cap_id</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">mseq</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">migrate_seq</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">max_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">);</span>

	<span class="n">snaptrace</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">snaptrace_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">snap_trace_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">version</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">snaptrace</span> <span class="o">+</span> <span class="n">snaptrace_len</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">.</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="n">ceph_decode_32_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">flock_len</span><span class="p">,</span> <span class="n">bad</span><span class="p">);</span>
		<span class="n">flock</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">flock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">flock_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">session</span><span class="o">-&gt;</span><span class="n">s_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot; mds%d seq %lld cap seq %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mds</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">s_seq</span><span class="p">,</span>
	     <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">seq</span><span class="p">);</span>

	<span class="cm">/* lookup ino */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">ceph_find_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">vino</span><span class="p">);</span>
	<span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot; op %s ino %llx.%llx inode %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ceph_cap_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">,</span>
	     <span class="n">vino</span><span class="p">.</span><span class="n">snap</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; i don&#39;t have ino %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">CEPH_CAP_OP_IMPORT</span><span class="p">)</span>
			<span class="n">__queue_cap_release</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">vino</span><span class="p">.</span><span class="n">ino</span><span class="p">,</span> <span class="n">cap_id</span><span class="p">,</span>
					    <span class="n">mseq</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">flush_cap_releases</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* these will work even if we don&#39;t have a cap yet */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CEPH_CAP_OP_FLUSHSNAP_ACK</span>:
		<span class="n">handle_cap_flushsnap_ack</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CEPH_CAP_OP_EXPORT</span>:
		<span class="n">handle_cap_export</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">open_target_sessions</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CEPH_CAP_OP_IMPORT</span>:
		<span class="n">handle_cap_import</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span>
				  <span class="n">snaptrace</span><span class="p">,</span> <span class="n">snaptrace_len</span><span class="p">);</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done_unlocked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the rest require a cap */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">cap</span> <span class="o">=</span> <span class="n">__get_cap_for_mds</span><span class="p">(</span><span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">mds</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot; no cap on %p ino %llx.%llx from mds%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">inode</span><span class="p">,</span> <span class="n">ceph_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">ceph_snap</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">mds</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">flush_cap_releases</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* note that each of these drops i_ceph_lock for us */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CEPH_CAP_OP_REVOKE</span>:
	<span class="k">case</span> <span class="n">CEPH_CAP_OP_GRANT</span>:
		<span class="n">handle_cap_grant</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">middle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done_unlocked</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CEPH_CAP_OP_FLUSH_ACK</span>:
		<span class="n">handle_cap_flush_ack</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CEPH_CAP_OP_TRUNC</span>:
		<span class="n">handle_cap_trunc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ceph_handle_caps: unknown cap op %d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span>
		       <span class="n">ceph_cap_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">flush_cap_releases:</span>
	<span class="cm">/*</span>
<span class="cm">	 * send any full release message to try to move things</span>
<span class="cm">	 * along for the mds (who clearly thinks we still have this</span>
<span class="cm">	 * cap).</span>
<span class="cm">	 */</span>
	<span class="n">ceph_add_cap_releases</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
	<span class="n">ceph_send_cap_releases</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
<span class="nl">done_unlocked:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">open_target_sessions</span><span class="p">)</span>
		<span class="n">ceph_mdsc_open_export_target_sessions</span><span class="p">(</span><span class="n">mdsc</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ceph_handle_caps: corrupt message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ceph_msg_dump</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Delayed work handler to process end of delayed cap release LRU list.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_check_delayed_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">CHECK_CAPS_NODELAY</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;check_delayed_caps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_list</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ci</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_list</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ceph_inode_info</span><span class="p">,</span>
				      <span class="n">i_cap_delay_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">CEPH_I_FLUSH</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_hold_caps_max</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_cap_delay_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;check_delayed_caps on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_delay_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush all dirty caps to the mds</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_flush_dirty_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_mds_client</span> <span class="o">*</span><span class="n">mdsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;flush_dirty_caps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ci</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ceph_inode_info</span><span class="p">,</span>
				      <span class="n">i_dirty_item</span><span class="p">);</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;flush_dirty_caps %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">CHECK_CAPS_NODELAY</span><span class="o">|</span><span class="n">CHECK_CAPS_FLUSH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdsc</span><span class="o">-&gt;</span><span class="n">cap_dirty_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;flush_dirty_caps done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Drop open file reference.  If we were the last open file,</span>
<span class="cm"> * we may need to release capabilities to the MDS (or schedule</span>
<span class="cm"> * their delayed release).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ceph_put_fmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fmode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;put_fmode %p fmode %d %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">fmode</span><span class="p">,</span>
	     <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_nr_by_mode</span><span class="p">[</span><span class="n">fmode</span><span class="p">],</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_nr_by_mode</span><span class="p">[</span><span class="n">fmode</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_nr_by_mode</span><span class="p">[</span><span class="n">fmode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_nr_by_mode</span><span class="p">[</span><span class="n">fmode</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">last</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_vino</span><span class="p">.</span><span class="n">snap</span> <span class="o">==</span> <span class="n">CEPH_NOSNAP</span><span class="p">)</span>
		<span class="n">ceph_check_caps</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helpers for embedding cap and dentry lease releases into mds</span>
<span class="cm"> * requests.</span>
<span class="cm"> *</span>
<span class="cm"> * @force is used by dentry_release (below) to force inclusion of a</span>
<span class="cm"> * record for the directory inode, even when there aren&#39;t any caps to</span>
<span class="cm"> * drop.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ceph_encode_inode_release</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">mds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">drop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unless</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ceph_inode_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">ceph_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ceph_cap</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_request_release</span> <span class="o">*</span><span class="n">rel</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">,</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">__ceph_caps_used</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
	<span class="n">dirty</span> <span class="o">=</span> <span class="n">__ceph_caps_dirty</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>

	<span class="n">dout</span><span class="p">(</span><span class="s">&quot;encode_inode_release %p mds%d used|dirty %s drop %s unless %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">used</span><span class="o">|</span><span class="n">dirty</span><span class="p">),</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">drop</span><span class="p">),</span>
	     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">unless</span><span class="p">));</span>

	<span class="cm">/* only drop unused, clean caps */</span>
	<span class="n">drop</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">used</span> <span class="o">|</span> <span class="n">dirty</span><span class="p">);</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">__get_cap_for_mds</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">mds</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;&amp;</span> <span class="n">__cap_is_valid</span><span class="p">(</span><span class="n">cap</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">drop</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">unless</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">drop</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="n">unless</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;encode_inode_release %p cap %p %s -&gt; &quot;</span>
				     <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span>
				     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">),</span>
				     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">drop</span><span class="p">));</span>
				<span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">drop</span><span class="p">;</span>
				<span class="n">cap</span><span class="o">-&gt;</span><span class="n">implemented</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">drop</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_flags</span> <span class="o">&amp;</span> <span class="n">CEPH_I_NODELAY</span><span class="p">)</span> <span class="p">{</span>
					<span class="kt">int</span> <span class="n">wanted</span> <span class="o">=</span> <span class="n">__ceph_caps_wanted</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
					<span class="n">dout</span><span class="p">(</span><span class="s">&quot;  wanted %s -&gt; %s (act %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span><span class="p">),</span>
					     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span> <span class="o">&amp;</span>
							     <span class="o">~</span><span class="n">wanted</span><span class="p">),</span>
					     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">wanted</span><span class="p">));</span>
					<span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span> <span class="o">&amp;=</span> <span class="n">wanted</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dout</span><span class="p">(</span><span class="s">&quot;encode_inode_release %p cap %p %s&quot;</span>
				     <span class="s">&quot; (force)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span>
				     <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ceph_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">cap_id</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">cap_id</span><span class="p">);</span>
			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">issue_seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issue_seq</span><span class="p">),</span>
			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">mseq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">mseq</span><span class="p">);</span>
			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">);</span>
			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">wanted</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">mds_wanted</span><span class="p">);</span>
			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">dname_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rel</span><span class="o">-&gt;</span><span class="n">dname_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rel</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dout</span><span class="p">(</span><span class="s">&quot;encode_inode_release %p cap %p %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">inode</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">ceph_cap_string</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">issued</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">i_ceph_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ceph_encode_dentry_release</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">mds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">drop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unless</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_mds_request_release</span> <span class="o">*</span><span class="n">rel</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ceph_dentry_info</span> <span class="o">*</span><span class="n">di</span> <span class="o">=</span> <span class="n">ceph_dentry</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">force</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * force an record for the directory caps if we have a dentry lease.</span>
<span class="cm">	 * this is racy (can&#39;t take i_ceph_lock and d_lock together), but it</span>
<span class="cm">	 * doesn&#39;t have to be perfect; the mds will revoke anything we don&#39;t</span>
<span class="cm">	 * release.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_session</span> <span class="o">&amp;&amp;</span> <span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_session</span><span class="o">-&gt;</span><span class="n">s_mds</span> <span class="o">==</span> <span class="n">mds</span><span class="p">)</span>
		<span class="n">force</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ceph_encode_inode_release</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span> <span class="n">drop</span><span class="p">,</span> <span class="n">unless</span><span class="p">,</span> <span class="n">force</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_session</span> <span class="o">&amp;&amp;</span> <span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_session</span><span class="o">-&gt;</span><span class="n">s_mds</span> <span class="o">==</span> <span class="n">mds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dout</span><span class="p">(</span><span class="s">&quot;encode_dentry_release %p mds%d seq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dentry</span><span class="p">,</span> <span class="n">mds</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_seq</span><span class="p">);</span>
		<span class="n">rel</span><span class="o">-&gt;</span><span class="n">dname_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">+=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
		<span class="n">rel</span><span class="o">-&gt;</span><span class="n">dname_seq</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">lease_seq</span><span class="p">);</span>
		<span class="n">__ceph_mdsc_drop_dentry_lease</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
