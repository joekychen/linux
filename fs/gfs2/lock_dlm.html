<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › gfs2 › lock_dlm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lock_dlm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.</span>
<span class="cm"> * Copyright 2004-2011 Red Hat, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This copyrighted material is made available to anyone wishing to use,</span>
<span class="cm"> * modify, copy, or redistribute it subject to the terms and conditions</span>
<span class="cm"> * of the GNU General Public License version 2.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/dlm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/gfs2_ondisk.h&gt;</span>

<span class="cp">#include &quot;incore.h&quot;</span>
<span class="cp">#include &quot;glock.h&quot;</span>
<span class="cp">#include &quot;util.h&quot;</span>
<span class="cp">#include &quot;sys.h&quot;</span>
<span class="cp">#include &quot;trace_gfs2.h&quot;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">gfs2_control_wq</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * gfs2_update_stats - Update time based stats</span>
<span class="cm"> * @mv: Pointer to mean/variance structure to update</span>
<span class="cm"> * @sample: New data to include</span>
<span class="cm"> *</span>
<span class="cm"> * @delta is the difference between the current rtt sample and the</span>
<span class="cm"> * running average srtt. We add 1/8 of that to the srtt in order to</span>
<span class="cm"> * update the current srtt estimate. The varience estimate is a bit</span>
<span class="cm"> * more complicated. We subtract the abs value of the @delta from</span>
<span class="cm"> * the current variance estimate and add 1/4 of that to the running</span>
<span class="cm"> * total.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the index points at the array entry containing the smoothed</span>
<span class="cm"> * mean value, and the variance is always in the following entry</span>
<span class="cm"> *</span>
<span class="cm"> * Reference: TCP/IP Illustrated, vol 2, p. 831,832</span>
<span class="cm"> * All times are in units of integer nanoseconds. Unlike the TCP/IP case,</span>
<span class="cm"> * they are not scaled fixed point.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gfs2_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_lkstats</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span>
				     <span class="n">s64</span> <span class="n">sample</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">sample</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">abs64</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gfs2_update_reply_times - Update locking statistics</span>
<span class="cm"> * @gl: The glock to update</span>
<span class="cm"> *</span>
<span class="cm"> * This assumes that gl-&gt;gl_dstamp has been set earlier.</span>
<span class="cm"> *</span>
<span class="cm"> * The rtt (lock round trip time) is an estimate of the time</span>
<span class="cm"> * taken to perform a dlm lock request. We update it on each</span>
<span class="cm"> * reply from the dlm.</span>
<span class="cm"> *</span>
<span class="cm"> * The blocking flag is set on the glock for all dlm requests</span>
<span class="cm"> * which may potentially block due to lock requests from other nodes.</span>
<span class="cm"> * DLM requests where the current lock state is exclusive, the</span>
<span class="cm"> * requested state is null (or unlocked) or where the TRY or</span>
<span class="cm"> * TRY_1CB flags are set are classified as non-blocking. All</span>
<span class="cm"> * other DLM requests are counted as (potentially) blocking.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gfs2_update_reply_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_glock</span> <span class="o">*</span><span class="n">gl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_pcpu_lkstats</span> <span class="o">*</span><span class="n">lks</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">gltype</span> <span class="o">=</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_name</span><span class="p">.</span><span class="n">ln_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">index</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">GLF_BLOCKING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_flags</span><span class="p">)</span> <span class="o">?</span>
			 <span class="n">GFS2_LKS_SRTTB</span> <span class="o">:</span> <span class="n">GFS2_LKS_SRTT</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">rtt</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">rtt</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">(),</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_dstamp</span><span class="p">));</span>
	<span class="n">lks</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_sbd</span><span class="o">-&gt;</span><span class="n">sd_lkstats</span><span class="p">);</span>
	<span class="n">gfs2_update_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_stats</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rtt</span><span class="p">);</span>		<span class="cm">/* Local */</span>
	<span class="n">gfs2_update_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lks</span><span class="o">-&gt;</span><span class="n">lkstats</span><span class="p">[</span><span class="n">gltype</span><span class="p">],</span> <span class="n">index</span><span class="p">,</span> <span class="n">rtt</span><span class="p">);</span>	<span class="cm">/* Global */</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="n">trace_gfs2_glock_lock_time</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">rtt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gfs2_update_request_times - Update locking statistics</span>
<span class="cm"> * @gl: The glock to update</span>
<span class="cm"> *</span>
<span class="cm"> * The irt (lock inter-request times) measures the average time</span>
<span class="cm"> * between requests to the dlm. It is updated immediately before</span>
<span class="cm"> * each dlm call.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gfs2_update_request_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_glock</span> <span class="o">*</span><span class="n">gl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_pcpu_lkstats</span> <span class="o">*</span><span class="n">lks</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">gltype</span> <span class="o">=</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_name</span><span class="p">.</span><span class="n">ln_type</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">dstamp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">irt</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">dstamp</span> <span class="o">=</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_dstamp</span><span class="p">;</span>
	<span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_dstamp</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="n">irt</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_dstamp</span><span class="p">,</span> <span class="n">dstamp</span><span class="p">));</span>
	<span class="n">lks</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_sbd</span><span class="o">-&gt;</span><span class="n">sd_lkstats</span><span class="p">);</span>
	<span class="n">gfs2_update_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_stats</span><span class="p">,</span> <span class="n">GFS2_LKS_SIRT</span><span class="p">,</span> <span class="n">irt</span><span class="p">);</span>		<span class="cm">/* Local */</span>
	<span class="n">gfs2_update_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lks</span><span class="o">-&gt;</span><span class="n">lkstats</span><span class="p">[</span><span class="n">gltype</span><span class="p">],</span> <span class="n">GFS2_LKS_SIRT</span><span class="p">,</span> <span class="n">irt</span><span class="p">);</span>	<span class="cm">/* Global */</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_ast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_glock</span> <span class="o">*</span><span class="n">gl</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_state</span><span class="p">;</span>

	<span class="n">gfs2_update_reply_times</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_SBF_DEMOTED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_SBF_VALNOTVALID</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lvb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GDLM_LVB_SIZE</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span>: <span class="cm">/* Unlocked, so glock can be freed */</span>
		<span class="n">gfs2_glock_free</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">DLM_ECANCEL</span>: <span class="cm">/* Cancel while getting lock */</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">LM_OUT_CANCELED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>: <span class="cm">/* Try lock fails */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EDEADLK</span>: <span class="cm">/* Deadlock detected */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>: <span class="cm">/* Canceled due to timeout */</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">LM_OUT_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* Success */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="cm">/* Something unexpected */</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_req</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_flags</span> <span class="o">&amp;</span> <span class="n">DLM_SBF_ALTMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_req</span> <span class="o">==</span> <span class="n">LM_ST_SHARED</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">LM_ST_DEFERRED</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_req</span> <span class="o">==</span> <span class="n">LM_ST_DEFERRED</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">LM_ST_SHARED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">GLF_INITIAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_flags</span><span class="p">);</span>
	<span class="n">gfs2_glock_complete</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">GLF_INITIAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_flags</span><span class="p">))</span>
		<span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_lkid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gfs2_glock_complete</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_bast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_glock</span> <span class="o">*</span><span class="n">gl</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLM_LOCK_EX</span>:
		<span class="n">gfs2_glock_cb</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">LM_ST_UNLOCKED</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_LOCK_CW</span>:
		<span class="n">gfs2_glock_cb</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">LM_ST_DEFERRED</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLM_LOCK_PR</span>:
		<span class="n">gfs2_glock_cb</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">LM_ST_SHARED</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unknown bast mode %d&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* convert gfs lock-state to dlm lock-mode */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_mode</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lmstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">lmstate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LM_ST_UNLOCKED</span>:
		<span class="k">return</span> <span class="n">DLM_LOCK_NL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_ST_EXCLUSIVE</span>:
		<span class="k">return</span> <span class="n">DLM_LOCK_EX</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_ST_DEFERRED</span>:
		<span class="k">return</span> <span class="n">DLM_LOCK_CW</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LM_ST_SHARED</span>:
		<span class="k">return</span> <span class="n">DLM_LOCK_PR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unknown LM state %d&quot;</span><span class="p">,</span> <span class="n">lmstate</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">make_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_glock</span> <span class="o">*</span><span class="n">gl</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gfs_flags</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">int</span> <span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">lkf</span> <span class="o">=</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lkid</span> <span class="o">=</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_lkid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfs_flags</span> <span class="o">&amp;</span> <span class="n">LM_FLAG_TRY</span><span class="p">)</span>
		<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_NOQUEUE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfs_flags</span> <span class="o">&amp;</span> <span class="n">LM_FLAG_TRY_1CB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_NOQUEUE</span><span class="p">;</span>
		<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_NOQUEUEBAST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfs_flags</span> <span class="o">&amp;</span> <span class="n">LM_FLAG_PRIORITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_NOORDER</span><span class="p">;</span>
		<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_HEADQUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfs_flags</span> <span class="o">&amp;</span> <span class="n">LM_FLAG_ANY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="n">DLM_LOCK_PR</span><span class="p">)</span>
			<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_ALTCW</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="n">DLM_LOCK_CW</span><span class="p">)</span>
			<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_ALTPR</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lkid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">GLF_BLOCKING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_flags</span><span class="p">))</span>
			<span class="n">lkf</span> <span class="o">|=</span> <span class="n">DLM_LKF_QUECVT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lkf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfs2_reverse_hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">c</span><span class="o">--</span> <span class="o">=</span> <span class="n">hex_asc</span><span class="p">[</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">];</span>
		<span class="n">value</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gdlm_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_glock</span> <span class="o">*</span><span class="n">gl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">req_state</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_sbd</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lkf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">strname</span><span class="p">[</span><span class="n">GDLM_STRNAME_BYTES</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">make_mode</span><span class="p">(</span><span class="n">req_state</span><span class="p">);</span>
	<span class="n">lkf</span> <span class="o">=</span> <span class="n">make_flags</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">gfs2_glstats_inc</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">GFS2_LKS_DCOUNT</span><span class="p">);</span>
	<span class="n">gfs2_sbstats_inc</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">GFS2_LKS_DCOUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_lkid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gfs2_update_request_times</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">strname</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="n">GDLM_STRNAME_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">strname</span><span class="p">[</span><span class="n">GDLM_STRNAME_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">gfs2_reverse_hex</span><span class="p">(</span><span class="n">strname</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_name</span><span class="p">.</span><span class="n">ln_type</span><span class="p">);</span>
		<span class="n">gfs2_reverse_hex</span><span class="p">(</span><span class="n">strname</span> <span class="o">+</span> <span class="mi">23</span><span class="p">,</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_name</span><span class="p">.</span><span class="n">ln_number</span><span class="p">);</span>
		<span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_dstamp</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Submit the actual lock request.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="n">dlm_lock</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">,</span> <span class="n">lkf</span><span class="p">,</span> <span class="n">strname</span><span class="p">,</span>
			<span class="n">GDLM_STRNAME_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gdlm_ast</span><span class="p">,</span> <span class="n">gl</span><span class="p">,</span> <span class="n">gdlm_bast</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_put_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_glock</span> <span class="o">*</span><span class="n">gl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_sbd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_lkid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gfs2_glock_free</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">GLF_BLOCKING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_flags</span><span class="p">);</span>
	<span class="n">gfs2_glstats_inc</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">GFS2_LKS_DCOUNT</span><span class="p">);</span>
	<span class="n">gfs2_sbstats_inc</span><span class="p">(</span><span class="n">gl</span><span class="p">,</span> <span class="n">GFS2_LKS_DCOUNT</span><span class="p">);</span>
	<span class="n">gfs2_update_request_times</span><span class="p">(</span><span class="n">gl</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_unlock</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">,</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_lkid</span><span class="p">,</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">,</span>
			   <span class="nb">NULL</span><span class="p">,</span> <span class="n">gl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;gdlm_unlock %x,%llx err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_name</span><span class="p">.</span><span class="n">ln_type</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_name</span><span class="p">.</span><span class="n">ln_number</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_glock</span> <span class="o">*</span><span class="n">gl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_sbd</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="n">dlm_unlock</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">,</span> <span class="n">gl</span><span class="o">-&gt;</span><span class="n">gl_lksb</span><span class="p">.</span><span class="n">sb_lkid</span><span class="p">,</span> <span class="n">DLM_LKF_CANCEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">gl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dlm/gfs2 recovery coordination using dlm_recover callbacks</span>
<span class="cm"> *</span>
<span class="cm"> *  1. dlm_controld sees lockspace members change</span>
<span class="cm"> *  2. dlm_controld blocks dlm-kernel locking activity</span>
<span class="cm"> *  3. dlm_controld within dlm-kernel notifies gfs2 (recover_prep)</span>
<span class="cm"> *  4. dlm_controld starts and finishes its own user level recovery</span>
<span class="cm"> *  5. dlm_controld starts dlm-kernel dlm_recoverd to do kernel recovery</span>
<span class="cm"> *  6. dlm_recoverd notifies gfs2 of failed nodes (recover_slot)</span>
<span class="cm"> *  7. dlm_recoverd does its own lock recovery</span>
<span class="cm"> *  8. dlm_recoverd unblocks dlm-kernel locking activity</span>
<span class="cm"> *  9. dlm_recoverd notifies gfs2 when done (recover_done with new generation)</span>
<span class="cm"> * 10. gfs2_control updates control_lock lvb with new generation and jid bits</span>
<span class="cm"> * 11. gfs2_control enqueues journals for gfs2_recover to recover (maybe none)</span>
<span class="cm"> * 12. gfs2_recover dequeues and recovers journals of failed nodes</span>
<span class="cm"> * 13. gfs2_recover provides recovery results to gfs2_control (recovery_result)</span>
<span class="cm"> * 14. gfs2_control updates control_lock lvb jid bits for recovered journals</span>
<span class="cm"> * 15. gfs2_control unblocks normal locking when all journals are recovered</span>
<span class="cm"> *</span>
<span class="cm"> * - failures during recovery</span>
<span class="cm"> *</span>
<span class="cm"> * recover_prep() may set BLOCK_LOCKS (step 3) again before gfs2_control</span>
<span class="cm"> * clears BLOCK_LOCKS (step 15), e.g. another node fails while still</span>
<span class="cm"> * recovering for a prior failure.  gfs2_control needs a way to detect</span>
<span class="cm"> * this so it can leave BLOCK_LOCKS set in step 15.  This is managed using</span>
<span class="cm"> * the recover_block and recover_start values.</span>
<span class="cm"> *</span>
<span class="cm"> * recover_done() provides a new lockspace generation number each time it</span>
<span class="cm"> * is called (step 9).  This generation number is saved as recover_start.</span>
<span class="cm"> * When recover_prep() is called, it sets BLOCK_LOCKS and sets</span>
<span class="cm"> * recover_block = recover_start.  So, while recover_block is equal to</span>
<span class="cm"> * recover_start, BLOCK_LOCKS should remain set.  (recover_spin must</span>
<span class="cm"> * be held around the BLOCK_LOCKS/recover_block/recover_start logic.)</span>
<span class="cm"> *</span>
<span class="cm"> * - more specific gfs2 steps in sequence above</span>
<span class="cm"> *</span>
<span class="cm"> *  3. recover_prep sets BLOCK_LOCKS and sets recover_block = recover_start</span>
<span class="cm"> *  6. recover_slot records any failed jids (maybe none)</span>
<span class="cm"> *  9. recover_done sets recover_start = new generation number</span>
<span class="cm"> * 10. gfs2_control sets control_lock lvb = new gen + bits for failed jids</span>
<span class="cm"> * 12. gfs2_recover does journal recoveries for failed jids identified above</span>
<span class="cm"> * 14. gfs2_control clears control_lock lvb bits for recovered jids</span>
<span class="cm"> * 15. gfs2_control checks if recover_block == recover_start (step 3 occured</span>
<span class="cm"> *     again) then do nothing, otherwise if recover_start &gt; recover_block</span>
<span class="cm"> *     then clear BLOCK_LOCKS.</span>
<span class="cm"> *</span>
<span class="cm"> * - parallel recovery steps across all nodes</span>
<span class="cm"> *</span>
<span class="cm"> * All nodes attempt to update the control_lock lvb with the new generation</span>
<span class="cm"> * number and jid bits, but only the first to get the control_lock EX will</span>
<span class="cm"> * do so; others will see that it&#39;s already done (lvb already contains new</span>
<span class="cm"> * generation number.)</span>
<span class="cm"> *</span>
<span class="cm"> * . All nodes get the same recover_prep/recover_slot/recover_done callbacks</span>
<span class="cm"> * . All nodes attempt to set control_lock lvb gen + bits for the new gen</span>
<span class="cm"> * . One node gets control_lock first and writes the lvb, others see it&#39;s done</span>
<span class="cm"> * . All nodes attempt to recover jids for which they see control_lock bits set</span>
<span class="cm"> * . One node succeeds for a jid, and that one clears the jid bit in the lvb</span>
<span class="cm"> * . All nodes will eventually see all lvb bits clear and unblock locks</span>
<span class="cm"> *</span>
<span class="cm"> * - is there a problem with clearing an lvb bit that should be set</span>
<span class="cm"> *   and missing a journal recovery?</span>
<span class="cm"> *</span>
<span class="cm"> * 1. jid fails</span>
<span class="cm"> * 2. lvb bit set for step 1</span>
<span class="cm"> * 3. jid recovered for step 1</span>
<span class="cm"> * 4. jid taken again (new mount)</span>
<span class="cm"> * 5. jid fails (for step 4)</span>
<span class="cm"> * 6. lvb bit set for step 5 (will already be set)</span>
<span class="cm"> * 7. lvb bit cleared for step 3</span>
<span class="cm"> *</span>
<span class="cm"> * This is not a problem because the failure in step 5 does not</span>
<span class="cm"> * require recovery, because the mount in step 4 could not have</span>
<span class="cm"> * progressed far enough to unblock locks and access the fs.  The</span>
<span class="cm"> * control_mount() function waits for all recoveries to be complete</span>
<span class="cm"> * for the latest lockspace generation before ever unblocking locks</span>
<span class="cm"> * and returning.  The mount in step 4 waits until the recovery in</span>
<span class="cm"> * step 1 is done.</span>
<span class="cm"> *</span>
<span class="cm"> * - special case of first mounter: first node to mount the fs</span>
<span class="cm"> *</span>
<span class="cm"> * The first node to mount a gfs2 fs needs to check all the journals</span>
<span class="cm"> * and recover any that need recovery before other nodes are allowed</span>
<span class="cm"> * to mount the fs.  (Others may begin mounting, but they must wait</span>
<span class="cm"> * for the first mounter to be done before taking locks on the fs</span>
<span class="cm"> * or accessing the fs.)  This has two parts:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. The mounted_lock tells a node it&#39;s the first to mount the fs.</span>
<span class="cm"> * Each node holds the mounted_lock in PR while it&#39;s mounted.</span>
<span class="cm"> * Each node tries to acquire the mounted_lock in EX when it mounts.</span>
<span class="cm"> * If a node is granted the mounted_lock EX it means there are no</span>
<span class="cm"> * other mounted nodes (no PR locks exist), and it is the first mounter.</span>
<span class="cm"> * The mounted_lock is demoted to PR when first recovery is done, so</span>
<span class="cm"> * others will fail to get an EX lock, but will get a PR lock.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. The control_lock blocks others in control_mount() while the first</span>
<span class="cm"> * mounter is doing first mount recovery of all journals.</span>
<span class="cm"> * A mounting node needs to acquire control_lock in EX mode before</span>
<span class="cm"> * it can proceed.  The first mounter holds control_lock in EX while doing</span>
<span class="cm"> * the first mount recovery, blocking mounts from other nodes, then demotes</span>
<span class="cm"> * control_lock to NL when it&#39;s done (others_may_mount/first_done),</span>
<span class="cm"> * allowing other nodes to continue mounting.</span>
<span class="cm"> *</span>
<span class="cm"> * first mounter:</span>
<span class="cm"> * control_lock EX/NOQUEUE success</span>
<span class="cm"> * mounted_lock EX/NOQUEUE success (no other PR, so no other mounters)</span>
<span class="cm"> * set first=1</span>
<span class="cm"> * do first mounter recovery</span>
<span class="cm"> * mounted_lock EX-&gt;PR</span>
<span class="cm"> * control_lock EX-&gt;NL, write lvb generation</span>
<span class="cm"> *</span>
<span class="cm"> * other mounter:</span>
<span class="cm"> * control_lock EX/NOQUEUE success (if fail -EAGAIN, retry)</span>
<span class="cm"> * mounted_lock EX/NOQUEUE fail -EAGAIN (expected due to other mounters PR)</span>
<span class="cm"> * mounted_lock PR/NOQUEUE success</span>
<span class="cm"> * read lvb generation</span>
<span class="cm"> * control_lock EX-&gt;NL</span>
<span class="cm"> * set first=0</span>
<span class="cm"> *</span>
<span class="cm"> * - mount during recovery</span>
<span class="cm"> *</span>
<span class="cm"> * If a node mounts while others are doing recovery (not first mounter),</span>
<span class="cm"> * the mounting node will get its initial recover_done() callback without</span>
<span class="cm"> * having seen any previous failures/callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * It must wait for all recoveries preceding its mount to be finished</span>
<span class="cm"> * before it unblocks locks.  It does this by repeating the &quot;other mounter&quot;</span>
<span class="cm"> * steps above until the lvb generation number is &gt;= its mount generation</span>
<span class="cm"> * number (from initial recover_done) and all lvb bits are clear.</span>
<span class="cm"> *</span>
<span class="cm"> * - control_lock lvb format</span>
<span class="cm"> *</span>
<span class="cm"> * 4 bytes generation number: the latest dlm lockspace generation number</span>
<span class="cm"> * from recover_done callback.  Indicates the jid bitmap has been updated</span>
<span class="cm"> * to reflect all slot failures through that generation.</span>
<span class="cm"> * 4 bytes unused.</span>
<span class="cm"> * GDLM_LVB_SIZE-8 bytes of jid bit map. If bit N is set, it indicates</span>
<span class="cm"> * that jid N needs recovery.</span>
<span class="cm"> */</span>

<span class="cp">#define JID_BITMAP_OFFSET 8 </span><span class="cm">/* 4 byte generation number + 4 byte unused */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">control_lvb_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lvb_gen</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">lvb_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">gen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">lvb_bits</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lvb</span><span class="p">,</span> <span class="n">GDLM_LVB_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gen</span><span class="p">,</span> <span class="n">lvb_bits</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="o">*</span><span class="n">lvb_gen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">control_lvb_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">lvb_gen</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">lvb_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">gen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lvb</span><span class="p">,</span> <span class="n">lvb_bits</span><span class="p">,</span> <span class="n">GDLM_LVB_SIZE</span><span class="p">);</span>
	<span class="n">gen</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lvb_gen</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lvb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gen</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">all_jid_bits_clear</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">lvb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">JID_BITMAP_OFFSET</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GDLM_LVB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lvb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_wait_cb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_sync_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sync_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_unlock</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">,</span> <span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lkid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lksb</span><span class="p">,</span> <span class="n">ls</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;%s lkid %x error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">name</span><span class="p">,</span> <span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lkid</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_sync_wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">DLM_EUNLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;%s lkid %x status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">name</span><span class="p">,</span> <span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lkid</span><span class="p">,</span> <span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_status</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sync_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">strname</span><span class="p">[</span><span class="n">GDLM_STRNAME_BYTES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">strname</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GDLM_STRNAME_BYTES</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">strname</span><span class="p">,</span> <span class="n">GDLM_STRNAME_BYTES</span><span class="p">,</span> <span class="s">&quot;%8x%16x&quot;</span><span class="p">,</span> <span class="n">LM_TYPE_NONDISK</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_lock</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">lksb</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
			 <span class="n">strname</span><span class="p">,</span> <span class="n">GDLM_STRNAME_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			 <span class="mi">0</span><span class="p">,</span> <span class="n">sync_wait_cb</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;%s lkid %x flags %x mode %d error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">name</span><span class="p">,</span> <span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lkid</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_sync_wait</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;%s lkid %x flags %x mode %d status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">name</span><span class="p">,</span> <span class="n">lksb</span><span class="o">-&gt;</span><span class="n">sb_lkid</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mounted_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sync_unlock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_mounted_lksb</span><span class="p">,</span> <span class="s">&quot;mounted_lock&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mounted_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sync_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">GFS2_MOUNTED_LOCK</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_mounted_lksb</span><span class="p">,</span> <span class="s">&quot;mounted_lock&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">control_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sync_unlock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lksb</span><span class="p">,</span> <span class="s">&quot;control_lock&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">control_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sync_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">GFS2_CONTROL_LOCK</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lksb</span><span class="p">,</span> <span class="s">&quot;control_lock&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gfs2_control_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gfs2_sbd</span><span class="p">,</span> <span class="n">sd_control_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">lvb_bits</span><span class="p">[</span><span class="n">GDLM_LVB_SIZE</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">block_gen</span><span class="p">,</span> <span class="n">start_gen</span><span class="p">,</span> <span class="n">lvb_gen</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recover_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_lvb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recover_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * No MOUNT_DONE means we&#39;re still mounting; control_mount()</span>
<span class="cm">	 * will set this flag, after which this thread will take over</span>
<span class="cm">	 * all further clearing of BLOCK_LOCKS.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIRST_MOUNT means this node is doing first mounter recovery,</span>
<span class="cm">	 * for which recovery control is handled by</span>
<span class="cm">	 * control_mount()/control_first_done(), not this thread.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_MOUNT_DONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_FIRST_MOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">block_gen</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span><span class="p">;</span>
	<span class="n">start_gen</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_start</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Equal block_gen and start_gen implies we are between</span>
<span class="cm">	 * recover_prep and recover_done callbacks, which means</span>
<span class="cm">	 * dlm recovery is in progress and dlm locking is blocked.</span>
<span class="cm">	 * There&#39;s no point trying to do any work until recover_done.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_gen</span> <span class="o">==</span> <span class="n">start_gen</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Propagate recover_submit[] and recover_result[] to lvb:</span>
<span class="cm">	 * dlm_recoverd adds to recover_submit[] jids needing recovery</span>
<span class="cm">	 * gfs2_recover adds to recover_result[] journal recovery results</span>
<span class="cm">	 *</span>
<span class="cm">	 * set lvb bit for jids in recover_submit[] if the lvb has not</span>
<span class="cm">	 * yet been updated for the generation of the failure</span>
<span class="cm">	 *</span>
<span class="cm">	 * clear lvb bit for jids in recover_result[] if the result of</span>
<span class="cm">	 * the journal recovery is SUCCESS</span>
<span class="cm">	 */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">control_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_EX</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="o">|</span><span class="n">DLM_LKF_VALBLK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control lock EX error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">control_lvb_read</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lvb_gen</span><span class="p">,</span> <span class="n">lvb_bits</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_gen</span> <span class="o">!=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span> <span class="o">||</span>
	    <span class="n">start_gen</span> <span class="o">!=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;recover generation %u block1 %u %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">start_gen</span><span class="p">,</span> <span class="n">block_gen</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="n">control_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_NL</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">recover_size</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lvb_gen</span> <span class="o">&lt;=</span> <span class="n">start_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear lvb bits for jids we&#39;ve successfully recovered.</span>
<span class="cm">		 * Because all nodes attempt to recover failed journals,</span>
<span class="cm">		 * a journal can be recovered multiple times successfully</span>
<span class="cm">		 * in succession.  Only the first will really do recovery,</span>
<span class="cm">		 * the others find it clean, but still report a successful</span>
<span class="cm">		 * recovery.  So, another node may have already recovered</span>
<span class="cm">		 * the jid and cleared the lvb bit for it.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">recover_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">LM_RD_SUCCESS</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit_le</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lvb_bits</span> <span class="o">+</span> <span class="n">JID_BITMAP_OFFSET</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">__clear_bit_le</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lvb_bits</span> <span class="o">+</span> <span class="n">JID_BITMAP_OFFSET</span><span class="p">);</span>
			<span class="n">write_lvb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lvb_gen</span> <span class="o">==</span> <span class="n">start_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Failed slots before start_gen are already set in lvb.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">recover_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lvb_gen</span><span class="p">)</span>
				<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lvb_gen</span> <span class="o">&lt;</span> <span class="n">start_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Failed slots before start_gen are not yet set in lvb.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">recover_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">start_gen</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">__set_bit_le</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lvb_bits</span> <span class="o">+</span> <span class="n">JID_BITMAP_OFFSET</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* even if there are no bits to set, we need to write the</span>
<span class="cm">		   latest generation to the lvb */</span>
		<span class="n">write_lvb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we should be getting a recover_done() for lvb_gen soon</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write_lvb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">control_lvb_write</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">start_gen</span><span class="p">,</span> <span class="n">lvb_bits</span><span class="p">);</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">DLM_LKF_CONVERT</span> <span class="o">|</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">control_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_NL</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control lock NL error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Everyone will see jid bits set in the lvb, run gfs2_recover_set(),</span>
<span class="cm">	 * and clear a jid bit in the lvb if the recovery is a success.</span>
<span class="cm">	 * Eventually all journals will be recovered, all jid bits will</span>
<span class="cm">	 * be cleared in the lvb, and everyone will clear BLOCK_LOCKS.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">recover_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit_le</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lvb_bits</span> <span class="o">+</span> <span class="n">JID_BITMAP_OFFSET</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;recover generation %u jid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">start_gen</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">gfs2_recover_set</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">recover_set</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recover_set</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No more jid bits set in lvb, all recovery is done, unblock locks</span>
<span class="cm">	 * (unless a new recover_prep callback has occured blocking locks</span>
<span class="cm">	 * again while working above)</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span> <span class="o">==</span> <span class="n">block_gen</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_start</span> <span class="o">==</span> <span class="n">start_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">DFL_BLOCK_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;recover generation %u done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start_gen</span><span class="p">);</span>
		<span class="n">gfs2_glock_thaw</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;recover generation %u block2 %u %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">start_gen</span><span class="p">,</span> <span class="n">block_gen</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">control_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">lvb_bits</span><span class="p">[</span><span class="n">GDLM_LVB_SIZE</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">start_gen</span><span class="p">,</span> <span class="n">block_gen</span><span class="p">,</span> <span class="n">mount_gen</span><span class="p">,</span> <span class="n">lvb_gen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mounted_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_mounted_lksb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lksb</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lksb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lksb</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lvb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GDLM_LVB_SIZE</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lksb</span><span class="p">.</span><span class="n">sb_lvbptr</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_control_lvb</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_sync_wait</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_BLOCK_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">control_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_NL</span><span class="p">,</span> <span class="n">DLM_LKF_VALBLK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount control_lock NL error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mounted_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_NL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount mounted_lock NL error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="n">control_unlock</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mounted_mode</span> <span class="o">=</span> <span class="n">DLM_LOCK_NL</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retries</span><span class="o">++</span> <span class="o">&amp;&amp;</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We always start with both locks in NL. control_lock is</span>
<span class="cm">	 * demoted to NL below so we don&#39;t need to do it here.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mounted_mode</span> <span class="o">!=</span> <span class="n">DLM_LOCK_NL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mounted_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_NL</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">mounted_mode</span> <span class="o">=</span> <span class="n">DLM_LOCK_NL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Other nodes need to do some work in dlm recovery and gfs2_control</span>
<span class="cm">	 * before the recover_done and control_lock will be ready for us below.</span>
<span class="cm">	 * A delay here is not required but often avoids having to retry.</span>
<span class="cm">	 */</span>

	<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Acquire control_lock in EX and mounted_lock in either EX or PR.</span>
<span class="cm">	 * control_lock lvb keeps track of any pending journal recoveries.</span>
<span class="cm">	 * mounted_lock indicates if any other nodes have the fs mounted.</span>
<span class="cm">	 */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">control_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_EX</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="o">|</span><span class="n">DLM_LKF_NOQUEUE</span><span class="o">|</span><span class="n">DLM_LKF_VALBLK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount control_lock EX error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mounted_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_EX</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="o">|</span><span class="n">DLM_LKF_NOQUEUE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mounted_mode</span> <span class="o">=</span> <span class="n">DLM_LOCK_EX</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">locks_done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount mounted_lock EX error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mounted_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_PR</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="o">|</span><span class="n">DLM_LKF_NOQUEUE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mounted_mode</span> <span class="o">=</span> <span class="n">DLM_LOCK_PR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">locks_done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* not even -EAGAIN should happen here */</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount mounted_lock PR error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">locks_done:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we got both locks above in EX, then we&#39;re the first mounter.</span>
<span class="cm">	 * If not, then we need to wait for the control_lock lvb to be</span>
<span class="cm">	 * updated by other mounted nodes to reflect our mount generation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In simple first mounter cases, first mounter will see zero lvb_gen,</span>
<span class="cm">	 * but in cases where all existing nodes leave/fail before mounting</span>
<span class="cm">	 * nodes finish control_mount, then all nodes will be mounting and</span>
<span class="cm">	 * lvb_gen will be non-zero.</span>
<span class="cm">	 */</span>

	<span class="n">control_lvb_read</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lvb_gen</span><span class="p">,</span> <span class="n">lvb_bits</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lvb_gen</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* special value to force mount attempts to fail */</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount control_lock disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mounted_mode</span> <span class="o">==</span> <span class="n">DLM_LOCK_EX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* first mounter, keep both EX while doing first recovery */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">DFL_BLOCK_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_MOUNT_DONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_FIRST_MOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;first mounter control generation %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lvb_gen</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">control_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_NL</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are not first mounter, now we need to wait for the control_lock</span>
<span class="cm">	 * lvb generation to be &gt;= the generation from our first recover_done</span>
<span class="cm">	 * and all lvb bits to be clear (no pending journal recoveries.)</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">all_jid_bits_clear</span><span class="p">(</span><span class="n">lvb_bits</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* journals need recovery, wait until all are clear */</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount wait for journal recovery</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="n">block_gen</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span><span class="p">;</span>
	<span class="n">start_gen</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_start</span><span class="p">;</span>
	<span class="n">mount_gen</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_mount</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lvb_gen</span> <span class="o">&lt;</span> <span class="n">mount_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* wait for mounted nodes to update control_lock lvb to our</span>
<span class="cm">		   generation, which might include new recovery bits set */</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount wait1 block %u start %u mount %u &quot;</span>
			<span class="s">&quot;lvb %u flags %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block_gen</span><span class="p">,</span> <span class="n">start_gen</span><span class="p">,</span> <span class="n">mount_gen</span><span class="p">,</span>
			<span class="n">lvb_gen</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lvb_gen</span> <span class="o">!=</span> <span class="n">start_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* wait for mounted nodes to update control_lock lvb to the</span>
<span class="cm">		   latest recovery generation */</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount wait2 block %u start %u mount %u &quot;</span>
			<span class="s">&quot;lvb %u flags %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block_gen</span><span class="p">,</span> <span class="n">start_gen</span><span class="p">,</span> <span class="n">mount_gen</span><span class="p">,</span>
			<span class="n">lvb_gen</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_gen</span> <span class="o">==</span> <span class="n">start_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* dlm recovery in progress, wait for it to finish */</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_mount wait3 block %u start %u mount %u &quot;</span>
			<span class="s">&quot;lvb %u flags %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block_gen</span><span class="p">,</span> <span class="n">start_gen</span><span class="p">,</span> <span class="n">mount_gen</span><span class="p">,</span>
			<span class="n">lvb_gen</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">DFL_BLOCK_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_MOUNT_DONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">mounted_unlock</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="n">control_unlock</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_recovery_wait</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">control_first_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">lvb_bits</span><span class="p">[</span><span class="n">GDLM_LVB_SIZE</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">start_gen</span><span class="p">,</span> <span class="n">block_gen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="n">start_gen</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_start</span><span class="p">;</span>
	<span class="n">block_gen</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_BLOCK_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_MOUNT_DONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_FIRST_MOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* sanity check, should not happen */</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_first_done start %u block %u flags %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">start_gen</span><span class="p">,</span> <span class="n">block_gen</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="n">control_unlock</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start_gen</span> <span class="o">==</span> <span class="n">block_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wait for the end of a dlm recovery cycle to switch from</span>
<span class="cm">		 * first mounter recovery.  We can ignore any recover_slot</span>
<span class="cm">		 * callbacks between the recover_prep and next recover_done</span>
<span class="cm">		 * because we are still the first mounter and any failed nodes</span>
<span class="cm">		 * have not fully mounted, so they don&#39;t need recovery.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_first_done wait gen %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start_gen</span><span class="p">);</span>

		<span class="n">wait_on_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">,</span> <span class="n">DFL_DLM_RECOVERY</span><span class="p">,</span>
			    <span class="n">dlm_recovery_wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">DFL_FIRST_MOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_FIRST_MOUNT_DONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">lvb_bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lvb_bits</span><span class="p">));</span>
	<span class="n">control_lvb_write</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">start_gen</span><span class="p">,</span> <span class="n">lvb_bits</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mounted_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_PR</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_first_done mounted PR error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">control_lock</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">DLM_LOCK_NL</span><span class="p">,</span> <span class="n">DLM_LKF_CONVERT</span><span class="o">|</span><span class="n">DLM_LKF_VALBLK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;control_first_done control NL error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Expand static jid arrays if necessary (by increments of RECOVER_SIZE_INC)</span>
<span class="cm"> * to accomodate the largest slot number.  (NB dlm slot numbers start at 1,</span>
<span class="cm"> * gfs2 jids start at 0, so jid = slot - 1)</span>
<span class="cm"> */</span>

<span class="cp">#define RECOVER_SIZE_INC 16</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_recover_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">num_slots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">submit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">max_jid</span><span class="p">;</span>

	<span class="n">max_jid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_jid</span> <span class="o">&lt;</span> <span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">max_jid</span> <span class="o">=</span> <span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">old_size</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">&gt;=</span> <span class="n">max_jid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new_size</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">+</span> <span class="n">RECOVER_SIZE_INC</span><span class="p">;</span>

	<span class="n">submit</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">new_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">new_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">submit</span> <span class="o">||</span> <span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">submit</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">submit</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span> <span class="o">=</span> <span class="n">submit</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_recover_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* dlm calls before it does lock recovery */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_recover_prep</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_start</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_DLM_RECOVERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_MOUNT_DONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_FIRST_MOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_BLOCK_LOCKS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* dlm calls after recover_prep has been completed on all lockspace members;</span>
<span class="cm">   identifies slot/jid of failed member */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_recover_slot</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jid</span> <span class="o">=</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span> <span class="o">&lt;</span> <span class="n">jid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;recover_slot jid %d gen %u short size %d&quot;</span><span class="p">,</span>
		       <span class="n">jid</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">jid</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;recover_slot jid %d gen %u prev %u&quot;</span><span class="p">,</span>
			<span class="n">jid</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">jid</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span><span class="p">[</span><span class="n">jid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* dlm calls after recover_slot and after it completes lock recovery */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_recover_done</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_slots</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">our_slot</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">generation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>

	<span class="cm">/* ensure the ls jid arrays are large enough */</span>
	<span class="n">set_recover_size</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">slots</span><span class="p">,</span> <span class="n">num_slots</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_start</span> <span class="o">=</span> <span class="n">generation</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_mount</span> <span class="o">=</span> <span class="n">generation</span><span class="p">;</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_jid</span> <span class="o">=</span> <span class="n">our_slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_UNMOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">gfs2_control_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_control_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">DFL_DLM_RECOVERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">,</span> <span class="n">DFL_DLM_RECOVERY</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* gfs2_recover thread has a journal recovery result */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_recovery_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">jid</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_NO_DLM_OPS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* don&#39;t care about the recovery of own journal during mount */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jid</span> <span class="o">==</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_jid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_FIRST_MOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span> <span class="o">&lt;</span> <span class="n">jid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;recovery_result jid %d short size %d&quot;</span><span class="p">,</span>
		       <span class="n">jid</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;recover jid %d result %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jid</span><span class="p">,</span>
		<span class="n">result</span> <span class="o">==</span> <span class="n">LM_RD_GAVEUP</span> <span class="o">?</span> <span class="s">&quot;busy&quot;</span> <span class="o">:</span> <span class="s">&quot;success&quot;</span><span class="p">);</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span><span class="p">[</span><span class="n">jid</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* GAVEUP means another node is recovering the journal; delay our</span>
<span class="cm">	   next attempt to recover it, to give the other node a chance to</span>
<span class="cm">	   finish before trying again */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_UNMOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">gfs2_control_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_control_work</span><span class="p">,</span>
				   <span class="n">result</span> <span class="o">==</span> <span class="n">LM_RD_GAVEUP</span> <span class="o">?</span> <span class="n">HZ</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dlm_lockspace_ops</span> <span class="n">gdlm_lockspace_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">recover_prep</span> <span class="o">=</span> <span class="n">gdlm_recover_prep</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recover_slot</span> <span class="o">=</span> <span class="n">gdlm_recover_slot</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recover_done</span> <span class="o">=</span> <span class="n">gdlm_recover_done</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gdlm_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cluster</span><span class="p">[</span><span class="n">GFS2_LOCKNAME_LEN</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fsname</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">ops_result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize everything</span>
<span class="cm">	 */</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_control_work</span><span class="p">,</span> <span class="n">gfs2_control_func</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_mount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_submit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">set_recover_size</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * prepare dlm_new_lockspace args</span>
<span class="cm">	 */</span>

	<span class="n">fsname</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsname</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;no fsname found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cluster</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="n">fsname</span><span class="p">));</span>
	<span class="n">fsname</span><span class="o">++</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">DLM_LSFL_FS</span> <span class="o">|</span> <span class="n">DLM_LSFL_NEWEXCL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * create/join lockspace</span>
<span class="cm">	 */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_new_lockspace</span><span class="p">(</span><span class="n">fsname</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">GDLM_LVB_SIZE</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">gdlm_lockspace_ops</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops_result</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;dlm_new_lockspace error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops_result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * dlm does not support ops callbacks,</span>
<span class="cm">		 * old dlm_controld/gfs_controld are used, try without ops.</span>
<span class="cm">		 */</span>
		<span class="n">fs_info</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;dlm lockspace ops not used</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">free_recover_size</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_NO_DLM_OPS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SDF_NOJOURNALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;dlm lockspace ops disallow jid preset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * control_mount() uses control_lock to determine first mounter,</span>
<span class="cm">	 * and for later mounts, waits for any recoveries to be cleared.</span>
<span class="cm">	 */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">control_mount</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;mount control error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_first</span> <span class="o">=</span> <span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_FIRST_MOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SDF_NOJOURNALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_flags</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_flags</span><span class="p">,</span> <span class="n">SDF_NOJOURNALID</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_release:</span>
	<span class="n">dlm_release_lockspace</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nl">fail_free:</span>
	<span class="n">free_recover_size</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_first_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_NO_DLM_OPS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">control_first_done</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fs_err</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;mount first_done error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdlm_unmount</span><span class="p">(</span><span class="k">struct</span> <span class="n">gfs2_sbd</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lm_lockstruct</span> <span class="o">*</span><span class="n">ls</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_lockstruct</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DFL_NO_DLM_OPS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>

	<span class="cm">/* wait for gfs2_control_wq to be done with this mount */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">DFL_UNMOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_flags</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_spin</span><span class="p">);</span>
	<span class="n">flush_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sd_control_work</span><span class="p">);</span>

	<span class="cm">/* mounted_lock and control_lock will be purged in dlm recovery */</span>
<span class="nl">release:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dlm_release_lockspace</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_dlm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_recover_size</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">match_table_t</span> <span class="n">dlm_tokens</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">Opt_jid</span><span class="p">,</span> <span class="s">&quot;jid=%d&quot;</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">Opt_id</span><span class="p">,</span> <span class="s">&quot;id=%d&quot;</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">Opt_first</span><span class="p">,</span> <span class="s">&quot;first=%d&quot;</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">Opt_nodir</span><span class="p">,</span> <span class="s">&quot;nodir=%d&quot;</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">Opt_err</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">lm_lockops</span> <span class="n">gfs2_dlm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lm_proto_name</span> <span class="o">=</span> <span class="s">&quot;lock_dlm&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_mount</span> <span class="o">=</span> <span class="n">gdlm_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_first_done</span> <span class="o">=</span> <span class="n">gdlm_first_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_recovery_result</span> <span class="o">=</span> <span class="n">gdlm_recovery_result</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_unmount</span> <span class="o">=</span> <span class="n">gdlm_unmount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_put_lock</span> <span class="o">=</span> <span class="n">gdlm_put_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_lock</span> <span class="o">=</span> <span class="n">gdlm_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_cancel</span> <span class="o">=</span> <span class="n">gdlm_cancel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_tokens</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlm_tokens</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
