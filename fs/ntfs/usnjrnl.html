<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › usnjrnl.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>usnjrnl.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * usnjrnl.h - Defines for NTFS kernel transaction log ($UsnJrnl) handling.</span>
<span class="cm"> *	       Part of the Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2005 Anton Altaparmakov</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_NTFS_USNJRNL_H</span>
<span class="cp">#define _LINUX_NTFS_USNJRNL_H</span>

<span class="cp">#ifdef NTFS_RW</span>

<span class="cp">#include &quot;types.h&quot;</span>
<span class="cp">#include &quot;endian.h&quot;</span>
<span class="cp">#include &quot;layout.h&quot;</span>
<span class="cp">#include &quot;volume.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Transaction log ($UsnJrnl) organization:</span>
<span class="cm"> *</span>
<span class="cm"> * The transaction log records whenever a file is modified in any way.  So for</span>
<span class="cm"> * example it will record that file &quot;blah&quot; was written to at a particular time</span>
<span class="cm"> * but not what was written.  If will record that a file was deleted or</span>
<span class="cm"> * created, that a file was truncated, etc.  See below for all the reason</span>
<span class="cm"> * codes used.</span>
<span class="cm"> *</span>
<span class="cm"> * The transaction log is in the $Extend directory which is in the root</span>
<span class="cm"> * directory of each volume.  If it is not present it means transaction</span>
<span class="cm"> * logging is disabled.  If it is present it means transaction logging is</span>
<span class="cm"> * either enabled or in the process of being disabled in which case we can</span>
<span class="cm"> * ignore it as it will go away as soon as Windows gets its hands on it.</span>
<span class="cm"> *</span>
<span class="cm"> * To determine whether the transaction logging is enabled or in the process</span>
<span class="cm"> * of being disabled, need to check the volume flags in the</span>
<span class="cm"> * $VOLUME_INFORMATION attribute in the $Volume system file (which is present</span>
<span class="cm"> * in the root directory and has a fixed mft record number, see layout.h).</span>
<span class="cm"> * If the flag VOLUME_DELETE_USN_UNDERWAY is set it means the transaction log</span>
<span class="cm"> * is in the process of being disabled and if this flag is clear it means the</span>
<span class="cm"> * transaction log is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * The transaction log consists of two parts; the $DATA/$Max attribute as well</span>
<span class="cm"> * as the $DATA/$J attribute.  $Max is a header describing the transaction</span>
<span class="cm"> * log whilst $J is the transaction log data itself as a sequence of variable</span>
<span class="cm"> * sized USN_RECORDs (see below for all the structures).</span>
<span class="cm"> *</span>
<span class="cm"> * We do not care about transaction logging at this point in time but we still</span>
<span class="cm"> * need to let windows know that the transaction log is out of date.  To do</span>
<span class="cm"> * this we need to stamp the transaction log.  This involves setting the</span>
<span class="cm"> * lowest_valid_usn field in the $DATA/$Max attribute to the usn to be used</span>
<span class="cm"> * for the next added USN_RECORD to the $DATA/$J attribute as well as</span>
<span class="cm"> * generating a new journal_id in $DATA/$Max.</span>
<span class="cm"> *</span>
<span class="cm"> * The journal_id is as of the current version (2.0) of the transaction log</span>
<span class="cm"> * simply the 64-bit timestamp of when the journal was either created or last</span>
<span class="cm"> * stamped.</span>
<span class="cm"> *</span>
<span class="cm"> * To determine the next usn there are two ways.  The first is to parse</span>
<span class="cm"> * $DATA/$J and to find the last USN_RECORD in it and to add its record_length</span>
<span class="cm"> * to its usn (which is the byte offset in the $DATA/$J attribute).  The</span>
<span class="cm"> * second is simply to take the data size of the attribute.  Since the usns</span>
<span class="cm"> * are simply byte offsets into $DATA/$J, this is exactly the next usn.  For</span>
<span class="cm"> * obvious reasons we use the second method as it is much simpler and faster.</span>
<span class="cm"> *</span>
<span class="cm"> * As an aside, note that to actually disable the transaction log, one would</span>
<span class="cm"> * need to set the VOLUME_DELETE_USN_UNDERWAY flag (see above), then go</span>
<span class="cm"> * through all the mft records on the volume and set the usn field in their</span>
<span class="cm"> * $STANDARD_INFORMATION attribute to zero.  Once that is done, one would need</span>
<span class="cm"> * to delete the transaction log file, i.e. \$Extent\$UsnJrnl, and finally,</span>
<span class="cm"> * one would need to clear the VOLUME_DELETE_USN_UNDERWAY flag.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if a volume is unmounted whilst the transaction log is being</span>
<span class="cm"> * disabled, the process will continue the next time the volume is mounted.</span>
<span class="cm"> * This is why we can safely mount read-write when we see a transaction log</span>
<span class="cm"> * in the process of being deleted.</span>
<span class="cm"> */</span>

<span class="cm">/* Some $UsnJrnl related constants. */</span>
<span class="cp">#define UsnJrnlMajorVer		2</span>
<span class="cp">#define UsnJrnlMinorVer		0</span>

<span class="cm">/*</span>
<span class="cm"> * $DATA/$Max attribute.  This is (always?) resident and has a fixed size of</span>
<span class="cm"> * 32 bytes.  It contains the header describing the transaction log.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*   0*/</span><span class="n">sle64</span> <span class="n">maximum_size</span><span class="p">;</span>	<span class="cm">/* The maximum on-disk size of the $DATA/$J</span>
<span class="cm">				   attribute. */</span>
<span class="cm">/*   8*/</span><span class="n">sle64</span> <span class="n">allocation_delta</span><span class="p">;</span>	<span class="cm">/* Number of bytes by which to increase the</span>
<span class="cm">				   size of the $DATA/$J attribute. */</span>
<span class="cm">/*0x10*/</span><span class="n">sle64</span> <span class="n">journal_id</span><span class="p">;</span>	<span class="cm">/* Current id of the transaction log. */</span>
<span class="cm">/*0x18*/</span><span class="n">leUSN</span> <span class="n">lowest_valid_usn</span><span class="p">;</span>	<span class="cm">/* Lowest valid usn in $DATA/$J for the</span>
<span class="cm">				   current journal_id. */</span>
<span class="cm">/* sizeof() = 32 (0x20) bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">USN_HEADER</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Reason flags (32-bit).  Cumulative flags describing the change(s) to the</span>
<span class="cm"> * file since it was last opened.  I think the names speak for themselves but</span>
<span class="cm"> * if you disagree check out the descriptions in the Linux NTFS project NTFS</span>
<span class="cm"> * documentation: http://www.linux-ntfs.org/</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">USN_REASON_DATA_OVERWRITE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>
	<span class="n">USN_REASON_DATA_EXTEND</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">),</span>
	<span class="n">USN_REASON_DATA_TRUNCATION</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000004</span><span class="p">),</span>
	<span class="n">USN_REASON_NAMED_DATA_OVERWRITE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000010</span><span class="p">),</span>
	<span class="n">USN_REASON_NAMED_DATA_EXTEND</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000020</span><span class="p">),</span>
	<span class="n">USN_REASON_NAMED_DATA_TRUNCATION</span><span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000040</span><span class="p">),</span>
	<span class="n">USN_REASON_FILE_CREATE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000100</span><span class="p">),</span>
	<span class="n">USN_REASON_FILE_DELETE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000200</span><span class="p">),</span>
	<span class="n">USN_REASON_EA_CHANGE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000400</span><span class="p">),</span>
	<span class="n">USN_REASON_SECURITY_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000800</span><span class="p">),</span>
	<span class="n">USN_REASON_RENAME_OLD_NAME</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00001000</span><span class="p">),</span>
	<span class="n">USN_REASON_RENAME_NEW_NAME</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00002000</span><span class="p">),</span>
	<span class="n">USN_REASON_INDEXABLE_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00004000</span><span class="p">),</span>
	<span class="n">USN_REASON_BASIC_INFO_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00008000</span><span class="p">),</span>
	<span class="n">USN_REASON_HARD_LINK_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00010000</span><span class="p">),</span>
	<span class="n">USN_REASON_COMPRESSION_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00020000</span><span class="p">),</span>
	<span class="n">USN_REASON_ENCRYPTION_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00040000</span><span class="p">),</span>
	<span class="n">USN_REASON_OBJECT_ID_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00080000</span><span class="p">),</span>
	<span class="n">USN_REASON_REPARSE_POINT_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00100000</span><span class="p">),</span>
	<span class="n">USN_REASON_STREAM_CHANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00200000</span><span class="p">),</span>
	<span class="n">USN_REASON_CLOSE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">USN_REASON_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Source info flags (32-bit).  Information about the source of the change(s)</span>
<span class="cm"> * to the file.  For detailed descriptions of what these mean, see the Linux</span>
<span class="cm"> * NTFS project NTFS documentation:</span>
<span class="cm"> *	http://www.linux-ntfs.org/</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">USN_SOURCE_DATA_MANAGEMENT</span>	  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>
	<span class="n">USN_SOURCE_AUXILIARY_DATA</span>	  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">),</span>
	<span class="n">USN_SOURCE_REPLICATION_MANAGEMENT</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000004</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">USN_SOURCE_INFO_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * $DATA/$J attribute.  This is always non-resident, is marked as sparse, and</span>
<span class="cm"> * is of variabled size.  It consists of a sequence of variable size</span>
<span class="cm"> * USN_RECORDS.  The minimum allocated_size is allocation_delta as</span>
<span class="cm"> * specified in $DATA/$Max.  When the maximum_size specified in $DATA/$Max is</span>
<span class="cm"> * exceeded by more than allocation_delta bytes, allocation_delta bytes are</span>
<span class="cm"> * allocated and appended to the $DATA/$J attribute and an equal number of</span>
<span class="cm"> * bytes at the beginning of the attribute are freed and made sparse.  Note the</span>
<span class="cm"> * making sparse only happens at volume checkpoints and hence the actual</span>
<span class="cm"> * $DATA/$J size can exceed maximum_size + allocation_delta temporarily.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*   0*/</span><span class="n">le32</span> <span class="n">length</span><span class="p">;</span>		<span class="cm">/* Byte size of this record (8-byte</span>
<span class="cm">				   aligned). */</span>
<span class="cm">/*   4*/</span><span class="n">le16</span> <span class="n">major_ver</span><span class="p">;</span>		<span class="cm">/* Major version of the transaction log used</span>
<span class="cm">				   for this record. */</span>
<span class="cm">/*   6*/</span><span class="n">le16</span> <span class="n">minor_ver</span><span class="p">;</span>		<span class="cm">/* Minor version of the transaction log used</span>
<span class="cm">				   for this record. */</span>
<span class="cm">/*   8*/</span><span class="n">leMFT_REF</span> <span class="n">mft_reference</span><span class="p">;</span><span class="cm">/* The mft reference of the file (or</span>
<span class="cm">				   directory) described by this record. */</span>
<span class="cm">/*0x10*/</span><span class="n">leMFT_REF</span> <span class="n">parent_directory</span><span class="p">;</span><span class="cm">/* The mft reference of the parent</span>
<span class="cm">				   directory of the file described by this</span>
<span class="cm">				   record. */</span>
<span class="cm">/*0x18*/</span><span class="n">leUSN</span> <span class="n">usn</span><span class="p">;</span>		<span class="cm">/* The usn of this record.  Equals the offset</span>
<span class="cm">				   within the $DATA/$J attribute. */</span>
<span class="cm">/*0x20*/</span><span class="n">sle64</span> <span class="n">time</span><span class="p">;</span>		<span class="cm">/* Time when this record was created. */</span>
<span class="cm">/*0x28*/</span><span class="n">USN_REASON_FLAGS</span> <span class="n">reason</span><span class="p">;</span><span class="cm">/* Reason flags (see above). */</span>
<span class="cm">/*0x2c*/</span><span class="n">USN_SOURCE_INFO_FLAGS</span> <span class="n">source_info</span><span class="p">;</span><span class="cm">/* Source info flags (see above). */</span>
<span class="cm">/*0x30*/</span><span class="n">le32</span> <span class="n">security_id</span><span class="p">;</span>	<span class="cm">/* File security_id copied from</span>
<span class="cm">				   $STANDARD_INFORMATION. */</span>
<span class="cm">/*0x34*/</span><span class="n">FILE_ATTR_FLAGS</span> <span class="n">file_attributes</span><span class="p">;</span>	<span class="cm">/* File attributes copied from</span>
<span class="cm">				   $STANDARD_INFORMATION or $FILE_NAME (not</span>
<span class="cm">				   sure which). */</span>
<span class="cm">/*0x38*/</span><span class="n">le16</span> <span class="n">file_name_size</span><span class="p">;</span>	<span class="cm">/* Size of the file name in bytes. */</span>
<span class="cm">/*0x3a*/</span><span class="n">le16</span> <span class="n">file_name_offset</span><span class="p">;</span>	<span class="cm">/* Offset to the file name in bytes from the</span>
<span class="cm">				   start of this record. */</span>
<span class="cm">/*0x3c*/</span><span class="n">ntfschar</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Use when creating only.  When reading use</span>
<span class="cm">				   file_name_offset to determine the location</span>
<span class="cm">				   of the name. */</span>
<span class="cm">/* sizeof() = 60 (0x3c) bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">USN_RECORD</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">ntfs_stamp_usnjrnl</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_NTFS_USNJRNL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
