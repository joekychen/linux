<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › file.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>file.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * file.c - NTFS kernel file operations.  Part of the Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2011 Anton Altaparmakov and Tuxera Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &quot;attrib.h&quot;</span>
<span class="cp">#include &quot;bitmap.h&quot;</span>
<span class="cp">#include &quot;inode.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;lcnalloc.h&quot;</span>
<span class="cp">#include &quot;malloc.h&quot;</span>
<span class="cp">#include &quot;mft.h&quot;</span>
<span class="cp">#include &quot;ntfs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_file_open - called when an inode is about to be opened</span>
<span class="cm"> * @vi:		inode to be opened</span>
<span class="cm"> * @filp:	file structure describing the inode</span>
<span class="cm"> *</span>
<span class="cm"> * Limit file size to the page cache limit on architectures where unsigned long</span>
<span class="cm"> * is 32-bits. This is the most we can do for now without overflowing the page</span>
<span class="cm"> * cache page index. Doing it this way means we don&#39;t run into problems because</span>
<span class="cm"> * of existing too large files. It would be better to allow the user to read</span>
<span class="cm"> * the beginning of the file but I doubt very much anyone is going to hit this</span>
<span class="cm"> * check on a 32-bit architecture, so there is no point in adding the extra</span>
<span class="cm"> * complexity required to support this.</span>
<span class="cm"> *</span>
<span class="cm"> * On 64-bit architectures, the check is hopefully optimized away by the</span>
<span class="cm"> * compiler.</span>
<span class="cm"> *</span>
<span class="cm"> * After the check passes, just call generic_file_open() to do its work.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">generic_file_open</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef NTFS_RW</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_attr_extend_initialized - extend the initialized size of an attribute</span>
<span class="cm"> * @ni:			ntfs inode of the attribute to extend</span>
<span class="cm"> * @new_init_size:	requested new initialized size in bytes</span>
<span class="cm"> * @cached_page:	store any allocated but unused page here</span>
<span class="cm"> * @lru_pvec:		lru-buffering pagevec of the caller</span>
<span class="cm"> *</span>
<span class="cm"> * Extend the initialized size of an attribute described by the ntfs inode @ni</span>
<span class="cm"> * to @new_init_size bytes.  This involves zeroing any non-sparse space between</span>
<span class="cm"> * the old initialized size and @new_init_size both in the page cache and on</span>
<span class="cm"> * disk (if relevant complete pages are already uptodate in the page cache then</span>
<span class="cm"> * these are simply marked dirty).</span>
<span class="cm"> *</span>
<span class="cm"> * As a side-effect, the file size (vfs inode-&gt;i_size) may be incremented as,</span>
<span class="cm"> * in the resident attribute case, it is tied to the initialized size and, in</span>
<span class="cm"> * the non-resident attribute case, it may not fall below the initialized size.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if the attribute is resident, we do not need to touch the page</span>
<span class="cm"> * cache at all.  This is because if the page cache page is not uptodate we</span>
<span class="cm"> * bring it uptodate later, when doing the write to the mft record since we</span>
<span class="cm"> * then already have the page mapped.  And if the page is uptodate, the</span>
<span class="cm"> * non-initialized region will already have been zeroed when the page was</span>
<span class="cm"> * brought uptodate and the region may in fact already have been overwritten</span>
<span class="cm"> * with new data via mmap() based writes, so we cannot just zero it.  And since</span>
<span class="cm"> * POSIX specifies that the behaviour of resizing a file whilst it is mmap()ped</span>
<span class="cm"> * is unspecified, we choose not to do zeroing and thus we do not need to touch</span>
<span class="cm"> * the page at all.  For a more detailed explanation see ntfs_truncate() in</span>
<span class="cm"> * fs/ntfs/inode.c.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success and -errno on error.  In the case that an error is</span>
<span class="cm"> * encountered it is possible that the initialized size will already have been</span>
<span class="cm"> * incremented some way towards @new_init_size but it is guaranteed that if</span>
<span class="cm"> * this is the case, the necessary zeroing will also have happened and that all</span>
<span class="cm"> * metadata is self-consistent.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: i_mutex on the vfs inode corrseponsind to the ntfs inode @ni must be</span>
<span class="cm"> *	    held by the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_attr_extend_initialized</span><span class="p">(</span><span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">,</span> <span class="k">const</span> <span class="n">s64</span> <span class="n">new_init_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">old_init_size</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">old_i_size</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">VFS_I</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">base_ni</span><span class="p">;</span>
	<span class="n">MFT_RECORD</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ATTR_RECORD</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">kattr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">attr_len</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old_init_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span><span class="p">;</span>
	<span class="n">old_i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">new_init_size</span> <span class="o">&gt;</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">allocated_size</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering for i_ino 0x%lx, attribute type 0x%x, &quot;</span>
			<span class="s">&quot;old_initialized_size 0x%llx, &quot;</span>
			<span class="s">&quot;new_initialized_size 0x%llx, i_size 0x%llx.&quot;</span><span class="p">,</span>
			<span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">old_init_size</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_init_size</span><span class="p">,</span> <span class="n">old_i_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NInoAttr</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span>
		<span class="n">base_ni</span> <span class="o">=</span> <span class="n">ni</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">base_ni</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">ext</span><span class="p">.</span><span class="n">base_ntfs_ino</span><span class="p">;</span>
	<span class="cm">/* Use goto to reduce indentation and we need the label below anyway. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NInoNonResident</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">do_non_resident_extend</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">old_init_size</span> <span class="o">!=</span> <span class="n">old_i_size</span><span class="p">);</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">base_ni</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span>
			<span class="n">CASE_SENSITIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mrec</span><span class="p">;</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">non_resident</span><span class="p">);</span>
	<span class="cm">/* The total length of the attribute value. */</span>
	<span class="n">attr_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_length</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">old_i_size</span> <span class="o">!=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">attr_len</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do the zeroing in the mft record and update the attribute size in</span>
<span class="cm">	 * the mft record.</span>
<span class="cm">	 */</span>
	<span class="n">kattr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_offset</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">kattr</span> <span class="o">+</span> <span class="n">attr_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_init_size</span> <span class="o">-</span> <span class="n">attr_len</span><span class="p">);</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">new_init_size</span><span class="p">);</span>
	<span class="cm">/* Finally, update the sizes in the vfs and ntfs inodes. */</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">i_size_write</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">new_init_size</span><span class="p">);</span>
	<span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">=</span> <span class="n">new_init_size</span><span class="p">;</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="nl">do_non_resident_extend:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the new initialized size @new_init_size exceeds the current file</span>
<span class="cm">	 * size (vfs inode-&gt;i_size), we need to extend the file size to the</span>
<span class="cm">	 * new initialized size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_init_size</span> <span class="o">&gt;</span> <span class="n">old_i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
			<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">base_ni</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span>
				<span class="n">CASE_SENSITIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mrec</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">non_resident</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">old_i_size</span> <span class="o">!=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span>
				<span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">data_size</span><span class="p">));</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">cpu_to_sle64</span><span class="p">(</span><span class="n">new_init_size</span><span class="p">);</span>
		<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
		<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
		<span class="cm">/* Update the file size in the vfs inode. */</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">new_init_size</span><span class="p">);</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">old_init_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">end_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_init_size</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read the page.  If the page is not present, this will zero</span>
<span class="cm">		 * the uninitialized regions for us.</span>
<span class="cm">		 */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">read_mapping_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">init_err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageError</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">init_err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update the initialized size in the ntfs inode.  This is</span>
<span class="cm">		 * enough to make ntfs_writepage() work.</span>
<span class="cm">		 */</span>
		<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">&gt;</span> <span class="n">new_init_size</span><span class="p">)</span>
			<span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">=</span> <span class="n">new_init_size</span><span class="p">;</span>
		<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Set the page dirty so it gets written out. */</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Play nice with the vm and the rest of the system.  This is</span>
<span class="cm">		 * very much needed as we can potentially be modifying the</span>
<span class="cm">		 * initialised size from a very small value to a really huge</span>
<span class="cm">		 * value, e.g.</span>
<span class="cm">		 *	f = open(somefile, O_TRUNC);</span>
<span class="cm">		 *	truncate(f, 10GiB);</span>
<span class="cm">		 *	seek(f, 10GiB);</span>
<span class="cm">		 *	write(f, 1);</span>
<span class="cm">		 * And this would mean we would be marking dirty hundreds of</span>
<span class="cm">		 * thousands of pages or as in the above example more than</span>
<span class="cm">		 * two and a half million pages!</span>
<span class="cm">		 *</span>
<span class="cm">		 * TODO: For sparse pages could optimize this workload by using</span>
<span class="cm">		 * the FsMisc / MiscFs page bit as a &quot;PageIsSparse&quot; bit.  This</span>
<span class="cm">		 * would be set in readpage for sparse pages and here we would</span>
<span class="cm">		 * not need to mark dirty any pages which have this bit set.</span>
<span class="cm">		 * The only caveat is that we have to clear the bit everywhere</span>
<span class="cm">		 * where we allocate any clusters that lie in the page or that</span>
<span class="cm">		 * contain the page.</span>
<span class="cm">		 *</span>
<span class="cm">		 * TODO: An even greater optimization would be for us to only</span>
<span class="cm">		 * call readpage() on pages which are not in sparse regions as</span>
<span class="cm">		 * determined from the runlist.  This would greatly reduce the</span>
<span class="cm">		 * number of pages we read and make dirty in the case of sparse</span>
<span class="cm">		 * files.</span>
<span class="cm">		 */</span>
		<span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">end_index</span><span class="p">);</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">!=</span> <span class="n">new_init_size</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Now bring in sync the initialized_size in the mft record. */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">init_err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">base_ni</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">init_err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span>
			<span class="n">CASE_SENSITIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">init_err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mrec</span><span class="p">;</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">non_resident</span><span class="p">);</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">initialized_size</span> <span class="o">=</span> <span class="n">cpu_to_sle64</span><span class="p">(</span><span class="n">new_init_size</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
	<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done, initialized_size 0x%llx, i_size 0x%llx.&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_init_size</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">init_err_out:</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">=</span> <span class="n">old_init_size</span><span class="p">;</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Failed.  Returning error code %i.&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_fault_in_pages_readable -</span>
<span class="cm"> *</span>
<span class="cm"> * Fault a number of userspace pages into pagetables.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike include/linux/pagemap.h::fault_in_pages_readable(), this one copes</span>
<span class="cm"> * with more than two userspace pages as well as handling the single page case</span>
<span class="cm"> * elegantly.</span>
<span class="cm"> *</span>
<span class="cm"> * If you find this difficult to understand, then think of the while loop being</span>
<span class="cm"> * the following code, except that we do without the integer variable ret:</span>
<span class="cm"> *</span>
<span class="cm"> *	do {</span>
<span class="cm"> *		ret = __get_user(c, uaddr);</span>
<span class="cm"> *		uaddr += PAGE_SIZE;</span>
<span class="cm"> *	} while (!ret &amp;&amp; uaddr &lt; end);</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the final __get_user() may well run out-of-bounds of the user buffer,</span>
<span class="cm"> * but _not_ out-of-bounds of the page the user buffer belongs to, and since</span>
<span class="cm"> * this is only a read and not a write, and since it is still in the same page,</span>
<span class="cm"> * it should not matter and this makes the code much simpler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ntfs_fault_in_pages_readable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

	<span class="cm">/* Set @end to the first byte outside the last page we care about. */</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span><span class="o">*</span><span class="p">)</span><span class="n">PAGE_ALIGN</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uaddr</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">__get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">uaddr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">))</span>
		<span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_fault_in_pages_readable_iovec -</span>
<span class="cm"> *</span>
<span class="cm"> * Same as ntfs_fault_in_pages_readable() but operates on an array of iovecs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ntfs_fault_in_pages_readable_iovec</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">iov_ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">iov_ofs</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">iov_ofs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">ntfs_fault_in_pages_readable</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">iov</span><span class="o">++</span><span class="p">;</span>
		<span class="n">iov_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __ntfs_grab_cache_pages - obtain a number of locked pages</span>
<span class="cm"> * @mapping:	address space mapping from which to obtain page cache pages</span>
<span class="cm"> * @index:	starting index in @mapping at which to begin obtaining pages</span>
<span class="cm"> * @nr_pages:	number of page cache pages to obtain</span>
<span class="cm"> * @pages:	array of pages in which to return the obtained page cache pages</span>
<span class="cm"> * @cached_page: allocated but as yet unused page</span>
<span class="cm"> * @lru_pvec:	lru-buffering pagevec of caller</span>
<span class="cm"> *</span>
<span class="cm"> * Obtain @nr_pages locked page cache pages from the mapping @mapping and</span>
<span class="cm"> * starting at index @index.</span>
<span class="cm"> *</span>
<span class="cm"> * If a page is newly created, add it to lru list</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the page locks are obtained in ascending page index order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ntfs_grab_cache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">cached_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">nr</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">nr</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">cached_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">cached_page</span> <span class="o">=</span> <span class="n">page_cache_alloc</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!*</span><span class="n">cached_page</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="o">*</span><span class="n">cached_page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">cached_page</span><span class="p">;</span>
			<span class="o">*</span><span class="n">cached_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="o">--</span><span class="n">nr</span><span class="p">]);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">nr</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ntfs_submit_bh_for_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_prepare_pages_for_non_resident_write - prepare pages for receiving data</span>
<span class="cm"> * @pages:	array of destination pages</span>
<span class="cm"> * @nr_pages:	number of pages in @pages</span>
<span class="cm"> * @pos:	byte position in file at which the write begins</span>
<span class="cm"> * @bytes:	number of bytes to be written</span>
<span class="cm"> *</span>
<span class="cm"> * This is called for non-resident attributes from ntfs_file_buffered_write()</span>
<span class="cm"> * with i_mutex held on the inode (@pages[0]-&gt;mapping-&gt;host).  There are</span>
<span class="cm"> * @nr_pages pages in @pages which are locked but not kmap()ped.  The source</span>
<span class="cm"> * data has not yet been copied into the @pages.</span>
<span class="cm"> * </span>
<span class="cm"> * Need to fill any holes with actual clusters, allocate buffers if necessary,</span>
<span class="cm"> * ensure all the buffers are mapped, and bring uptodate any buffers that are</span>
<span class="cm"> * only partially being written to.</span>
<span class="cm"> *</span>
<span class="cm"> * If @nr_pages is greater than one, we are guaranteed that the cluster size is</span>
<span class="cm"> * greater than PAGE_CACHE_SIZE, that all pages in @pages are entirely inside</span>
<span class="cm"> * the same cluster and that they are the entirety of that cluster, and that</span>
<span class="cm"> * the cluster is sparse, i.e. we need to allocate a cluster to fill the hole.</span>
<span class="cm"> *</span>
<span class="cm"> * i_size is not to be modified yet.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success or -errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_prepare_pages_for_non_resident_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">s64</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VCN</span> <span class="n">vcn</span><span class="p">,</span> <span class="n">highest_vcn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cpos</span><span class="p">,</span> <span class="n">cend</span><span class="p">,</span> <span class="n">bh_cpos</span><span class="p">,</span> <span class="n">bh_cend</span><span class="p">;</span>
	<span class="n">LCN</span> <span class="n">lcn</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bh_pos</span><span class="p">,</span> <span class="n">vcn_len</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">initialized_size</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">lcn_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">,</span> <span class="o">*</span><span class="n">base_ni</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">;</span>
	<span class="n">runlist_element</span> <span class="o">*</span><span class="n">rl</span><span class="p">,</span> <span class="o">*</span><span class="n">rl2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">wait</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">wait_bh</span> <span class="o">=</span> <span class="n">wait</span><span class="p">;</span>
	<span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">MFT_RECORD</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ATTR_RECORD</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">attr_rec_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">mp_size</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rl_write_locked</span><span class="p">,</span> <span class="n">was_hole</span><span class="p">,</span> <span class="n">is_retry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">blocksize_bits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">runlist_merged</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">mft_attr_mapped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">mp_rebuilt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">attr_switched</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">status</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!*</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">vi</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
	<span class="n">vol</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering for inode 0x%lx, attribute type 0x%x, start page &quot;</span>
			<span class="s">&quot;index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.&quot;</span><span class="p">,</span>
			<span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">blocksize_bits</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * create_empty_buffers() will create uptodate/dirty buffers if</span>
<span class="cm">		 * the page is uptodate/dirty.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">u</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">rl_write_locked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">rl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vcn</span> <span class="o">=</span> <span class="n">lcn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">vcn_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lcn_block</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">was_hole</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">cpos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">cend</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over each page and for each page over each buffer.  Use goto to</span>
<span class="cm">	 * reduce indentation.</span>
<span class="cm">	 */</span>
	<span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">do_next_page:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
	<span class="n">bh_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">VCN</span> <span class="n">cdelta</span><span class="p">;</span>
		<span class="n">s64</span> <span class="n">bh_end</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">bh_cofs</span><span class="p">;</span>

		<span class="cm">/* Clear buffer_new on all buffers to reinitialise state. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh_end</span> <span class="o">=</span> <span class="n">bh_pos</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="n">bh_cpos</span> <span class="o">=</span> <span class="n">bh_pos</span> <span class="o">&gt;&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">;</span>
		<span class="n">bh_cofs</span> <span class="o">=</span> <span class="n">bh_pos</span> <span class="o">&amp;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The buffer is already mapped.  If it is uptodate,</span>
<span class="cm">			 * ignore it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * The buffer is not uptodate.  If the page is uptodate</span>
<span class="cm">			 * set the buffer uptodate and otherwise ignore it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Neither the page nor the buffer are uptodate.  If</span>
<span class="cm">			 * the buffer is only partially being written to, we</span>
<span class="cm">			 * need to read it in before the write, i.e. now.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">bh_end</span> <span class="o">&gt;</span> <span class="n">pos</span><span class="p">)</span> <span class="o">||</span>
					<span class="p">(</span><span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">bh_end</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If the buffer is fully or partially within</span>
<span class="cm">				 * the initialized size, do an actual read.</span>
<span class="cm">				 * Otherwise, simply zero the buffer.</span>
<span class="cm">				 */</span>
				<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">initialized_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span><span class="p">;</span>
				<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">initialized_size</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ntfs_submit_bh_for_read</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="o">*</span><span class="n">wait_bh</span><span class="o">++</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
							<span class="n">blocksize</span><span class="p">);</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Unmapped buffer.  Need to map it. */</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the current buffer is in the same clusters as the map</span>
<span class="cm">		 * cache, there is no need to check the runlist again.  The</span>
<span class="cm">		 * map cache is made up of @vcn, which is the first cached file</span>
<span class="cm">		 * cluster, @vcn_len which is the number of cached file</span>
<span class="cm">		 * clusters, @lcn is the device cluster corresponding to @vcn,</span>
<span class="cm">		 * and @lcn_block is the block number corresponding to @lcn.</span>
<span class="cm">		 */</span>
		<span class="n">cdelta</span> <span class="o">=</span> <span class="n">bh_cpos</span> <span class="o">-</span> <span class="n">vcn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">cdelta</span> <span class="o">||</span> <span class="p">(</span><span class="n">cdelta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cdelta</span> <span class="o">&lt;</span> <span class="n">vcn_len</span><span class="p">)))</span> <span class="p">{</span>
<span class="nl">map_buffer_cached:</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">lcn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="n">lcn_block</span> <span class="o">+</span>
					<span class="p">(</span><span class="n">cdelta</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">-</span>
					<span class="n">blocksize_bits</span><span class="p">))</span> <span class="o">+</span>
					<span class="p">(</span><span class="n">bh_cofs</span> <span class="o">&gt;&gt;</span> <span class="n">blocksize_bits</span><span class="p">);</span>
			<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the page is uptodate so is the buffer.  If the</span>
<span class="cm">			 * buffer is fully outside the write, we ignore it if</span>
<span class="cm">			 * it was already allocated and we mark it dirty so it</span>
<span class="cm">			 * gets written out if we allocated it.  On the other</span>
<span class="cm">			 * hand, if we allocated the buffer but we are not</span>
<span class="cm">			 * marking it dirty we set buffer_new so we can do</span>
<span class="cm">			 * error recovery.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">was_hole</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* We allocated the buffer. */</span>
					<span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span>
							<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">bh_end</span> <span class="o">&lt;=</span> <span class="n">pos</span> <span class="o">||</span> <span class="n">bh_pos</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
						<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="k">else</span>
						<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Page is _not_ uptodate. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">was_hole</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Buffer was already allocated.  If it is not</span>
<span class="cm">				 * uptodate and is only partially being written</span>
<span class="cm">				 * to, we need to read it in before the write,</span>
<span class="cm">				 * i.e. now.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span>
						<span class="n">bh_end</span> <span class="o">&gt;</span> <span class="n">pos</span> <span class="o">&amp;&amp;</span>
						<span class="p">(</span><span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">pos</span> <span class="o">||</span>
						<span class="n">bh_end</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * If the buffer is fully or partially</span>
<span class="cm">					 * within the initialized size, do an</span>
<span class="cm">					 * actual read.  Otherwise, simply zero</span>
<span class="cm">					 * the buffer.</span>
<span class="cm">					 */</span>
					<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span>
							<span class="n">flags</span><span class="p">);</span>
					<span class="n">initialized_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span><span class="p">;</span>
					<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span>
							<span class="n">flags</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">initialized_size</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">ntfs_submit_bh_for_read</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
						<span class="o">*</span><span class="n">wait_bh</span><span class="o">++</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
								<span class="n">blocksize</span><span class="p">);</span>
						<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* We allocated the buffer. */</span>
			<span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the buffer is fully outside the write, zero it,</span>
<span class="cm">			 * set it uptodate, and mark it dirty so it gets</span>
<span class="cm">			 * written out.  If it is partially being written to,</span>
<span class="cm">			 * zero region surrounding the write but leave it to</span>
<span class="cm">			 * commit write to do anything else.  Finally, if the</span>
<span class="cm">			 * buffer is fully being overwritten, do nothing.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh_end</span> <span class="o">&lt;=</span> <span class="n">pos</span> <span class="o">||</span> <span class="n">bh_pos</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
							<span class="n">blocksize</span><span class="p">);</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">pos</span> <span class="o">||</span> <span class="n">bh_end</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">u8</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="n">pofs</span><span class="p">;</span>
					
				<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pofs</span> <span class="o">=</span> <span class="n">bh_pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">pofs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">bh_pos</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bh_end</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pofs</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">pofs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bh_end</span> <span class="o">-</span> <span class="n">end</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Slow path: this is the first buffer in the cluster.  If it</span>
<span class="cm">		 * is outside allocated size and is not uptodate, zero it and</span>
<span class="cm">		 * set it uptodate.</span>
<span class="cm">		 */</span>
		<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">initialized_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">allocated_size</span><span class="p">;</span>
		<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh_pos</span> <span class="o">&gt;</span> <span class="n">initialized_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span> <span class="n">blocksize</span><span class="p">);</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">is_retry</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">retry_remap:</span>
			<span class="n">rl</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">rl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Seek to element containing target cluster. */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">rl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">vcn</span> <span class="o">&lt;=</span> <span class="n">bh_cpos</span><span class="p">)</span>
				<span class="n">rl</span><span class="o">++</span><span class="p">;</span>
			<span class="n">lcn</span> <span class="o">=</span> <span class="n">ntfs_rl_vcn_to_lcn</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">bh_cpos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">lcn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Successful remap, setup the map cache and</span>
<span class="cm">				 * use that to deal with the buffer.</span>
<span class="cm">				 */</span>
				<span class="n">was_hole</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">vcn</span> <span class="o">=</span> <span class="n">bh_cpos</span><span class="p">;</span>
				<span class="n">vcn_len</span> <span class="o">=</span> <span class="n">rl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">vcn</span> <span class="o">-</span> <span class="n">vcn</span><span class="p">;</span>
				<span class="n">lcn_block</span> <span class="o">=</span> <span class="n">lcn</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">-</span>
						<span class="n">blocksize_bits</span><span class="p">);</span>
				<span class="n">cdelta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * If the number of remaining clusters touched</span>
<span class="cm">				 * by the write is smaller or equal to the</span>
<span class="cm">				 * number of cached clusters, unlock the</span>
<span class="cm">				 * runlist as the map cache will be used from</span>
<span class="cm">				 * now on.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vcn</span> <span class="o">+</span> <span class="n">vcn_len</span> <span class="o">&gt;=</span> <span class="n">cend</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">rl_write_locked</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
						<span class="n">rl_write_locked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
					<span class="n">rl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">map_buffer_cached</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">lcn</span> <span class="o">=</span> <span class="n">LCN_RL_NOT_MAPPED</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it is not a hole and not out of bounds, the runlist is</span>
<span class="cm">		 * probably unmapped so try to map it now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lcn</span> <span class="o">!=</span> <span class="n">LCN_HOLE</span> <span class="o">&amp;&amp;</span> <span class="n">lcn</span> <span class="o">!=</span> <span class="n">LCN_ENOENT</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">is_retry</span> <span class="o">&amp;&amp;</span> <span class="n">lcn</span> <span class="o">==</span> <span class="n">LCN_RL_NOT_MAPPED</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Attempt to map runlist. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rl_write_locked</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * We need the runlist locked for</span>
<span class="cm">					 * writing, so if it is locked for</span>
<span class="cm">					 * reading relock it now and retry in</span>
<span class="cm">					 * case it changed whilst we dropped</span>
<span class="cm">					 * the lock.</span>
<span class="cm">					 */</span>
					<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
					<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
					<span class="n">rl_write_locked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">retry_remap</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_map_runlist_nolock</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">bh_cpos</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">is_retry</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">retry_remap</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * If @vcn is out of bounds, pretend @lcn is</span>
<span class="cm">				 * LCN_ENOENT.  As long as the buffer is out</span>
<span class="cm">				 * of bounds this will work fine.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">lcn</span> <span class="o">=</span> <span class="n">LCN_ENOENT</span><span class="p">;</span>
					<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">rl_not_mapped_enoent</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="cm">/* Failed to map the buffer, even after retrying. */</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to write to inode 0x%lx, &quot;</span>
					<span class="s">&quot;attribute type 0x%x, vcn 0x%llx, &quot;</span>
					<span class="s">&quot;vcn offset 0x%x, because its &quot;</span>
					<span class="s">&quot;location on disk could not be &quot;</span>
					<span class="s">&quot;determined%s (error code %i).&quot;</span><span class="p">,</span>
					<span class="n">ni</span><span class="o">-&gt;</span><span class="n">mft_no</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh_cpos</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">bh_pos</span> <span class="o">&amp;</span>
					<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_mask</span><span class="p">,</span>
					<span class="n">is_retry</span> <span class="o">?</span> <span class="s">&quot; even after retrying&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
					<span class="n">err</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">rl_not_mapped_enoent:</span>
		<span class="cm">/*</span>
<span class="cm">		 * The buffer is in a hole or out of bounds.  We need to fill</span>
<span class="cm">		 * the hole, unless the buffer is in a cluster which is not</span>
<span class="cm">		 * touched by the write, in which case we just leave the buffer</span>
<span class="cm">		 * unmapped.  This can only happen when the cluster size is</span>
<span class="cm">		 * less than the page cache size.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bh_cend</span> <span class="o">=</span> <span class="p">(</span><span class="n">bh_end</span> <span class="o">+</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
					<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">bh_cend</span> <span class="o">&lt;=</span> <span class="n">cpos</span> <span class="o">||</span> <span class="n">bh_cpos</span> <span class="o">&gt;=</span> <span class="n">cend</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * If the buffer is uptodate we skip it.  If it</span>
<span class="cm">				 * is not but the page is uptodate, we can set</span>
<span class="cm">				 * the buffer uptodate.  If the page is not</span>
<span class="cm">				 * uptodate, we can clear the buffer and set it</span>
<span class="cm">				 * uptodate.  Whether this is worthwhile is</span>
<span class="cm">				 * debatable and this could be removed.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
						<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
						<span class="n">blocksize</span><span class="p">);</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Out of bounds buffer is invalid if it was not really out of</span>
<span class="cm">		 * bounds.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">lcn</span> <span class="o">!=</span> <span class="n">LCN_HOLE</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need the runlist locked for writing, so if it is locked</span>
<span class="cm">		 * for reading relock it now and retry in case it changed</span>
<span class="cm">		 * whilst we dropped the lock.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rl_write_locked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">rl_write_locked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry_remap</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Find the previous last allocated cluster. */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">lcn</span> <span class="o">!=</span> <span class="n">LCN_HOLE</span><span class="p">);</span>
		<span class="n">lcn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">rl2</span> <span class="o">=</span> <span class="n">rl</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">rl2</span> <span class="o">&gt;=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">rl</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rl2</span><span class="o">-&gt;</span><span class="n">lcn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lcn</span> <span class="o">=</span> <span class="n">rl2</span><span class="o">-&gt;</span><span class="n">lcn</span> <span class="o">+</span> <span class="n">rl2</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">rl2</span> <span class="o">=</span> <span class="n">ntfs_cluster_alloc</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">bh_cpos</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lcn</span><span class="p">,</span> <span class="n">DATA_ZONE</span><span class="p">,</span>
				<span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rl2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rl2</span><span class="p">);</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Failed to allocate cluster, error code %i.&quot;</span><span class="p">,</span>
					<span class="n">err</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lcn</span> <span class="o">=</span> <span class="n">rl2</span><span class="o">-&gt;</span><span class="n">lcn</span><span class="p">;</span>
		<span class="n">rl</span> <span class="o">=</span> <span class="n">ntfs_runlists_merge</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">rl</span><span class="p">,</span> <span class="n">rl2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rl</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_cluster_free_from_rl</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">rl2</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to release &quot;</span>
						<span class="s">&quot;allocated cluster in error &quot;</span>
						<span class="s">&quot;code path.  Run chkdsk to &quot;</span>
						<span class="s">&quot;recover the lost cluster.&quot;</span><span class="p">);</span>
				<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ntfs_free</span><span class="p">(</span><span class="n">rl2</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">rl</span> <span class="o">=</span> <span class="n">rl</span><span class="p">;</span>
		<span class="n">status</span><span class="p">.</span><span class="n">runlist_merged</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Allocated cluster, lcn 0x%llx.&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lcn</span><span class="p">);</span>
		<span class="cm">/* Map and lock the mft record and get the attribute record. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NInoAttr</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span>
			<span class="n">base_ni</span> <span class="o">=</span> <span class="n">ni</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">base_ni</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">ext</span><span class="p">.</span><span class="n">base_ntfs_ino</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">base_ni</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span><span class="p">.</span><span class="n">mft_attr_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span>
				<span class="n">CASE_SENSITIVE</span><span class="p">,</span> <span class="n">bh_cpos</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mrec</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Find the runlist element with which the attribute extent</span>
<span class="cm">		 * starts.  Note, we cannot use the _attr_ version because we</span>
<span class="cm">		 * have mapped the mft record.  That is ok because we know the</span>
<span class="cm">		 * runlist fragment must be mapped already to have ever gotten</span>
<span class="cm">		 * here, so we can just use the _rl_ version.</span>
<span class="cm">		 */</span>
		<span class="n">vcn</span> <span class="o">=</span> <span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">lowest_vcn</span><span class="p">);</span>
		<span class="n">rl2</span> <span class="o">=</span> <span class="n">ntfs_rl_find_vcn_nolock</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">vcn</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rl2</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rl2</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rl2</span><span class="o">-&gt;</span><span class="n">lcn</span> <span class="o">&lt;</span> <span class="n">LCN_HOLE</span><span class="p">);</span>
		<span class="n">highest_vcn</span> <span class="o">=</span> <span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">highest_vcn</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If @highest_vcn is zero, calculate the real highest_vcn</span>
<span class="cm">		 * (which can really be zero).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">highest_vcn</span><span class="p">)</span>
			<span class="n">highest_vcn</span> <span class="o">=</span> <span class="p">(</span><span class="n">sle64_to_cpu</span><span class="p">(</span>
					<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">allocated_size</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
					<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Determine the size of the mapping pairs array for the new</span>
<span class="cm">		 * extent, i.e. the old extent with the hole filled.</span>
<span class="cm">		 */</span>
		<span class="n">mp_size</span> <span class="o">=</span> <span class="n">ntfs_get_size_for_mapping_pairs</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">rl2</span><span class="p">,</span> <span class="n">vcn</span><span class="p">,</span>
				<span class="n">highest_vcn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mp_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="n">mp_size</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Failed to get size for mapping pairs &quot;</span>
					<span class="s">&quot;array, error code %i.&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Resize the attribute record to fit the new mapping pairs</span>
<span class="cm">		 * array.</span>
<span class="cm">		 */</span>
		<span class="n">attr_rec_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_record_resize</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">mp_size</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span>
				<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">mapping_pairs_offset</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>TODO: Deal with this by using the current attribute
and fill it with as much of the mapping pairs
array as possible.  Then loop over each attribute
extent rewriting the mapping pairs arrays as we go
along and if when we reach the end we have not
enough space, try to resize the last attribute
extent and if even that fails, add a new attribute
extent.
We could also try to resize at each step in the hope
that we will not need to rewrite every single extent.
Note, we may need to decompress some extents to fill
the runlist as we are walking the extents...</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Not enough space in the mft &quot;</span>
					<span class="s">&quot;record for the extended attribute &quot;</span>
					<span class="s">&quot;record.  This case is not &quot;</span>
					<span class="s">&quot;implemented yet.&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">break</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span><span class="p">.</span><span class="n">mp_rebuilt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Generate the mapping pairs array directly into the attribute</span>
<span class="cm">		 * record.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_mapping_pairs_build</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span>
				<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">mapping_pairs_offset</span><span class="p">),</span>
				<span class="n">mp_size</span><span class="p">,</span> <span class="n">rl2</span><span class="p">,</span> <span class="n">vcn</span><span class="p">,</span> <span class="n">highest_vcn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cannot fill hole in inode 0x%lx, &quot;</span>
					<span class="s">&quot;attribute type 0x%x, because building &quot;</span>
					<span class="s">&quot;the mapping pairs failed with error &quot;</span>
					<span class="s">&quot;code %i.&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Update the highest_vcn but only if it was not set. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">highest_vcn</span><span class="p">))</span>
			<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">highest_vcn</span> <span class="o">=</span>
					<span class="n">cpu_to_sle64</span><span class="p">(</span><span class="n">highest_vcn</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the attribute is sparse/compressed, update the compressed</span>
<span class="cm">		 * size in the ntfs_inode structure and the attribute record.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">NInoSparse</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span> <span class="o">||</span> <span class="n">NInoCompressed</span><span class="p">(</span><span class="n">ni</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we are not in the first attribute extent, switch</span>
<span class="cm">			 * to it, but first ensure the changes will make it to</span>
<span class="cm">			 * disk later.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">lowest_vcn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
				<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
				<span class="n">ntfs_attr_reinit_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						<span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span> <span class="n">CASE_SENSITIVE</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">status</span><span class="p">.</span><span class="n">attr_switched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* @m is not used any more so do not set it. */</span>
				<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ni</span><span class="o">-&gt;</span><span class="n">itype</span><span class="p">.</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">;</span>
			<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">compressed_size</span> <span class="o">=</span>
					<span class="n">cpu_to_sle64</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">itype</span><span class="p">.</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
			<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Ensure the changes make it to disk. */</span>
		<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
		<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
		<span class="cm">/* Successfully filled the hole. */</span>
		<span class="n">status</span><span class="p">.</span><span class="n">runlist_merged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span><span class="p">.</span><span class="n">mft_attr_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span><span class="p">.</span><span class="n">mp_rebuilt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Setup the map cache and use that to deal with the buffer. */</span>
		<span class="n">was_hole</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">vcn</span> <span class="o">=</span> <span class="n">bh_cpos</span><span class="p">;</span>
		<span class="n">vcn_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lcn_block</span> <span class="o">=</span> <span class="n">lcn</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">-</span> <span class="n">blocksize_bits</span><span class="p">);</span>
		<span class="n">cdelta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the number of remaining clusters in the @pages is smaller</span>
<span class="cm">		 * or equal to the number of cached clusters, unlock the</span>
<span class="cm">		 * runlist as the map cache will be used from now on.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vcn</span> <span class="o">+</span> <span class="n">vcn_len</span> <span class="o">&gt;=</span> <span class="n">cend</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">rl_write_locked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">rl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">map_buffer_cached</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh_pos</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">,</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="cm">/* If there are no errors, do the next page. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">u</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">do_next_page</span><span class="p">;</span>
	<span class="cm">/* If there are no errors, release the runlist lock if we took it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rl_write_locked</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">rl_write_locked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rl</span><span class="p">))</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">rl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If we issued read requests, let them complete. */</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">initialized_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span><span class="p">;</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">wait_bh</span> <span class="o">&gt;</span> <span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="o">*--</span><span class="n">wait_bh</span><span class="p">;</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
			<span class="n">bh_pos</span> <span class="o">=</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the buffer overflows the initialized size, need</span>
<span class="cm">			 * to zero the overflowing region.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bh_pos</span> <span class="o">+</span> <span class="n">blocksize</span> <span class="o">&gt;</span> <span class="n">initialized_size</span><span class="p">))</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bh_pos</span> <span class="o">&lt;</span> <span class="n">initialized_size</span><span class="p">))</span>
					<span class="n">ofs</span> <span class="o">=</span> <span class="n">initialized_size</span> <span class="o">-</span> <span class="n">bh_pos</span><span class="p">;</span>
				<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">,</span>
						<span class="n">blocksize</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* if (unlikely(!buffer_uptodate(bh))) */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Clear buffer_new on all buffers. */</span>
		<span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
					<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">u</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">);</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">attr_switched</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get back to the attribute extent we modified. */</span>
		<span class="n">ntfs_attr_reinit_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span>
				<span class="n">CASE_SENSITIVE</span><span class="p">,</span> <span class="n">bh_cpos</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to find required &quot;</span>
					<span class="s">&quot;attribute extent of attribute in &quot;</span>
					<span class="s">&quot;error code path.  Run chkdsk to &quot;</span>
					<span class="s">&quot;recover.&quot;</span><span class="p">);</span>
			<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ni</span><span class="o">-&gt;</span><span class="n">itype</span><span class="p">.</span><span class="n">compressed</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">;</span>
			<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
			<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * The only thing that is now wrong is the compressed</span>
<span class="cm">			 * size of the base attribute extent which chkdsk</span>
<span class="cm">			 * should be able to fix.</span>
<span class="cm">			 */</span>
			<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mrec</span><span class="p">;</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
			<span class="n">status</span><span class="p">.</span><span class="n">attr_switched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the runlist has been modified, need to restore it by punching a</span>
<span class="cm">	 * hole into it and we then need to deallocate the on-disk cluster as</span>
<span class="cm">	 * well.  Note, we only modify the runlist if we are able to generate a</span>
<span class="cm">	 * new mapping pairs array, i.e. only when the mapped attribute extent</span>
<span class="cm">	 * is not switched.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">runlist_merged</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">attr_switched</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rl_write_locked</span><span class="p">);</span>
		<span class="cm">/* Make the file cluster we allocated sparse in the runlist. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_rl_punch_nolock</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">,</span> <span class="n">bh_cpos</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to punch hole into &quot;</span>
					<span class="s">&quot;attribute runlist in error code &quot;</span>
					<span class="s">&quot;path.  Run chkdsk to recover the &quot;</span>
					<span class="s">&quot;lost cluster.&quot;</span><span class="p">);</span>
			<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* if (success) */</span> <span class="p">{</span>
			<span class="n">status</span><span class="p">.</span><span class="n">runlist_merged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Deallocate the on-disk cluster we allocated but only</span>
<span class="cm">			 * if we succeeded in punching its vcn out of the</span>
<span class="cm">			 * runlist.</span>
<span class="cm">			 */</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_bitmap_clear_bit</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">,</span> <span class="n">lcn</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to release &quot;</span>
						<span class="s">&quot;allocated cluster in error &quot;</span>
						<span class="s">&quot;code path.  Run chkdsk to &quot;</span>
						<span class="s">&quot;recover the lost cluster.&quot;</span><span class="p">);</span>
				<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Resize the attribute record to its old size and rebuild the mapping</span>
<span class="cm">	 * pairs array.  Note, we only can do this if the runlist has been</span>
<span class="cm">	 * restored to its old state which also implies that the mapped</span>
<span class="cm">	 * attribute extent is not switched.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">mp_rebuilt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">runlist_merged</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_attr_record_resize</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">attr_rec_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to restore attribute &quot;</span>
					<span class="s">&quot;record in error code path.  Run &quot;</span>
					<span class="s">&quot;chkdsk to recover.&quot;</span><span class="p">);</span>
			<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* if (success) */</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_mapping_pairs_build</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">+</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span>
					<span class="n">mapping_pairs_offset</span><span class="p">),</span> <span class="n">attr_rec_len</span> <span class="o">-</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span>
					<span class="n">mapping_pairs_offset</span><span class="p">),</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">rl</span><span class="p">,</span>
					<span class="n">vcn</span><span class="p">,</span> <span class="n">highest_vcn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to restore &quot;</span>
						<span class="s">&quot;mapping pairs array in error &quot;</span>
						<span class="s">&quot;code path.  Run chkdsk to &quot;</span>
						<span class="s">&quot;recover.&quot;</span><span class="p">);</span>
				<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
			<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Release the mft record and the attribute. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">mft_attr_mapped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Release the runlist lock. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rl_write_locked</span><span class="p">)</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="p">)</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Zero out any newly allocated blocks to avoid exposing stale data.</span>
<span class="cm">	 * If BH_New is set, we know that the block was newly allocated above</span>
<span class="cm">	 * and that it has not been fully zeroed and marked dirty yet.</span>
<span class="cm">	 */</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
	<span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">bh_cpos</span> <span class="o">&lt;&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">nr_pages</span> <span class="o">&amp;&amp;</span>
					<span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
							<span class="n">blocksize</span><span class="p">);</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">u</span> <span class="o">&lt;=</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed.  Returning error code %i.&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy as much as we can into the pages and return the number of bytes which</span>
<span class="cm"> * were successfully copied.  If a fault is encountered then clear the pages</span>
<span class="cm"> * out to (ofs + bytes) and return the number of bytes which were copied.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">ntfs_copy_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ofs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">last_page</span> <span class="o">=</span> <span class="n">pages</span> <span class="o">+</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">__copy_from_user_inatomic</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Do it the slow way. */</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">__copy_from_user</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">pages</span> <span class="o">&lt;</span> <span class="n">last_page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
	<span class="cm">/* Zero the rest of the target like __copy_from_user(). */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">pages</span> <span class="o">&lt;</span> <span class="n">last_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">zero_user</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">__ntfs_copy_from_user_iovec_inatomic</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">iov_ofs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">iov_ofs</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">left</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">iov_ofs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">__copy_from_user_inatomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">left</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">total</span> <span class="o">-=</span> <span class="n">left</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">iov</span><span class="o">++</span><span class="p">;</span>
		<span class="n">iov_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ntfs_set_next_iovec</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">**</span><span class="n">iovp</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="o">*</span><span class="n">iov_ofsp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span> <span class="o">=</span> <span class="o">*</span><span class="n">iovp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">iov_ofs</span> <span class="o">=</span> <span class="o">*</span><span class="n">iov_ofsp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">iov_ofs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">iov_ofs</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">==</span> <span class="n">iov_ofs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iov</span><span class="o">++</span><span class="p">;</span>
			<span class="n">iov_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">iovp</span> <span class="o">=</span> <span class="n">iov</span><span class="p">;</span>
	<span class="o">*</span><span class="n">iov_ofsp</span> <span class="o">=</span> <span class="n">iov_ofs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This has the same side-effects and return value as ntfs_copy_from_user().</span>
<span class="cm"> * The difference is that on a fault we need to memset the remainder of the</span>
<span class="cm"> * pages (out to offset + bytes), to emulate ntfs_copy_from_user()&#39;s</span>
<span class="cm"> * single-segment behaviour.</span>
<span class="cm"> *</span>
<span class="cm"> * We call the same helper (__ntfs_copy_from_user_iovec_inatomic()) both when</span>
<span class="cm"> * atomic and when not atomic.  This is ok because it calls</span>
<span class="cm"> * __copy_from_user_inatomic() and it is ok to call this when non-atomic.  In</span>
<span class="cm"> * fact, the only difference between __copy_from_user_inatomic() and</span>
<span class="cm"> * __copy_from_user() is that the latter calls might_sleep() and the former</span>
<span class="cm"> * should not zero the tail of the buffer on error.  And on many architectures</span>
<span class="cm"> * __copy_from_user_inatomic() is just defined to __copy_from_user() so it</span>
<span class="cm"> * makes no difference at all on those architectures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">ntfs_copy_from_user_iovec</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ofs</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">**</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="o">*</span><span class="n">iov_ofs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">last_page</span> <span class="o">=</span> <span class="n">pages</span> <span class="o">+</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copied</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">__ntfs_copy_from_user_iovec_inatomic</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">,</span>
				<span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="o">*</span><span class="n">iov_ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">!=</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Do it the slow way. */</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="n">__ntfs_copy_from_user_iovec_inatomic</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span>
					<span class="n">ofs</span><span class="p">,</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="o">*</span><span class="n">iov_ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">!=</span> <span class="n">len</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">ntfs_set_next_iovec</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">iov_ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">pages</span> <span class="o">&lt;</span> <span class="n">last_page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">);</span>
	<span class="cm">/* Zero the rest of the target like __copy_from_user(). */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ofs</span> <span class="o">+</span> <span class="n">copied</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
	<span class="n">ntfs_set_next_iovec</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">iov_ofs</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">pages</span> <span class="o">&lt;</span> <span class="n">last_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">zero_user</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ntfs_flush_dcache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Warning: Do not do the decrement at the same time as the call to</span>
<span class="cm">	 * flush_dcache_page() because it is a NULL macro on i386 and hence the</span>
<span class="cm">	 * decrement never happens so the loop never terminates.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">nr_pages</span><span class="p">;</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">nr_pages</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_commit_pages_after_non_resident_write - commit the received data</span>
<span class="cm"> * @pages:	array of destination pages</span>
<span class="cm"> * @nr_pages:	number of pages in @pages</span>
<span class="cm"> * @pos:	byte position in file at which the write begins</span>
<span class="cm"> * @bytes:	number of bytes to be written</span>
<span class="cm"> *</span>
<span class="cm"> * See description of ntfs_commit_pages_after_write(), below.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ntfs_commit_pages_after_non_resident_write</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span>
		<span class="n">s64</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">end</span><span class="p">,</span> <span class="n">initialized_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">,</span> <span class="o">*</span><span class="n">base_ni</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">MFT_RECORD</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">ATTR_RECORD</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vi</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">bh_pos</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">partial</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
		<span class="n">bh_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">partial</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">s64</span> <span class="n">bh_end</span><span class="p">;</span>

			<span class="n">bh_end</span> <span class="o">=</span> <span class="n">bh_pos</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh_end</span> <span class="o">&lt;=</span> <span class="n">pos</span> <span class="o">||</span> <span class="n">bh_pos</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
					<span class="n">partial</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh_pos</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">,</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If all buffers are now uptodate but the page is not, set the</span>
<span class="cm">		 * page uptodate.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">u</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Finally, if we do not need to update initialized_size or i_size we</span>
<span class="cm">	 * are finished.</span>
<span class="cm">	 */</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">initialized_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span><span class="p">;</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">initialized_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update initialized_size/i_size as appropriate, both in the inode and</span>
<span class="cm">	 * the mft record.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NInoAttr</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span>
		<span class="n">base_ni</span> <span class="o">=</span> <span class="n">ni</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">base_ni</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">ext</span><span class="p">.</span><span class="n">base_ntfs_ino</span><span class="p">;</span>
	<span class="cm">/* Map, pin, and lock the mft record. */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">NInoNonResident</span><span class="p">(</span><span class="n">ni</span><span class="p">));</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">base_ni</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span>
			<span class="n">CASE_SENSITIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">non_resident</span><span class="p">);</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">allocated_size</span><span class="p">);</span>
	<span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">initialized_size</span> <span class="o">=</span> <span class="n">cpu_to_sle64</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span>
				<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">non_resident</span><span class="p">.</span><span class="n">initialized_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Mark the mft record dirty, so it gets written back. */</span>
	<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
	<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
	<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;Failed to update initialized_size/i_size (error &quot;</span>
			<span class="s">&quot;code %i).&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_commit_pages_after_write - commit the received data</span>
<span class="cm"> * @pages:	array of destination pages</span>
<span class="cm"> * @nr_pages:	number of pages in @pages</span>
<span class="cm"> * @pos:	byte position in file at which the write begins</span>
<span class="cm"> * @bytes:	number of bytes to be written</span>
<span class="cm"> *</span>
<span class="cm"> * This is called from ntfs_file_buffered_write() with i_mutex held on the inode</span>
<span class="cm"> * (@pages[0]-&gt;mapping-&gt;host).  There are @nr_pages pages in @pages which are</span>
<span class="cm"> * locked but not kmap()ped.  The source data has already been copied into the</span>
<span class="cm"> * @page.  ntfs_prepare_pages_for_non_resident_write() has been called before</span>
<span class="cm"> * the data was copied (for non-resident attributes only) and it returned</span>
<span class="cm"> * success.</span>
<span class="cm"> *</span>
<span class="cm"> * Need to set uptodate and mark dirty all buffers within the boundary of the</span>
<span class="cm"> * write.  If all buffers in a page are uptodate we set the page uptodate, too.</span>
<span class="cm"> *</span>
<span class="cm"> * Setting the buffers dirty ensures that they get written out later when</span>
<span class="cm"> * ntfs_writepage() is invoked by the VM.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, we need to update i_size and initialized_size as appropriate both</span>
<span class="cm"> * in the inode and the mft record.</span>
<span class="cm"> *</span>
<span class="cm"> * This is modelled after fs/buffer.c::generic_commit_write(), which marks</span>
<span class="cm"> * buffers uptodate and dirty, sets the page uptodate if all buffers in the</span>
<span class="cm"> * page are uptodate, and updates i_size if the end of io is beyond i_size.  In</span>
<span class="cm"> * that case, it also marks the inode dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * If things have gone as outlined in</span>
<span class="cm"> * ntfs_prepare_pages_for_non_resident_write(), we do not need to do any page</span>
<span class="cm"> * content modifications here for non-resident attributes.  For resident</span>
<span class="cm"> * attributes we need to do the uptodate bringing here which we combine with</span>
<span class="cm"> * the copying into the mft record which means we save one atomic kmap.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success or -errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_commit_pages_after_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">s64</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">end</span><span class="p">,</span> <span class="n">initialized_size</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">,</span> <span class="o">*</span><span class="n">base_ni</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">MFT_RECORD</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">ATTR_RECORD</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kattr</span><span class="p">,</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">attr_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">);</span>
	<span class="n">vi</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering for inode 0x%lx, attribute type 0x%x, start page &quot;</span>
			<span class="s">&quot;index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.&quot;</span><span class="p">,</span>
			<span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NInoNonResident</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ntfs_commit_pages_after_non_resident_write</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span>
				<span class="n">nr_pages</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Attribute is resident, implying it is not compressed, encrypted, or</span>
<span class="cm">	 * sparse.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NInoAttr</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span>
		<span class="n">base_ni</span> <span class="o">=</span> <span class="n">ni</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">base_ni</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">ext</span><span class="p">.</span><span class="n">base_ntfs_ino</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">NInoNonResident</span><span class="p">(</span><span class="n">ni</span><span class="p">));</span>
	<span class="cm">/* Map, pin, and lock the mft record. */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">base_ni</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span>
			<span class="n">CASE_SENSITIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">non_resident</span><span class="p">);</span>
	<span class="cm">/* The total length of the attribute value. */</span>
	<span class="n">attr_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_length</span><span class="p">);</span>
	<span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">attr_len</span> <span class="o">!=</span> <span class="n">i_size</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">attr_len</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_offset</span><span class="p">));</span>
	<span class="n">kattr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_offset</span><span class="p">);</span>
	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/* Copy the received data from the page to the mft record. */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kattr</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="cm">/* Update the attribute length if necessary. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">attr_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">attr_len</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">attr_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the page is not uptodate, bring the out of bounds area(s)</span>
<span class="cm">	 * uptodate by copying data from the mft record to the page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">kattr</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">attr_len</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">end</span><span class="p">,</span> <span class="n">kattr</span> <span class="o">+</span> <span class="n">end</span><span class="p">,</span> <span class="n">attr_len</span> <span class="o">-</span> <span class="n">end</span><span class="p">);</span>
		<span class="cm">/* Zero the region outside the end of the attribute value. */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">attr_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">attr_len</span><span class="p">);</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="cm">/* Update initialized_size/i_size if necessary. */</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">initialized_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">allocated_size</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">initialized_size</span> <span class="o">!=</span> <span class="n">i_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">initialized_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Mark the mft record dirty, so it gets written back. */</span>
	<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
	<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
	<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;Error allocating memory required to &quot;</span>
				<span class="s">&quot;commit the write.&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;Page is uptodate, setting &quot;</span>
					<span class="s">&quot;dirty so the write will be retried &quot;</span>
					<span class="s">&quot;later on by the VM.&quot;</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Put the page on mapping-&gt;dirty_pages, but leave its</span>
<span class="cm">			 * buffers&#39; dirty state as-is.</span>
<span class="cm">			 */</span>
			<span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;Page is not uptodate.  Written &quot;</span>
					<span class="s">&quot;data has been lost.&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;Resident attribute commit write failed &quot;</span>
				<span class="s">&quot;with error %i.&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">base_ni</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_file_buffered_write -</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: The vfs is holding -&gt;i_mutex on the inode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ntfs_file_buffered_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">NTFS_MAX_PAGES_PER_CLUSTER</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">cached_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">end</span><span class="p">,</span> <span class="n">ll</span><span class="p">;</span>
	<span class="n">VCN</span> <span class="n">last_vcn</span><span class="p">;</span>
	<span class="n">LCN</span> <span class="n">lcn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">iov_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Offset in the current iovec. */</span>
	<span class="kt">ssize_t</span> <span class="n">status</span><span class="p">,</span> <span class="n">written</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering for i_ino 0x%lx, attribute type 0x%x, &quot;</span>
			<span class="s">&quot;pos 0x%llx, count 0x%lx.&quot;</span><span class="p">,</span>
			<span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">NInoMstProtected</span><span class="p">(</span><span class="n">ni</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the attribute is not an index root and it is encrypted or</span>
<span class="cm">	 * compressed, we cannot write to it yet.  Note we need to check for</span>
<span class="cm">	 * AT_INDEX_ALLOCATION since this is the type of both directory and</span>
<span class="cm">	 * index inodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AT_INDEX_ALLOCATION</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If file is encrypted, deny access, just like NT4. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NInoEncrypted</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Reminder for later: Encrypted files are _always_</span>
<span class="cm">			 * non-resident so that the content can always be</span>
<span class="cm">			 * encrypted.</span>
<span class="cm">			 */</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Denying write access to encrypted file.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NInoCompressed</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Only unnamed $DATA attribute can be compressed. */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AT_DATA</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Reminder for later: If resident, the data is not</span>
<span class="cm">			 * actually compressed.  Only on the switch to non-</span>
<span class="cm">			 * resident does compression kick in.  This is in</span>
<span class="cm">			 * contrast to encrypted files (see above).</span>
<span class="cm">			 */</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;Writing to compressed files is &quot;</span>
					<span class="s">&quot;not implemented yet.  Sorry.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If a previous ntfs_truncate() failed, repeat it and abort if it</span>
<span class="cm">	 * fails again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">NInoTruncateFailed</span><span class="p">(</span><span class="n">ni</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_truncate</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">NInoTruncateFailed</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cannot perform write to inode &quot;</span>
					<span class="s">&quot;0x%lx, attribute type 0x%x, because &quot;</span>
					<span class="s">&quot;ntfs_truncate() failed (error code &quot;</span>
					<span class="s">&quot;%i).&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* The first byte after the write. */</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the write goes beyond the allocated size, extend the allocation</span>
<span class="cm">	 * to cover the whole of the write, rounded up to the nearest cluster.</span>
<span class="cm">	 */</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ll</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">allocated_size</span><span class="p">;</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">ll</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Extend the allocation without changing the data size. */</span>
		<span class="n">ll</span> <span class="o">=</span> <span class="n">ntfs_attr_extend_allocation</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">ll</span><span class="p">);</span>
			<span class="cm">/* If the extension was partial truncate the write. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">ll</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Truncating write to inode 0x%lx, &quot;</span>
						<span class="s">&quot;attribute type 0x%x, because &quot;</span>
						<span class="s">&quot;the allocation was only &quot;</span>
						<span class="s">&quot;partially extended.&quot;</span><span class="p">,</span>
						<span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>
						<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
			<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ll</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">allocated_size</span><span class="p">;</span>
			<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="cm">/* Perform a partial write if possible or fail. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">ll</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Truncating write to inode 0x%lx, &quot;</span>
						<span class="s">&quot;attribute type 0x%x, because &quot;</span>
						<span class="s">&quot;extending the allocation &quot;</span>
						<span class="s">&quot;failed (error code %i).&quot;</span><span class="p">,</span>
						<span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>
						<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cannot perform write to &quot;</span>
						<span class="s">&quot;inode 0x%lx, attribute type &quot;</span>
						<span class="s">&quot;0x%x, because extending the &quot;</span>
						<span class="s">&quot;allocation failed (error &quot;</span>
						<span class="s">&quot;code %i).&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>
						<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the write starts beyond the initialized size, extend it up to the</span>
<span class="cm">	 * beginning of the write and initialize all non-sparse space between</span>
<span class="cm">	 * the old initialized size and the new one.  This automatically also</span>
<span class="cm">	 * increments the vfs inode-&gt;i_size to keep it above or equal to the</span>
<span class="cm">	 * initialized_size.</span>
<span class="cm">	 */</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ll</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span><span class="p">;</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">ll</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_extend_initialized</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cannot perform write to inode &quot;</span>
					<span class="s">&quot;0x%lx, attribute type 0x%x, because &quot;</span>
					<span class="s">&quot;extending the initialized size &quot;</span>
					<span class="s">&quot;failed (error code %i).&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Determine the number of pages per cluster for non-resident</span>
<span class="cm">	 * attributes.</span>
<span class="cm">	 */</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">NInoNonResident</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="cm">/* Finally, perform the actual write. */</span>
	<span class="n">last_vcn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nr_segs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">VCN</span> <span class="n">vcn</span><span class="p">;</span>
		<span class="n">pgoff_t</span> <span class="n">idx</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">do_pages</span><span class="p">,</span> <span class="n">u</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">copied</span><span class="p">;</span>

		<span class="n">start_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="n">do_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vcn</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vcn</span> <span class="o">!=</span> <span class="n">last_vcn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">last_vcn</span> <span class="o">=</span> <span class="n">vcn</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * Get the lcn of the vcn the write is in.  If</span>
<span class="cm">				 * it is a hole, need to lock down all pages in</span>
<span class="cm">				 * the cluster.</span>
<span class="cm">				 */</span>
				<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">lcn</span> <span class="o">=</span> <span class="n">ntfs_attr_vcn_to_lcn_nolock</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span>
						<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
				<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lcn</span> <span class="o">&lt;</span> <span class="n">LCN_HOLE</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">lcn</span> <span class="o">==</span> <span class="n">LCN_ENOMEM</span><span class="p">)</span>
						<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cannot &quot;</span>
							<span class="s">&quot;perform write to &quot;</span>
							<span class="s">&quot;inode 0x%lx, &quot;</span>
							<span class="s">&quot;attribute type 0x%x, &quot;</span>
							<span class="s">&quot;because the attribute &quot;</span>
							<span class="s">&quot;is corrupt.&quot;</span><span class="p">,</span>
							<span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>
							<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lcn</span> <span class="o">==</span> <span class="n">LCN_HOLE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">start_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">s64</span><span class="p">)</span>
							<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_mask</span><span class="p">)</span>
							<span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
					<span class="n">bytes</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span>
							<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_mask</span><span class="p">);</span>
					<span class="n">do_pages</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Bring in the user page(s) that we will copy from _first_.</span>
<span class="cm">		 * Otherwise there is a nasty deadlock on copying from the same</span>
<span class="cm">		 * page(s) as we are writing to, without it/them being marked</span>
<span class="cm">		 * up-to-date.  Note, at present there is nothing to stop the</span>
<span class="cm">		 * pages being swapped out between us bringing them into memory</span>
<span class="cm">		 * and doing the actual copying.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nr_segs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">ntfs_fault_in_pages_readable</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ntfs_fault_in_pages_readable_iovec</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">iov_ofs</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="cm">/* Get and lock @do_pages starting at index @start_idx. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">__ntfs_grab_cache_pages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">do_pages</span><span class="p">,</span>
				<span class="n">pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * For non-resident attributes, we need to fill any holes with</span>
<span class="cm">		 * actual clusters and ensure all bufferes are mapped.  We also</span>
<span class="cm">		 * need to bring uptodate any buffers that are only partially</span>
<span class="cm">		 * being written to.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NInoNonResident</span><span class="p">(</span><span class="n">ni</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ntfs_prepare_pages_for_non_resident_write</span><span class="p">(</span>
					<span class="n">pages</span><span class="p">,</span> <span class="n">do_pages</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>

				<span class="k">do</span> <span class="p">{</span>
					<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="o">--</span><span class="n">do_pages</span><span class="p">]);</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">do_pages</span><span class="p">]);</span>
				<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">do_pages</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * The write preparation may have instantiated</span>
<span class="cm">				 * allocated space outside i_size.  Trim this</span>
<span class="cm">				 * off again.  We can ignore any errors in this</span>
<span class="cm">				 * case as we will just be waisting a bit of</span>
<span class="cm">				 * allocated space, which is not a disaster.</span>
<span class="cm">				 */</span>
				<span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">i_size</span><span class="p">)</span>
					<span class="n">vmtruncate</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">i_size</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nr_segs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="n">ntfs_copy_from_user</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">u</span><span class="p">,</span> <span class="n">do_pages</span> <span class="o">-</span> <span class="n">u</span><span class="p">,</span>
					<span class="n">ofs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="n">ntfs_copy_from_user_iovec</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">u</span><span class="p">,</span>
					<span class="n">do_pages</span> <span class="o">-</span> <span class="n">u</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov_ofs</span><span class="p">,</span>
					<span class="n">bytes</span><span class="p">);</span>
		<span class="n">ntfs_flush_dcache_pages</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">u</span><span class="p">,</span> <span class="n">do_pages</span> <span class="o">-</span> <span class="n">u</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ntfs_commit_pages_after_write</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">do_pages</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
				<span class="n">bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">written</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">-=</span> <span class="n">copied</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">!=</span> <span class="n">bytes</span><span class="p">))</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="o">--</span><span class="n">do_pages</span><span class="p">]);</span>
			<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">do_pages</span><span class="p">]);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">do_pages</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">do_pages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cached_page</span><span class="p">)</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">cached_page</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.  Returning %s (written 0x%lx, status %li).&quot;</span><span class="p">,</span>
			<span class="n">written</span> <span class="o">?</span> <span class="s">&quot;written&quot;</span> <span class="o">:</span> <span class="s">&quot;status&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">written</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">written</span> <span class="o">?</span> <span class="n">written</span> <span class="o">:</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_file_aio_write_nolock -</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ntfs_file_aio_write_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* after file limit checks */</span>
	<span class="kt">ssize_t</span> <span class="n">written</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">generic_segment_checks</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="n">vfs_check_frozen</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">);</span>
	<span class="cm">/* We can write back this queue in page reclaim. */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">generic_write_checks</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">file_remove_suid</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">file_update_time</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">written</span> <span class="o">=</span> <span class="n">ntfs_file_buffered_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span>
			<span class="n">count</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">written</span> <span class="o">?</span> <span class="n">written</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_file_aio_write -</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ntfs_file_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ntfs_file_aio_write_nolock</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">generic_write_sync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_file_fsync - sync a file to disk</span>
<span class="cm"> * @filp:	file to be synced</span>
<span class="cm"> * @datasync:	if non-zero only flush user data and not metadata</span>
<span class="cm"> *</span>
<span class="cm"> * Data integrity sync of a file to disk.  Used for fsync, fdatasync, and msync</span>
<span class="cm"> * system calls.  This function is inspired by fs/buffer.c::file_fsync().</span>
<span class="cm"> *</span>
<span class="cm"> * If @datasync is false, write the mft record and all associated extent mft</span>
<span class="cm"> * records as well as the $DATA attribute and then sync the block device.</span>
<span class="cm"> *</span>
<span class="cm"> * If @datasync is true and the attribute is non-resident, we skip the writing</span>
<span class="cm"> * of the mft record and all associated extent mft records (this might still</span>
<span class="cm"> * happen due to the write_inode_now() call).</span>
<span class="cm"> *</span>
<span class="cm"> * Also, if @datasync is true, we do not wait on the inode to be written out</span>
<span class="cm"> * but we always wait on the page cache pages to be written out.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: Caller must hold i_mutex on the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: We should probably also write all attribute/index inodes associated</span>
<span class="cm"> * with this inode but since we have no simple way of getting to them we ignore</span>
<span class="cm"> * this problem for now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_file_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering for inode 0x%lx.&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">datasync</span> <span class="o">||</span> <span class="o">!</span><span class="n">NInoNonResident</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vi</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__ntfs_write_inode</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">write_inode_now</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="o">!</span><span class="n">datasync</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * NOTE: If we were to use mapping-&gt;private_list (see ext2 and</span>
<span class="cm">	 * fs/buffer.c) for dirty blocks then we could optimize the below to be</span>
<span class="cm">	 * sync_mapping_buffers(vi-&gt;i_mapping).</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sync_blockdev</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;Failed to f%ssync inode 0x%lx.  Error &quot;</span>
				<span class="s">&quot;%u.&quot;</span><span class="p">,</span> <span class="n">datasync</span> <span class="o">?</span> <span class="s">&quot;data&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ntfs_file_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>	 <span class="cm">/* Seek inside file. */</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>		 <span class="cm">/* Read from file. */</span>
	<span class="p">.</span><span class="n">aio_read</span>	<span class="o">=</span> <span class="n">generic_file_aio_read</span><span class="p">,</span> <span class="cm">/* Async read from file. */</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>	 <span class="cm">/* Write to file. */</span>
	<span class="p">.</span><span class="n">aio_write</span>	<span class="o">=</span> <span class="n">ntfs_file_aio_write</span><span class="p">,</span>	 <span class="cm">/* Async write to file. */</span>
	<span class="cm">/*.release	= ,*/</span>			 <span class="cm">/* Last file is closed.  See</span>
<span class="cm">						    fs/ext2/file.c::</span>
<span class="cm">						    ext2_release_file() for</span>
<span class="cm">						    how to use this to discard</span>
<span class="cm">						    preallocated space for</span>
<span class="cm">						    write opened files. */</span>
	<span class="p">.</span><span class="n">fsync</span>		<span class="o">=</span> <span class="n">ntfs_file_fsync</span><span class="p">,</span>	 <span class="cm">/* Sync a file to disk. */</span>
	<span class="cm">/*.aio_fsync	= ,*/</span>			 <span class="cm">/* Sync all outstanding async</span>
<span class="cm">						    i/o operations on a</span>
<span class="cm">						    kiocb. */</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="cm">/*.ioctl	= ,*/</span>			 <span class="cm">/* Perform function on the</span>
<span class="cm">						    mounted filesystem. */</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">generic_file_mmap</span><span class="p">,</span>	 <span class="cm">/* Mmap file. */</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">ntfs_file_open</span><span class="p">,</span>	 <span class="cm">/* Open file. */</span>
	<span class="p">.</span><span class="n">splice_read</span>	<span class="o">=</span> <span class="n">generic_file_splice_read</span> <span class="cm">/* Zero-copy data send with</span>
<span class="cm">						    the data source being on</span>
<span class="cm">						    the ntfs partition.  We do</span>
<span class="cm">						    not need to care about the</span>
<span class="cm">						    data destination. */</span>
	<span class="cm">/*.sendpage	= ,*/</span>			 <span class="cm">/* Zero-copy data send with</span>
<span class="cm">						    the data destination being</span>
<span class="cm">						    on the ntfs partition.  We</span>
<span class="cm">						    do not need to care about</span>
<span class="cm">						    the data source. */</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ntfs_file_inode_ops</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="p">.</span><span class="n">truncate</span>	<span class="o">=</span> <span class="n">ntfs_truncate_vfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">ntfs_setattr</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ntfs_empty_file_ops</span> <span class="o">=</span> <span class="p">{};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ntfs_empty_inode_ops</span> <span class="o">=</span> <span class="p">{};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
