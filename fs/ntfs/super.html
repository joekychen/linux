<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › super.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>super.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * super.c - NTFS kernel super block handling. Part of the Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2012 Anton Altaparmakov and Tuxera Inc.</span>
<span class="cm"> * Copyright (c) 2001,2002 Richard Russon</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;	</span><span class="cm">/* For bdev_logical_block_size(). */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/vfs.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>

<span class="cp">#include &quot;sysctl.h&quot;</span>
<span class="cp">#include &quot;logfile.h&quot;</span>
<span class="cp">#include &quot;quota.h&quot;</span>
<span class="cp">#include &quot;usnjrnl.h&quot;</span>
<span class="cp">#include &quot;dir.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;index.h&quot;</span>
<span class="cp">#include &quot;inode.h&quot;</span>
<span class="cp">#include &quot;aops.h&quot;</span>
<span class="cp">#include &quot;layout.h&quot;</span>
<span class="cp">#include &quot;malloc.h&quot;</span>
<span class="cp">#include &quot;ntfs.h&quot;</span>

<span class="cm">/* Number of mounted filesystems which have compression enabled. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ntfs_nr_compression_users</span><span class="p">;</span>

<span class="cm">/* A global default upcase table and a corresponding reference count. */</span>
<span class="k">static</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">default_upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ntfs_nr_upcase_users</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Error constants/strings used in inode.c::ntfs_show_options(). */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* One of these must be present, default is ON_ERRORS_CONTINUE. */</span>
	<span class="n">ON_ERRORS_PANIC</span>			<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">ON_ERRORS_REMOUNT_RO</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">ON_ERRORS_CONTINUE</span>		<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="cm">/* Optional, can be combined with any of the above. */</span>
	<span class="n">ON_ERRORS_RECOVER</span>		<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
<span class="p">}</span> <span class="n">ON_ERRORS_ACTIONS</span><span class="p">;</span>

<span class="k">const</span> <span class="n">option_t</span> <span class="n">on_errors_arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">ON_ERRORS_PANIC</span><span class="p">,</span>	<span class="s">&quot;panic&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">ON_ERRORS_REMOUNT_RO</span><span class="p">,</span>	<span class="s">&quot;remount-ro&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">ON_ERRORS_CONTINUE</span><span class="p">,</span>	<span class="s">&quot;continue&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">ON_ERRORS_RECOVER</span><span class="p">,</span>	<span class="s">&quot;recover&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span>			<span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * simple_getbool -</span>
<span class="cm"> *</span>
<span class="cm"> * Copied from old ntfs driver (which copied from vfat driver).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">simple_getbool</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">setval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;yes&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;true&quot;</span><span class="p">))</span>
			<span class="o">*</span><span class="n">setval</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;0&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;no&quot;</span><span class="p">)</span> <span class="o">||</span>
							<span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;false&quot;</span><span class="p">))</span>
			<span class="o">*</span><span class="n">setval</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">setval</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parse_options - parse the (re)mount options</span>
<span class="cm"> * @vol:	ntfs volume</span>
<span class="cm"> * @opt:	string containing the (re)mount options</span>
<span class="cm"> *</span>
<span class="cm"> * Parse the recognized options in @opt for the ntfs volume described by @vol.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">parse_options</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">ov</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">utf8</span> <span class="o">=</span> <span class="s">&quot;utf8&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sloppy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">fmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">umode_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">umode_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mft_zone_multiplier</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_errors</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">show_sys_files</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">case_sensitive</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">disable_sparse</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">nls_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">old_nls</span><span class="p">;</span>

	<span class="cm">/* I am lazy... (-8 */</span>
<span class="cp">#define NTFS_GETOPT_WITH_DEFAULT(option, variable, default_value)	\</span>
<span class="cp">	if (!strcmp(p, option)) {					\</span>
<span class="cp">		if (!v || !*v)						\</span>
<span class="cp">			variable = default_value;			\</span>
<span class="cp">		else {							\</span>
<span class="cp">			variable = simple_strtoul(ov = v, &amp;v, 0);	\</span>
<span class="cp">			if (*v)						\</span>
<span class="cp">				goto needs_val;				\</span>
<span class="cp">		}							\</span>
<span class="cp">	}</span>
<span class="cp">#define NTFS_GETOPT(option, variable)					\</span>
<span class="cp">	if (!strcmp(p, option)) {					\</span>
<span class="cp">		if (!v || !*v)						\</span>
<span class="cp">			goto needs_arg;					\</span>
<span class="cp">		variable = simple_strtoul(ov = v, &amp;v, 0);		\</span>
<span class="cp">		if (*v)							\</span>
<span class="cp">			goto needs_val;					\</span>
<span class="cp">	}</span>
<span class="cp">#define NTFS_GETOPT_OCTAL(option, variable)				\</span>
<span class="cp">	if (!strcmp(p, option)) {					\</span>
<span class="cp">		if (!v || !*v)						\</span>
<span class="cp">			goto needs_arg;					\</span>
<span class="cp">		variable = simple_strtoul(ov = v, &amp;v, 8);		\</span>
<span class="cp">		if (*v)							\</span>
<span class="cp">			goto needs_val;					\</span>
<span class="cp">	}</span>
<span class="cp">#define NTFS_GETOPT_BOOL(option, variable)				\</span>
<span class="cp">	if (!strcmp(p, option)) {					\</span>
<span class="cp">		bool val;						\</span>
<span class="cp">		if (!simple_getbool(v, &amp;val))				\</span>
<span class="cp">			goto needs_bool;				\</span>
<span class="cp">		variable = val;						\</span>
<span class="cp">	}</span>
<span class="cp">#define NTFS_GETOPT_OPTIONS_ARRAY(option, variable, opt_array)		\</span>
<span class="cp">	if (!strcmp(p, option)) {					\</span>
<span class="cp">		int _i;							\</span>
<span class="cp">		if (!v || !*v)						\</span>
<span class="cp">			goto needs_arg;					\</span>
<span class="cp">		ov = v;							\</span>
<span class="cp">		if (variable == -1)					\</span>
<span class="cp">			variable = 0;					\</span>
<span class="cp">		for (_i = 0; opt_array[_i].str &amp;&amp; *opt_array[_i].str; _i++) \</span>
<span class="cp">			if (!strcmp(opt_array[_i].str, v)) {		\</span>
<span class="cp">				variable |= opt_array[_i].val;		\</span>
<span class="cp">				break;					\</span>
<span class="cp">			}						\</span>
<span class="cp">		if (!opt_array[_i].str || !*opt_array[_i].str)		\</span>
<span class="cp">			goto needs_val;					\</span>
<span class="cp">	}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opt</span> <span class="o">||</span> <span class="o">!*</span><span class="n">opt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_mount_options</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering with mount options string: %s&quot;</span><span class="p">,</span> <span class="n">opt</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">)))</span>
			<span class="o">*</span><span class="n">v</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">NTFS_GETOPT</span><span class="p">(</span><span class="s">&quot;uid&quot;</span><span class="p">,</span> <span class="n">uid</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT</span><span class="p">(</span><span class="s">&quot;gid&quot;</span><span class="p">,</span> <span class="n">gid</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT_OCTAL</span><span class="p">(</span><span class="s">&quot;umask&quot;</span><span class="p">,</span> <span class="n">fmask</span> <span class="o">=</span> <span class="n">dmask</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT_OCTAL</span><span class="p">(</span><span class="s">&quot;fmask&quot;</span><span class="p">,</span> <span class="n">fmask</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT_OCTAL</span><span class="p">(</span><span class="s">&quot;dmask&quot;</span><span class="p">,</span> <span class="n">dmask</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT</span><span class="p">(</span><span class="s">&quot;mft_zone_multiplier&quot;</span><span class="p">,</span> <span class="n">mft_zone_multiplier</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT_WITH_DEFAULT</span><span class="p">(</span><span class="s">&quot;sloppy&quot;</span><span class="p">,</span> <span class="n">sloppy</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT_BOOL</span><span class="p">(</span><span class="s">&quot;show_sys_files&quot;</span><span class="p">,</span> <span class="n">show_sys_files</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT_BOOL</span><span class="p">(</span><span class="s">&quot;case_sensitive&quot;</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT_BOOL</span><span class="p">(</span><span class="s">&quot;disable_sparse&quot;</span><span class="p">,</span> <span class="n">disable_sparse</span><span class="p">)</span>
		<span class="k">else</span> <span class="n">NTFS_GETOPT_OPTIONS_ARRAY</span><span class="p">(</span><span class="s">&quot;errors&quot;</span><span class="p">,</span> <span class="n">on_errors</span><span class="p">,</span>
				<span class="n">on_errors_arr</span><span class="p">)</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;posix&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;show_inodes&quot;</span><span class="p">))</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Ignoring obsolete option %s.&quot;</span><span class="p">,</span>
					<span class="n">p</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;nls&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;iocharset&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;iocharset&quot;</span><span class="p">))</span>
				<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Option iocharset is &quot;</span>
						<span class="s">&quot;deprecated. Please use &quot;</span>
						<span class="s">&quot;option nls=&lt;charsetname&gt; in &quot;</span>
						<span class="s">&quot;the future.&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span> <span class="o">||</span> <span class="o">!*</span><span class="n">v</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">needs_arg</span><span class="p">;</span>
<span class="nl">use_utf8:</span>
			<span class="n">old_nls</span> <span class="o">=</span> <span class="n">nls_map</span><span class="p">;</span>
			<span class="n">nls_map</span> <span class="o">=</span> <span class="n">load_nls</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nls_map</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_nls</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;NLS character set &quot;</span>
							<span class="s">&quot;%s not found.&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
					<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;NLS character set %s not &quot;</span>
						<span class="s">&quot;found. Using previous one %s.&quot;</span><span class="p">,</span>
						<span class="n">v</span><span class="p">,</span> <span class="n">old_nls</span><span class="o">-&gt;</span><span class="n">charset</span><span class="p">);</span>
				<span class="n">nls_map</span> <span class="o">=</span> <span class="n">old_nls</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="cm">/* nls_map */</span> <span class="p">{</span>
				<span class="n">unload_nls</span><span class="p">(</span><span class="n">old_nls</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;utf8&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Option utf8 is no longer &quot;</span>
				   <span class="s">&quot;supported, using option nls=utf8. Please &quot;</span>
				   <span class="s">&quot;use option nls=utf8 in the future and &quot;</span>
				   <span class="s">&quot;make sure utf8 is compiled either as a &quot;</span>
				   <span class="s">&quot;module or into the kernel.&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span> <span class="o">||</span> <span class="o">!*</span><span class="n">v</span><span class="p">)</span>
				<span class="n">val</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">simple_getbool</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">needs_bool</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">v</span> <span class="o">=</span> <span class="n">utf8</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">use_utf8</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Unrecognized mount option %s.&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">)</span>
				<span class="n">errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#undef NTFS_GETOPT_OPTIONS_ARRAY</span>
<span class="cp">#undef NTFS_GETOPT_BOOL</span>
<span class="cp">#undef NTFS_GETOPT</span>
<span class="cp">#undef NTFS_GETOPT_WITH_DEFAULT</span>
	<span class="p">}</span>
<span class="nl">no_mount_options:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sloppy</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sloppy</span><span class="p">)</span>
		<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Sloppy option given. Ignoring &quot;</span>
				<span class="s">&quot;unrecognized mount option(s) and continuing.&quot;</span><span class="p">);</span>
	<span class="cm">/* Keep this first! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_errors</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on_errors</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Invalid errors option argument &quot;</span>
					<span class="s">&quot;or bug in options parser.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nls_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span> <span class="o">&amp;&amp;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span> <span class="o">!=</span> <span class="n">nls_map</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cannot change NLS character set &quot;</span>
					<span class="s">&quot;on remount.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* else (!vol-&gt;nls_map) */</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Using NLS character set %s.&quot;</span><span class="p">,</span> <span class="n">nls_map</span><span class="o">-&gt;</span><span class="n">charset</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span> <span class="o">=</span> <span class="n">nls_map</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* (!nls_map) */</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span> <span class="o">=</span> <span class="n">load_nls_default</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load default &quot;</span>
						<span class="s">&quot;NLS character set.&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Using default NLS character set (%s).&quot;</span><span class="p">,</span>
					<span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span><span class="o">-&gt;</span><span class="n">charset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mft_zone_multiplier</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_multiplier</span> <span class="o">&amp;&amp;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_multiplier</span> <span class="o">!=</span>
				<span class="n">mft_zone_multiplier</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cannot change mft_zone_multiplier &quot;</span>
					<span class="s">&quot;on remount.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mft_zone_multiplier</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">mft_zone_multiplier</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Invalid mft_zone_multiplier. &quot;</span>
					<span class="s">&quot;Using default value, i.e. 1.&quot;</span><span class="p">);</span>
			<span class="n">mft_zone_multiplier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_multiplier</span> <span class="o">=</span> <span class="n">mft_zone_multiplier</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_multiplier</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_multiplier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_errors</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">=</span> <span class="n">on_errors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">==</span> <span class="n">ON_ERRORS_RECOVER</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">|=</span> <span class="n">ON_ERRORS_CONTINUE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">uid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">gid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmask</span> <span class="o">!=</span> <span class="p">(</span><span class="n">umode_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">fmask</span> <span class="o">=</span> <span class="n">fmask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmask</span> <span class="o">!=</span> <span class="p">(</span><span class="n">umode_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">dmask</span> <span class="o">=</span> <span class="n">dmask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_sys_files</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">show_sys_files</span><span class="p">)</span>
			<span class="n">NVolSetShowSystemFiles</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">NVolClearShowSystemFiles</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">case_sensitive</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">case_sensitive</span><span class="p">)</span>
			<span class="n">NVolSetCaseSensitive</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">NVolClearCaseSensitive</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disable_sparse</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disable_sparse</span><span class="p">)</span>
			<span class="n">NVolClearSparseEnabled</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NVolSparseEnabled</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span> <span class="o">&amp;&amp;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Not enabling sparse &quot;</span>
						<span class="s">&quot;support due to NTFS volume &quot;</span>
						<span class="s">&quot;version %i.%i (need at least &quot;</span>
						<span class="s">&quot;version 3.0).&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span><span class="p">,</span>
						<span class="n">vol</span><span class="o">-&gt;</span><span class="n">minor_ver</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">NVolSetSparseEnabled</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="nl">needs_arg:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;The %s option requires an argument.&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="nl">needs_bool:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;The %s option requires a boolean argument.&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="nl">needs_val:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Invalid %s option argument: %s&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ov</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef NTFS_RW</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_write_volume_flags - write new flags to the volume information flags</span>
<span class="cm"> * @vol:	ntfs volume on which to modify the flags</span>
<span class="cm"> * @flags:	new flags value for the volume information flags</span>
<span class="cm"> *</span>
<span class="cm"> * Internal function.  You probably want to use ntfs_{set,clear}_volume_flags()</span>
<span class="cm"> * instead (see below).</span>
<span class="cm"> *</span>
<span class="cm"> * Replace the volume information flags on the volume @vol with the value</span>
<span class="cm"> * supplied in @flags.  Note, this overwrites the volume information flags, so</span>
<span class="cm"> * make sure to combine the flags you want to modify with the old flags and use</span>
<span class="cm"> * the result when calling ntfs_write_volume_flags().</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success and -errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_write_volume_flags</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="k">const</span> <span class="n">VOLUME_FLAGS</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">);</span>
	<span class="n">MFT_RECORD</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">VOLUME_INFORMATION</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering, old flags = 0x%x, new flags = 0x%x.&quot;</span><span class="p">,</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span><span class="p">),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">flags</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">==</span> <span class="n">flags</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ni</span><span class="p">);</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">put_unm_err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">AT_VOLUME_INFORMATION</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">put_unm_err_out</span><span class="p">;</span>
	<span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">VOLUME_INFORMATION</span><span class="o">*</span><span class="p">)((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">+</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_offset</span><span class="p">));</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">flush_dcache_mft_record_page</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
	<span class="n">mark_mft_record_dirty</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ntfs_ino</span><span class="p">);</span>
	<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">put_unm_err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed with error code %i.&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_set_volume_flags - set bits in the volume information flags</span>
<span class="cm"> * @vol:	ntfs volume on which to modify the flags</span>
<span class="cm"> * @flags:	flags to set on the volume</span>
<span class="cm"> *</span>
<span class="cm"> * Set the bits in @flags in the volume information flags on the volume @vol.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success and -errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ntfs_set_volume_flags</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="n">VOLUME_FLAGS</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">VOLUME_FLAGS_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ntfs_write_volume_flags</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">|</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_clear_volume_flags - clear bits in the volume information flags</span>
<span class="cm"> * @vol:	ntfs volume on which to modify the flags</span>
<span class="cm"> * @flags:	flags to clear on the volume</span>
<span class="cm"> *</span>
<span class="cm"> * Clear the bits in @flags in the volume information flags on the volume @vol.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success and -errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ntfs_clear_volume_flags</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="n">VOLUME_FLAGS</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">VOLUME_FLAGS_MASK</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="o">~</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">flags</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ntfs_write_volume_flags</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_remount - change the mount options of a mounted ntfs filesystem</span>
<span class="cm"> * @sb:		superblock of mounted ntfs filesystem</span>
<span class="cm"> * @flags:	remount flags</span>
<span class="cm"> * @opt:	remount options string</span>
<span class="cm"> *</span>
<span class="cm"> * Change the mount options of an already mounted ntfs filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  The VFS sets the @sb-&gt;s_flags remount flags to @flags after</span>
<span class="cm"> * ntfs_remount() returns successfully (i.e. returns 0).  Otherwise,</span>
<span class="cm"> * @sb-&gt;s_flags are not changed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">NTFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering with remount options string: %s&quot;</span><span class="p">,</span> <span class="n">opt</span><span class="p">);</span>

<span class="cp">#ifndef NTFS_RW</span>
	<span class="cm">/* For read-only compiled driver, enforce read-only flag. */</span>
	<span class="o">*</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
<span class="cp">#else </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="cm">/*</span>
<span class="cm">	 * For the read-write compiled driver, if we are remounting read-write,</span>
<span class="cm">	 * make sure there are no volume errors and that no unsupported volume</span>
<span class="cm">	 * flags are set.  Also, empty the logfile journal as it would become</span>
<span class="cm">	 * stale as soon as something is written to the volume and mark the</span>
<span class="cm">	 * volume dirty so that chkdsk is run if the volume is not umounted</span>
<span class="cm">	 * cleanly.  Finally, mark the quotas out of date so Windows rescans</span>
<span class="cm">	 * the volume on boot and updates them.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When remounting read-only, mark the volume clean if no volume errors</span>
<span class="cm">	 * have occurred.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es</span> <span class="o">=</span> <span class="s">&quot;.  Cannot remount read-write.&quot;</span><span class="p">;</span>

		<span class="cm">/* Remounting read-write. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NVolErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Volume has errors and is read-only%s&quot;</span><span class="p">,</span>
					<span class="n">es</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">&amp;</span> <span class="n">VOLUME_IS_DIRTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Volume is dirty and read-only%s&quot;</span><span class="p">,</span> <span class="n">es</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">&amp;</span> <span class="n">VOLUME_MODIFIED_BY_CHKDSK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Volume has been modified by chkdsk &quot;</span>
					<span class="s">&quot;and is read-only%s&quot;</span><span class="p">,</span> <span class="n">es</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">&amp;</span> <span class="n">VOLUME_MUST_MOUNT_RO_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Volume has unsupported flags set &quot;</span>
					<span class="s">&quot;(0x%x) and is read-only%s&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span><span class="p">),</span>
					<span class="n">es</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_set_volume_flags</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">VOLUME_IS_DIRTY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to set dirty bit in volume &quot;</span>
					<span class="s">&quot;information flags%s&quot;</span><span class="p">,</span> <span class="n">es</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>TODO: Enable this code once we start modifying anything that
 is different between NTFS 1.2 and 3.x...</p></td><td class="code"><div class="highlight"><pre><span class="c">		/* Set NT4 compatibility flag on newer NTFS version volumes. */</span>
<span class="c">		if ((vol-&gt;major_ver &gt; 1)) {</span>
<span class="c">			if (ntfs_set_volume_flags(vol, VOLUME_MOUNTED_ON_NT4)) {</span>
<span class="c">				ntfs_error(sb, &quot;Failed to set NT4 &quot;</span>
<span class="c">						&quot;compatibility flag%s&quot;, es);</span>
<span class="c">				NVolSetErrors(vol);</span>
<span class="c">				return -EROFS;</span>
<span class="c">			}</span>
<span class="c">		}</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_empty_logfile</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to empty journal $LogFile%s&quot;</span><span class="p">,</span>
					<span class="n">es</span><span class="p">);</span>
			<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_mark_quotas_out_of_date</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to mark quotas out of date%s&quot;</span><span class="p">,</span>
					<span class="n">es</span><span class="p">);</span>
			<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_stamp_usnjrnl</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to stamp transation log &quot;</span>
					<span class="s">&quot;($UsnJrnl)%s&quot;</span><span class="p">,</span> <span class="n">es</span><span class="p">);</span>
			<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Remounting read-only. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NVolErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_clear_volume_flags</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">VOLUME_IS_DIRTY</span><span class="p">))</span>
				<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to clear dirty bit &quot;</span>
						<span class="s">&quot;in volume information &quot;</span>
						<span class="s">&quot;flags.  Run chkdsk.&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>TODO: Deal with *flags.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_options</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">opt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_boot_sector_ntfs - check whether a boot sector is a valid NTFS boot sector</span>
<span class="cm"> * @sb:		Super block of the device to which @b belongs.</span>
<span class="cm"> * @b:		Boot sector of device @sb to check.</span>
<span class="cm"> * @silent:	If &#39;true&#39;, all output will be silenced.</span>
<span class="cm"> *</span>
<span class="cm"> * is_boot_sector_ntfs() checks whether the boot sector @b is a valid NTFS boot</span>
<span class="cm"> * sector. Returns &#39;true&#39; if it is valid and &#39;false&#39; if not.</span>
<span class="cm"> *</span>
<span class="cm"> * @sb is only needed for warning/error output, i.e. it can be NULL when silent</span>
<span class="cm"> * is &#39;true&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_boot_sector_ntfs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">NTFS_BOOT_SECTOR</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check that checksum == sum of u32 values from b to the checksum</span>
<span class="cm">	 * field.  If checksum is zero, no checking is done.  We will work when</span>
<span class="cm">	 * the checksum test fails, since some utilities update the boot sector</span>
<span class="cm">	 * ignoring the checksum which leaves the checksum out-of-date.  We</span>
<span class="cm">	 * report a warning if this is the case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">silent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">le32</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">le32</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">);</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">le32_to_cpup</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Invalid boot sector checksum.&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Check OEMidentifier is &quot;NTFS    &quot; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">oem_id</span> <span class="o">!=</span> <span class="n">magicNTFS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_ntfs</span><span class="p">;</span>
	<span class="cm">/* Check bytes per sector value is between 256 and 4096. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">bytes_per_sector</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x100</span> <span class="o">||</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">bytes_per_sector</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x1000</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_ntfs</span><span class="p">;</span>
	<span class="cm">/* Check sectors per cluster value is valid. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">sectors_per_cluster</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="k">case</span> <span class="mi">2</span>: <span class="k">case</span> <span class="mi">4</span>: <span class="k">case</span> <span class="mi">8</span>: <span class="k">case</span> <span class="mi">16</span>: <span class="k">case</span> <span class="mi">32</span>: <span class="k">case</span> <span class="mi">64</span>: <span class="k">case</span> <span class="mi">128</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">not_ntfs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check the cluster size is not above the maximum (64kiB). */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">bytes_per_sector</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">sectors_per_cluster</span> <span class="o">&gt;</span> <span class="n">NTFS_MAX_CLUSTER_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_ntfs</span><span class="p">;</span>
	<span class="cm">/* Check reserved/unused fields are really zero. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">reserved_sectors</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">root_entries</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">sectors</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">sectors_per_fat</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">large_sectors</span><span class="p">)</span> <span class="o">||</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">fats</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_ntfs</span><span class="p">;</span>
	<span class="cm">/* Check clusters per file mft record value is valid. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u8</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">clusters_per_mft_record</span> <span class="o">&lt;</span> <span class="mh">0xe1</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">clusters_per_mft_record</span> <span class="o">&gt;</span> <span class="mh">0xf7</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">clusters_per_mft_record</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="k">case</span> <span class="mi">2</span>: <span class="k">case</span> <span class="mi">4</span>: <span class="k">case</span> <span class="mi">8</span>: <span class="k">case</span> <span class="mi">16</span>: <span class="k">case</span> <span class="mi">32</span>: <span class="k">case</span> <span class="mi">64</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">not_ntfs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cm">/* Check clusters per index block value is valid. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u8</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">clusters_per_index_record</span> <span class="o">&lt;</span> <span class="mh">0xe1</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">clusters_per_index_record</span> <span class="o">&gt;</span> <span class="mh">0xf7</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">clusters_per_index_record</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>: <span class="k">case</span> <span class="mi">2</span>: <span class="k">case</span> <span class="mi">4</span>: <span class="k">case</span> <span class="mi">8</span>: <span class="k">case</span> <span class="mi">16</span>: <span class="k">case</span> <span class="mi">32</span>: <span class="k">case</span> <span class="mi">64</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">not_ntfs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for valid end of sector marker. We will work without it, but</span>
<span class="cm">	 * many BIOSes will refuse to boot from a bootsector if the magic is</span>
<span class="cm">	 * incorrect, so we emit a warning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">end_of_sector_marker</span> <span class="o">!=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0xaa55</span><span class="p">))</span>
		<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Invalid end of sector marker.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="nl">not_ntfs:</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_ntfs_boot_sector - read the NTFS boot sector of a device</span>
<span class="cm"> * @sb:		super block of device to read the boot sector from</span>
<span class="cm"> * @silent:	if true, suppress all output</span>
<span class="cm"> *</span>
<span class="cm"> * Reads the boot sector from the device and validates it. If that fails, tries</span>
<span class="cm"> * to read the backup boot sector, first from the end of the device a-la NT4 and</span>
<span class="cm"> * later and then from the middle of the device a-la NT3.51 and before.</span>
<span class="cm"> *</span>
<span class="cm"> * If a valid boot sector is found but it is not the primary boot sector, we</span>
<span class="cm"> * repair the primary boot sector silently (unless the device is read-only or</span>
<span class="cm"> * the primary boot sector is not accessible).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: To call this function, @sb must have the fields s_dev, the ntfs super</span>
<span class="cm"> * block (u.ntfs_sb), nr_blocks and the device flags (s_flags) initialized</span>
<span class="cm"> * to their respective values.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the unlocked buffer head containing the boot sector or NULL on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">read_ntfs_boot_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">read_err_str</span> <span class="o">=</span> <span class="s">&quot;Unable to read %s boot sector.&quot;</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_primary</span><span class="p">,</span> <span class="o">*</span><span class="n">bh_backup</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">nr_blocks</span> <span class="o">=</span> <span class="n">NTFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_blocks</span><span class="p">;</span>

	<span class="cm">/* Try to read primary boot sector. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bh_primary</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_boot_sector_ntfs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="p">(</span><span class="n">NTFS_BOOT_SECTOR</span><span class="o">*</span><span class="p">)</span>
				<span class="n">bh_primary</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">silent</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">bh_primary</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Primary boot sector is invalid.&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">read_err_str</span><span class="p">,</span> <span class="s">&quot;primary&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NTFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="n">ON_ERRORS_RECOVER</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh_primary</span><span class="p">)</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh_primary</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Mount option errors=recover not used. &quot;</span>
					<span class="s">&quot;Aborting without trying to recover.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Try to read NT4+ backup boot sector. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bh_backup</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">nr_blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_boot_sector_ntfs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="p">(</span><span class="n">NTFS_BOOT_SECTOR</span><span class="o">*</span><span class="p">)</span>
				<span class="n">bh_backup</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">silent</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">hotfix_primary_boot_sector</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh_backup</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">read_err_str</span><span class="p">,</span> <span class="s">&quot;backup&quot;</span><span class="p">);</span>
	<span class="cm">/* Try to read NT3.51- backup boot sector. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bh_backup</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">nr_blocks</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_boot_sector_ntfs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="p">(</span><span class="n">NTFS_BOOT_SECTOR</span><span class="o">*</span><span class="p">)</span>
				<span class="n">bh_backup</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">silent</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">hotfix_primary_boot_sector</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Could not find a valid backup boot &quot;</span>
					<span class="s">&quot;sector.&quot;</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh_backup</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">read_err_str</span><span class="p">,</span> <span class="s">&quot;backup&quot;</span><span class="p">);</span>
	<span class="cm">/* We failed. Cleanup and return. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh_primary</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh_primary</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">hotfix_primary_boot_sector:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh_primary</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we managed to read sector zero and the volume is not</span>
<span class="cm">		 * read-only, copy the found, valid backup boot sector to the</span>
<span class="cm">		 * primary boot sector.  Note we only copy the actual boot</span>
<span class="cm">		 * sector structure, not the actual whole device sector as that</span>
<span class="cm">		 * may be bigger and would potentially damage the $Boot system</span>
<span class="cm">		 * file (FIXME: Would be nice to know if the backup boot sector</span>
<span class="cm">		 * on a large sector device contains the whole boot loader or</span>
<span class="cm">		 * just the first 512 bytes).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Hot-fix: Recovering invalid primary &quot;</span>
					<span class="s">&quot;boot sector from backup copy.&quot;</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">bh_primary</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">bh_backup</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
					<span class="n">NTFS_BLOCK_SIZE</span><span class="p">);</span>
			<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh_primary</span><span class="p">);</span>
			<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh_primary</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh_primary</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bh_backup</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">bh_primary</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Hot-fix: Device write error while &quot;</span>
					<span class="s">&quot;recovering primary boot sector.&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Hot-fix: Recovery of primary boot &quot;</span>
					<span class="s">&quot;sector failed: Read-only mount.&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh_primary</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Using backup boot sector.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bh_backup</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parse_ntfs_boot_sector - parse the boot sector and store the data in @vol</span>
<span class="cm"> * @vol:	volume structure to initialise with data from boot sector</span>
<span class="cm"> * @b:		boot sector to parse</span>
<span class="cm"> *</span>
<span class="cm"> * Parse the ntfs boot sector @b and store all imporant information therein in</span>
<span class="cm"> * the ntfs super block @vol.  Return &#39;true&#39; on success and &#39;false&#39; on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">parse_ntfs_boot_sector</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="k">const</span> <span class="n">NTFS_BOOT_SECTOR</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors_per_cluster_bits</span><span class="p">,</span> <span class="n">nr_hidden_sects</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">clusters_per_mft_record</span><span class="p">,</span> <span class="n">clusters_per_index_record</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">ll</span><span class="p">;</span>

	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">bytes_per_sector</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size_bits</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;sector_size = %i (0x%x)&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;sector_size_bits = %i (0x%x)&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size_bits</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Sector size (%i) is smaller than the &quot;</span>
				<span class="s">&quot;device block size (%lu).  This is not &quot;</span>
				<span class="s">&quot;supported.  Sorry.&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">,</span>
				<span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;sectors_per_cluster = 0x%x&quot;</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">sectors_per_cluster</span><span class="p">);</span>
	<span class="n">sectors_per_cluster_bits</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">sectors_per_cluster</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;sectors_per_cluster_bits = 0x%x&quot;</span><span class="p">,</span>
			<span class="n">sectors_per_cluster_bits</span><span class="p">);</span>
	<span class="n">nr_hidden_sects</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bpb</span><span class="p">.</span><span class="n">hidden_sectors</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;number of hidden sectors = 0x%x&quot;</span><span class="p">,</span> <span class="n">nr_hidden_sects</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">&lt;&lt;</span> <span class="n">sectors_per_cluster_bits</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_mask</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;cluster_size = %i (0x%x)&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;cluster_size_mask = 0x%x&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_mask</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;cluster_size_bits = %i&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cluster size (%i) is smaller than the &quot;</span>
				<span class="s">&quot;sector size (%i).  This is not supported.  &quot;</span>
				<span class="s">&quot;Sorry.&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clusters_per_mft_record</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">clusters_per_mft_record</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;clusters_per_mft_record = %i (0x%x)&quot;</span><span class="p">,</span>
			<span class="n">clusters_per_mft_record</span><span class="p">,</span> <span class="n">clusters_per_mft_record</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clusters_per_mft_record</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;&lt;</span>
				<span class="p">(</span><span class="n">ffs</span><span class="p">(</span><span class="n">clusters_per_mft_record</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/*</span>
<span class="cm">		 * When mft_record_size &lt; cluster_size, clusters_per_mft_record</span>
<span class="cm">		 * = -log2(mft_record_size) bytes. mft_record_size normaly is</span>
<span class="cm">		 * 1024 bytes, which is encoded as 0xF6 (-10 in decimal).</span>
<span class="cm">		 */</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="n">clusters_per_mft_record</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_mask</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_bits</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_record_size = %i (0x%x)&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_record_size_mask = 0x%x&quot;</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_mask</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_record_size_bits = %i (0x%x)&quot;</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_bits</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_bits</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We cannot support mft record sizes above the PAGE_CACHE_SIZE since</span>
<span class="cm">	 * we store $MFT/$DATA, the table of mft records in the page cache.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Mft record size (%i) exceeds the &quot;</span>
				<span class="s">&quot;PAGE_CACHE_SIZE on your system (%lu).  &quot;</span>
				<span class="s">&quot;This is not supported.  Sorry.&quot;</span><span class="p">,</span>
				<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We cannot support mft record sizes below the sector size. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span> <span class="o">&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Mft record size (%i) is smaller than the &quot;</span>
				<span class="s">&quot;sector size (%i).  This is not supported.  &quot;</span>
				<span class="s">&quot;Sorry.&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">,</span>
				<span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clusters_per_index_record</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">clusters_per_index_record</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;clusters_per_index_record = %i (0x%x)&quot;</span><span class="p">,</span>
			<span class="n">clusters_per_index_record</span><span class="p">,</span> <span class="n">clusters_per_index_record</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clusters_per_index_record</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;&lt;</span>
				<span class="p">(</span><span class="n">ffs</span><span class="p">(</span><span class="n">clusters_per_index_record</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/*</span>
<span class="cm">		 * When index_record_size &lt; cluster_size,</span>
<span class="cm">		 * clusters_per_index_record = -log2(index_record_size) bytes.</span>
<span class="cm">		 * index_record_size normaly equals 4096 bytes, which is</span>
<span class="cm">		 * encoded as 0xF4 (-12 in decimal).</span>
<span class="cm">		 */</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="n">clusters_per_index_record</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size_mask</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size_bits</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;index_record_size = %i (0x%x)&quot;</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;index_record_size_mask = 0x%x&quot;</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size_mask</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;index_record_size_bits = %i (0x%x)&quot;</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size_bits</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size_bits</span><span class="p">);</span>
	<span class="cm">/* We cannot support index record sizes below the sector size. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size</span> <span class="o">&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Index record size (%i) is smaller than &quot;</span>
				<span class="s">&quot;the sector size (%i).  This is not &quot;</span>
				<span class="s">&quot;supported.  Sorry.&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">index_record_size</span><span class="p">,</span>
				<span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the size of the volume in clusters and check for 64-bit-ness.</span>
<span class="cm">	 * Windows currently only uses 32 bits to save the clusters so we do</span>
<span class="cm">	 * the same as it is much faster on 32-bit CPUs.</span>
<span class="cm">	 */</span>
	<span class="n">ll</span> <span class="o">=</span> <span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">number_of_sectors</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">sectors_per_cluster_bits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Cannot handle 64-bit clusters.  Sorry.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;nr_clusters = 0x%llx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * On an architecture where unsigned long is 32-bits, we restrict the</span>
<span class="cm">	 * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler</span>
<span class="cm">	 * will hopefully optimize the whole check away.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ll</span> <span class="o">&lt;&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">41</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Volume size (%lluTiB) is too &quot;</span>
					<span class="s">&quot;large for this architecture.  &quot;</span>
					<span class="s">&quot;Maximum supported is 2TiB.  Sorry.&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ll</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">40</span> <span class="o">-</span>
					<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">));</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="o">=</span> <span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">mft_lcn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;MFT LCN (%lli, 0x%llx) is beyond end of &quot;</span>
				<span class="s">&quot;volume.  Weird.&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ll</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ll</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_lcn</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_lcn = 0x%llx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_lcn</span><span class="p">);</span>
	<span class="n">ll</span> <span class="o">=</span> <span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">mftmirr_lcn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;MFTMirr LCN (%lli, 0x%llx) is beyond end &quot;</span>
				<span class="s">&quot;of volume.  Weird.&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ll</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ll</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_lcn</span> <span class="o">=</span> <span class="n">ll</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mftmirr_lcn = 0x%llx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_lcn</span><span class="p">);</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/*</span>
<span class="cm">	 * Work out the size of the mft mirror in number of mft records. If the</span>
<span class="cm">	 * cluster size is less than or equal to the size taken by four mft</span>
<span class="cm">	 * records, the mft mirror stores the first four mft records. If the</span>
<span class="cm">	 * cluster size is bigger than the size taken by four mft records, the</span>
<span class="cm">	 * mft mirror contains as many mft records as will fit into one</span>
<span class="cm">	 * cluster.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_bits</span><span class="p">))</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_size</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&gt;&gt;</span>
				<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_bits</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mftmirr_size = %i&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_size</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">serial_no</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">volume_serial_number</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;serial_no = 0x%llx&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">serial_no</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_setup_allocators - initialize the cluster and mft allocators</span>
<span class="cm"> * @vol:	volume structure for which to setup the allocators</span>
<span class="cm"> *</span>
<span class="cm"> * Setup the cluster (lcn) and mft allocators to the starting values.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ntfs_setup_allocators</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="n">LCN</span> <span class="n">mft_zone_size</span><span class="p">,</span> <span class="n">mft_lcn</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_zone_multiplier = 0x%x&quot;</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_multiplier</span><span class="p">);</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/* Determine the size of the MFT zone. */</span>
	<span class="n">mft_zone_size</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_multiplier</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* % of volume size in clusters */</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">mft_zone_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* 50%   */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">mft_zone_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">mft_zone_size</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">mft_zone_size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* 37.5% */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">mft_zone_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>			<span class="cm">/* 25%   */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* case 1: */</span>
	<span class="nl">default:</span>
		<span class="n">mft_zone_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>			<span class="cm">/* 12.5% */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Setup the mft zone. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_start</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_pos</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_lcn</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_zone_pos = 0x%llx&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_pos</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Calculate the mft_lcn for an unmodified NTFS volume (see mkntfs</span>
<span class="cm">	 * source) and if the actual mft_lcn is in the expected place or even</span>
<span class="cm">	 * further to the front of the volume, extend the mft_zone to cover the</span>
<span class="cm">	 * beginning of the volume as well.  This is in order to protect the</span>
<span class="cm">	 * area reserved for the mft bitmap as well within the mft_zone itself.</span>
<span class="cm">	 * On non-standard volumes we do not protect it as the overhead would</span>
<span class="cm">	 * be higher than the speed increase we would get by doing it.</span>
<span class="cm">	 */</span>
	<span class="n">mft_lcn</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8192</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mft_lcn</span> <span class="o">*</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">mft_lcn</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">+</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
				<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_start</span> <span class="o">&lt;=</span> <span class="n">mft_lcn</span><span class="p">)</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_zone_start = 0x%llx&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_start</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Need to cap the mft zone on non-standard volumes so that it does</span>
<span class="cm">	 * not point outside the boundaries of the volume.  We do this by</span>
<span class="cm">	 * halving the zone size until we are inside the volume.</span>
<span class="cm">	 */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_end</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_lcn</span> <span class="o">+</span> <span class="n">mft_zone_size</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_end</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mft_zone_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_end</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_lcn</span> <span class="o">+</span> <span class="n">mft_zone_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_zone_end = 0x%llx&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_end</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set the current position within each data zone to the start of the</span>
<span class="cm">	 * respective zone.</span>
<span class="cm">	 */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">data1_zone_pos</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_zone_end</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;data1_zone_pos = 0x%llx&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">data1_zone_pos</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">data2_zone_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;data2_zone_pos = 0x%llx&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">data2_zone_pos</span><span class="p">);</span>

	<span class="cm">/* Set the mft data allocation position to mft record 24. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_data_pos</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;vol-&gt;mft_data_pos = 0x%llx&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_data_pos</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cp">#ifdef NTFS_RW</span>

<span class="cm">/**</span>
<span class="cm"> * load_and_init_mft_mirror - load and setup the mft mirror inode for a volume</span>
<span class="cm"> * @vol:	ntfs super block describing device whose mft mirror to load</span>
<span class="cm"> *</span>
<span class="cm"> * Return &#39;true&#39; on success or &#39;false&#39; on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">load_and_init_mft_mirror</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">tmp_ino</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">tmp_ni</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/* Get mft mirror inode. */</span>
	<span class="n">tmp_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_MFTMirr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">);</span>
		<span class="cm">/* Caller will display error message. */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Re-initialize some specifics about $MFTMirr&#39;s inode as</span>
<span class="cm">	 * ntfs_read_inode() will have set up the default ones.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Set uid and gid to root. */</span>
	<span class="n">tmp_ino</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">tmp_ino</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Regular file.  No access for anyone. */</span>
	<span class="n">tmp_ino</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFREG</span><span class="p">;</span>
	<span class="cm">/* No VFS initiated operations allowed for $MFTMirr. */</span>
	<span class="n">tmp_ino</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ntfs_empty_inode_ops</span><span class="p">;</span>
	<span class="n">tmp_ino</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ntfs_empty_file_ops</span><span class="p">;</span>
	<span class="cm">/* Put in our special address space operations. */</span>
	<span class="n">tmp_ino</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ntfs_mst_aops</span><span class="p">;</span>
	<span class="n">tmp_ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">);</span>
	<span class="cm">/* The $MFTMirr, like the $MFT is multi sector transfer protected. */</span>
	<span class="n">NInoSetMstProtected</span><span class="p">(</span><span class="n">tmp_ni</span><span class="p">);</span>
	<span class="n">NInoSetSparseDisabled</span><span class="p">(</span><span class="n">tmp_ni</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up our little cheat allowing us to reuse the async read io</span>
<span class="cm">	 * completion handler for directories.</span>
<span class="cm">	 */</span>
	<span class="n">tmp_ni</span><span class="o">-&gt;</span><span class="n">itype</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">;</span>
	<span class="n">tmp_ni</span><span class="o">-&gt;</span><span class="n">itype</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">block_size_bits</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_bits</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span> <span class="o">=</span> <span class="n">tmp_ino</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_mft_mirror - compare contents of the mft mirror with the mft</span>
<span class="cm"> * @vol:	ntfs super block describing device whose mft mirror to check</span>
<span class="cm"> *</span>
<span class="cm"> * Return &#39;true&#39; on success or &#39;false&#39; on error.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, this function also results in the mft mirror runlist being completely</span>
<span class="cm"> * mapped into memory.  The mft mirror write code requires this and will BUG()</span>
<span class="cm"> * should it find an unmapped runlist element.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">check_mft_mirror</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">mirr_ni</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">mft_page</span><span class="p">,</span> <span class="o">*</span><span class="n">mirr_page</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">kmft</span><span class="p">,</span> <span class="o">*</span><span class="n">kmirr</span><span class="p">;</span>
	<span class="n">runlist_element</span> <span class="o">*</span><span class="n">rl</span><span class="p">,</span> <span class="n">rl2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mrecs_per_page</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/* Compare contents of $MFT and $MFTMirr. */</span>
	<span class="n">mrecs_per_page</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">/</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mrecs_per_page</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_size</span><span class="p">);</span>
	<span class="n">mft_page</span> <span class="o">=</span> <span class="n">mirr_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kmft</span> <span class="o">=</span> <span class="n">kmirr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">bytes</span><span class="p">;</span>

		<span class="cm">/* Switch pages if necessary. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">mrecs_per_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">mft_page</span><span class="p">);</span>
				<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">mirr_page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Get the $MFT page. */</span>
			<span class="n">mft_page</span> <span class="o">=</span> <span class="n">ntfs_map_page</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
					<span class="n">index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mft_page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to read $MFT.&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kmft</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">mft_page</span><span class="p">);</span>
			<span class="cm">/* Get the $MFTMirr page. */</span>
			<span class="n">mirr_page</span> <span class="o">=</span> <span class="n">ntfs_map_page</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
					<span class="n">index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mirr_page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to read $MFTMirr.&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">mft_unmap_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kmirr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">mirr_page</span><span class="p">);</span>
			<span class="o">++</span><span class="n">index</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Do not check the record if it is not in use. */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">MFT_RECORD</span><span class="o">*</span><span class="p">)</span><span class="n">kmft</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MFT_RECORD_IN_USE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Make sure the record is ok. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_is_baad_recordp</span><span class="p">((</span><span class="n">le32</span><span class="o">*</span><span class="p">)</span><span class="n">kmft</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Incomplete multi sector &quot;</span>
						<span class="s">&quot;transfer detected in mft &quot;</span>
						<span class="s">&quot;record %i.&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="nl">mm_unmap_out:</span>
				<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">mirr_page</span><span class="p">);</span>
<span class="nl">mft_unmap_out:</span>
				<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">mft_page</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Do not check the mirror record if it is not in use. */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">MFT_RECORD</span><span class="o">*</span><span class="p">)</span><span class="n">kmirr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MFT_RECORD_IN_USE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_is_baad_recordp</span><span class="p">((</span><span class="n">le32</span><span class="o">*</span><span class="p">)</span><span class="n">kmirr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Incomplete multi sector &quot;</span>
						<span class="s">&quot;transfer detected in mft &quot;</span>
						<span class="s">&quot;mirror record %i.&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">mm_unmap_out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Get the amount of data in the current record. */</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">MFT_RECORD</span><span class="o">*</span><span class="p">)</span><span class="n">kmft</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bytes_in_use</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MFT_RECORD_OLD</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span> <span class="o">||</span>
				<span class="n">ntfs_is_baad_recordp</span><span class="p">((</span><span class="n">le32</span><span class="o">*</span><span class="p">)</span><span class="n">kmft</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(((</span><span class="n">MFT_RECORD</span><span class="o">*</span><span class="p">)</span><span class="n">kmirr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bytes_in_use</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MFT_RECORD_OLD</span><span class="p">)</span> <span class="o">||</span>
					<span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span> <span class="o">||</span>
					<span class="n">ntfs_is_baad_recordp</span><span class="p">((</span><span class="n">le32</span><span class="o">*</span><span class="p">)</span><span class="n">kmirr</span><span class="p">))</span>
				<span class="n">bytes</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Compare the two records. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">kmft</span><span class="p">,</span> <span class="n">kmirr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;$MFT and $MFTMirr (record %i) do not &quot;</span>
					<span class="s">&quot;match.  Run ntfsfix or chkdsk.&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">mm_unmap_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kmft</span> <span class="o">+=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">;</span>
		<span class="n">kmirr</span> <span class="o">+=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_size</span><span class="p">);</span>
	<span class="cm">/* Release the last pages. */</span>
	<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">mft_page</span><span class="p">);</span>
	<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">mirr_page</span><span class="p">);</span>

	<span class="cm">/* Construct the mft mirror runlist by hand. */</span>
	<span class="n">rl2</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vcn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rl2</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lcn</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_lcn</span><span class="p">;</span>
	<span class="n">rl2</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_size</span> <span class="o">*</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size</span> <span class="o">+</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span><span class="p">;</span>
	<span class="n">rl2</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">vcn</span> <span class="o">=</span> <span class="n">rl2</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
	<span class="n">rl2</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lcn</span> <span class="o">=</span> <span class="n">LCN_ENOENT</span><span class="p">;</span>
	<span class="n">rl2</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Because we have just read all of the mft mirror, we know we have</span>
<span class="cm">	 * mapped the full runlist for it.</span>
<span class="cm">	 */</span>
	<span class="n">mirr_ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">);</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mirr_ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rl</span> <span class="o">=</span> <span class="n">mirr_ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">rl</span><span class="p">;</span>
	<span class="cm">/* Compare the two runlists.  They must be identical. */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rl2</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vcn</span> <span class="o">!=</span> <span class="n">rl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vcn</span> <span class="o">||</span> <span class="n">rl2</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lcn</span> <span class="o">!=</span> <span class="n">rl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lcn</span> <span class="o">||</span>
				<span class="n">rl2</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">!=</span> <span class="n">rl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;$MFTMirr location mismatch.  &quot;</span>
					<span class="s">&quot;Run chkdsk.&quot;</span><span class="p">);</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mirr_ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rl2</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mirr_ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * load_and_check_logfile - load and check the logfile inode for a volume</span>
<span class="cm"> * @vol:	ntfs super block describing device whose logfile to load</span>
<span class="cm"> *</span>
<span class="cm"> * Return &#39;true&#39; on success or &#39;false&#39; on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">load_and_check_logfile</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		<span class="n">RESTART_PAGE_HEADER</span> <span class="o">**</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">tmp_ino</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="n">tmp_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_LogFile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">);</span>
		<span class="cm">/* Caller will display error message. */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_check_logfile</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">,</span> <span class="n">rp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">);</span>
		<span class="cm">/* ntfs_check_logfile() will have displayed error output. */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">NInoSetSparseDisabled</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">));</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span> <span class="o">=</span> <span class="n">tmp_ino</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define NTFS_HIBERFIL_HEADER_SIZE	4096</span>

<span class="cm">/**</span>
<span class="cm"> * check_windows_hibernation_status - check if Windows is suspended on a volume</span>
<span class="cm"> * @vol:	ntfs super block of device to check</span>
<span class="cm"> *</span>
<span class="cm"> * Check if Windows is hibernated on the ntfs volume @vol.  This is done by</span>
<span class="cm"> * looking for the file hiberfil.sys in the root directory of the volume.  If</span>
<span class="cm"> * the file is not present Windows is definitely not suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * If hiberfil.sys exists and is less than 4kiB in size it means Windows is</span>
<span class="cm"> * definitely suspended (this volume is not the system volume).  Caveat:  on a</span>
<span class="cm"> * system with many volumes it is possible that the &lt; 4kiB check is bogus but</span>
<span class="cm"> * for now this should do fine.</span>
<span class="cm"> *</span>
<span class="cm"> * If hiberfil.sys exists and is larger than 4kiB in size, we need to read the</span>
<span class="cm"> * hiberfil header (which is the first 4kiB).  If this begins with &quot;hibr&quot;,</span>
<span class="cm"> * Windows is definitely suspended.  If it is completely full of zeroes,</span>
<span class="cm"> * Windows is definitely not hibernated.  Any other case is treated as if</span>
<span class="cm"> * Windows is suspended.  This caters for the above mentioned caveat of a</span>
<span class="cm"> * system with many volumes where no &quot;hibr&quot; magic would be present and there is</span>
<span class="cm"> * no zero header.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if Windows is not hibernated on the volume, &gt;0 if Windows is</span>
<span class="cm"> * hibernated on the volume, and -errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_windows_hibernation_status</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MFT_REF</span> <span class="n">mref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">,</span> <span class="o">*</span><span class="n">kend</span><span class="p">;</span>
	<span class="n">ntfs_name</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">ntfschar</span> <span class="n">hiberfil</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;h&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;i&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;b&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;e&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;r&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;f&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;i&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;l&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;s&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;y&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;s&#39;</span><span class="p">),</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the inode number for the hibernation file by looking up the</span>
<span class="cm">	 * filename hiberfil.sys in the root directory.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">mref</span> <span class="o">=</span> <span class="n">ntfs_lookup_inode_by_name</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">),</span> <span class="n">hiberfil</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_MREF</span><span class="p">(</span><span class="n">mref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MREF_ERR</span><span class="p">(</span><span class="n">mref</span><span class="p">);</span>
		<span class="cm">/* If the file does not exist, Windows is not hibernated. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;hiberfil.sys not present.  Windows is not &quot;</span>
					<span class="s">&quot;hibernated on the volume.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* A real error occurred. */</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to find inode number for &quot;</span>
				<span class="s">&quot;hiberfil.sys.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We do not care for the type of match that was found. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="cm">/* Get the inode. */</span>
	<span class="n">vi</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">MREF</span><span class="p">(</span><span class="n">mref</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">vi</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vi</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load hiberfil.sys.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NTFS_HIBERFIL_HEADER_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;hiberfil.sys is smaller than 4kiB (0x%llx).  &quot;</span>
				<span class="s">&quot;Windows is hibernated on the volume.  This &quot;</span>
				<span class="s">&quot;is not the system volume.&quot;</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">iput_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">ntfs_map_page</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to read from hiberfil.sys.&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iput_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">le32</span><span class="o">*</span><span class="p">)</span><span class="n">kaddr</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x72626968</span><span class="p">)</span><span class="cm">/*&#39;hibr&#39;*/</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Magic </span><span class="se">\&quot;</span><span class="s">hibr</span><span class="se">\&quot;</span><span class="s"> found in hiberfil.sys.  Windows is &quot;</span>
				<span class="s">&quot;hibernated on the volume.  This is the &quot;</span>
				<span class="s">&quot;system volume.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unm_iput_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kend</span> <span class="o">=</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">NTFS_HIBERFIL_HEADER_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">kaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;hiberfil.sys is larger than 4kiB &quot;</span>
					<span class="s">&quot;(0x%llx), does not contain the &quot;</span>
					<span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">hibr</span><span class="se">\&quot;</span><span class="s"> magic, and does not have a &quot;</span>
					<span class="s">&quot;zero header.  Windows is hibernated &quot;</span>
					<span class="s">&quot;on the volume.  This is not the &quot;</span>
					<span class="s">&quot;system volume.&quot;</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vi</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">unm_iput_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">kaddr</span> <span class="o">&lt;</span> <span class="n">kend</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;hiberfil.sys contains a zero header.  Windows is not &quot;</span>
			<span class="s">&quot;hibernated on the volume.  This is the system &quot;</span>
			<span class="s">&quot;volume.&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unm_iput_out:</span>
	<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">iput_out:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * load_and_init_quota - load and setup the quota file for a volume if present</span>
<span class="cm"> * @vol:	ntfs super block describing device whose quota file to load</span>
<span class="cm"> *</span>
<span class="cm"> * Return &#39;true&#39; on success or &#39;false&#39; on error.  If $Quota is not present, we</span>
<span class="cm"> * leave vol-&gt;quota_ino as NULL and return success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">load_and_init_quota</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MFT_REF</span> <span class="n">mref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">tmp_ino</span><span class="p">;</span>
	<span class="n">ntfs_name</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">ntfschar</span> <span class="n">Quota</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;Q&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;u&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;o&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;t&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">),</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">static</span> <span class="n">ntfschar</span> <span class="n">Q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;Q&#39;</span><span class="p">),</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the inode number for the quota file by looking up the filename</span>
<span class="cm">	 * $Quota in the extended system files directory $Extend.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">mref</span> <span class="o">=</span> <span class="n">ntfs_lookup_inode_by_name</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">),</span> <span class="n">Quota</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_MREF</span><span class="p">(</span><span class="n">mref</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the file does not exist, quotas are disabled and have</span>
<span class="cm">		 * never been enabled on this volume, just return success.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MREF_ERR</span><span class="p">(</span><span class="n">mref</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;$Quota not present.  Volume does not have &quot;</span>
					<span class="s">&quot;quotas enabled.&quot;</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * No need to try to set quotas out of date if they are</span>
<span class="cm">			 * not enabled.</span>
<span class="cm">			 */</span>
			<span class="n">NVolSetQuotaOutOfDate</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* A real error occurred. */</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to find inode number for $Quota.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We do not care for the type of match that was found. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="cm">/* Get the inode. */</span>
	<span class="n">tmp_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">MREF</span><span class="p">(</span><span class="n">mref</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">);</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $Quota.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span> <span class="o">=</span> <span class="n">tmp_ino</span><span class="p">;</span>
	<span class="cm">/* Get the $Q index allocation attribute. */</span>
	<span class="n">tmp_ino</span> <span class="o">=</span> <span class="n">ntfs_index_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $Quota/$Q index.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span> <span class="o">=</span> <span class="n">tmp_ino</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * load_and_init_usnjrnl - load and setup the transaction log if present</span>
<span class="cm"> * @vol:	ntfs super block describing device whose usnjrnl file to load</span>
<span class="cm"> *</span>
<span class="cm"> * Return &#39;true&#39; on success or &#39;false&#39; on error.</span>
<span class="cm"> *</span>
<span class="cm"> * If $UsnJrnl is not present or in the process of being disabled, we set</span>
<span class="cm"> * NVolUsnJrnlStamped() and return success.</span>
<span class="cm"> *</span>
<span class="cm"> * If the $UsnJrnl $DATA/$J attribute has a size equal to the lowest valid usn,</span>
<span class="cm"> * i.e. transaction logging has only just been enabled or the journal has been</span>
<span class="cm"> * stamped and nothing has been logged since, we also set NVolUsnJrnlStamped()</span>
<span class="cm"> * and return success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">load_and_init_usnjrnl</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MFT_REF</span> <span class="n">mref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">tmp_ino</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">tmp_ni</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">ntfs_name</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">USN_HEADER</span> <span class="o">*</span><span class="n">uh</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">ntfschar</span> <span class="n">UsnJrnl</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;U&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;s&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;n&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;J&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;r&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;n&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;l&#39;</span><span class="p">),</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">static</span> <span class="n">ntfschar</span> <span class="n">Max</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">),</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;x&#39;</span><span class="p">),</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">static</span> <span class="n">ntfschar</span> <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">),</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="sc">&#39;J&#39;</span><span class="p">),</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the inode number for the transaction log file by looking up the</span>
<span class="cm">	 * filename $UsnJrnl in the extended system files directory $Extend.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">mref</span> <span class="o">=</span> <span class="n">ntfs_lookup_inode_by_name</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">),</span> <span class="n">UsnJrnl</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_MREF</span><span class="p">(</span><span class="n">mref</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the file does not exist, transaction logging is disabled,</span>
<span class="cm">		 * just return success.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MREF_ERR</span><span class="p">(</span><span class="n">mref</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;$UsnJrnl not present.  Volume does not &quot;</span>
					<span class="s">&quot;have transaction logging enabled.&quot;</span><span class="p">);</span>
<span class="nl">not_enabled:</span>
			<span class="cm">/*</span>
<span class="cm">			 * No need to try to stamp the transaction log if</span>
<span class="cm">			 * transaction logging is not enabled.</span>
<span class="cm">			 */</span>
			<span class="n">NVolSetUsnJrnlStamped</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* A real error occurred. */</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to find inode number for &quot;</span>
				<span class="s">&quot;$UsnJrnl.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We do not care for the type of match that was found. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="cm">/* Get the inode. */</span>
	<span class="n">tmp_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">MREF</span><span class="p">(</span><span class="n">mref</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">);</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $UsnJrnl.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span> <span class="o">=</span> <span class="n">tmp_ino</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the transaction log is in the process of being deleted, we can</span>
<span class="cm">	 * ignore it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">&amp;</span> <span class="n">VOLUME_DELETE_USN_UNDERWAY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;$UsnJrnl in the process of being disabled.  &quot;</span>
				<span class="s">&quot;Volume does not have transaction logging &quot;</span>
				<span class="s">&quot;enabled.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">not_enabled</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Get the $DATA/$Max attribute. */</span>
	<span class="n">tmp_ino</span> <span class="o">=</span> <span class="n">ntfs_attr_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">,</span> <span class="n">AT_DATA</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $UsnJrnl/$DATA/$Max &quot;</span>
				<span class="s">&quot;attribute.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span> <span class="o">=</span> <span class="n">tmp_ino</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">USN_HEADER</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Found corrupt $UsnJrnl/$DATA/$Max &quot;</span>
				<span class="s">&quot;attribute (size is 0x%llx but should be at &quot;</span>
				<span class="s">&quot;least 0x%zx bytes).&quot;</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">),</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">USN_HEADER</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Get the $DATA/$J attribute. */</span>
	<span class="n">tmp_ino</span> <span class="o">=</span> <span class="n">ntfs_attr_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">,</span> <span class="n">AT_DATA</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $UsnJrnl/$DATA/$J &quot;</span>
				<span class="s">&quot;attribute.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span> <span class="o">=</span> <span class="n">tmp_ino</span><span class="p">;</span>
	<span class="cm">/* Verify $J is non-resident and sparse. */</span>
	<span class="n">tmp_ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">NInoNonResident</span><span class="p">(</span><span class="n">tmp_ni</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">NInoSparse</span><span class="p">(</span><span class="n">tmp_ni</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;$UsnJrnl/$DATA/$J attribute is resident &quot;</span>
				<span class="s">&quot;and/or not sparse.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Read the USN_HEADER from $DATA/$Max. */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">ntfs_map_page</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to read from $UsnJrnl/$DATA/$Max &quot;</span>
				<span class="s">&quot;attribute.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">uh</span> <span class="o">=</span> <span class="p">(</span><span class="n">USN_HEADER</span><span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/* Sanity check the $Max. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">allocation_delta</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">maximum_size</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Allocation delta (0x%llx) exceeds &quot;</span>
				<span class="s">&quot;maximum size (0x%llx).  $UsnJrnl is corrupt.&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">allocation_delta</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">maximum_size</span><span class="p">));</span>
		<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the transaction log has been stamped and nothing has been written</span>
<span class="cm">	 * to it since, we do not need to stamp it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">lowest_valid_usn</span><span class="p">)</span> <span class="o">&gt;=</span>
			<span class="n">i_size_read</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">lowest_valid_usn</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">i_size_read</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;$UsnJrnl is enabled but nothing has been &quot;</span>
					<span class="s">&quot;logged since it was last stamped.  &quot;</span>
					<span class="s">&quot;Treating this as if the volume does &quot;</span>
					<span class="s">&quot;not have transaction logging &quot;</span>
					<span class="s">&quot;enabled.&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">not_enabled</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;$UsnJrnl has lowest valid usn (0x%llx) &quot;</span>
				<span class="s">&quot;which is out of bounds (0x%llx).  $UsnJrnl &quot;</span>
				<span class="s">&quot;is corrupt.&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sle64_to_cpu</span><span class="p">(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">lowest_valid_usn</span><span class="p">),</span>
				<span class="n">i_size_read</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">));</span>
		<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * load_and_init_attrdef - load the attribute definitions table for a volume</span>
<span class="cm"> * @vol:	ntfs super block describing device whose attrdef to load</span>
<span class="cm"> *</span>
<span class="cm"> * Return &#39;true&#39; on success or &#39;false&#39; on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">load_and_init_attrdef</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">max_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/* Read attrdef table and setup vol-&gt;attrdef and vol-&gt;attrdef_size. */</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_AttrDef</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">NInoSetSparseDisabled</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">));</span>
	<span class="cm">/* The size of FILE_AttrDef must be above 0 and fit inside 31 bits. */</span>
	<span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i_size</span> <span class="o">&gt;</span> <span class="mh">0x7fffffff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">iput_failed</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span> <span class="o">=</span> <span class="p">(</span><span class="n">ATTR_DEF</span><span class="o">*</span><span class="p">)</span><span class="n">ntfs_malloc_nofs</span><span class="p">(</span><span class="n">i_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">iput_failed</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">max_index</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">max_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the attrdef table and copy it into the linear buffer. */</span>
<span class="nl">read_partial_attrdef_page:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">ntfs_map_page</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_iput_failed</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">),</span>
				<span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">};</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">read_partial_attrdef_page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef_size</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Read %llu bytes from $AttrDef.&quot;</span><span class="p">,</span> <span class="n">i_size</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="nl">free_iput_failed:</span>
	<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">iput_failed:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
<span class="nl">failed:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to initialize attribute definition table.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * load_and_init_upcase - load the upcase table for an ntfs volume</span>
<span class="cm"> * @vol:	ntfs super block describing device whose upcase to load</span>
<span class="cm"> *</span>
<span class="cm"> * Return &#39;true&#39; on success or &#39;false&#39; on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">load_and_init_upcase</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">max_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/* Read upcase table and setup vol-&gt;upcase and vol-&gt;upcase_len. */</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_UpCase</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">upcase_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * The upcase size must not be above 64k Unicode characters, must not</span>
<span class="cm">	 * be zero and must be a multiple of sizeof(ntfschar).</span>
<span class="cm">	 */</span>
	<span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_size</span> <span class="o">||</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ntfschar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">i_size</span> <span class="o">&gt;</span> <span class="mi">64ULL</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ntfschar</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">iput_upcase_failed</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntfschar</span><span class="o">*</span><span class="p">)</span><span class="n">ntfs_malloc_nofs</span><span class="p">(</span><span class="n">i_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">iput_upcase_failed</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">max_index</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">max_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the upcase table and copy it into the linear buffer. */</span>
<span class="nl">read_partial_upcase_page:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">ntfs_map_page</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">iput_upcase_failed</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">),</span>
				<span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">ntfs_unmap_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">};</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">read_partial_upcase_page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase_len</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">UCHAR_T_SIZE_BITS</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Read %llu bytes from $UpCase (expected %zu bytes).&quot;</span><span class="p">,</span>
			<span class="n">i_size</span><span class="p">,</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ntfschar</span><span class="p">));</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">default_upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Using volume specified $UpCase since default is &quot;</span>
				<span class="s">&quot;not present.&quot;</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">default_upcase_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase_len</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase_len</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">default_upcase</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="n">default_upcase</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase_len</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
		<span class="n">ntfs_nr_upcase_users</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Volume specified $UpCase matches default. Using &quot;</span>
				<span class="s">&quot;default.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Using volume specified $UpCase since it does not match &quot;</span>
			<span class="s">&quot;the default.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="nl">iput_upcase_failed:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">upcase_failed:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">default_upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="n">default_upcase</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase_len</span> <span class="o">=</span> <span class="n">default_upcase_len</span><span class="p">;</span>
		<span class="n">ntfs_nr_upcase_users</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $UpCase from the volume. Using &quot;</span>
				<span class="s">&quot;default.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to initialize upcase table.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The lcn and mft bitmap inodes are NTFS-internal inodes with</span>
<span class="cm"> * their own special locking rules:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span>
	<span class="n">lcnbmp_runlist_lock_key</span><span class="p">,</span> <span class="n">lcnbmp_mrec_lock_key</span><span class="p">,</span>
	<span class="n">mftbmp_runlist_lock_key</span><span class="p">,</span> <span class="n">mftbmp_mrec_lock_key</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * load_system_files - open the system files using normal functions</span>
<span class="cm"> * @vol:	ntfs super block describing device whose system files to load</span>
<span class="cm"> *</span>
<span class="cm"> * Open the system files with normal access functions and complete setting up</span>
<span class="cm"> * the ntfs super block @vol.</span>
<span class="cm"> *</span>
<span class="cm"> * Return &#39;true&#39; on success or &#39;false&#39; on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">load_system_files</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">MFT_RECORD</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">VOLUME_INFORMATION</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
	<span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="n">RESTART_PAGE_HEADER</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/* Get mft mirror inode compare the contents of $MFT and $MFTMirr. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_and_init_mft_mirror</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">check_mft_mirror</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span> <span class="o">=</span> <span class="s">&quot;Failed to load $MFTMirr&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;$MFTMirr does not match $MFT&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es3</span> <span class="o">=</span> <span class="s">&quot;.  Run ntfsfix and/or chkdsk.&quot;</span><span class="p">;</span>

		<span class="cm">/* If a read-write mount, convert it to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
					<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=&quot;</span>
						<span class="s">&quot;continue nor on_errors=&quot;</span>
						<span class="s">&quot;remount-ro was specified%s&quot;</span><span class="p">,</span>
						<span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span> <span class="o">?</span> <span class="n">es1</span> <span class="o">:</span> <span class="n">es2</span><span class="p">,</span>
						<span class="n">es3</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">iput_mirr_err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span>
					<span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span> <span class="o">?</span> <span class="n">es1</span> <span class="o">:</span> <span class="n">es2</span><span class="p">,</span> <span class="n">es3</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Will not be able to remount &quot;</span>
					<span class="s">&quot;read-write%s&quot;</span><span class="p">,</span>
					<span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span> <span class="o">?</span> <span class="n">es1</span> <span class="o">:</span> <span class="n">es2</span><span class="p">,</span> <span class="n">es3</span><span class="p">);</span>
		<span class="cm">/* This will prevent a read-write remount. */</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="cm">/* Get mft bitmap attribute inode. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span> <span class="o">=</span> <span class="n">ntfs_attr_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">,</span> <span class="n">AT_BITMAP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $MFT/$BITMAP attribute.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iput_mirr_err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">mftbmp_runlist_lock_key</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mrec_lock</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">mftbmp_mrec_lock_key</span><span class="p">);</span>
	<span class="cm">/* Read upcase table and setup @vol-&gt;upcase and @vol-&gt;upcase_len. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_and_init_upcase</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">iput_mftbmp_err_out</span><span class="p">;</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read attribute definitions table and setup @vol-&gt;attrdef and</span>
<span class="cm">	 * @vol-&gt;attrdef_size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_and_init_attrdef</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">iput_upcase_err_out</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the cluster allocation bitmap inode and verify the size, no</span>
<span class="cm">	 * need for any locking at this stage as we are already running</span>
<span class="cm">	 * exclusively as we are mount in progress task.</span>
<span class="cm">	 */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_Bitmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bitmap_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">lcnbmp_runlist_lock_key</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mrec_lock</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">lcnbmp_mrec_lock_key</span><span class="p">);</span>

	<span class="n">NInoSetSparseDisabled</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">);</span>
<span class="nl">bitmap_failed:</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $Bitmap.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iput_attrdef_err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the volume inode and setup our cache of the volume flags and</span>
<span class="cm">	 * version.</span>
<span class="cm">	 */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_Volume</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">);</span>
<span class="nl">volume_failed:</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $Volume.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iput_lcnbmp_err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">iput_volume_failed:</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">volume_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">),</span> <span class="n">m</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to get attribute search context.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">get_ctx_vol_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">AT_VOLUME_INFORMATION</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">ctx</span><span class="p">)</span> <span class="o">||</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">non_resident</span> <span class="o">||</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">err_put_vol:</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="nl">get_ctx_vol_failed:</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">iput_volume_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">VOLUME_INFORMATION</span><span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">+</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_offset</span><span class="p">));</span>
	<span class="cm">/* Some bounds checks. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">vi</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">||</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">vi</span> <span class="o">+</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_length</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_put_vol</span><span class="p">;</span>
	<span class="cm">/* Copy the volume flags and version to the ntfs_volume structure. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">major_ver</span><span class="p">;</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">minor_ver</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">minor_ver</span><span class="p">;</span>
	<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NTFS volume version %i.%i.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span><span class="p">,</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">minor_ver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">NVolSparseEnabled</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Disabling sparse support due to NTFS &quot;</span>
				<span class="s">&quot;volume version %i.%i (need at least version &quot;</span>
				<span class="s">&quot;3.0).&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">minor_ver</span><span class="p">);</span>
		<span class="n">NVolClearSparseEnabled</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/* Make sure that no unsupported volume flags are set. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">&amp;</span> <span class="n">VOLUME_MUST_MOUNT_RO_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1a</span> <span class="o">=</span> <span class="s">&quot;Volume is dirty&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1b</span> <span class="o">=</span> <span class="s">&quot;Volume has been modified by chkdsk&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1c</span> <span class="o">=</span> <span class="s">&quot;Volume has unsupported flags set&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2a</span> <span class="o">=</span> <span class="s">&quot;.  Run chkdsk and mount in Windows.&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2b</span> <span class="o">=</span> <span class="s">&quot;.  Mount in Windows.&quot;</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span><span class="p">,</span> <span class="o">*</span><span class="n">es2</span><span class="p">;</span>

		<span class="n">es2</span> <span class="o">=</span> <span class="n">es2a</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">&amp;</span> <span class="n">VOLUME_IS_DIRTY</span><span class="p">)</span>
			<span class="n">es1</span> <span class="o">=</span> <span class="n">es1a</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span> <span class="o">&amp;</span> <span class="n">VOLUME_MODIFIED_BY_CHKDSK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">es1</span> <span class="o">=</span> <span class="n">es1b</span><span class="p">;</span>
			<span class="n">es2</span> <span class="o">=</span> <span class="n">es2b</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">es1</span> <span class="o">=</span> <span class="n">es1c</span><span class="p">;</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Unsupported volume flags 0x%x &quot;</span>
					<span class="s">&quot;encountered.&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_flags</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/* If a read-write mount, convert it to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
					<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=&quot;</span>
						<span class="s">&quot;continue nor on_errors=&quot;</span>
						<span class="s">&quot;remount-ro was specified%s&quot;</span><span class="p">,</span>
						<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">iput_vol_err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Will not be able to remount &quot;</span>
					<span class="s">&quot;read-write%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not set NVolErrors() because ntfs_remount() re-checks the</span>
<span class="cm">		 * flags which we need to do in case any flags have changed.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the inode for the logfile, check it and determine if the volume</span>
<span class="cm">	 * was shutdown cleanly.</span>
<span class="cm">	 */</span>
	<span class="n">rp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_and_check_logfile</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">ntfs_is_logfile_clean</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">,</span> <span class="n">rp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1a</span> <span class="o">=</span> <span class="s">&quot;Failed to load $LogFile&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1b</span> <span class="o">=</span> <span class="s">&quot;$LogFile is not clean&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;.  Mount in Windows.&quot;</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span><span class="p">;</span>

		<span class="n">es1</span> <span class="o">=</span> <span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span> <span class="o">?</span> <span class="n">es1a</span> <span class="o">:</span> <span class="n">es1b</span><span class="p">;</span>
		<span class="cm">/* If a read-write mount, convert it to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
					<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=&quot;</span>
						<span class="s">&quot;continue nor on_errors=&quot;</span>
						<span class="s">&quot;remount-ro was specified%s&quot;</span><span class="p">,</span>
						<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rp</span><span class="p">);</span>
					<span class="n">ntfs_free</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">iput_logfile_err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Will not be able to remount &quot;</span>
					<span class="s">&quot;read-write%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="cm">/* This will prevent a read-write remount. */</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ntfs_free</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="cm">/* Get the root directory inode so we can do path lookups. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">);</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load root directory.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iput_logfile_err_out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if Windows is suspended to disk on the target volume.  If it</span>
<span class="cm">	 * is hibernated, we must not write *anything* to the disk so set</span>
<span class="cm">	 * NVolErrors() without setting the dirty volume flag and mount</span>
<span class="cm">	 * read-only.  This will prevent read-write remounting and it will also</span>
<span class="cm">	 * prevent all writes.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">check_windows_hibernation_status</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1a</span> <span class="o">=</span> <span class="s">&quot;Failed to determine if Windows is &quot;</span>
				<span class="s">&quot;hibernated&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1b</span> <span class="o">=</span> <span class="s">&quot;Windows is hibernated&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;.  Run chkdsk.&quot;</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span><span class="p">;</span>

		<span class="n">es1</span> <span class="o">=</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">es1a</span> <span class="o">:</span> <span class="n">es1b</span><span class="p">;</span>
		<span class="cm">/* If a read-write mount, convert it to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
					<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=&quot;</span>
						<span class="s">&quot;continue nor on_errors=&quot;</span>
						<span class="s">&quot;remount-ro was specified%s&quot;</span><span class="p">,</span>
						<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">iput_root_err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Will not be able to remount &quot;</span>
					<span class="s">&quot;read-write%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="cm">/* This will prevent a read-write remount. */</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* If (still) a read-write mount, mark the volume dirty. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">ntfs_set_volume_flags</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">VOLUME_IS_DIRTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span> <span class="o">=</span> <span class="s">&quot;Failed to set dirty bit in volume &quot;</span>
				<span class="s">&quot;information flags&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;.  Run chkdsk.&quot;</span><span class="p">;</span>

		<span class="cm">/* Convert to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
				<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=continue nor &quot;</span>
					<span class="s">&quot;on_errors=remount-ro was specified%s&quot;</span><span class="p">,</span>
					<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">iput_root_err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not set NVolErrors() because ntfs_remount() might manage</span>
<span class="cm">		 * to set the dirty flag in which case all would be well.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
<span class="cp">#if 0</span><span class="c"></span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>TODO: Enable this code once we start modifying anything that is
 different between NTFS 1.2 and 3.x...</p></td><td class="code"><div class="highlight"><pre><span class="c">	/*</span>
<span class="c">	 * If (still) a read-write mount, set the NT4 compatibility flag on</span>
<span class="c">	 * newer NTFS version volumes.</span>
<span class="c">	 */</span>
<span class="c">	if (!(sb-&gt;s_flags &amp; MS_RDONLY) &amp;&amp; (vol-&gt;major_ver &gt; 1) &amp;&amp;</span>
<span class="c">			ntfs_set_volume_flags(vol, VOLUME_MOUNTED_ON_NT4)) {</span>
<span class="c">		static const char *es1 = &quot;Failed to set NT4 compatibility flag&quot;;</span>
<span class="c">		static const char *es2 = &quot;.  Run chkdsk.&quot;;</span>

<span class="c">		/* Convert to a read-only mount. */</span>
<span class="c">		if (!(vol-&gt;on_errors &amp; (ON_ERRORS_REMOUNT_RO |</span>
<span class="c">				ON_ERRORS_CONTINUE))) {</span>
<span class="c">			ntfs_error(sb, &quot;%s and neither on_errors=continue nor &quot;</span>
<span class="c">					&quot;on_errors=remount-ro was specified%s&quot;,</span>
<span class="c">					es1, es2);</span>
<span class="c">			goto iput_root_err_out;</span>
<span class="c">		}</span>
<span class="c">		ntfs_error(sb, &quot;%s.  Mounting read-only%s&quot;, es1, es2);</span>
<span class="c">		sb-&gt;s_flags |= MS_RDONLY;</span>
<span class="c">		NVolSetErrors(vol);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
	<span class="cm">/* If (still) a read-write mount, empty the logfile. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">ntfs_empty_logfile</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span> <span class="o">=</span> <span class="s">&quot;Failed to empty $LogFile&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;.  Mount in Windows.&quot;</span><span class="p">;</span>

		<span class="cm">/* Convert to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
				<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=continue nor &quot;</span>
					<span class="s">&quot;on_errors=remount-ro was specified%s&quot;</span><span class="p">,</span>
					<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">iput_root_err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="cm">/* If on NTFS versions before 3.0, we are done. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/* NTFS 3.0+ specific initialization. */</span>
	<span class="cm">/* Get the security descriptors inode. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_Secure</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">);</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $Secure.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iput_root_err_out</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>TODO: Initialize security.</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* Get the extended system files&#39; directory inode. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILE_Extend</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">))</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">);</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load $Extend.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iput_sec_err_out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/* Find the quota file, load it if present, and set it up. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_and_init_quota</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span> <span class="o">=</span> <span class="s">&quot;Failed to load $Quota&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;.  Run chkdsk.&quot;</span><span class="p">;</span>

		<span class="cm">/* If a read-write mount, convert it to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
					<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=&quot;</span>
						<span class="s">&quot;continue nor on_errors=&quot;</span>
						<span class="s">&quot;remount-ro was specified%s&quot;</span><span class="p">,</span>
						<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">iput_quota_err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Will not be able to remount &quot;</span>
					<span class="s">&quot;read-write%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="cm">/* This will prevent a read-write remount. */</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* If (still) a read-write mount, mark the quotas out of date. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">ntfs_mark_quotas_out_of_date</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span> <span class="o">=</span> <span class="s">&quot;Failed to mark quotas out of date&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;.  Run chkdsk.&quot;</span><span class="p">;</span>

		<span class="cm">/* Convert to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
				<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=continue nor &quot;</span>
					<span class="s">&quot;on_errors=remount-ro was specified%s&quot;</span><span class="p">,</span>
					<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">iput_quota_err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the transaction log file ($UsnJrnl), load it if present, check</span>
<span class="cm">	 * it, and set it up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_and_init_usnjrnl</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span> <span class="o">=</span> <span class="s">&quot;Failed to load $UsnJrnl&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;.  Run chkdsk.&quot;</span><span class="p">;</span>

		<span class="cm">/* If a read-write mount, convert it to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
					<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=&quot;</span>
						<span class="s">&quot;continue nor on_errors=&quot;</span>
						<span class="s">&quot;remount-ro was specified%s&quot;</span><span class="p">,</span>
						<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">iput_usnjrnl_err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Will not be able to remount &quot;</span>
					<span class="s">&quot;read-write%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="cm">/* This will prevent a read-write remount. */</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* If (still) a read-write mount, stamp the transaction log. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ntfs_stamp_usnjrnl</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es1</span> <span class="o">=</span> <span class="s">&quot;Failed to stamp transaction log &quot;</span>
				<span class="s">&quot;($UsnJrnl)&quot;</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">es2</span> <span class="o">=</span> <span class="s">&quot;.  Run chkdsk.&quot;</span><span class="p">;</span>

		<span class="cm">/* Convert to a read-only mount. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">on_errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ON_ERRORS_REMOUNT_RO</span> <span class="o">|</span>
				<span class="n">ON_ERRORS_CONTINUE</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s and neither on_errors=continue nor &quot;</span>
					<span class="s">&quot;on_errors=remount-ro was specified%s&quot;</span><span class="p">,</span>
					<span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">iput_usnjrnl_err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;%s.  Mounting read-only%s&quot;</span><span class="p">,</span> <span class="n">es1</span><span class="p">,</span> <span class="n">es2</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
		<span class="n">NVolSetErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#ifdef NTFS_RW</span>
<span class="nl">iput_usnjrnl_err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">);</span>
<span class="nl">iput_quota_err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
<span class="nl">iput_sec_err_out:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">);</span>
<span class="nl">iput_root_err_out:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">);</span>
<span class="nl">iput_logfile_err_out:</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">);</span>
<span class="nl">iput_vol_err_out:</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">);</span>
<span class="nl">iput_lcnbmp_err_out:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">);</span>
<span class="nl">iput_attrdef_err_out:</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef NTFS_RW</span>
<span class="nl">iput_upcase_err_out:</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">==</span> <span class="n">default_upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_nr_upcase_users</span><span class="o">--</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">iput_mftbmp_err_out:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span><span class="p">);</span>
<span class="nl">iput_mirr_err_out:</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_put_super - called by the vfs to unmount a volume</span>
<span class="cm"> * @sb:		vfs superblock of volume to unmount</span>
<span class="cm"> *</span>
<span class="cm"> * ntfs_put_super() is called by the VFS (from fs/super.c::do_umount()) when</span>
<span class="cm"> * the volume is being unmounted (umount system call has been invoked) and it</span>
<span class="cm"> * releases all inodes and memory belonging to the NTFS specific part of the</span>
<span class="cm"> * super block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ntfs_put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">NTFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>

<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/*</span>
<span class="cm">	 * Commit all inodes while they are still open in case some of them</span>
<span class="cm">	 * cause others to be dirtied.</span>
<span class="cm">	 */</span>
	<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">);</span>

	<span class="cm">/* NTFS 3.0+ specific. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">)</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="p">)</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">)</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span><span class="p">)</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">)</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">)</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">)</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>
	<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_lock</span><span class="p">);</span>
	<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">)</span>
		<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">)</span>
		<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">);</span>
	<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a read-write mount and no volume errors have occurred, mark the</span>
<span class="cm">	 * volume clean.  Also, re-commit all affected inodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NVolErrors</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_clear_volume_flags</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">VOLUME_IS_DIRTY</span><span class="p">))</span>
				<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to clear dirty bit &quot;</span>
						<span class="s">&quot;in volume information &quot;</span>
						<span class="s">&quot;flags.  Run chkdsk.&quot;</span><span class="p">);</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">);</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">)</span>
				<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">);</span>
			<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Volume has errors.  Leaving volume &quot;</span>
					<span class="s">&quot;marked dirty.  Run chkdsk.&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* NTFS 3.0+ specific clean up. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef NTFS_RW</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_lock</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_lock</span><span class="p">);</span>

<span class="cp">#ifdef NTFS_RW</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Re-commit the mft mirror and mft just in case. */</span>
		<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">);</span>
		<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We should have no dirty inodes left, due to</span>
<span class="cm">	 * mft.c::ntfs_mft_writepage() cleaning all the dirty pages as</span>
<span class="cm">	 * the underlying mft records are written out and cleaned.</span>
<span class="cm">	 */</span>
	<span class="n">ntfs_commit_inode</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">);</span>
	<span class="n">write_inode_now</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Throw away the table of attribute definitions. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Destroy the global default upcase table if necessary.  Also decrease</span>
<span class="cm">	 * the number of upcase users if we are a user.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">==</span> <span class="n">default_upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_nr_upcase_users</span><span class="o">--</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_nr_upcase_users</span> <span class="o">&amp;&amp;</span> <span class="n">default_upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">default_upcase</span><span class="p">);</span>
		<span class="n">default_upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;=</span> <span class="mi">4096</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">ntfs_nr_compression_users</span><span class="p">)</span>
		<span class="n">free_compression_buffers</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unload_nls</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span><span class="p">);</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_nr_free_clusters - return the number of free clusters on a volume</span>
<span class="cm"> * @vol:	ntfs volume for which to obtain free cluster count</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate the number of free clusters on the mounted NTFS volume @vol. We</span>
<span class="cm"> * actually calculate the number of clusters in use instead because this</span>
<span class="cm"> * allows us to not care about partial pages as these will be just zero filled</span>
<span class="cm"> * and hence not be counted as allocated clusters.</span>
<span class="cm"> *</span>
<span class="cm"> * The only particularity is that clusters beyond the end of the logical ntfs</span>
<span class="cm"> * volume will be marked as allocated to prevent errors which means we have to</span>
<span class="cm"> * discount those at the end. This is important as the cluster bitmap always</span>
<span class="cm"> * has a size in multiples of 8 bytes, i.e. up to 63 clusters could be outside</span>
<span class="cm"> * the logical volume and marked in use when they are not as they do not exist.</span>
<span class="cm"> *</span>
<span class="cm"> * If any pages cannot be read we assume all clusters in the erroring pages are</span>
<span class="cm"> * in use. This means we return an underestimate on errors which is better than</span>
<span class="cm"> * an overestimate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s64</span> <span class="nf">get_nr_free_clusters</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">nr_free</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">max_index</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/* Serialize accesses to the cluster bitmap. */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Convert the number of bits into bytes rounded up, then convert into</span>
<span class="cm">	 * multiples of PAGE_CACHE_SIZE, rounding up so that if we have one</span>
<span class="cm">	 * full and one partial page max_index = 2.</span>
<span class="cm">	 */</span>
	<span class="n">max_index</span> <span class="o">=</span> <span class="p">(((</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			<span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="cm">/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Reading $Bitmap, max_index = 0x%lx, max_size = 0x%lx.&quot;</span><span class="p">,</span>
			<span class="n">max_index</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">max_index</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read the page from page cache, getting it from backing store</span>
<span class="cm">		 * if necessary, and increment the use count.</span>
<span class="cm">		 */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">read_mapping_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Ignore pages which errored synchronously. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;read_mapping_page() error. Skipping &quot;</span>
					<span class="s">&quot;page (index 0x%lx).&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">nr_free</span> <span class="o">-=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Subtract the number of set bits. If this</span>
<span class="cm">		 * is the last page and it is partial we don&#39;t really care as</span>
<span class="cm">		 * it just means we do a little extra work but it won&#39;t affect</span>
<span class="cm">		 * the result as all out of range bytes are set to zero by</span>
<span class="cm">		 * ntfs_readpage().</span>
<span class="cm">		 */</span>
		<span class="n">nr_free</span> <span class="o">-=</span> <span class="n">bitmap_weight</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span>
					<span class="n">PAGE_CACHE_SIZE</span> <span class="o">*</span> <span class="n">BITS_PER_BYTE</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Finished reading $Bitmap, last index = 0x%lx.&quot;</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fixup for eventual bits outside logical ntfs volume (see function</span>
<span class="cm">	 * description above).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">)</span>
		<span class="n">nr_free</span> <span class="o">+=</span> <span class="mi">64</span> <span class="o">-</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>
	<span class="cm">/* If errors occurred we may well have gone below zero, fix this. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_free</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nr_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Exiting.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nr_free</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __get_nr_free_mft_records - return the number of free inodes on a volume</span>
<span class="cm"> * @vol:	ntfs volume for which to obtain free inode count</span>
<span class="cm"> * @nr_free:	number of mft records in filesystem</span>
<span class="cm"> * @max_index:	maximum number of pages containing set bits</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate the number of free mft records (inodes) on the mounted NTFS</span>
<span class="cm"> * volume @vol. We actually calculate the number of mft records in use instead</span>
<span class="cm"> * because this allows us to not care about partial pages as these will be just</span>
<span class="cm"> * zero filled and hence not be counted as allocated mft record.</span>
<span class="cm"> *</span>
<span class="cm"> * If any pages cannot be read we assume all mft records in the erroring pages</span>
<span class="cm"> * are in use. This means we return an underestimate on errors which is better</span>
<span class="cm"> * than an overestimate.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Caller must hold mftbmp_lock rw_semaphore for reading or writing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__get_nr_free_mft_records</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		<span class="n">s64</span> <span class="n">nr_free</span><span class="p">,</span> <span class="k">const</span> <span class="n">pgoff_t</span> <span class="n">max_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/* Use multiples of 4 bytes, thus max_size is PAGE_CACHE_SIZE / 4. */</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Reading $MFT/$BITMAP, max_index = 0x%lx, max_size = &quot;</span>
			<span class="s">&quot;0x%lx.&quot;</span><span class="p">,</span> <span class="n">max_index</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">max_index</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read the page from page cache, getting it from backing store</span>
<span class="cm">		 * if necessary, and increment the use count.</span>
<span class="cm">		 */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">read_mapping_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* Ignore pages which errored synchronously. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;read_mapping_page() error. Skipping &quot;</span>
					<span class="s">&quot;page (index 0x%lx).&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">nr_free</span> <span class="o">-=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Subtract the number of set bits. If this</span>
<span class="cm">		 * is the last page and it is partial we don&#39;t really care as</span>
<span class="cm">		 * it just means we do a little extra work but it won&#39;t affect</span>
<span class="cm">		 * the result as all out of range bytes are set to zero by</span>
<span class="cm">		 * ntfs_readpage().</span>
<span class="cm">		 */</span>
		<span class="n">nr_free</span> <span class="o">-=</span> <span class="n">bitmap_weight</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span>
					<span class="n">PAGE_CACHE_SIZE</span> <span class="o">*</span> <span class="n">BITS_PER_BYTE</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Finished reading $MFT/$BITMAP, last index = 0x%lx.&quot;</span><span class="p">,</span>
			<span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* If errors occurred we may well have gone below zero, fix this. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_free</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nr_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Exiting.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nr_free</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_statfs - return information about mounted NTFS volume</span>
<span class="cm"> * @dentry:	dentry from mounted volume</span>
<span class="cm"> * @sfs:	statfs structure in which to return the information</span>
<span class="cm"> *</span>
<span class="cm"> * Return information about the mounted NTFS volume @dentry in the statfs structure</span>
<span class="cm"> * pointed to by @sfs (this is initialized with zeros before ntfs_statfs is</span>
<span class="cm"> * called). We interpret the values to be correct of the moment in time at</span>
<span class="cm"> * which we are called. Most values are variable otherwise and this isn&#39;t just</span>
<span class="cm"> * the free values but the totals as well. For example we can increase the</span>
<span class="cm"> * total number of file nodes if we run out and we can keep doing this until</span>
<span class="cm"> * there is no more space on the volume left at all.</span>
<span class="cm"> *</span>
<span class="cm"> * Called from vfs_statfs which is used to handle the statfs, fstatfs, and</span>
<span class="cm"> * ustat system calls.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success or -errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="n">sfs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">NTFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">mft_ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">);</span>
	<span class="n">pgoff_t</span> <span class="n">max_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="cm">/* Type of filesystem. */</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_type</span>   <span class="o">=</span> <span class="n">NTFS_SB_MAGIC</span><span class="p">;</span>
	<span class="cm">/* Optimal transfer block size. */</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_bsize</span>  <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Total data blocks in filesystem in units of f_bsize and since</span>
<span class="cm">	 * inodes are also stored in data blocs ($MFT is a file) this is just</span>
<span class="cm">	 * the total clusters.</span>
<span class="cm">	 */</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_blocks</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_clusters</span> <span class="o">&lt;&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">&gt;&gt;</span>
				<span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="cm">/* Free data blocks in filesystem in units of f_bsize. */</span>
	<span class="n">size</span>	      <span class="o">=</span> <span class="n">get_nr_free_clusters</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">&gt;&gt;</span>
				<span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0LL</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
	<span class="cm">/* Free blocks avail to non-superuser, same as above on NTFS. */</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_bavail</span> <span class="o">=</span> <span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_bfree</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/* Serialize accesses to the inode bitmap. */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_lock</span><span class="p">);</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mft_ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_bits</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Convert the maximum number of set bits into bytes rounded up, then</span>
<span class="cm">	 * convert into multiples of PAGE_CACHE_SIZE, rounding up so that if we</span>
<span class="cm">	 * have one full and one partial page max_index = 2.</span>
<span class="cm">	 */</span>
	<span class="n">max_index</span> <span class="o">=</span> <span class="p">((((</span><span class="n">mft_ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span> <span class="o">&gt;&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_record_size_bits</span><span class="p">)</span>
			<span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mft_ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Number of inodes in filesystem (at this point in time). */</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_files</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/* Free inodes in fs (based on current total count). */</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_ffree</span> <span class="o">=</span> <span class="n">__get_nr_free_mft_records</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">max_index</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * File system id. This is extremely *nix flavour dependent and even</span>
<span class="cm">	 * within Linux itself all fs do their own thing. I interpret this to</span>
<span class="cm">	 * mean a unique id associated with the mounted fs and not the id</span>
<span class="cm">	 * associated with the filesystem driver, the latter is already given</span>
<span class="cm">	 * by the filesystem type in sfs-&gt;f_type. Thus we use the 64-bit</span>
<span class="cm">	 * volume serial number splitting it into two 32-bit parts. We enter</span>
<span class="cm">	 * the least significant 32-bits in f_fsid[0] and the most significant</span>
<span class="cm">	 * 32-bits in f_fsid[1].</span>
<span class="cm">	 */</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_fsid</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">serial_no</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_fsid</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">serial_no</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="cm">/* Maximum length of filenames. */</span>
	<span class="n">sfs</span><span class="o">-&gt;</span><span class="n">f_namelen</span>	   <span class="o">=</span> <span class="n">NTFS_MAX_NAME_LEN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef NTFS_RW</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ntfs_write_inode</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * The complete super operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">ntfs_sops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc_inode</span>	<span class="o">=</span> <span class="n">ntfs_alloc_big_inode</span><span class="p">,</span>	  <span class="cm">/* VFS: Allocate new inode. */</span>
	<span class="p">.</span><span class="n">destroy_inode</span>	<span class="o">=</span> <span class="n">ntfs_destroy_big_inode</span><span class="p">,</span> <span class="cm">/* VFS: Deallocate inode. */</span>
<span class="cp">#ifdef NTFS_RW</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>.dirty<em>inode    = NULL,         /* VFS: Called from
                   _</em>mark<em>inode</em>dirty(). */</p></td><td class="code"><div class="highlight"><pre>	<span class="p">.</span><span class="n">write_inode</span>	<span class="o">=</span> <span class="n">ntfs_write_inode</span><span class="p">,</span>	<span class="cm">/* VFS: Write dirty inode to</span>
<span class="cm">						   disk. */</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>.drop<em>inode    = NULL,         /* VFS: Called just after the
                   inode reference count has
                   been decreased to zero.
                   NOTE: The inode lock is
                   held. See fs/inode.c::
                   generic</em>drop<em>inode(). */
.delete</em>inode    = NULL,         /* VFS: Delete inode from disk.
                   Called when i<em>count becomes
                   0 and i</em>nlink is also 0. <em>/
.write_super    = NULL,         /</em> Flush dirty super block to
                   disk. <em>/
.sync_fs    = NULL,         /</em> ? <em>/
.write_super_lockfs    = NULL,     /</em> ? <em>/
.unlockfs    = NULL,         /</em> ? */</p></td><td class="code"><div class="highlight"><pre><span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="p">.</span><span class="n">put_super</span>	<span class="o">=</span> <span class="n">ntfs_put_super</span><span class="p">,</span>	<span class="cm">/* Syscall: umount. */</span>
	<span class="p">.</span><span class="n">statfs</span>		<span class="o">=</span> <span class="n">ntfs_statfs</span><span class="p">,</span>		<span class="cm">/* Syscall: statfs */</span>
	<span class="p">.</span><span class="n">remount_fs</span>	<span class="o">=</span> <span class="n">ntfs_remount</span><span class="p">,</span>		<span class="cm">/* Syscall: mount -o remount. */</span>
	<span class="p">.</span><span class="n">evict_inode</span>	<span class="o">=</span> <span class="n">ntfs_evict_big_inode</span><span class="p">,</span>	<span class="cm">/* VFS: Called when an inode is</span>
<span class="cm">						   removed from memory. */</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>.umount_begin    = NULL,         /* Forced umount. */</p></td><td class="code"><div class="highlight"><pre>	<span class="p">.</span><span class="n">show_options</span>	<span class="o">=</span> <span class="n">ntfs_show_options</span><span class="p">,</span>	<span class="cm">/* Show mount options in</span>
<span class="cm">						   proc. */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_fill_super - mount an ntfs filesystem</span>
<span class="cm"> * @sb:		super block of ntfs filesystem to mount</span>
<span class="cm"> * @opt:	string containing the mount options</span>
<span class="cm"> * @silent:	silence error output</span>
<span class="cm"> *</span>
<span class="cm"> * ntfs_fill_super() is called by the VFS to mount the device described by @sb</span>
<span class="cm"> * with the mount otions in @data with the NTFS filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> * If @silent is true, remain silent even if errors are detected. This is used</span>
<span class="cm"> * during bootup, when the kernel tries to mount the root filesystem with all</span>
<span class="cm"> * registered filesystems one after the other until one succeeds. This implies</span>
<span class="cm"> * that all filesystems except the correct one will quite correctly and</span>
<span class="cm"> * expectedly return an error, but nobody wants to see error messages when in</span>
<span class="cm"> * fact this is what is supposed to happen.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: @sb-&gt;s_flags contains the mount options flags.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">tmp_ino</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do a pretty difficult piece of bootstrap by reading the</span>
<span class="cm">	 * MFT (and other metadata) from disk into memory. We&#39;ll only</span>
<span class="cm">	 * release this metadata during umount, so the locking patterns</span>
<span class="cm">	 * observed during bootstrap do not count. So turn off the</span>
<span class="cm">	 * observation of locking patterns (strictly for this context</span>
<span class="cm">	 * only) while mounting NTFS. [The validator is still active</span>
<span class="cm">	 * otherwise, even for this context: it will for example record</span>
<span class="cm">	 * lock class registrations.]</span>
<span class="cm">	 */</span>
	<span class="n">lockdep_off</span><span class="p">();</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
<span class="cp">#ifndef NTFS_RW</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* ! NTFS_RW */</span><span class="cp"></span>
	<span class="cm">/* Allocate a new ntfs_volume and place it in sb-&gt;s_fs_info. */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ntfs_volume</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">vol</span> <span class="o">=</span> <span class="n">NTFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Allocation of NTFS volume structure &quot;</span>
					<span class="s">&quot;failed. Aborting mount...&quot;</span><span class="p">);</span>
		<span class="n">lockdep_on</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Initialize ntfs_volume structure. */</span>
	<span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntfs_volume</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">,</span>
		<span class="cm">/*</span>
<span class="cm">		 * Default is group and other don&#39;t have any access to files or</span>
<span class="cm">		 * directories while owner has full access. Further, files by</span>
<span class="cm">		 * default are not executable but directories are of course</span>
<span class="cm">		 * browseable.</span>
<span class="cm">		 */</span>
		<span class="p">.</span><span class="n">fmask</span> <span class="o">=</span> <span class="mo">0177</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dmask</span> <span class="o">=</span> <span class="mo">0077</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_lock</span><span class="p">);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>

	<span class="cm">/* By default, enable sparse support. */</span>
	<span class="n">NVolSetSparseEnabled</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>

	<span class="cm">/* Important to get the mount options dealt with now. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_options</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">opt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_out_now</span><span class="p">;</span>

	<span class="cm">/* We support sector sizes up to the PAGE_CACHE_SIZE. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdev_logical_block_size</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Device has unsupported sector size &quot;</span>
					<span class="s">&quot;(%i).  The maximum supported sector &quot;</span>
					<span class="s">&quot;size on this architecture is %lu &quot;</span>
					<span class="s">&quot;bytes.&quot;</span><span class="p">,</span>
					<span class="n">bdev_logical_block_size</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">),</span>
					<span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setup the device access block size to NTFS_BLOCK_SIZE or the hard</span>
<span class="cm">	 * sector size, whichever is bigger.</span>
<span class="cm">	 */</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">sb_min_blocksize</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">NTFS_BLOCK_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">&lt;</span> <span class="n">NTFS_BLOCK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Unable to set device block size.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blocksize</span> <span class="o">!=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Set device block size to %i bytes (block size bits %i).&quot;</span><span class="p">,</span>
			<span class="n">blocksize</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
	<span class="cm">/* Determine the size of the device in units of block_size bytes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Unable to determine device size.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_blocks</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="cm">/* Read the boot sector and return unlocked buffer head to it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">read_ntfs_boot_sector</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">silent</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Not an NTFS volume.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Extract the data from the boot sector and setup the ntfs volume</span>
<span class="cm">	 * using it.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">parse_ntfs_boot_sector</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="p">(</span><span class="n">NTFS_BOOT_SECTOR</span><span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Unsupported NTFS filesystem.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the boot sector indicates a sector size bigger than the current</span>
<span class="cm">	 * device block size, switch the device block size to the sector size.</span>
<span class="cm">	 * TODO: It may be possible to support this case even when the set</span>
<span class="cm">	 * below fails, we would just be breaking up the i/o for each sector</span>
<span class="cm">	 * into multiple blocks for i/o purposes but otherwise it should just</span>
<span class="cm">	 * work.  However it is safer to leave disabled until someone hits this</span>
<span class="cm">	 * error message and then we can get them to try it without the setting</span>
<span class="cm">	 * so we know for sure that it works.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">&gt;</span> <span class="n">blocksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blocksize</span> <span class="o">=</span> <span class="n">sb_set_blocksize</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">!=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Unable to set device block &quot;</span>
						<span class="s">&quot;size to sector size (%i).&quot;</span><span class="p">,</span>
						<span class="n">vol</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_now</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">blocksize</span> <span class="o">!=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">nr_blocks</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Changed device block size to %i bytes (block size &quot;</span>
				<span class="s">&quot;bits %i) to match volume sector size.&quot;</span><span class="p">,</span>
				<span class="n">blocksize</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Initialize the cluster and mft allocators. */</span>
	<span class="n">ntfs_setup_allocators</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="cm">/* Setup remaining fields in the super block. */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">NTFS_SB_MAGIC</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ntfs allows 63 bits for the file size, i.e. correct would be:</span>
<span class="cm">	 *	sb-&gt;s_maxbytes = ~0ULL &gt;&gt; 1;</span>
<span class="cm">	 * But the kernel uses a long as the page cache page index which on</span>
<span class="cm">	 * 32-bit architectures is only 32-bits. MAX_LFS_FILESIZE is kernel</span>
<span class="cm">	 * defined to the maximum the page cache page index can cope with</span>
<span class="cm">	 * without overflowing the index or to 2^63 - 1, whichever is smaller.</span>
<span class="cm">	 */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">=</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">;</span>
	<span class="cm">/* Ntfs measures time in 100ns intervals. */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now load the metadata required for the page cache and our address</span>
<span class="cm">	 * space operations to function. We do this by setting up a specialised</span>
<span class="cm">	 * read_inode method and then just calling the normal iget() to obtain</span>
<span class="cm">	 * the inode for $MFT which is sufficient to allow our normal inode</span>
<span class="cm">	 * operations and associated address space operations to function.</span>
<span class="cm">	 */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ntfs_sops</span><span class="p">;</span>
	<span class="n">tmp_ino</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load essential metadata.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tmp_ino</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">FILE_MFT</span><span class="p">;</span>
	<span class="n">insert_inode_hash</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntfs_read_inode_mount</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load essential metadata.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iput_tmp_ino_err_out_now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The current mount is a compression user if the cluster size is</span>
<span class="cm">	 * less than or equal 4kiB.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;=</span> <span class="mi">4096</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ntfs_nr_compression_users</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">allocate_compression_buffers</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Failed to allocate buffers &quot;</span>
					<span class="s">&quot;for compression engine.&quot;</span><span class="p">);</span>
			<span class="n">ntfs_nr_compression_users</span><span class="o">--</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">iput_tmp_ino_err_out_now</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Generate the global default upcase table if necessary.  Also</span>
<span class="cm">	 * temporarily increment the number of upcase users to avoid race</span>
<span class="cm">	 * conditions with concurrent (u)mounts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">default_upcase</span><span class="p">)</span>
		<span class="n">default_upcase</span> <span class="o">=</span> <span class="n">generate_default_upcase</span><span class="p">();</span>
	<span class="n">ntfs_nr_upcase_users</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * From now on, ignore @silent parameter. If we fail below this line,</span>
<span class="cm">	 * it will be due to a corrupt fs or a system error, so we report it.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Open the system files with normal access functions and complete</span>
<span class="cm">	 * setting up the ntfs super block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_system_files</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to load system files.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unl_upcase_iput_tmp_ino_err_out_now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We grab a reference, simulating an ntfs_iget(). */</span>
	<span class="n">ihold</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Exiting, status successful.&quot;</span><span class="p">);</span>
		<span class="cm">/* Release the default upcase if it has no users. */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">ntfs_nr_upcase_users</span> <span class="o">&amp;&amp;</span> <span class="n">default_upcase</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_free</span><span class="p">(</span><span class="n">default_upcase</span><span class="p">);</span>
			<span class="n">default_upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_export_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ntfs_export_ops</span><span class="p">;</span>
		<span class="n">lockdep_on</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to allocate root directory.&quot;</span><span class="p">);</span>
	<span class="cm">/* Clean up after the successful load_system_files() call from above. */</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>TODO: Use ntfs<em>put</em>super() instead of repeating all this code...
FIXME: Should mark the volume clean as the error is most likely
      -ENOMEM.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* NTFS 3.0+ specific clean up. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">major_ver</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef NTFS_RW</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_j_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_max_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">usnjrnl_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_q_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">quota_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">extend_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">secure_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">root_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftbmp_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">logfile_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mftmirr_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="cm">/* Throw away the table of attribute definitions. */</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">attrdef</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">==</span> <span class="n">default_upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_nr_upcase_users</span><span class="o">--</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unload_nls</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Error exit code path. */</span>
<span class="nl">unl_upcase_iput_tmp_ino_err_out_now:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Decrease the number of upcase users and destroy the global default</span>
<span class="cm">	 * upcase table if necessary.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">ntfs_nr_upcase_users</span> <span class="o">&amp;&amp;</span> <span class="n">default_upcase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_free</span><span class="p">(</span><span class="n">default_upcase</span><span class="p">);</span>
		<span class="n">default_upcase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&lt;=</span> <span class="mi">4096</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">ntfs_nr_compression_users</span><span class="p">)</span>
		<span class="n">free_compression_buffers</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_lock</span><span class="p">);</span>
<span class="nl">iput_tmp_ino_err_out_now:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">tmp_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span> <span class="o">&amp;&amp;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span> <span class="o">!=</span> <span class="n">tmp_ino</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">mft_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Errors at this stage are irrelevant. */</span>
<span class="nl">err_out_now:</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Failed, returning -EINVAL.&quot;</span><span class="p">);</span>
	<span class="n">lockdep_on</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a slab cache to optimize allocations and deallocations of Unicode</span>
<span class="cm"> * strings of the maximum length allowed by NTFS, which is NTFS_MAX_NAME_LEN</span>
<span class="cm"> * (255) Unicode characters + a terminating NULL Unicode character.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ntfs_name_cache</span><span class="p">;</span>

<span class="cm">/* Slab caches for efficient allocation/deallocation of inodes. */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ntfs_inode_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ntfs_big_inode_cache</span><span class="p">;</span>

<span class="cm">/* Init once constructor for the inode slab cache. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ntfs_big_inode_init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntfs_inode</span> <span class="o">*</span><span class="p">)</span><span class="n">foo</span><span class="p">;</span>

	<span class="n">inode_init_once</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ni</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Slab caches to optimize allocations and deallocations of attribute search</span>
<span class="cm"> * contexts and index contexts, respectively.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ntfs_attr_ctx_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ntfs_index_ctx_cache</span><span class="p">;</span>

<span class="cm">/* Driver wide mutex. */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ntfs_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ntfs_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mount_bdev</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ntfs_fill_super</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">ntfs_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;ntfs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>		<span class="o">=</span> <span class="n">ntfs_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>	<span class="o">=</span> <span class="n">kill_block_super</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fs_flags</span>	<span class="o">=</span> <span class="n">FS_REQUIRES_DEV</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Stable names for the slab caches. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ntfs_index_ctx_cache_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ntfs_index_ctx_cache&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ntfs_attr_ctx_cache_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ntfs_attr_ctx_cache&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ntfs_name_cache_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ntfs_name_cache&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ntfs_inode_cache_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ntfs_inode_cache&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ntfs_big_inode_cache_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;ntfs_big_inode_cache&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_ntfs_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This may be ugly but it results in pretty output so who cares. (-8 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NTFS driver &quot;</span> <span class="n">NTFS_VERSION</span> <span class="s">&quot; [Flags: R/&quot;</span>
<span class="cp">#ifdef NTFS_RW</span>
			<span class="s">&quot;W&quot;</span>
<span class="cp">#else</span>
			<span class="s">&quot;O&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef DEBUG</span>
			<span class="s">&quot; DEBUG&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef MODULE</span>
			<span class="s">&quot; MODULE&quot;</span>
<span class="cp">#endif</span>
			<span class="s">&quot;].</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Debug messages are enabled.&quot;</span><span class="p">);</span>

	<span class="n">ntfs_index_ctx_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">ntfs_index_ctx_cache_name</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ntfs_index_context</span><span class="p">),</span> <span class="mi">0</span> <span class="cm">/* offset */</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span> <span class="cm">/* ctor */</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_index_ctx_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NTFS: Failed to create %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ntfs_index_ctx_cache_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">ictx_err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfs_attr_ctx_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">ntfs_attr_ctx_cache_name</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ntfs_attr_search_ctx</span><span class="p">),</span> <span class="mi">0</span> <span class="cm">/* offset */</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span> <span class="cm">/* ctor */</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_attr_ctx_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NTFS: Failed to create %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ntfs_attr_ctx_cache_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">actx_err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ntfs_name_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">ntfs_name_cache_name</span><span class="p">,</span>
			<span class="p">(</span><span class="n">NTFS_MAX_NAME_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ntfschar</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_name_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NTFS: Failed to create %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ntfs_name_cache_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">name_err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ntfs_inode_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">ntfs_inode_cache_name</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ntfs_inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="o">|</span><span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_inode_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NTFS: Failed to create %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ntfs_inode_cache_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">inode_err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ntfs_big_inode_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">ntfs_big_inode_cache_name</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">big_ntfs_inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="o">|</span><span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span>
			<span class="n">ntfs_big_inode_init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_big_inode_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NTFS: Failed to create %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ntfs_big_inode_cache_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">big_inode_err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register the ntfs sysctls. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_sysctl</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NTFS: Failed to register NTFS sysctls!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">sysctl_err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;NTFS driver registered successfully.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Success! */</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NTFS: Failed to register NTFS filesystem driver!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Unregister the ntfs sysctls. */</span>
	<span class="n">ntfs_sysctl</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="nl">sysctl_err_out:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_big_inode_cache</span><span class="p">);</span>
<span class="nl">big_inode_err_out:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_inode_cache</span><span class="p">);</span>
<span class="nl">inode_err_out:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_name_cache</span><span class="p">);</span>
<span class="nl">name_err_out:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_attr_ctx_cache</span><span class="p">);</span>
<span class="nl">actx_err_out:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_index_ctx_cache</span><span class="p">);</span>
<span class="nl">ictx_err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NTFS: Aborting NTFS filesystem driver &quot;</span>
				<span class="s">&quot;registration...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">exit_ntfs_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Unregistering NTFS driver.&quot;</span><span class="p">);</span>

	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_fs_type</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_big_inode_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_inode_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_name_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_attr_ctx_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ntfs_index_ctx_cache</span><span class="p">);</span>
	<span class="cm">/* Unregister the ntfs sysctls. */</span>
	<span class="n">ntfs_sysctl</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Anton Altaparmakov &lt;anton@tuxera.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;NTFS 1.2/3.x driver - Copyright (c) 2001-2011 Anton Altaparmakov and Tuxera Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">NTFS_VERSION</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug_msgs</span><span class="p">,</span> <span class="n">bint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug_msgs</span><span class="p">,</span> <span class="s">&quot;Enable debug messages.&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_ntfs_fs</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_ntfs_fs</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
