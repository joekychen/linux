<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › layout.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>layout.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * layout.h - All NTFS associated on-disk structures. Part of the Linux-NTFS</span>
<span class="cm"> *	      project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2005 Anton Altaparmakov</span>
<span class="cm"> * Copyright (c) 2002 Richard Russon</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_NTFS_LAYOUT_H</span>
<span class="cp">#define _LINUX_NTFS_LAYOUT_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &quot;types.h&quot;</span>

<span class="cm">/* The NTFS oem_id &quot;NTFS    &quot; */</span>
<span class="cp">#define magicNTFS	cpu_to_le64(0x202020205346544eULL)</span>

<span class="cm">/*</span>
<span class="cm"> * Location of bootsector on partition:</span>
<span class="cm"> *	The standard NTFS_BOOT_SECTOR is on sector 0 of the partition.</span>
<span class="cm"> *	On NT4 and above there is one backup copy of the boot sector to</span>
<span class="cm"> *	be found on the last sector of the partition (not normally accessible</span>
<span class="cm"> *	from within Windows as the bootsector contained number of sectors</span>
<span class="cm"> *	value is one less than the actual value!).</span>
<span class="cm"> *	On versions of NT 3.51 and earlier, the backup copy was located at</span>
<span class="cm"> *	number of sectors/2 (integer divide), i.e. in the middle of the volume.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * BIOS parameter block (bpb) structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le16</span> <span class="n">bytes_per_sector</span><span class="p">;</span>		<span class="cm">/* Size of a sector in bytes. */</span>
	<span class="n">u8</span>  <span class="n">sectors_per_cluster</span><span class="p">;</span>	<span class="cm">/* Size of a cluster in sectors. */</span>
	<span class="n">le16</span> <span class="n">reserved_sectors</span><span class="p">;</span>		<span class="cm">/* zero */</span>
	<span class="n">u8</span>  <span class="n">fats</span><span class="p">;</span>			<span class="cm">/* zero */</span>
	<span class="n">le16</span> <span class="n">root_entries</span><span class="p">;</span>		<span class="cm">/* zero */</span>
	<span class="n">le16</span> <span class="n">sectors</span><span class="p">;</span>			<span class="cm">/* zero */</span>
	<span class="n">u8</span>  <span class="n">media_type</span><span class="p">;</span>			<span class="cm">/* 0xf8 = hard disk */</span>
	<span class="n">le16</span> <span class="n">sectors_per_fat</span><span class="p">;</span>		<span class="cm">/* zero */</span>
	<span class="n">le16</span> <span class="n">sectors_per_track</span><span class="p">;</span>		<span class="cm">/* irrelevant */</span>
	<span class="n">le16</span> <span class="n">heads</span><span class="p">;</span>			<span class="cm">/* irrelevant */</span>
	<span class="n">le32</span> <span class="n">hidden_sectors</span><span class="p">;</span>		<span class="cm">/* zero */</span>
	<span class="n">le32</span> <span class="n">large_sectors</span><span class="p">;</span>		<span class="cm">/* zero */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">BIOS_PARAMETER_BLOCK</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * NTFS boot sector structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u8</span>  <span class="n">jump</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="cm">/* Irrelevant (jump to boot up code).*/</span>
	<span class="n">le64</span> <span class="n">oem_id</span><span class="p">;</span>			<span class="cm">/* Magic &quot;NTFS    &quot;. */</span>
	<span class="n">BIOS_PARAMETER_BLOCK</span> <span class="n">bpb</span><span class="p">;</span>	<span class="cm">/* See BIOS_PARAMETER_BLOCK. */</span>
	<span class="n">u8</span>  <span class="n">unused</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>			<span class="cm">/* zero, NTFS diskedit.exe states that</span>
<span class="cm">					   this is actually:</span>
<span class="cm">						__u8 physical_drive;	// 0x80</span>
<span class="cm">						__u8 current_head;	// zero</span>
<span class="cm">						__u8 extended_boot_signature;</span>

<span class="cm">//DIVIDER</span>
<span class="cm">						__u8 unused;		// zero</span>
<span class="cm">					 */</span>
<span class="cm">/*0x28*/</span><span class="n">sle64</span> <span class="n">number_of_sectors</span><span class="p">;</span>	<span class="cm">/* Number of sectors in volume. Gives</span>
<span class="cm">					   maximum volume size of 2^63 sectors.</span>
<span class="cm">					   Assuming standard sector size of 512</span>
<span class="cm">					   bytes, the maximum byte size is</span>
<span class="cm">					   approx. 4.7x10^21 bytes. (-; */</span>
	<span class="n">sle64</span> <span class="n">mft_lcn</span><span class="p">;</span>			<span class="cm">/* Cluster location of mft data. */</span>
	<span class="n">sle64</span> <span class="n">mftmirr_lcn</span><span class="p">;</span>		<span class="cm">/* Cluster location of copy of mft. */</span>
	<span class="n">s8</span>  <span class="n">clusters_per_mft_record</span><span class="p">;</span>	<span class="cm">/* Mft record size in clusters. */</span>
	<span class="n">u8</span>  <span class="n">reserved0</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* zero */</span>
	<span class="n">s8</span>  <span class="n">clusters_per_index_record</span><span class="p">;</span>	<span class="cm">/* Index block size in clusters. */</span>
	<span class="n">u8</span>  <span class="n">reserved1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* zero */</span>
	<span class="n">le64</span> <span class="n">volume_serial_number</span><span class="p">;</span>	<span class="cm">/* Irrelevant (serial number). */</span>
	<span class="n">le32</span> <span class="n">checksum</span><span class="p">;</span>			<span class="cm">/* Boot sector checksum. */</span>
<span class="cm">/*0x54*/</span><span class="n">u8</span>  <span class="n">bootstrap</span><span class="p">[</span><span class="mi">426</span><span class="p">];</span>		<span class="cm">/* Irrelevant (boot up code). */</span>
	<span class="n">le16</span> <span class="n">end_of_sector_marker</span><span class="p">;</span>	<span class="cm">/* End of bootsector magic. Always is</span>
<span class="cm">					   0xaa55 in little endian. */</span>
<span class="cm">/* sizeof() = 512 (0x200) bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">NTFS_BOOT_SECTOR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Magic identifiers present at the beginning of all ntfs record containing</span>
<span class="cm"> * records (like mft records for example).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Found in $MFT/$DATA. */</span>
	<span class="n">magic_FILE</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x454c4946</span><span class="p">),</span> <span class="cm">/* Mft entry. */</span>
	<span class="n">magic_INDX</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x58444e49</span><span class="p">),</span> <span class="cm">/* Index buffer. */</span>
	<span class="n">magic_HOLE</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x454c4f48</span><span class="p">),</span> <span class="cm">/* ? (NTFS 3.0+?) */</span>

	<span class="cm">/* Found in $LogFile/$DATA. */</span>
	<span class="n">magic_RSTR</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x52545352</span><span class="p">),</span> <span class="cm">/* Restart page. */</span>
	<span class="n">magic_RCRD</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x44524352</span><span class="p">),</span> <span class="cm">/* Log record page. */</span>

	<span class="cm">/* Found in $LogFile/$DATA.  (May be found in $MFT/$DATA, also?) */</span>
	<span class="n">magic_CHKD</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x444b4843</span><span class="p">),</span> <span class="cm">/* Modified by chkdsk. */</span>

	<span class="cm">/* Found in all ntfs record containing records. */</span>
	<span class="n">magic_BAAD</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x44414142</span><span class="p">),</span> <span class="cm">/* Failed multi sector</span>
<span class="cm">						       transfer was detected. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Found in $LogFile/$DATA when a page is full of 0xff bytes and is</span>
<span class="cm">	 * thus not initialized.  Page must be initialized before using it.</span>
<span class="cm">	 */</span>
	<span class="n">magic_empty</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">)</span> <span class="cm">/* Record is empty. */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">NTFS_RECORD_TYPE</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Generic magic comparison macros. Finally found a use for the ## preprocessor</span>
<span class="cm"> * operator! (-8</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__ntfs_is_magic</span><span class="p">(</span><span class="n">le32</span> <span class="n">x</span><span class="p">,</span> <span class="n">NTFS_RECORD_TYPE</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define ntfs_is_magic(x, m)	__ntfs_is_magic(x, magic_##m)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__ntfs_is_magicp</span><span class="p">(</span><span class="n">le32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">NTFS_RECORD_TYPE</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define ntfs_is_magicp(p, m)	__ntfs_is_magicp(p, magic_##m)</span>

<span class="cm">/*</span>
<span class="cm"> * Specialised magic comparison macros for the NTFS_RECORD_TYPEs defined above.</span>
<span class="cm"> */</span>
<span class="cp">#define ntfs_is_file_record(x)		( ntfs_is_magic (x, FILE) )</span>
<span class="cp">#define ntfs_is_file_recordp(p)		( ntfs_is_magicp(p, FILE) )</span>
<span class="cp">#define ntfs_is_mft_record(x)		( ntfs_is_file_record (x) )</span>
<span class="cp">#define ntfs_is_mft_recordp(p)		( ntfs_is_file_recordp(p) )</span>
<span class="cp">#define ntfs_is_indx_record(x)		( ntfs_is_magic (x, INDX) )</span>
<span class="cp">#define ntfs_is_indx_recordp(p)		( ntfs_is_magicp(p, INDX) )</span>
<span class="cp">#define ntfs_is_hole_record(x)		( ntfs_is_magic (x, HOLE) )</span>
<span class="cp">#define ntfs_is_hole_recordp(p)		( ntfs_is_magicp(p, HOLE) )</span>

<span class="cp">#define ntfs_is_rstr_record(x)		( ntfs_is_magic (x, RSTR) )</span>
<span class="cp">#define ntfs_is_rstr_recordp(p)		( ntfs_is_magicp(p, RSTR) )</span>
<span class="cp">#define ntfs_is_rcrd_record(x)		( ntfs_is_magic (x, RCRD) )</span>
<span class="cp">#define ntfs_is_rcrd_recordp(p)		( ntfs_is_magicp(p, RCRD) )</span>

<span class="cp">#define ntfs_is_chkd_record(x)		( ntfs_is_magic (x, CHKD) )</span>
<span class="cp">#define ntfs_is_chkd_recordp(p)		( ntfs_is_magicp(p, CHKD) )</span>

<span class="cp">#define ntfs_is_baad_record(x)		( ntfs_is_magic (x, BAAD) )</span>
<span class="cp">#define ntfs_is_baad_recordp(p)		( ntfs_is_magicp(p, BAAD) )</span>

<span class="cp">#define ntfs_is_empty_record(x)		( ntfs_is_magic (x, empty) )</span>
<span class="cp">#define ntfs_is_empty_recordp(p)	( ntfs_is_magicp(p, empty) )</span>

<span class="cm">/*</span>
<span class="cm"> * The Update Sequence Array (usa) is an array of the le16 values which belong</span>
<span class="cm"> * to the end of each sector protected by the update sequence record in which</span>
<span class="cm"> * this array is contained. Note that the first entry is the Update Sequence</span>
<span class="cm"> * Number (usn), a cyclic counter of how many times the protected record has</span>
<span class="cm"> * been written to disk. The values 0 and -1 (ie. 0xffff) are not used. All</span>
<span class="cm"> * last le16&#39;s of each sector have to be equal to the usn (during reading) or</span>
<span class="cm"> * are set to it (during writing). If they are not, an incomplete multi sector</span>
<span class="cm"> * transfer has occurred when the data was written.</span>
<span class="cm"> * The maximum size for the update sequence array is fixed to:</span>
<span class="cm"> *	maximum size = usa_ofs + (usa_count * 2) = 510 bytes</span>
<span class="cm"> * The 510 bytes comes from the fact that the last le16 in the array has to</span>
<span class="cm"> * (obviously) finish before the last le16 of the first 512-byte sector.</span>
<span class="cm"> * This formula can be used as a consistency check in that usa_ofs +</span>
<span class="cm"> * (usa_count * 2) has to be less than or equal to 510.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">NTFS_RECORD_TYPE</span> <span class="n">magic</span><span class="p">;</span>	<span class="cm">/* A four-byte magic identifying the record</span>
<span class="cm">				   type and/or status. */</span>
	<span class="n">le16</span> <span class="n">usa_ofs</span><span class="p">;</span>		<span class="cm">/* Offset to the Update Sequence Array (usa)</span>
<span class="cm">				   from the start of the ntfs record. */</span>
	<span class="n">le16</span> <span class="n">usa_count</span><span class="p">;</span>		<span class="cm">/* Number of le16 sized entries in the usa</span>
<span class="cm">				   including the Update Sequence Number (usn),</span>
<span class="cm">				   thus the number of fixups is the usa_count</span>
<span class="cm">				   minus 1. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">NTFS_RECORD</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * System files mft record numbers. All these files are always marked as used</span>
<span class="cm"> * in the bitmap attribute of the mft; presumably in order to avoid accidental</span>
<span class="cm"> * allocation for random other mft records. Also, the sequence number for each</span>
<span class="cm"> * of the system files is always equal to their mft record number and it is</span>
<span class="cm"> * never modified.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">FILE_MFT</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Master file table (mft). Data attribute</span>
<span class="cm">				   contains the entries and bitmap attribute</span>
<span class="cm">				   records which ones are in use (bit==1). */</span>
	<span class="n">FILE_MFTMirr</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Mft mirror: copy of first four mft records</span>
<span class="cm">				   in data attribute. If cluster size &gt; 4kiB,</span>
<span class="cm">				   copy of first N mft records, with</span>
<span class="cm">					N = cluster_size / mft_record_size. */</span>
	<span class="n">FILE_LogFile</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* Journalling log in data attribute. */</span>
	<span class="n">FILE_Volume</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* Volume name attribute and volume information</span>
<span class="cm">				   attribute (flags and ntfs version). Windows</span>
<span class="cm">				   refers to this file as volume DASD (Direct</span>
<span class="cm">				   Access Storage Device). */</span>
	<span class="n">FILE_AttrDef</span>   <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* Array of attribute definitions in data</span>
<span class="cm">				   attribute. */</span>
	<span class="n">FILE_root</span>      <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* Root directory. */</span>
	<span class="n">FILE_Bitmap</span>    <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* Allocation bitmap of all clusters (lcns) in</span>
<span class="cm">				   data attribute. */</span>
	<span class="n">FILE_Boot</span>      <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* Boot sector (always at cluster 0) in data</span>
<span class="cm">				   attribute. */</span>
	<span class="n">FILE_BadClus</span>   <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>	<span class="cm">/* Contains all bad clusters in the non-resident</span>
<span class="cm">				   data attribute. */</span>
	<span class="n">FILE_Secure</span>    <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>	<span class="cm">/* Shared security descriptors in data attribute</span>
<span class="cm">				   and two indexes into the descriptors.</span>
<span class="cm">				   Appeared in Windows 2000. Before that, this</span>
<span class="cm">				   file was named $Quota but was unused. */</span>
	<span class="n">FILE_UpCase</span>    <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>	<span class="cm">/* Uppercase equivalents of all 65536 Unicode</span>
<span class="cm">				   characters in data attribute. */</span>
	<span class="n">FILE_Extend</span>    <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>	<span class="cm">/* Directory containing other system files (eg.</span>
<span class="cm">				   $ObjId, $Quota, $Reparse and $UsnJrnl). This</span>
<span class="cm">				   is new to NTFS3.0. */</span>
	<span class="n">FILE_reserved12</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>	<span class="cm">/* Reserved for future use (records 12-15). */</span>
	<span class="n">FILE_reserved13</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">FILE_reserved14</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">FILE_reserved15</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">FILE_first_user</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>	<span class="cm">/* First user file, used as test limit for</span>
<span class="cm">				   whether to allow opening a file or not. */</span>
<span class="p">}</span> <span class="n">NTFS_SYSTEM_FILES</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * These are the so far known MFT_RECORD_* flags (16-bit) which contain</span>
<span class="cm"> * information about the mft record in which they are present.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MFT_RECORD_IN_USE</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">),</span>
	<span class="n">MFT_RECORD_IS_DIRECTORY</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">),</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">le16</span> <span class="n">MFT_RECORD_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * mft references (aka file references or file record segment references) are</span>
<span class="cm"> * used whenever a structure needs to refer to a record in the mft.</span>
<span class="cm"> *</span>
<span class="cm"> * A reference consists of a 48-bit index into the mft and a 16-bit sequence</span>
<span class="cm"> * number used to detect stale references.</span>
<span class="cm"> *</span>
<span class="cm"> * For error reporting purposes we treat the 48-bit index as a signed quantity.</span>
<span class="cm"> *</span>
<span class="cm"> * The sequence number is a circular counter (skipping 0) describing how many</span>
<span class="cm"> * times the referenced mft record has been (re)used. This has to match the</span>
<span class="cm"> * sequence number of the mft record being referenced, otherwise the reference</span>
<span class="cm"> * is considered stale and removed (FIXME: only ntfsck or the driver itself?).</span>
<span class="cm"> *</span>
<span class="cm"> * If the sequence number is zero it is assumed that no sequence number</span>
<span class="cm"> * consistency checking should be performed.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: Since inodes are 32-bit as of now, the driver needs to always check</span>
<span class="cm"> * for high_part being 0 and if not either BUG(), cause a panic() or handle</span>
<span class="cm"> * the situation in some other way. This shouldn&#39;t be a problem as a volume has</span>
<span class="cm"> * to become HUGE in order to need more than 32-bits worth of mft records.</span>
<span class="cm"> * Assuming the standard mft record size of 1kb only the records (never mind</span>
<span class="cm"> * the non-resident attributes, etc.) would require 4Tb of space on their own</span>
<span class="cm"> * for the first 32 bits worth of records. This is only if some strange person</span>
<span class="cm"> * doesn&#39;t decide to foul play and make the mft sparse which would be a really</span>
<span class="cm"> * horrible thing to do as it would trash our current driver implementation. )-:</span>
<span class="cm"> * Do I hear screams &quot;we want 64-bit inodes!&quot; ?!? (-;</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: The mft zone is defined as the first 12% of the volume. This space is</span>
<span class="cm"> * reserved so that the mft can grow contiguously and hence doesn&#39;t become</span>
<span class="cm"> * fragmented. Volume free space includes the empty part of the mft zone and</span>
<span class="cm"> * when the volume&#39;s free 88% are used up, the mft zone is shrunk by a factor</span>
<span class="cm"> * of 2, thus making more space available for more files/data. This process is</span>
<span class="cm"> * repeated every time there is no more free space except for the mft zone until</span>
<span class="cm"> * there really is no more free space.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Typedef the MFT_REF as a 64-bit value for easier handling.</span>
<span class="cm"> * Also define two unpacking macros to get to the reference (MREF) and</span>
<span class="cm"> * sequence number (MSEQNO) respectively.</span>
<span class="cm"> * The _LE versions are to be applied on little endian MFT_REFs.</span>
<span class="cm"> * Note: The _LE versions will return a CPU endian formatted value!</span>
<span class="cm"> */</span>
<span class="cp">#define MFT_REF_MASK_CPU 0x0000ffffffffffffULL</span>
<span class="cp">#define MFT_REF_MASK_LE cpu_to_le64(MFT_REF_MASK_CPU)</span>

<span class="k">typedef</span> <span class="n">u64</span> <span class="n">MFT_REF</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">le64</span> <span class="n">leMFT_REF</span><span class="p">;</span>

<span class="cp">#define MK_MREF(m, s)	((MFT_REF)(((MFT_REF)(s) &lt;&lt; 48) |		\</span>
<span class="cp">					((MFT_REF)(m) &amp; MFT_REF_MASK_CPU)))</span>
<span class="cp">#define MK_LE_MREF(m, s) cpu_to_le64(MK_MREF(m, s))</span>

<span class="cp">#define MREF(x)		((unsigned long)((x) &amp; MFT_REF_MASK_CPU))</span>
<span class="cp">#define MSEQNO(x)	((u16)(((x) &gt;&gt; 48) &amp; 0xffff))</span>
<span class="cp">#define MREF_LE(x)	((unsigned long)(le64_to_cpu(x) &amp; MFT_REF_MASK_CPU))</span>
<span class="cp">#define MSEQNO_LE(x)	((u16)((le64_to_cpu(x) &gt;&gt; 48) &amp; 0xffff))</span>

<span class="cp">#define IS_ERR_MREF(x)	(((x) &amp; 0x0000800000000000ULL) ? true : false)</span>
<span class="cp">#define ERR_MREF(x)	((u64)((s64)(x)))</span>
<span class="cp">#define MREF_ERR(x)	((int)((s64)(x)))</span>

<span class="cm">/*</span>
<span class="cm"> * The mft record header present at the beginning of every record in the mft.</span>
<span class="cm"> * This is followed by a sequence of variable length attribute records which</span>
<span class="cm"> * is terminated by an attribute of type AT_END which is a truncated attribute</span>
<span class="cm"> * in that it only consists of the attribute type code AT_END and none of the</span>
<span class="cm"> * other members of the attribute structure are present.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn&#39;t like unnamed structs. */</span>
	<span class="n">NTFS_RECORD_TYPE</span> <span class="n">magic</span><span class="p">;</span>	<span class="cm">/* Usually the magic is &quot;FILE&quot;. */</span>
	<span class="n">le16</span> <span class="n">usa_ofs</span><span class="p">;</span>		<span class="cm">/* See NTFS_RECORD definition above. */</span>
	<span class="n">le16</span> <span class="n">usa_count</span><span class="p">;</span>		<span class="cm">/* See NTFS_RECORD definition above. */</span>

<span class="cm">/*  8*/</span>	<span class="n">le64</span> <span class="n">lsn</span><span class="p">;</span>		<span class="cm">/* $LogFile sequence number for this record.</span>
<span class="cm">				   Changed every time the record is modified. */</span>
<span class="cm">/* 16*/</span>	<span class="n">le16</span> <span class="n">sequence_number</span><span class="p">;</span>	<span class="cm">/* Number of times this mft record has been</span>
<span class="cm">				   reused. (See description for MFT_REF</span>
<span class="cm">				   above.) NOTE: The increment (skipping zero)</span>
<span class="cm">				   is done when the file is deleted. NOTE: If</span>
<span class="cm">				   this is zero it is left zero. */</span>
<span class="cm">/* 18*/</span>	<span class="n">le16</span> <span class="n">link_count</span><span class="p">;</span>	<span class="cm">/* Number of hard links, i.e. the number of</span>
<span class="cm">				   directory entries referencing this record.</span>
<span class="cm">				   NOTE: Only used in mft base records.</span>
<span class="cm">				   NOTE: When deleting a directory entry we</span>
<span class="cm">				   check the link_count and if it is 1 we</span>
<span class="cm">				   delete the file. Otherwise we delete the</span>
<span class="cm">				   FILE_NAME_ATTR being referenced by the</span>
<span class="cm">				   directory entry from the mft record and</span>
<span class="cm">				   decrement the link_count.</span>
<span class="cm">				   FIXME: Careful with Win32 + DOS names! */</span>
<span class="cm">/* 20*/</span>	<span class="n">le16</span> <span class="n">attrs_offset</span><span class="p">;</span>	<span class="cm">/* Byte offset to the first attribute in this</span>
<span class="cm">				   mft record from the start of the mft record.</span>
<span class="cm">				   NOTE: Must be aligned to 8-byte boundary. */</span>
<span class="cm">/* 22*/</span>	<span class="n">MFT_RECORD_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Bit array of MFT_RECORD_FLAGS. When a file</span>
<span class="cm">				   is deleted, the MFT_RECORD_IN_USE flag is</span>
<span class="cm">				   set to zero. */</span>
<span class="cm">/* 24*/</span>	<span class="n">le32</span> <span class="n">bytes_in_use</span><span class="p">;</span>	<span class="cm">/* Number of bytes used in this mft record.</span>
<span class="cm">				   NOTE: Must be aligned to 8-byte boundary. */</span>
<span class="cm">/* 28*/</span>	<span class="n">le32</span> <span class="n">bytes_allocated</span><span class="p">;</span>	<span class="cm">/* Number of bytes allocated for this mft</span>
<span class="cm">				   record. This should be equal to the mft</span>
<span class="cm">				   record size. */</span>
<span class="cm">/* 32*/</span>	<span class="n">leMFT_REF</span> <span class="n">base_mft_record</span><span class="p">;</span><span class="cm">/* This is zero for base mft records.</span>
<span class="cm">				   When it is not zero it is a mft reference</span>
<span class="cm">				   pointing to the base mft record to which</span>
<span class="cm">				   this record belongs (this is then used to</span>
<span class="cm">				   locate the attribute list attribute present</span>
<span class="cm">				   in the base record which describes this</span>
<span class="cm">				   extension record and hence might need</span>
<span class="cm">				   modification when the extension record</span>
<span class="cm">				   itself is modified, also locating the</span>
<span class="cm">				   attribute list also means finding the other</span>
<span class="cm">				   potential extents, belonging to the non-base</span>
<span class="cm">				   mft record). */</span>
<span class="cm">/* 40*/</span>	<span class="n">le16</span> <span class="n">next_attr_instance</span><span class="p">;</span><span class="cm">/* The instance number that will be assigned to</span>
<span class="cm">				   the next attribute added to this mft record.</span>
<span class="cm">				   NOTE: Incremented each time after it is used.</span>
<span class="cm">				   NOTE: Every time the mft record is reused</span>
<span class="cm">				   this number is set to zero.  NOTE: The first</span>
<span class="cm">				   instance number is always 0. */</span>
<span class="cm">/* The below fields are specific to NTFS 3.1+ (Windows XP and above): */</span>
<span class="cm">/* 42*/</span> <span class="n">le16</span> <span class="n">reserved</span><span class="p">;</span>		<span class="cm">/* Reserved/alignment. */</span>
<span class="cm">/* 44*/</span> <span class="n">le32</span> <span class="n">mft_record_number</span><span class="p">;</span>	<span class="cm">/* Number of this mft record. */</span>
<span class="cm">/* sizeof() = 48 bytes */</span>
<span class="cm">/*</span>
<span class="cm"> * When (re)using the mft record, we place the update sequence array at this</span>
<span class="cm"> * offset, i.e. before we start with the attributes.  This also makes sense,</span>
<span class="cm"> * otherwise we could run into problems with the update sequence array</span>
<span class="cm"> * containing in itself the last two bytes of a sector which would mean that</span>
<span class="cm"> * multi sector transfer protection wouldn&#39;t work.  As you can&#39;t protect data</span>
<span class="cm"> * by overwriting it since you then can&#39;t get it back...</span>
<span class="cm"> * When reading we obviously use the data from the ntfs record header.</span>
<span class="cm"> */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">MFT_RECORD</span><span class="p">;</span>

<span class="cm">/* This is the version without the NTFS 3.1+ specific fields. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn&#39;t like unnamed structs. */</span>
	<span class="n">NTFS_RECORD_TYPE</span> <span class="n">magic</span><span class="p">;</span>	<span class="cm">/* Usually the magic is &quot;FILE&quot;. */</span>
	<span class="n">le16</span> <span class="n">usa_ofs</span><span class="p">;</span>		<span class="cm">/* See NTFS_RECORD definition above. */</span>
	<span class="n">le16</span> <span class="n">usa_count</span><span class="p">;</span>		<span class="cm">/* See NTFS_RECORD definition above. */</span>

<span class="cm">/*  8*/</span>	<span class="n">le64</span> <span class="n">lsn</span><span class="p">;</span>		<span class="cm">/* $LogFile sequence number for this record.</span>
<span class="cm">				   Changed every time the record is modified. */</span>
<span class="cm">/* 16*/</span>	<span class="n">le16</span> <span class="n">sequence_number</span><span class="p">;</span>	<span class="cm">/* Number of times this mft record has been</span>
<span class="cm">				   reused. (See description for MFT_REF</span>
<span class="cm">				   above.) NOTE: The increment (skipping zero)</span>
<span class="cm">				   is done when the file is deleted. NOTE: If</span>
<span class="cm">				   this is zero it is left zero. */</span>
<span class="cm">/* 18*/</span>	<span class="n">le16</span> <span class="n">link_count</span><span class="p">;</span>	<span class="cm">/* Number of hard links, i.e. the number of</span>
<span class="cm">				   directory entries referencing this record.</span>
<span class="cm">				   NOTE: Only used in mft base records.</span>
<span class="cm">				   NOTE: When deleting a directory entry we</span>
<span class="cm">				   check the link_count and if it is 1 we</span>
<span class="cm">				   delete the file. Otherwise we delete the</span>
<span class="cm">				   FILE_NAME_ATTR being referenced by the</span>
<span class="cm">				   directory entry from the mft record and</span>
<span class="cm">				   decrement the link_count.</span>
<span class="cm">				   FIXME: Careful with Win32 + DOS names! */</span>
<span class="cm">/* 20*/</span>	<span class="n">le16</span> <span class="n">attrs_offset</span><span class="p">;</span>	<span class="cm">/* Byte offset to the first attribute in this</span>
<span class="cm">				   mft record from the start of the mft record.</span>
<span class="cm">				   NOTE: Must be aligned to 8-byte boundary. */</span>
<span class="cm">/* 22*/</span>	<span class="n">MFT_RECORD_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Bit array of MFT_RECORD_FLAGS. When a file</span>
<span class="cm">				   is deleted, the MFT_RECORD_IN_USE flag is</span>
<span class="cm">				   set to zero. */</span>
<span class="cm">/* 24*/</span>	<span class="n">le32</span> <span class="n">bytes_in_use</span><span class="p">;</span>	<span class="cm">/* Number of bytes used in this mft record.</span>
<span class="cm">				   NOTE: Must be aligned to 8-byte boundary. */</span>
<span class="cm">/* 28*/</span>	<span class="n">le32</span> <span class="n">bytes_allocated</span><span class="p">;</span>	<span class="cm">/* Number of bytes allocated for this mft</span>
<span class="cm">				   record. This should be equal to the mft</span>
<span class="cm">				   record size. */</span>
<span class="cm">/* 32*/</span>	<span class="n">leMFT_REF</span> <span class="n">base_mft_record</span><span class="p">;</span><span class="cm">/* This is zero for base mft records.</span>
<span class="cm">				   When it is not zero it is a mft reference</span>
<span class="cm">				   pointing to the base mft record to which</span>
<span class="cm">				   this record belongs (this is then used to</span>
<span class="cm">				   locate the attribute list attribute present</span>
<span class="cm">				   in the base record which describes this</span>
<span class="cm">				   extension record and hence might need</span>
<span class="cm">				   modification when the extension record</span>
<span class="cm">				   itself is modified, also locating the</span>
<span class="cm">				   attribute list also means finding the other</span>
<span class="cm">				   potential extents, belonging to the non-base</span>
<span class="cm">				   mft record). */</span>
<span class="cm">/* 40*/</span>	<span class="n">le16</span> <span class="n">next_attr_instance</span><span class="p">;</span><span class="cm">/* The instance number that will be assigned to</span>
<span class="cm">				   the next attribute added to this mft record.</span>
<span class="cm">				   NOTE: Incremented each time after it is used.</span>
<span class="cm">				   NOTE: Every time the mft record is reused</span>
<span class="cm">				   this number is set to zero.  NOTE: The first</span>
<span class="cm">				   instance number is always 0. */</span>
<span class="cm">/* sizeof() = 42 bytes */</span>
<span class="cm">/*</span>
<span class="cm"> * When (re)using the mft record, we place the update sequence array at this</span>
<span class="cm"> * offset, i.e. before we start with the attributes.  This also makes sense,</span>
<span class="cm"> * otherwise we could run into problems with the update sequence array</span>
<span class="cm"> * containing in itself the last two bytes of a sector which would mean that</span>
<span class="cm"> * multi sector transfer protection wouldn&#39;t work.  As you can&#39;t protect data</span>
<span class="cm"> * by overwriting it since you then can&#39;t get it back...</span>
<span class="cm"> * When reading we obviously use the data from the ntfs record header.</span>
<span class="cm"> */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">MFT_RECORD_OLD</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * System defined attributes (32-bit).  Each attribute type has a corresponding</span>
<span class="cm"> * attribute name (Unicode string of maximum 64 character length) as described</span>
<span class="cm"> * by the attribute definitions present in the data attribute of the $AttrDef</span>
<span class="cm"> * system file.  On NTFS 3.0 volumes the names are just as the types are named</span>
<span class="cm"> * in the below defines exchanging AT_ for the dollar sign ($).  If that is not</span>
<span class="cm"> * a revealing choice of symbol I do not know what is... (-;</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">AT_UNUSED</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>         <span class="mi">0</span><span class="p">),</span>
	<span class="n">AT_STANDARD_INFORMATION</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x10</span><span class="p">),</span>
	<span class="n">AT_ATTRIBUTE_LIST</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x20</span><span class="p">),</span>
	<span class="n">AT_FILE_NAME</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x30</span><span class="p">),</span>
	<span class="n">AT_OBJECT_ID</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x40</span><span class="p">),</span>
	<span class="n">AT_SECURITY_DESCRIPTOR</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x50</span><span class="p">),</span>
	<span class="n">AT_VOLUME_NAME</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x60</span><span class="p">),</span>
	<span class="n">AT_VOLUME_INFORMATION</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x70</span><span class="p">),</span>
	<span class="n">AT_DATA</span>				<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x80</span><span class="p">),</span>
	<span class="n">AT_INDEX_ROOT</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0x90</span><span class="p">),</span>
	<span class="n">AT_INDEX_ALLOCATION</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0xa0</span><span class="p">),</span>
	<span class="n">AT_BITMAP</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0xb0</span><span class="p">),</span>
	<span class="n">AT_REPARSE_POINT</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0xc0</span><span class="p">),</span>
	<span class="n">AT_EA_INFORMATION</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0xd0</span><span class="p">),</span>
	<span class="n">AT_EA</span>				<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0xe0</span><span class="p">),</span>
	<span class="n">AT_PROPERTY_SET</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>      <span class="mh">0xf0</span><span class="p">),</span>
	<span class="n">AT_LOGGED_UTILITY_STREAM</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>     <span class="mh">0x100</span><span class="p">),</span>
	<span class="n">AT_FIRST_USER_DEFINED_ATTRIBUTE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>    <span class="mh">0x1000</span><span class="p">),</span>
	<span class="n">AT_END</span>				<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">ATTR_TYPE</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The collation rules for sorting views/indexes/etc (32-bit).</span>
<span class="cm"> *</span>
<span class="cm"> * COLLATION_BINARY - Collate by binary compare where the first byte is most</span>
<span class="cm"> *	significant.</span>
<span class="cm"> * COLLATION_UNICODE_STRING - Collate Unicode strings by comparing their binary</span>
<span class="cm"> *	Unicode values, except that when a character can be uppercased, the</span>
<span class="cm"> *	upper case value collates before the lower case one.</span>
<span class="cm"> * COLLATION_FILE_NAME - Collate file names as Unicode strings. The collation</span>
<span class="cm"> *	is done very much like COLLATION_UNICODE_STRING. In fact I have no idea</span>
<span class="cm"> *	what the difference is. Perhaps the difference is that file names</span>
<span class="cm"> *	would treat some special characters in an odd way (see</span>
<span class="cm"> *	unistr.c::ntfs_collate_names() and unistr.c::legal_ansi_char_array[]</span>
<span class="cm"> *	for what I mean but COLLATION_UNICODE_STRING would not give any special</span>
<span class="cm"> *	treatment to any characters at all, but this is speculation.</span>
<span class="cm"> * COLLATION_NTOFS_ULONG - Sorting is done according to ascending le32 key</span>
<span class="cm"> *	values. E.g. used for $SII index in FILE_Secure, which sorts by</span>
<span class="cm"> *	security_id (le32).</span>
<span class="cm"> * COLLATION_NTOFS_SID - Sorting is done according to ascending SID values.</span>
<span class="cm"> *	E.g. used for $O index in FILE_Extend/$Quota.</span>
<span class="cm"> * COLLATION_NTOFS_SECURITY_HASH - Sorting is done first by ascending hash</span>
<span class="cm"> *	values and second by ascending security_id values. E.g. used for $SDH</span>
<span class="cm"> *	index in FILE_Secure.</span>
<span class="cm"> * COLLATION_NTOFS_ULONGS - Sorting is done according to a sequence of ascending</span>
<span class="cm"> *	le32 key values. E.g. used for $O index in FILE_Extend/$ObjId, which</span>
<span class="cm"> *	sorts by object_id (16-byte), by splitting up the object_id in four</span>
<span class="cm"> *	le32 values and using them as individual keys. E.g. take the following</span>
<span class="cm"> *	two security_ids, stored as follows on disk:</span>
<span class="cm"> *		1st: a1 61 65 b7 65 7b d4 11 9e 3d 00 e0 81 10 42 59</span>
<span class="cm"> *		2nd: 38 14 37 d2 d2 f3 d4 11 a5 21 c8 6b 79 b1 97 45</span>
<span class="cm"> *	To compare them, they are split into four le32 values each, like so:</span>
<span class="cm"> *		1st: 0xb76561a1 0x11d47b65 0xe0003d9e 0x59421081</span>
<span class="cm"> *		2nd: 0xd2371438 0x11d4f3d2 0x6bc821a5 0x4597b179</span>
<span class="cm"> *	Now, it is apparent why the 2nd object_id collates after the 1st: the</span>
<span class="cm"> *	first le32 value of the 1st object_id is less than the first le32 of</span>
<span class="cm"> *	the 2nd object_id. If the first le32 values of both object_ids were</span>
<span class="cm"> *	equal then the second le32 values would be compared, etc.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">COLLATION_BINARY</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00</span><span class="p">),</span>
	<span class="n">COLLATION_FILE_NAME</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x01</span><span class="p">),</span>
	<span class="n">COLLATION_UNICODE_STRING</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x02</span><span class="p">),</span>
	<span class="n">COLLATION_NTOFS_ULONG</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x10</span><span class="p">),</span>
	<span class="n">COLLATION_NTOFS_SID</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x11</span><span class="p">),</span>
	<span class="n">COLLATION_NTOFS_SECURITY_HASH</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x12</span><span class="p">),</span>
	<span class="n">COLLATION_NTOFS_ULONGS</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x13</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">COLLATION_RULE</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The flags (32-bit) describing attribute properties in the attribute</span>
<span class="cm"> * definition structure.  FIXME: This information is based on Regis&#39;s</span>
<span class="cm"> * information and, according to him, it is not certain and probably</span>
<span class="cm"> * incomplete.  The INDEXABLE flag is fairly certainly correct as only the file</span>
<span class="cm"> * name attribute has this flag set and this is the only attribute indexed in</span>
<span class="cm"> * NT4.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ATTR_DEF_INDEXABLE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x02</span><span class="p">),</span> <span class="cm">/* Attribute can be</span>
<span class="cm">					indexed. */</span>
	<span class="n">ATTR_DEF_MULTIPLE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x04</span><span class="p">),</span> <span class="cm">/* Attribute type</span>
<span class="cm">					can be present multiple times in the</span>
<span class="cm">					mft records of an inode. */</span>
	<span class="n">ATTR_DEF_NOT_ZERO</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x08</span><span class="p">),</span> <span class="cm">/* Attribute value</span>
<span class="cm">					must contain at least one non-zero</span>
<span class="cm">					byte. */</span>
	<span class="n">ATTR_DEF_INDEXED_UNIQUE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x10</span><span class="p">),</span> <span class="cm">/* Attribute must be</span>
<span class="cm">					indexed and the attribute value must be</span>
<span class="cm">					unique for the attribute type in all of</span>
<span class="cm">					the mft records of an inode. */</span>
	<span class="n">ATTR_DEF_NAMED_UNIQUE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x20</span><span class="p">),</span> <span class="cm">/* Attribute must be</span>
<span class="cm">					named and the name must be unique for</span>
<span class="cm">					the attribute type in all of the mft</span>
<span class="cm">					records of an inode. */</span>
	<span class="n">ATTR_DEF_RESIDENT</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">),</span> <span class="cm">/* Attribute must be</span>
<span class="cm">					resident. */</span>
	<span class="n">ATTR_DEF_ALWAYS_LOG</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x80</span><span class="p">),</span> <span class="cm">/* Always log</span>
<span class="cm">					modifications to this attribute,</span>
<span class="cm">					regardless of whether it is resident or</span>
<span class="cm">					non-resident.  Without this, only log</span>
<span class="cm">					modifications if the attribute is</span>
<span class="cm">					resident. */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">ATTR_DEF_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The data attribute of FILE_AttrDef contains a sequence of attribute</span>
<span class="cm"> * definitions for the NTFS volume. With this, it is supposed to be safe for an</span>
<span class="cm"> * older NTFS driver to mount a volume containing a newer NTFS version without</span>
<span class="cm"> * damaging it (that&#39;s the theory. In practice it&#39;s: not damaging it too much).</span>
<span class="cm"> * Entries are sorted by attribute type. The flags describe whether the</span>
<span class="cm"> * attribute can be resident/non-resident and possibly other things, but the</span>
<span class="cm"> * actual bits are unknown.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*hex ofs*/</span>
<span class="cm">/*  0*/</span>	<span class="n">ntfschar</span> <span class="n">name</span><span class="p">[</span><span class="mh">0x40</span><span class="p">];</span>		<span class="cm">/* Unicode name of the attribute. Zero</span>
<span class="cm">					   terminated. */</span>
<span class="cm">/* 80*/</span>	<span class="n">ATTR_TYPE</span> <span class="n">type</span><span class="p">;</span>			<span class="cm">/* Type of the attribute. */</span>
<span class="cm">/* 84*/</span>	<span class="n">le32</span> <span class="n">display_rule</span><span class="p">;</span>		<span class="cm">/* Default display rule.</span>
<span class="cm">					   FIXME: What does it mean? (AIA) */</span>
<span class="cm">/* 88*/</span> <span class="n">COLLATION_RULE</span> <span class="n">collation_rule</span><span class="p">;</span>	<span class="cm">/* Default collation rule. */</span>
<span class="cm">/* 8c*/</span>	<span class="n">ATTR_DEF_FLAGS</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Flags describing the attribute. */</span>
<span class="cm">/* 90*/</span>	<span class="n">sle64</span> <span class="n">min_size</span><span class="p">;</span>			<span class="cm">/* Optional minimum attribute size. */</span>
<span class="cm">/* 98*/</span>	<span class="n">sle64</span> <span class="n">max_size</span><span class="p">;</span>			<span class="cm">/* Maximum size of attribute. */</span>
<span class="cm">/* sizeof() = 0xa0 or 160 bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ATTR_DEF</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute flags (16-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ATTR_IS_COMPRESSED</span>    <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">),</span>
	<span class="n">ATTR_COMPRESSION_MASK</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x00ff</span><span class="p">),</span> <span class="cm">/* Compression method</span>
<span class="cm">							      mask.  Also, first</span>
<span class="cm">							      illegal value. */</span>
	<span class="n">ATTR_IS_ENCRYPTED</span>     <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">),</span>
	<span class="n">ATTR_IS_SPARSE</span>	      <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">),</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">le16</span> <span class="n">ATTR_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute compression.</span>
<span class="cm"> *</span>
<span class="cm"> * Only the data attribute is ever compressed in the current ntfs driver in</span>
<span class="cm"> * Windows. Further, compression is only applied when the data attribute is</span>
<span class="cm"> * non-resident. Finally, to use compression, the maximum allowed cluster size</span>
<span class="cm"> * on a volume is 4kib.</span>
<span class="cm"> *</span>
<span class="cm"> * The compression method is based on independently compressing blocks of X</span>
<span class="cm"> * clusters, where X is determined from the compression_unit value found in the</span>
<span class="cm"> * non-resident attribute record header (more precisely: X = 2^compression_unit</span>
<span class="cm"> * clusters). On Windows NT/2k, X always is 16 clusters (compression_unit = 4).</span>
<span class="cm"> *</span>
<span class="cm"> * There are three different cases of how a compression block of X clusters</span>
<span class="cm"> * can be stored:</span>
<span class="cm"> *</span>
<span class="cm"> *   1) The data in the block is all zero (a sparse block):</span>
<span class="cm"> *	  This is stored as a sparse block in the runlist, i.e. the runlist</span>
<span class="cm"> *	  entry has length = X and lcn = -1. The mapping pairs array actually</span>
<span class="cm"> *	  uses a delta_lcn value length of 0, i.e. delta_lcn is not present at</span>
<span class="cm"> *	  all, which is then interpreted by the driver as lcn = -1.</span>
<span class="cm"> *	  NOTE: Even uncompressed files can be sparse on NTFS 3.0 volumes, then</span>
<span class="cm"> *	  the same principles apply as above, except that the length is not</span>
<span class="cm"> *	  restricted to being any particular value.</span>
<span class="cm"> *</span>
<span class="cm"> *   2) The data in the block is not compressed:</span>
<span class="cm"> *	  This happens when compression doesn&#39;t reduce the size of the block</span>
<span class="cm"> *	  in clusters. I.e. if compression has a small effect so that the</span>
<span class="cm"> *	  compressed data still occupies X clusters, then the uncompressed data</span>
<span class="cm"> *	  is stored in the block.</span>
<span class="cm"> *	  This case is recognised by the fact that the runlist entry has</span>
<span class="cm"> *	  length = X and lcn &gt;= 0. The mapping pairs array stores this as</span>
<span class="cm"> *	  normal with a run length of X and some specific delta_lcn, i.e.</span>
<span class="cm"> *	  delta_lcn has to be present.</span>
<span class="cm"> *</span>
<span class="cm"> *   3) The data in the block is compressed:</span>
<span class="cm"> *	  The common case. This case is recognised by the fact that the run</span>
<span class="cm"> *	  list entry has length L &lt; X and lcn &gt;= 0. The mapping pairs array</span>
<span class="cm"> *	  stores this as normal with a run length of X and some specific</span>
<span class="cm"> *	  delta_lcn, i.e. delta_lcn has to be present. This runlist entry is</span>
<span class="cm"> *	  immediately followed by a sparse entry with length = X - L and</span>
<span class="cm"> *	  lcn = -1. The latter entry is to make up the vcn counting to the</span>
<span class="cm"> *	  full compression block size X.</span>
<span class="cm"> *</span>
<span class="cm"> * In fact, life is more complicated because adjacent entries of the same type</span>
<span class="cm"> * can be coalesced. This means that one has to keep track of the number of</span>
<span class="cm"> * clusters handled and work on a basis of X clusters at a time being one</span>
<span class="cm"> * block. An example: if length L &gt; X this means that this particular runlist</span>
<span class="cm"> * entry contains a block of length X and part of one or more blocks of length</span>
<span class="cm"> * L - X. Another example: if length L &lt; X, this does not necessarily mean that</span>
<span class="cm"> * the block is compressed as it might be that the lcn changes inside the block</span>
<span class="cm"> * and hence the following runlist entry describes the continuation of the</span>
<span class="cm"> * potentially compressed block. The block would be compressed if the</span>
<span class="cm"> * following runlist entry describes at least X - L sparse clusters, thus</span>
<span class="cm"> * making up the compression block length as described in point 3 above. (Of</span>
<span class="cm"> * course, there can be several runlist entries with small lengths so that the</span>
<span class="cm"> * sparse entry does not follow the first data containing entry with</span>
<span class="cm"> * length &lt; X.)</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: At the end of the compressed attribute value, there most likely is not</span>
<span class="cm"> * just the right amount of data to make up a compression block, thus this data</span>
<span class="cm"> * is not even attempted to be compressed. It is just stored as is, unless</span>
<span class="cm"> * the number of clusters it occupies is reduced when compressed in which case</span>
<span class="cm"> * it is stored as a compressed compression block, complete with sparse</span>
<span class="cm"> * clusters at the end.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Flags of resident attributes (8-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RESIDENT_ATTR_IS_INDEXED</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span> <span class="cm">/* Attribute is referenced in an index</span>
<span class="cm">					    (has implications for deleting and</span>
<span class="cm">					    modifying the attribute). */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">u8</span> <span class="n">RESIDENT_ATTR_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute record header. Always aligned to 8-byte boundary.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0*/</span>	<span class="n">ATTR_TYPE</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* The (32-bit) type of the attribute. */</span>
<span class="cm">/*  4*/</span>	<span class="n">le32</span> <span class="n">length</span><span class="p">;</span>		<span class="cm">/* Byte size of the resident part of the</span>
<span class="cm">				   attribute (aligned to 8-byte boundary).</span>
<span class="cm">				   Used to get to the next attribute. */</span>
<span class="cm">/*  8*/</span>	<span class="n">u8</span> <span class="n">non_resident</span><span class="p">;</span>	<span class="cm">/* If 0, attribute is resident.</span>
<span class="cm">				   If 1, attribute is non-resident. */</span>
<span class="cm">/*  9*/</span>	<span class="n">u8</span> <span class="n">name_length</span><span class="p">;</span>		<span class="cm">/* Unicode character size of name of attribute.</span>
<span class="cm">				   0 if unnamed. */</span>
<span class="cm">/* 10*/</span>	<span class="n">le16</span> <span class="n">name_offset</span><span class="p">;</span>	<span class="cm">/* If name_length != 0, the byte offset to the</span>
<span class="cm">				   beginning of the name from the attribute</span>
<span class="cm">				   record. Note that the name is stored as a</span>
<span class="cm">				   Unicode string. When creating, place offset</span>
<span class="cm">				   just at the end of the record header. Then,</span>
<span class="cm">				   follow with attribute value or mapping pairs</span>
<span class="cm">				   array, resident and non-resident attributes</span>
<span class="cm">				   respectively, aligning to an 8-byte</span>
<span class="cm">				   boundary. */</span>
<span class="cm">/* 12*/</span>	<span class="n">ATTR_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Flags describing the attribute. */</span>
<span class="cm">/* 14*/</span>	<span class="n">le16</span> <span class="n">instance</span><span class="p">;</span>		<span class="cm">/* The instance of this attribute record. This</span>
<span class="cm">				   number is unique within this mft record (see</span>
<span class="cm">				   MFT_RECORD/next_attribute_instance notes in</span>
<span class="cm">				   in mft.h for more details). */</span>
<span class="cm">/* 16*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* Resident attributes. */</span>
		<span class="k">struct</span> <span class="p">{</span>
<span class="cm">/* 16 */</span>		<span class="n">le32</span> <span class="n">value_length</span><span class="p">;</span><span class="cm">/* Byte size of attribute value. */</span>
<span class="cm">/* 20 */</span>		<span class="n">le16</span> <span class="n">value_offset</span><span class="p">;</span><span class="cm">/* Byte offset of the attribute</span>
<span class="cm">					     value from the start of the</span>
<span class="cm">					     attribute record. When creating,</span>
<span class="cm">					     align to 8-byte boundary if we</span>
<span class="cm">					     have a name present as this might</span>
<span class="cm">					     not have a length of a multiple</span>
<span class="cm">					     of 8-bytes. */</span>
<span class="cm">/* 22 */</span>		<span class="n">RESIDENT_ATTR_FLAGS</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* See above. */</span>
<span class="cm">/* 23 */</span>		<span class="n">s8</span> <span class="n">reserved</span><span class="p">;</span>	  <span class="cm">/* Reserved/alignment to 8-byte</span>
<span class="cm">					     boundary. */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">resident</span><span class="p">;</span>
		<span class="cm">/* Non-resident attributes. */</span>
		<span class="k">struct</span> <span class="p">{</span>
<span class="cm">/* 16*/</span>			<span class="n">leVCN</span> <span class="n">lowest_vcn</span><span class="p">;</span><span class="cm">/* Lowest valid virtual cluster number</span>
<span class="cm">				for this portion of the attribute value or</span>
<span class="cm">				0 if this is the only extent (usually the</span>
<span class="cm">				case). - Only when an attribute list is used</span>
<span class="cm">				does lowest_vcn != 0 ever occur. */</span>
<span class="cm">/* 24*/</span>			<span class="n">leVCN</span> <span class="n">highest_vcn</span><span class="p">;</span><span class="cm">/* Highest valid vcn of this extent of</span>
<span class="cm">				the attribute value. - Usually there is only one</span>
<span class="cm">				portion, so this usually equals the attribute</span>
<span class="cm">				value size in clusters minus 1. Can be -1 for</span>
<span class="cm">				zero length files. Can be 0 for &quot;single extent&quot;</span>
<span class="cm">				attributes. */</span>
<span class="cm">/* 32*/</span>			<span class="n">le16</span> <span class="n">mapping_pairs_offset</span><span class="p">;</span> <span class="cm">/* Byte offset from the</span>
<span class="cm">				beginning of the structure to the mapping pairs</span>
<span class="cm">				array which contains the mappings between the</span>
<span class="cm">				vcns and the logical cluster numbers (lcns).</span>
<span class="cm">				When creating, place this at the end of this</span>
<span class="cm">				record header aligned to 8-byte boundary. */</span>
<span class="cm">/* 34*/</span>			<span class="n">u8</span> <span class="n">compression_unit</span><span class="p">;</span> <span class="cm">/* The compression unit expressed</span>
<span class="cm">				as the log to the base 2 of the number of</span>
<span class="cm">				clusters in a compression unit.  0 means not</span>
<span class="cm">				compressed.  (This effectively limits the</span>
<span class="cm">				compression unit size to be a power of two</span>
<span class="cm">				clusters.)  WinNT4 only uses a value of 4.</span>
<span class="cm">				Sparse files have this set to 0 on XPSP2. */</span>
<span class="cm">/* 35*/</span>			<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>		<span class="cm">/* Align to 8-byte boundary. */</span>
<span class="cm">/* The sizes below are only used when lowest_vcn is zero, as otherwise it would</span>
<span class="cm">   be difficult to keep them up-to-date.*/</span>
<span class="cm">/* 40*/</span>			<span class="n">sle64</span> <span class="n">allocated_size</span><span class="p">;</span>	<span class="cm">/* Byte size of disk space</span>
<span class="cm">				allocated to hold the attribute value. Always</span>
<span class="cm">				is a multiple of the cluster size. When a file</span>
<span class="cm">				is compressed, this field is a multiple of the</span>
<span class="cm">				compression block size (2^compression_unit) and</span>
<span class="cm">				it represents the logically allocated space</span>
<span class="cm">				rather than the actual on disk usage. For this</span>
<span class="cm">				use the compressed_size (see below). */</span>
<span class="cm">/* 48*/</span>			<span class="n">sle64</span> <span class="n">data_size</span><span class="p">;</span>	<span class="cm">/* Byte size of the attribute</span>
<span class="cm">				value. Can be larger than allocated_size if</span>
<span class="cm">				attribute value is compressed or sparse. */</span>
<span class="cm">/* 56*/</span>			<span class="n">sle64</span> <span class="n">initialized_size</span><span class="p">;</span>	<span class="cm">/* Byte size of initialized</span>
<span class="cm">				portion of the attribute value. Usually equals</span>
<span class="cm">				data_size. */</span>
<span class="cm">/* sizeof(uncompressed attr) = 64*/</span>
<span class="cm">/* 64*/</span>			<span class="n">sle64</span> <span class="n">compressed_size</span><span class="p">;</span>	<span class="cm">/* Byte size of the attribute</span>
<span class="cm">				value after compression.  Only present when</span>
<span class="cm">				compressed or sparse.  Always is a multiple of</span>
<span class="cm">				the cluster size.  Represents the actual amount</span>
<span class="cm">				of disk space being used on the disk. */</span>
<span class="cm">/* sizeof(compressed attr) = 72*/</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">non_resident</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ATTR_RECORD</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">ATTR_RECORD</span> <span class="n">ATTR_REC</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * File attribute flags (32-bit) appearing in the file_attributes fields of the</span>
<span class="cm"> * STANDARD_INFORMATION attribute of MFT_RECORDs and the FILENAME_ATTR</span>
<span class="cm"> * attributes of MFT_RECORDs and directory index entries.</span>
<span class="cm"> *</span>
<span class="cm"> * All of the below flags appear in the directory index entries but only some</span>
<span class="cm"> * appear in the STANDARD_INFORMATION attribute whilst only some others appear</span>
<span class="cm"> * in the FILENAME_ATTR attribute of MFT_RECORDs.  Unless otherwise stated the</span>
<span class="cm"> * flags appear in all of the above.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FILE_ATTR_READONLY</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>
	<span class="n">FILE_ATTR_HIDDEN</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">),</span>
	<span class="n">FILE_ATTR_SYSTEM</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000004</span><span class="p">),</span>
	<span class="cm">/* Old DOS volid. Unused in NT.	= cpu_to_le32(0x00000008), */</span>

	<span class="n">FILE_ATTR_DIRECTORY</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000010</span><span class="p">),</span>
	<span class="cm">/* Note, FILE_ATTR_DIRECTORY is not considered valid in NT.  It is</span>
<span class="cm">	   reserved for the DOS SUBDIRECTORY flag. */</span>
	<span class="n">FILE_ATTR_ARCHIVE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000020</span><span class="p">),</span>
	<span class="n">FILE_ATTR_DEVICE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000040</span><span class="p">),</span>
	<span class="n">FILE_ATTR_NORMAL</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000080</span><span class="p">),</span>

	<span class="n">FILE_ATTR_TEMPORARY</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000100</span><span class="p">),</span>
	<span class="n">FILE_ATTR_SPARSE_FILE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000200</span><span class="p">),</span>
	<span class="n">FILE_ATTR_REPARSE_POINT</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000400</span><span class="p">),</span>
	<span class="n">FILE_ATTR_COMPRESSED</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000800</span><span class="p">),</span>

	<span class="n">FILE_ATTR_OFFLINE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00001000</span><span class="p">),</span>
	<span class="n">FILE_ATTR_NOT_CONTENT_INDEXED</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00002000</span><span class="p">),</span>
	<span class="n">FILE_ATTR_ENCRYPTED</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00004000</span><span class="p">),</span>

	<span class="n">FILE_ATTR_VALID_FLAGS</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00007fb7</span><span class="p">),</span>
	<span class="cm">/* Note, FILE_ATTR_VALID_FLAGS masks out the old DOS VolId and the</span>
<span class="cm">	   FILE_ATTR_DEVICE and preserves everything else.  This mask is used</span>
<span class="cm">	   to obtain all flags that are valid for reading. */</span>
	<span class="n">FILE_ATTR_VALID_SET_FLAGS</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x000031a7</span><span class="p">),</span>
	<span class="cm">/* Note, FILE_ATTR_VALID_SET_FLAGS masks out the old DOS VolId, the</span>
<span class="cm">	   F_A_DEVICE, F_A_DIRECTORY, F_A_SPARSE_FILE, F_A_REPARSE_POINT,</span>
<span class="cm">	   F_A_COMPRESSED, and F_A_ENCRYPTED and preserves the rest.  This mask</span>
<span class="cm">	   is used to obtain all flags that are valid for setting. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The flag FILE_ATTR_DUP_FILENAME_INDEX_PRESENT is present in all</span>
<span class="cm">	 * FILENAME_ATTR attributes but not in the STANDARD_INFORMATION</span>
<span class="cm">	 * attribute of an mft record.</span>
<span class="cm">	 */</span>
	<span class="n">FILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x10000000</span><span class="p">),</span>
	<span class="cm">/* Note, this is a copy of the corresponding bit from the mft record,</span>
<span class="cm">	   telling us whether this is a directory or not, i.e. whether it has</span>
<span class="cm">	   an index root attribute or not. */</span>
	<span class="n">FILE_ATTR_DUP_VIEW_INDEX_PRESENT</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x20000000</span><span class="p">),</span>
	<span class="cm">/* Note, this is a copy of the corresponding bit from the mft record,</span>
<span class="cm">	   telling us whether this file has a view index present (eg. object id</span>
<span class="cm">	   index, quota index, one of the security indexes or the encrypting</span>
<span class="cm">	   filesystem related indexes). */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">FILE_ATTR_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE on times in NTFS: All times are in MS standard time format, i.e. they</span>
<span class="cm"> * are the number of 100-nanosecond intervals since 1st January 1601, 00:00:00</span>
<span class="cm"> * universal coordinated time (UTC). (In Linux time starts 1st January 1970,</span>
<span class="cm"> * 00:00:00 UTC and is stored as the number of 1-second intervals since then.)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Standard information (0x10).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Always resident.</span>
<span class="cm"> * NOTE: Present in all base file records on a volume.</span>
<span class="cm"> * NOTE: There is conflicting information about the meaning of each of the time</span>
<span class="cm"> *	 fields but the meaning as defined below has been verified to be</span>
<span class="cm"> *	 correct by practical experimentation on Windows NT4 SP6a and is hence</span>
<span class="cm"> *	 assumed to be the one and only correct interpretation.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0*/</span>	<span class="n">sle64</span> <span class="n">creation_time</span><span class="p">;</span>		<span class="cm">/* Time file was created. Updated when</span>
<span class="cm">					   a filename is changed(?). */</span>
<span class="cm">/*  8*/</span>	<span class="n">sle64</span> <span class="n">last_data_change_time</span><span class="p">;</span>	<span class="cm">/* Time the data attribute was last</span>
<span class="cm">					   modified. */</span>
<span class="cm">/* 16*/</span>	<span class="n">sle64</span> <span class="n">last_mft_change_time</span><span class="p">;</span>	<span class="cm">/* Time this mft record was last</span>
<span class="cm">					   modified. */</span>
<span class="cm">/* 24*/</span>	<span class="n">sle64</span> <span class="n">last_access_time</span><span class="p">;</span>		<span class="cm">/* Approximate time when the file was</span>
<span class="cm">					   last accessed (obviously this is not</span>
<span class="cm">					   updated on read-only volumes). In</span>
<span class="cm">					   Windows this is only updated when</span>
<span class="cm">					   accessed if some time delta has</span>
<span class="cm">					   passed since the last update. Also,</span>
<span class="cm">					   last access time updates can be</span>
<span class="cm">					   disabled altogether for speed. */</span>
<span class="cm">/* 32*/</span>	<span class="n">FILE_ATTR_FLAGS</span> <span class="n">file_attributes</span><span class="p">;</span> <span class="cm">/* Flags describing the file. */</span>
<span class="cm">/* 36*/</span>	<span class="k">union</span> <span class="p">{</span>
	<span class="cm">/* NTFS 1.2 */</span>
		<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* 36*/</span>	<span class="n">u8</span> <span class="n">reserved12</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>	<span class="cm">/* Reserved/alignment to 8-byte</span>
<span class="cm">						   boundary. */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">v1</span><span class="p">;</span>
	<span class="cm">/* sizeof() = 48 bytes */</span>
	<span class="cm">/* NTFS 3.x */</span>
		<span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> * If a volume has been upgraded from a previous NTFS version, then these</span>
<span class="cm"> * fields are present only if the file has been accessed since the upgrade.</span>
<span class="cm"> * Recognize the difference by comparing the length of the resident attribute</span>
<span class="cm"> * value. If it is 48, then the following fields are missing. If it is 72 then</span>
<span class="cm"> * the fields are present. Maybe just check like this:</span>
<span class="cm"> *	if (resident.ValueLength &lt; sizeof(STANDARD_INFORMATION)) {</span>
<span class="cm"> *		Assume NTFS 1.2- format.</span>
<span class="cm"> *		If (volume version is 3.x)</span>
<span class="cm"> *			Upgrade attribute to NTFS 3.x format.</span>
<span class="cm"> *		else</span>
<span class="cm"> *			Use NTFS 1.2- format for access.</span>
<span class="cm"> *	} else</span>
<span class="cm"> *		Use NTFS 3.x format for access.</span>
<span class="cm"> * Only problem is that it might be legal to set the length of the value to</span>
<span class="cm"> * arbitrarily large values thus spoiling this check. - But chkdsk probably</span>
<span class="cm"> * views that as a corruption, assuming that it behaves like this for all</span>
<span class="cm"> * attributes.</span>
<span class="cm"> */</span>
		<span class="cm">/* 36*/</span>	<span class="n">le32</span> <span class="n">maximum_versions</span><span class="p">;</span>	<span class="cm">/* Maximum allowed versions for</span>
<span class="cm">				file. Zero if version numbering is disabled. */</span>
		<span class="cm">/* 40*/</span>	<span class="n">le32</span> <span class="n">version_number</span><span class="p">;</span>	<span class="cm">/* This file&#39;s version (if any).</span>
<span class="cm">				Set to zero if maximum_versions is zero. */</span>
		<span class="cm">/* 44*/</span>	<span class="n">le32</span> <span class="n">class_id</span><span class="p">;</span>		<span class="cm">/* Class id from bidirectional</span>
<span class="cm">				class id index (?). */</span>
		<span class="cm">/* 48*/</span>	<span class="n">le32</span> <span class="n">owner_id</span><span class="p">;</span>		<span class="cm">/* Owner_id of the user owning</span>
<span class="cm">				the file. Translate via $Q index in FILE_Extend</span>
<span class="cm">				/$Quota to the quota control entry for the user</span>
<span class="cm">				owning the file. Zero if quotas are disabled. */</span>
		<span class="cm">/* 52*/</span>	<span class="n">le32</span> <span class="n">security_id</span><span class="p">;</span>	<span class="cm">/* Security_id for the file.</span>
<span class="cm">				Translate via $SII index and $SDS data stream</span>
<span class="cm">				in FILE_Secure to the security descriptor. */</span>
		<span class="cm">/* 56*/</span>	<span class="n">le64</span> <span class="n">quota_charged</span><span class="p">;</span>	<span class="cm">/* Byte size of the charge to</span>
<span class="cm">				the quota for all streams of the file. Note: Is</span>
<span class="cm">				zero if quotas are disabled. */</span>
		<span class="cm">/* 64*/</span>	<span class="n">leUSN</span> <span class="n">usn</span><span class="p">;</span>		<span class="cm">/* Last update sequence number</span>
<span class="cm">				of the file.  This is a direct index into the</span>
<span class="cm">				transaction log file ($UsnJrnl).  It is zero if</span>
<span class="cm">				the usn journal is disabled or this file has</span>
<span class="cm">				not been subject to logging yet.  See usnjrnl.h</span>
<span class="cm">				for details. */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">v3</span><span class="p">;</span>
	<span class="cm">/* sizeof() = 72 bytes (NTFS 3.x) */</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ver</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">STANDARD_INFORMATION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Attribute list (0x20).</span>
<span class="cm"> *</span>
<span class="cm"> * - Can be either resident or non-resident.</span>
<span class="cm"> * - Value consists of a sequence of variable length, 8-byte aligned,</span>
<span class="cm"> * ATTR_LIST_ENTRY records.</span>
<span class="cm"> * - The list is not terminated by anything at all! The only way to know when</span>
<span class="cm"> * the end is reached is to keep track of the current offset and compare it to</span>
<span class="cm"> * the attribute value size.</span>
<span class="cm"> * - The attribute list attribute contains one entry for each attribute of</span>
<span class="cm"> * the file in which the list is located, except for the list attribute</span>
<span class="cm"> * itself. The list is sorted: first by attribute type, second by attribute</span>
<span class="cm"> * name (if present), third by instance number. The extents of one</span>
<span class="cm"> * non-resident attribute (if present) immediately follow after the initial</span>
<span class="cm"> * extent. They are ordered by lowest_vcn and have their instace set to zero.</span>
<span class="cm"> * It is not allowed to have two attributes with all sorting keys equal.</span>
<span class="cm"> * - Further restrictions:</span>
<span class="cm"> *	- If not resident, the vcn to lcn mapping array has to fit inside the</span>
<span class="cm"> *	  base mft record.</span>
<span class="cm"> *	- The attribute list attribute value has a maximum size of 256kb. This</span>
<span class="cm"> *	  is imposed by the Windows cache manager.</span>
<span class="cm"> * - Attribute lists are only used when the attributes of mft record do not</span>
<span class="cm"> * fit inside the mft record despite all attributes (that can be made</span>
<span class="cm"> * non-resident) having been made non-resident. This can happen e.g. when:</span>
<span class="cm"> *	- File has a large number of hard links (lots of file name</span>
<span class="cm"> *	  attributes present).</span>
<span class="cm"> *	- The mapping pairs array of some non-resident attribute becomes so</span>
<span class="cm"> *	  large due to fragmentation that it overflows the mft record.</span>
<span class="cm"> *	- The security descriptor is very complex (not applicable to</span>
<span class="cm"> *	  NTFS 3.0 volumes).</span>
<span class="cm"> *	- There are many named streams.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0*/</span>	<span class="n">ATTR_TYPE</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* Type of referenced attribute. */</span>
<span class="cm">/*  4*/</span>	<span class="n">le16</span> <span class="n">length</span><span class="p">;</span>		<span class="cm">/* Byte size of this entry (8-byte aligned). */</span>
<span class="cm">/*  6*/</span>	<span class="n">u8</span> <span class="n">name_length</span><span class="p">;</span>		<span class="cm">/* Size in Unicode chars of the name of the</span>
<span class="cm">				   attribute or 0 if unnamed. */</span>
<span class="cm">/*  7*/</span>	<span class="n">u8</span> <span class="n">name_offset</span><span class="p">;</span>		<span class="cm">/* Byte offset to beginning of attribute name</span>
<span class="cm">				   (always set this to where the name would</span>
<span class="cm">				   start even if unnamed). */</span>
<span class="cm">/*  8*/</span>	<span class="n">leVCN</span> <span class="n">lowest_vcn</span><span class="p">;</span>	<span class="cm">/* Lowest virtual cluster number of this portion</span>
<span class="cm">				   of the attribute value. This is usually 0. It</span>
<span class="cm">				   is non-zero for the case where one attribute</span>
<span class="cm">				   does not fit into one mft record and thus</span>
<span class="cm">				   several mft records are allocated to hold</span>
<span class="cm">				   this attribute. In the latter case, each mft</span>
<span class="cm">				   record holds one extent of the attribute and</span>
<span class="cm">				   there is one attribute list entry for each</span>
<span class="cm">				   extent. NOTE: This is DEFINITELY a signed</span>
<span class="cm">				   value! The windows driver uses cmp, followed</span>
<span class="cm">				   by jg when comparing this, thus it treats it</span>
<span class="cm">				   as signed. */</span>
<span class="cm">/* 16*/</span>	<span class="n">leMFT_REF</span> <span class="n">mft_reference</span><span class="p">;</span><span class="cm">/* The reference of the mft record holding</span>
<span class="cm">				   the ATTR_RECORD for this portion of the</span>
<span class="cm">				   attribute value. */</span>
<span class="cm">/* 24*/</span>	<span class="n">le16</span> <span class="n">instance</span><span class="p">;</span>		<span class="cm">/* If lowest_vcn = 0, the instance of the</span>
<span class="cm">				   attribute being referenced; otherwise 0. */</span>
<span class="cm">/* 26*/</span>	<span class="n">ntfschar</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Use when creating only. When reading use</span>
<span class="cm">				   name_offset to determine the location of the</span>
<span class="cm">				   name. */</span>
<span class="cm">/* sizeof() = 26 + (attribute_name_length * 2) bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ATTR_LIST_ENTRY</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum allowed length for a file name.</span>
<span class="cm"> */</span>
<span class="cp">#define MAXIMUM_FILE_NAME_LENGTH	255</span>

<span class="cm">/*</span>
<span class="cm"> * Possible namespaces for filenames in ntfs (8-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FILE_NAME_POSIX</span>		<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="cm">/* This is the largest namespace. It is case sensitive and allows all</span>
<span class="cm">	   Unicode characters except for: &#39;\0&#39; and &#39;/&#39;.  Beware that in</span>
<span class="cm">	   WinNT/2k/2003 by default files which eg have the same name except</span>
<span class="cm">	   for their case will not be distinguished by the standard utilities</span>
<span class="cm">	   and thus a &quot;del filename&quot; will delete both &quot;filename&quot; and &quot;fileName&quot;</span>
<span class="cm">	   without warning.  However if for example Services For Unix (SFU) are</span>
<span class="cm">	   installed and the case sensitive option was enabled at installation</span>
<span class="cm">	   time, then you can create/access/delete such files.</span>
<span class="cm">	   Note that even SFU places restrictions on the filenames beyond the</span>
<span class="cm">	   &#39;\0&#39; and &#39;/&#39; and in particular the following set of characters is</span>
<span class="cm">	   not allowed: &#39;&quot;&#39;, &#39;/&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;\&#39;.  All other characters,</span>
<span class="cm">	   including the ones no allowed in WIN32 namespace are allowed.</span>
<span class="cm">	   Tested with SFU 3.5 (this is now free) running on Windows XP. */</span>
	<span class="n">FILE_NAME_WIN32</span>		<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="cm">/* The standard WinNT/2k NTFS long filenames. Case insensitive.  All</span>
<span class="cm">	   Unicode chars except: &#39;\0&#39;, &#39;&quot;&#39;, &#39;*&#39;, &#39;/&#39;, &#39;:&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;?&#39;, &#39;\&#39;,</span>
<span class="cm">	   and &#39;|&#39;.  Further, names cannot end with a &#39;.&#39; or a space. */</span>
	<span class="n">FILE_NAME_DOS</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="cm">/* The standard DOS filenames (8.3 format). Uppercase only.  All 8-bit</span>
<span class="cm">	   characters greater space, except: &#39;&quot;&#39;, &#39;*&#39;, &#39;+&#39;, &#39;,&#39;, &#39;/&#39;, &#39;:&#39;, &#39;;&#39;,</span>
<span class="cm">	   &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;, and &#39;\&#39;. */</span>
	<span class="n">FILE_NAME_WIN32_AND_DOS</span>	<span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="cm">/* 3 means that both the Win32 and the DOS filenames are identical and</span>
<span class="cm">	   hence have been saved in this single filename record. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">u8</span> <span class="n">FILE_NAME_TYPE_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Filename (0x30).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Always resident.</span>
<span class="cm"> * NOTE: All fields, except the parent_directory, are only updated when the</span>
<span class="cm"> *	 filename is changed. Until then, they just become out of sync with</span>
<span class="cm"> *	 reality and the more up to date values are present in the standard</span>
<span class="cm"> *	 information attribute.</span>
<span class="cm"> * NOTE: There is conflicting information about the meaning of each of the time</span>
<span class="cm"> *	 fields but the meaning as defined below has been verified to be</span>
<span class="cm"> *	 correct by practical experimentation on Windows NT4 SP6a and is hence</span>
<span class="cm"> *	 assumed to be the one and only correct interpretation.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*hex ofs*/</span>
<span class="cm">/*  0*/</span>	<span class="n">leMFT_REF</span> <span class="n">parent_directory</span><span class="p">;</span>	<span class="cm">/* Directory this filename is</span>
<span class="cm">					   referenced from. */</span>
<span class="cm">/*  8*/</span>	<span class="n">sle64</span> <span class="n">creation_time</span><span class="p">;</span>		<span class="cm">/* Time file was created. */</span>
<span class="cm">/* 10*/</span>	<span class="n">sle64</span> <span class="n">last_data_change_time</span><span class="p">;</span>	<span class="cm">/* Time the data attribute was last</span>
<span class="cm">					   modified. */</span>
<span class="cm">/* 18*/</span>	<span class="n">sle64</span> <span class="n">last_mft_change_time</span><span class="p">;</span>	<span class="cm">/* Time this mft record was last</span>
<span class="cm">					   modified. */</span>
<span class="cm">/* 20*/</span>	<span class="n">sle64</span> <span class="n">last_access_time</span><span class="p">;</span>		<span class="cm">/* Time this mft record was last</span>
<span class="cm">					   accessed. */</span>
<span class="cm">/* 28*/</span>	<span class="n">sle64</span> <span class="n">allocated_size</span><span class="p">;</span>		<span class="cm">/* Byte size of on-disk allocated space</span>
<span class="cm">					   for the unnamed data attribute.  So</span>
<span class="cm">					   for normal $DATA, this is the</span>
<span class="cm">					   allocated_size from the unnamed</span>
<span class="cm">					   $DATA attribute and for compressed</span>
<span class="cm">					   and/or sparse $DATA, this is the</span>
<span class="cm">					   compressed_size from the unnamed</span>
<span class="cm">					   $DATA attribute.  For a directory or</span>
<span class="cm">					   other inode without an unnamed $DATA</span>
<span class="cm">					   attribute, this is always 0.  NOTE:</span>
<span class="cm">					   This is a multiple of the cluster</span>
<span class="cm">					   size. */</span>
<span class="cm">/* 30*/</span>	<span class="n">sle64</span> <span class="n">data_size</span><span class="p">;</span>		<span class="cm">/* Byte size of actual data in unnamed</span>
<span class="cm">					   data attribute.  For a directory or</span>
<span class="cm">					   other inode without an unnamed $DATA</span>
<span class="cm">					   attribute, this is always 0. */</span>
<span class="cm">/* 38*/</span>	<span class="n">FILE_ATTR_FLAGS</span> <span class="n">file_attributes</span><span class="p">;</span>	<span class="cm">/* Flags describing the file. */</span>
<span class="cm">/* 3c*/</span>	<span class="k">union</span> <span class="p">{</span>
	<span class="cm">/* 3c*/</span>	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* 3c*/</span>	<span class="n">le16</span> <span class="n">packed_ea_size</span><span class="p">;</span>	<span class="cm">/* Size of the buffer needed to</span>
<span class="cm">						   pack the extended attributes</span>
<span class="cm">						   (EAs), if such are present.*/</span>
		<span class="cm">/* 3e*/</span>	<span class="n">le16</span> <span class="n">reserved</span><span class="p">;</span>		<span class="cm">/* Reserved for alignment. */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ea</span><span class="p">;</span>
	<span class="cm">/* 3c*/</span>	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* 3c*/</span>	<span class="n">le32</span> <span class="n">reparse_point_tag</span><span class="p">;</span>	<span class="cm">/* Type of reparse point,</span>
<span class="cm">						   present only in reparse</span>
<span class="cm">						   points and only if there are</span>
<span class="cm">						   no EAs. */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">rp</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">type</span><span class="p">;</span>
<span class="cm">/* 40*/</span>	<span class="n">u8</span> <span class="n">file_name_length</span><span class="p">;</span>			<span class="cm">/* Length of file name in</span>
<span class="cm">						   (Unicode) characters. */</span>
<span class="cm">/* 41*/</span>	<span class="n">FILE_NAME_TYPE_FLAGS</span> <span class="n">file_name_type</span><span class="p">;</span>	<span class="cm">/* Namespace of the file name.*/</span>
<span class="cm">/* 42*/</span>	<span class="n">ntfschar</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>			<span class="cm">/* File name in Unicode. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">FILE_NAME_ATTR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * GUID structures store globally unique identifiers (GUID). A GUID is a</span>
<span class="cm"> * 128-bit value consisting of one group of eight hexadecimal digits, followed</span>
<span class="cm"> * by three groups of four hexadecimal digits each, followed by one group of</span>
<span class="cm"> * twelve hexadecimal digits. GUIDs are Microsoft&#39;s implementation of the</span>
<span class="cm"> * distributed computing environment (DCE) universally unique identifier (UUID).</span>
<span class="cm"> * Example of a GUID:</span>
<span class="cm"> *	1F010768-5A73-BC91-0010A52216A7</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">data1</span><span class="p">;</span>	<span class="cm">/* The first eight hexadecimal digits of the GUID. */</span>
	<span class="n">le16</span> <span class="n">data2</span><span class="p">;</span>	<span class="cm">/* The first group of four hexadecimal digits. */</span>
	<span class="n">le16</span> <span class="n">data3</span><span class="p">;</span>	<span class="cm">/* The second group of four hexadecimal digits. */</span>
	<span class="n">u8</span> <span class="n">data4</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* The first two bytes are the third group of four</span>
<span class="cm">			   hexadecimal digits. The remaining six bytes are the</span>
<span class="cm">			   final 12 hexadecimal digits. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">GUID</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * FILE_Extend/$ObjId contains an index named $O. This index contains all</span>
<span class="cm"> * object_ids present on the volume as the index keys and the corresponding</span>
<span class="cm"> * mft_record numbers as the index entry data parts. The data part (defined</span>
<span class="cm"> * below) also contains three other object_ids:</span>
<span class="cm"> *	birth_volume_id - object_id of FILE_Volume on which the file was first</span>
<span class="cm"> *			  created. Optional (i.e. can be zero).</span>
<span class="cm"> *	birth_object_id - object_id of file when it was first created. Usually</span>
<span class="cm"> *			  equals the object_id. Optional (i.e. can be zero).</span>
<span class="cm"> *	domain_id	- Reserved (always zero).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">leMFT_REF</span> <span class="n">mft_reference</span><span class="p">;</span><span class="cm">/* Mft record containing the object_id in</span>
<span class="cm">				   the index entry key. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">GUID</span> <span class="n">birth_volume_id</span><span class="p">;</span>
			<span class="n">GUID</span> <span class="n">birth_object_id</span><span class="p">;</span>
			<span class="n">GUID</span> <span class="n">domain_id</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">origin</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">extended_info</span><span class="p">[</span><span class="mi">48</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">opt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">OBJ_ID_INDEX_DATA</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Object id (NTFS 3.0+) (0x40).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Always resident.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">GUID</span> <span class="n">object_id</span><span class="p">;</span>				<span class="cm">/* Unique id assigned to the</span>
<span class="cm">						   file.*/</span>
	<span class="cm">/* The following fields are optional. The attribute value size is 16</span>
<span class="cm">	   bytes, i.e. sizeof(GUID), if these are not present at all. Note,</span>
<span class="cm">	   the entries can be present but one or more (or all) can be zero</span>
<span class="cm">	   meaning that that particular value(s) is(are) not defined. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">GUID</span> <span class="n">birth_volume_id</span><span class="p">;</span>	<span class="cm">/* Unique id of volume on which</span>
<span class="cm">						   the file was first created.*/</span>
			<span class="n">GUID</span> <span class="n">birth_object_id</span><span class="p">;</span>	<span class="cm">/* Unique id of file when it was</span>
<span class="cm">						   first created. */</span>
			<span class="n">GUID</span> <span class="n">domain_id</span><span class="p">;</span>		<span class="cm">/* Reserved, zero. */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">origin</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">extended_info</span><span class="p">[</span><span class="mi">48</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">opt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">OBJECT_ID_ATTR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The pre-defined IDENTIFIER_AUTHORITIES used as SID_IDENTIFIER_AUTHORITY in</span>
<span class="cm"> * the SID structure (see below).</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>0x80</p></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * These relative identifiers (RIDs) are used with the above identifier</span>
<span class="cm"> * authorities to make up universal well-known SIDs.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The relative identifier (RID) refers to the portion of a SID, which</span>
<span class="cm"> * identifies a user or group in relation to the authority that issued the SID.</span>
<span class="cm"> * For example, the universal well-known SID Creator Owner ID (S-1-3-0) is</span>
<span class="cm"> * made up of the identifier authority SECURITY_CREATOR_SID_AUTHORITY (3) and</span>
<span class="cm"> * the relative identifier SECURITY_CREATOR_OWNER_RID (0).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>					<span class="cm">/* Identifier authority. */</span>
	<span class="n">SECURITY_NULL_RID</span>		  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* S-1-0 */</span>
	<span class="n">SECURITY_WORLD_RID</span>		  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* S-1-1 */</span>
	<span class="n">SECURITY_LOCAL_RID</span>		  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* S-1-2 */</span>

	<span class="n">SECURITY_CREATOR_OWNER_RID</span>	  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* S-1-3 */</span>
	<span class="n">SECURITY_CREATOR_GROUP_RID</span>	  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* S-1-3 */</span>

	<span class="n">SECURITY_CREATOR_OWNER_SERVER_RID</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* S-1-3 */</span>
	<span class="n">SECURITY_CREATOR_GROUP_SERVER_RID</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* S-1-3 */</span>

	<span class="n">SECURITY_DIALUP_RID</span>		  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SECURITY_NETWORK_RID</span>		  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">SECURITY_BATCH_RID</span>		  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">SECURITY_INTERACTIVE_RID</span>	  <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">SECURITY_SERVICE_RID</span>		  <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">SECURITY_ANONYMOUS_LOGON_RID</span>	  <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">SECURITY_PROXY_RID</span>		  <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">SECURITY_ENTERPRISE_CONTROLLERS_RID</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
	<span class="n">SECURITY_SERVER_LOGON_RID</span>	  <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">SECURITY_PRINCIPAL_SELF_RID</span>	  <span class="o">=</span> <span class="mh">0xa</span><span class="p">,</span>
	<span class="n">SECURITY_AUTHENTICATED_USER_RID</span>	  <span class="o">=</span> <span class="mh">0xb</span><span class="p">,</span>
	<span class="n">SECURITY_RESTRICTED_CODE_RID</span>	  <span class="o">=</span> <span class="mh">0xc</span><span class="p">,</span>
	<span class="n">SECURITY_TERMINAL_SERVER_RID</span>	  <span class="o">=</span> <span class="mh">0xd</span><span class="p">,</span>

	<span class="n">SECURITY_LOGON_IDS_RID</span>		  <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">SECURITY_LOGON_IDS_RID_COUNT</span>	  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">SECURITY_LOCAL_SYSTEM_RID</span>	  <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>

	<span class="n">SECURITY_NT_NON_UNIQUE</span>		  <span class="o">=</span> <span class="mh">0x15</span><span class="p">,</span>

	<span class="n">SECURITY_BUILTIN_DOMAIN_RID</span>	  <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Well-known domain relative sub-authority values (RIDs).</span>
<span class="cm">	 */</span>

	<span class="cm">/* Users. */</span>
	<span class="n">DOMAIN_USER_RID_ADMIN</span>		  <span class="o">=</span> <span class="mh">0x1f4</span><span class="p">,</span>
	<span class="n">DOMAIN_USER_RID_GUEST</span>		  <span class="o">=</span> <span class="mh">0x1f5</span><span class="p">,</span>
	<span class="n">DOMAIN_USER_RID_KRBTGT</span>		  <span class="o">=</span> <span class="mh">0x1f6</span><span class="p">,</span>

	<span class="cm">/* Groups. */</span>
	<span class="n">DOMAIN_GROUP_RID_ADMINS</span>		  <span class="o">=</span> <span class="mh">0x200</span><span class="p">,</span>
	<span class="n">DOMAIN_GROUP_RID_USERS</span>		  <span class="o">=</span> <span class="mh">0x201</span><span class="p">,</span>
	<span class="n">DOMAIN_GROUP_RID_GUESTS</span>		  <span class="o">=</span> <span class="mh">0x202</span><span class="p">,</span>
	<span class="n">DOMAIN_GROUP_RID_COMPUTERS</span>	  <span class="o">=</span> <span class="mh">0x203</span><span class="p">,</span>
	<span class="n">DOMAIN_GROUP_RID_CONTROLLERS</span>	  <span class="o">=</span> <span class="mh">0x204</span><span class="p">,</span>
	<span class="n">DOMAIN_GROUP_RID_CERT_ADMINS</span>	  <span class="o">=</span> <span class="mh">0x205</span><span class="p">,</span>
	<span class="n">DOMAIN_GROUP_RID_SCHEMA_ADMINS</span>	  <span class="o">=</span> <span class="mh">0x206</span><span class="p">,</span>
	<span class="n">DOMAIN_GROUP_RID_ENTERPRISE_ADMINS</span><span class="o">=</span> <span class="mh">0x207</span><span class="p">,</span>
	<span class="n">DOMAIN_GROUP_RID_POLICY_ADMINS</span>	  <span class="o">=</span> <span class="mh">0x208</span><span class="p">,</span>

	<span class="cm">/* Aliases. */</span>
	<span class="n">DOMAIN_ALIAS_RID_ADMINS</span>		  <span class="o">=</span> <span class="mh">0x220</span><span class="p">,</span>
	<span class="n">DOMAIN_ALIAS_RID_USERS</span>		  <span class="o">=</span> <span class="mh">0x221</span><span class="p">,</span>
	<span class="n">DOMAIN_ALIAS_RID_GUESTS</span>		  <span class="o">=</span> <span class="mh">0x222</span><span class="p">,</span>
	<span class="n">DOMAIN_ALIAS_RID_POWER_USERS</span>	  <span class="o">=</span> <span class="mh">0x223</span><span class="p">,</span>

	<span class="n">DOMAIN_ALIAS_RID_ACCOUNT_OPS</span>	  <span class="o">=</span> <span class="mh">0x224</span><span class="p">,</span>
	<span class="n">DOMAIN_ALIAS_RID_SYSTEM_OPS</span>	  <span class="o">=</span> <span class="mh">0x225</span><span class="p">,</span>
	<span class="n">DOMAIN_ALIAS_RID_PRINT_OPS</span>	  <span class="o">=</span> <span class="mh">0x226</span><span class="p">,</span>
	<span class="n">DOMAIN_ALIAS_RID_BACKUP_OPS</span>	  <span class="o">=</span> <span class="mh">0x227</span><span class="p">,</span>

	<span class="n">DOMAIN_ALIAS_RID_REPLICATOR</span>	  <span class="o">=</span> <span class="mh">0x228</span><span class="p">,</span>
	<span class="n">DOMAIN_ALIAS_RID_RAS_SERVERS</span>	  <span class="o">=</span> <span class="mh">0x229</span><span class="p">,</span>
	<span class="n">DOMAIN_ALIAS_RID_PREW2KCOMPACCESS</span> <span class="o">=</span> <span class="mh">0x22a</span><span class="p">,</span>
<span class="p">}</span> <span class="n">RELATIVE_IDENTIFIERS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The universal well-known SIDs:</span>
<span class="cm"> *</span>
<span class="cm"> *	NULL_SID			S-1-0-0</span>
<span class="cm"> *	WORLD_SID			S-1-1-0</span>
<span class="cm"> *	LOCAL_SID			S-1-2-0</span>
<span class="cm"> *	CREATOR_OWNER_SID		S-1-3-0</span>
<span class="cm"> *	CREATOR_GROUP_SID		S-1-3-1</span>
<span class="cm"> *	CREATOR_OWNER_SERVER_SID	S-1-3-2</span>
<span class="cm"> *	CREATOR_GROUP_SERVER_SID	S-1-3-3</span>
<span class="cm"> *</span>
<span class="cm"> *	(Non-unique IDs)		S-1-4</span>
<span class="cm"> *</span>
<span class="cm"> * NT well-known SIDs:</span>
<span class="cm"> *</span>
<span class="cm"> *	NT_AUTHORITY_SID	S-1-5</span>
<span class="cm"> *	DIALUP_SID		S-1-5-1</span>
<span class="cm"> *</span>
<span class="cm"> *	NETWORD_SID		S-1-5-2</span>
<span class="cm"> *	BATCH_SID		S-1-5-3</span>
<span class="cm"> *	INTERACTIVE_SID		S-1-5-4</span>
<span class="cm"> *	SERVICE_SID		S-1-5-6</span>
<span class="cm"> *	ANONYMOUS_LOGON_SID	S-1-5-7		(aka null logon session)</span>
<span class="cm"> *	PROXY_SID		S-1-5-8</span>
<span class="cm"> *	SERVER_LOGON_SID	S-1-5-9		(aka domain controller account)</span>
<span class="cm"> *	SELF_SID		S-1-5-10	(self RID)</span>
<span class="cm"> *	AUTHENTICATED_USER_SID	S-1-5-11</span>
<span class="cm"> *	RESTRICTED_CODE_SID	S-1-5-12	(running restricted code)</span>
<span class="cm"> *	TERMINAL_SERVER_SID	S-1-5-13	(running on terminal server)</span>
<span class="cm"> *</span>
<span class="cm"> *	(Logon IDs)		S-1-5-5-X-Y</span>
<span class="cm"> *</span>
<span class="cm"> *	(NT non-unique IDs)	S-1-5-0x15-...</span>
<span class="cm"> *</span>
<span class="cm"> *	(Built-in domain)	S-1-5-0x20</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The SID_IDENTIFIER_AUTHORITY is a 48-bit value used in the SID structure.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This is stored as a big endian number, hence the high_part comes</span>
<span class="cm"> * before the low_part.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">high_part</span><span class="p">;</span>	<span class="cm">/* High 16-bits. */</span>
		<span class="n">u32</span> <span class="n">low_part</span><span class="p">;</span>	<span class="cm">/* Low 32-bits. */</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">parts</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">value</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>		<span class="cm">/* Value as individual bytes. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">SID_IDENTIFIER_AUTHORITY</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The SID structure is a variable-length structure used to uniquely identify</span>
<span class="cm"> * users or groups. SID stands for security identifier.</span>
<span class="cm"> *</span>
<span class="cm"> * The standard textual representation of the SID is of the form:</span>
<span class="cm"> *	S-R-I-S-S...</span>
<span class="cm"> * Where:</span>
<span class="cm"> *    - The first &quot;S&quot; is the literal character &#39;S&#39; identifying the following</span>
<span class="cm"> *	digits as a SID.</span>
<span class="cm"> *    - R is the revision level of the SID expressed as a sequence of digits</span>
<span class="cm"> *	either in decimal or hexadecimal (if the later, prefixed by &quot;0x&quot;).</span>
<span class="cm"> *    - I is the 48-bit identifier_authority, expressed as digits as R above.</span>
<span class="cm"> *    - S... is one or more sub_authority values, expressed as digits as above.</span>
<span class="cm"> *</span>
<span class="cm"> * Example SID; the domain-relative SID of the local Administrators group on</span>
<span class="cm"> * Windows NT/2k:</span>
<span class="cm"> *	S-1-5-32-544</span>
<span class="cm"> * This translates to a SID with:</span>
<span class="cm"> *	revision = 1,</span>
<span class="cm"> *	sub_authority_count = 2,</span>
<span class="cm"> *	identifier_authority = {0,0,0,0,0,5},	// SECURITY_NT_AUTHORITY</span>
<span class="cm"> *	sub_authority[0] = 32,			// SECURITY_BUILTIN_DOMAIN_RID</span>
<span class="cm"> *	sub_authority[1] = 544			// DOMAIN_ALIAS_RID_ADMINS</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">revision</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sub_authority_count</span><span class="p">;</span>
	<span class="n">SID_IDENTIFIER_AUTHORITY</span> <span class="n">identifier_authority</span><span class="p">;</span>
	<span class="n">le32</span> <span class="n">sub_authority</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>		<span class="cm">/* At least one sub_authority. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">SID</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Current constants for SIDs.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">SID_REVISION</span>			<span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Current revision level. */</span>
	<span class="n">SID_MAX_SUB_AUTHORITIES</span>		<span class="o">=</span> <span class="mi">15</span><span class="p">,</span>	<span class="cm">/* Maximum number of those. */</span>
	<span class="n">SID_RECOMMENDED_SUB_AUTHORITIES</span>	<span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Will change to around 6 in</span>
<span class="cm">						   a future revision. */</span>
<span class="p">}</span> <span class="n">SID_CONSTANTS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The predefined ACE types (8-bit, see below).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ACCESS_MIN_MS_ACE_TYPE</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ACCESS_ALLOWED_ACE_TYPE</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ACCESS_DENIED_ACE_TYPE</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SYSTEM_AUDIT_ACE_TYPE</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">SYSTEM_ALARM_ACE_TYPE</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* Not implemented as of Win2k. */</span>
	<span class="n">ACCESS_MAX_MS_V2_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">ACCESS_ALLOWED_COMPOUND_ACE_TYPE</span><span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">ACCESS_MAX_MS_V3_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

	<span class="cm">/* The following are Win2k only. */</span>
	<span class="n">ACCESS_MIN_MS_OBJECT_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">ACCESS_ALLOWED_OBJECT_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">ACCESS_DENIED_OBJECT_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">SYSTEM_AUDIT_OBJECT_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">SYSTEM_ALARM_OBJECT_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">ACCESS_MAX_MS_OBJECT_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

	<span class="n">ACCESS_MAX_MS_V4_ACE_TYPE</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

	<span class="cm">/* This one is for WinNT/2k. */</span>
	<span class="n">ACCESS_MAX_MS_ACE_TYPE</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">u8</span> <span class="n">ACE_TYPES</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The ACE flags (8-bit) for audit and inheritance (see below).</span>
<span class="cm"> *</span>
<span class="cm"> * SUCCESSFUL_ACCESS_ACE_FLAG is only used with system audit and alarm ACE</span>
<span class="cm"> * types to indicate that a message is generated (in Windows!) for successful</span>
<span class="cm"> * accesses.</span>
<span class="cm"> *</span>
<span class="cm"> * FAILED_ACCESS_ACE_FLAG is only used with system audit and alarm ACE types</span>
<span class="cm"> * to indicate that a message is generated (in Windows!) for failed accesses.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* The inheritance flags. */</span>
	<span class="n">OBJECT_INHERIT_ACE</span>		<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">CONTAINER_INHERIT_ACE</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">NO_PROPAGATE_INHERIT_ACE</span>	<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">INHERIT_ONLY_ACE</span>		<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">INHERITED_ACE</span>			<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>	<span class="cm">/* Win2k only. */</span>
	<span class="n">VALID_INHERIT_FLAGS</span>		<span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>

	<span class="cm">/* The audit flags. */</span>
	<span class="n">SUCCESSFUL_ACCESS_ACE_FLAG</span>	<span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">FAILED_ACCESS_ACE_FLAG</span>		<span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">u8</span> <span class="n">ACE_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * An ACE is an access-control entry in an access-control list (ACL).</span>
<span class="cm"> * An ACE defines access to an object for a specific user or group or defines</span>
<span class="cm"> * the types of access that generate system-administration messages or alarms</span>
<span class="cm"> * for a specific user or group. The user or group is identified by a security</span>
<span class="cm"> * identifier (SID).</span>
<span class="cm"> *</span>
<span class="cm"> * Each ACE starts with an ACE_HEADER structure (aligned on 4-byte boundary),</span>
<span class="cm"> * which specifies the type and size of the ACE. The format of the subsequent</span>
<span class="cm"> * data depends on the ACE type.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0*/</span>	<span class="n">ACE_TYPES</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* Type of the ACE. */</span>
<span class="cm">/*  1*/</span>	<span class="n">ACE_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Flags describing the ACE. */</span>
<span class="cm">/*  2*/</span>	<span class="n">le16</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* Size in bytes of the ACE. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ACE_HEADER</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The access mask (32-bit). Defines the access rights.</span>
<span class="cm"> *</span>
<span class="cm"> * The specific rights (bits 0 to 15).  These depend on the type of the object</span>
<span class="cm"> * being secured by the ACE.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Specific rights for files and directories are as follows: */</span>

	<span class="cm">/* Right to read data from the file. (FILE) */</span>
	<span class="n">FILE_READ_DATA</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>
	<span class="cm">/* Right to list contents of a directory. (DIRECTORY) */</span>
	<span class="n">FILE_LIST_DIRECTORY</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>

	<span class="cm">/* Right to write data to the file. (FILE) */</span>
	<span class="n">FILE_WRITE_DATA</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">),</span>
	<span class="cm">/* Right to create a file in the directory. (DIRECTORY) */</span>
	<span class="n">FILE_ADD_FILE</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">),</span>

	<span class="cm">/* Right to append data to the file. (FILE) */</span>
	<span class="n">FILE_APPEND_DATA</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000004</span><span class="p">),</span>
	<span class="cm">/* Right to create a subdirectory. (DIRECTORY) */</span>
	<span class="n">FILE_ADD_SUBDIRECTORY</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000004</span><span class="p">),</span>

	<span class="cm">/* Right to read extended attributes. (FILE/DIRECTORY) */</span>
	<span class="n">FILE_READ_EA</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000008</span><span class="p">),</span>

	<span class="cm">/* Right to write extended attributes. (FILE/DIRECTORY) */</span>
	<span class="n">FILE_WRITE_EA</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000010</span><span class="p">),</span>

	<span class="cm">/* Right to execute a file. (FILE) */</span>
	<span class="n">FILE_EXECUTE</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000020</span><span class="p">),</span>
	<span class="cm">/* Right to traverse the directory. (DIRECTORY) */</span>
	<span class="n">FILE_TRAVERSE</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000020</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * Right to delete a directory and all the files it contains (its</span>
<span class="cm">	 * children), even if the files are read-only. (DIRECTORY)</span>
<span class="cm">	 */</span>
	<span class="n">FILE_DELETE_CHILD</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000040</span><span class="p">),</span>

	<span class="cm">/* Right to read file attributes. (FILE/DIRECTORY) */</span>
	<span class="n">FILE_READ_ATTRIBUTES</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000080</span><span class="p">),</span>

	<span class="cm">/* Right to change file attributes. (FILE/DIRECTORY) */</span>
	<span class="n">FILE_WRITE_ATTRIBUTES</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000100</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * The standard rights (bits 16 to 23).  These are independent of the</span>
<span class="cm">	 * type of object being secured.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Right to delete the object. */</span>
	<span class="n">DELETE</span>				<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00010000</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * Right to read the information in the object&#39;s security descriptor,</span>
<span class="cm">	 * not including the information in the SACL, i.e. right to read the</span>
<span class="cm">	 * security descriptor and owner.</span>
<span class="cm">	 */</span>
	<span class="n">READ_CONTROL</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00020000</span><span class="p">),</span>

	<span class="cm">/* Right to modify the DACL in the object&#39;s security descriptor. */</span>
	<span class="n">WRITE_DAC</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00040000</span><span class="p">),</span>

	<span class="cm">/* Right to change the owner in the object&#39;s security descriptor. */</span>
	<span class="n">WRITE_OWNER</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00080000</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * Right to use the object for synchronization.  Enables a process to</span>
<span class="cm">	 * wait until the object is in the signalled state.  Some object types</span>
<span class="cm">	 * do not support this access right.</span>
<span class="cm">	 */</span>
	<span class="n">SYNCHRONIZE</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00100000</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following STANDARD_RIGHTS_* are combinations of the above for</span>
<span class="cm">	 * convenience and are defined by the Win32 API.</span>
<span class="cm">	 */</span>

	<span class="cm">/* These are currently defined to READ_CONTROL. */</span>
	<span class="n">STANDARD_RIGHTS_READ</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00020000</span><span class="p">),</span>
	<span class="n">STANDARD_RIGHTS_WRITE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00020000</span><span class="p">),</span>
	<span class="n">STANDARD_RIGHTS_EXECUTE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00020000</span><span class="p">),</span>

	<span class="cm">/* Combines DELETE, READ_CONTROL, WRITE_DAC, and WRITE_OWNER access. */</span>
	<span class="n">STANDARD_RIGHTS_REQUIRED</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x000f0000</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * Combines DELETE, READ_CONTROL, WRITE_DAC, WRITE_OWNER, and</span>
<span class="cm">	 * SYNCHRONIZE access.</span>
<span class="cm">	 */</span>
	<span class="n">STANDARD_RIGHTS_ALL</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x001f0000</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * The access system ACL and maximum allowed access types (bits 24 to</span>
<span class="cm">	 * 25, bits 26 to 27 are reserved).</span>
<span class="cm">	 */</span>
	<span class="n">ACCESS_SYSTEM_SECURITY</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x01000000</span><span class="p">),</span>
	<span class="n">MAXIMUM_ALLOWED</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x02000000</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * The generic rights (bits 28 to 31).  These map onto the standard and</span>
<span class="cm">	 * specific rights.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Read, write, and execute access. */</span>
	<span class="n">GENERIC_ALL</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x10000000</span><span class="p">),</span>

	<span class="cm">/* Execute access. */</span>
	<span class="n">GENERIC_EXECUTE</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x20000000</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write access.  For files, this maps onto:</span>
<span class="cm">	 *	FILE_APPEND_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA |</span>
<span class="cm">	 *	FILE_WRITE_EA | STANDARD_RIGHTS_WRITE | SYNCHRONIZE</span>
<span class="cm">	 * For directories, the mapping has the same numerical value.  See</span>
<span class="cm">	 * above for the descriptions of the rights granted.</span>
<span class="cm">	 */</span>
	<span class="n">GENERIC_WRITE</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read access.  For files, this maps onto:</span>
<span class="cm">	 *	FILE_READ_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA |</span>
<span class="cm">	 *	STANDARD_RIGHTS_READ | SYNCHRONIZE</span>
<span class="cm">	 * For directories, the mapping has the same numberical value.  See</span>
<span class="cm">	 * above for the descriptions of the rights granted.</span>
<span class="cm">	 */</span>
	<span class="n">GENERIC_READ</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">ACCESS_MASK</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The generic mapping array. Used to denote the mapping of each generic</span>
<span class="cm"> * access right to a specific access mask.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: What exactly is this and what is it for? (AIA)</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">ACCESS_MASK</span> <span class="n">generic_read</span><span class="p">;</span>
	<span class="n">ACCESS_MASK</span> <span class="n">generic_write</span><span class="p">;</span>
	<span class="n">ACCESS_MASK</span> <span class="n">generic_execute</span><span class="p">;</span>
	<span class="n">ACCESS_MASK</span> <span class="n">generic_all</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">GENERIC_MAPPING</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The predefined ACE type structures are as defined below.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE, SYSTEM_AUDIT_ACE, SYSTEM_ALARM_ACE</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*  0	ACE_HEADER; -- Unfolded here as gcc doesn&#39;t like unnamed structs. */</span>
	<span class="n">ACE_TYPES</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* Type of the ACE. */</span>
	<span class="n">ACE_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Flags describing the ACE. */</span>
	<span class="n">le16</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* Size in bytes of the ACE. */</span>
<span class="cm">/*  4*/</span>	<span class="n">ACCESS_MASK</span> <span class="n">mask</span><span class="p">;</span>	<span class="cm">/* Access mask associated with the ACE. */</span>

<span class="cm">/*  8*/</span>	<span class="n">SID</span> <span class="n">sid</span><span class="p">;</span>		<span class="cm">/* The SID associated with the ACE. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ACCESS_ALLOWED_ACE</span><span class="p">,</span> <span class="n">ACCESS_DENIED_ACE</span><span class="p">,</span>
			       <span class="n">SYSTEM_AUDIT_ACE</span><span class="p">,</span> <span class="n">SYSTEM_ALARM_ACE</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The object ACE flags (32-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ACE_OBJECT_TYPE_PRESENT</span>			<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
	<span class="n">ACE_INHERITED_OBJECT_TYPE_PRESENT</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">OBJECT_ACE_FLAGS</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*  0	ACE_HEADER; -- Unfolded here as gcc doesn&#39;t like unnamed structs. */</span>
	<span class="n">ACE_TYPES</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* Type of the ACE. */</span>
	<span class="n">ACE_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Flags describing the ACE. */</span>
	<span class="n">le16</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* Size in bytes of the ACE. */</span>
<span class="cm">/*  4*/</span>	<span class="n">ACCESS_MASK</span> <span class="n">mask</span><span class="p">;</span>	<span class="cm">/* Access mask associated with the ACE. */</span>

<span class="cm">/*  8*/</span>	<span class="n">OBJECT_ACE_FLAGS</span> <span class="n">object_flags</span><span class="p">;</span>	<span class="cm">/* Flags describing the object ACE. */</span>
<span class="cm">/* 12*/</span>	<span class="n">GUID</span> <span class="n">object_type</span><span class="p">;</span>
<span class="cm">/* 28*/</span>	<span class="n">GUID</span> <span class="n">inherited_object_type</span><span class="p">;</span>

<span class="cm">/* 44*/</span>	<span class="n">SID</span> <span class="n">sid</span><span class="p">;</span>		<span class="cm">/* The SID associated with the ACE. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ACCESS_ALLOWED_OBJECT_ACE</span><span class="p">,</span>
			       <span class="n">ACCESS_DENIED_OBJECT_ACE</span><span class="p">,</span>
			       <span class="n">SYSTEM_AUDIT_OBJECT_ACE</span><span class="p">,</span>
			       <span class="n">SYSTEM_ALARM_OBJECT_ACE</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * An ACL is an access-control list (ACL).</span>
<span class="cm"> * An ACL starts with an ACL header structure, which specifies the size of</span>
<span class="cm"> * the ACL and the number of ACEs it contains. The ACL header is followed by</span>
<span class="cm"> * zero or more access control entries (ACEs). The ACL as well as each ACE</span>
<span class="cm"> * are aligned on 4-byte boundaries.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">revision</span><span class="p">;</span>	<span class="cm">/* Revision of this ACL. */</span>
	<span class="n">u8</span> <span class="n">alignment1</span><span class="p">;</span>
	<span class="n">le16</span> <span class="n">size</span><span class="p">;</span>	<span class="cm">/* Allocated space in bytes for ACL. Includes this</span>
<span class="cm">			   header, the ACEs and the remaining free space. */</span>
	<span class="n">le16</span> <span class="n">ace_count</span><span class="p">;</span>	<span class="cm">/* Number of ACEs in the ACL. */</span>
	<span class="n">le16</span> <span class="n">alignment2</span><span class="p">;</span>
<span class="cm">/* sizeof() = 8 bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">ACL</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Current constants for ACLs.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Current revision. */</span>
	<span class="n">ACL_REVISION</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">ACL_REVISION_DS</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

	<span class="cm">/* History of revisions. */</span>
	<span class="n">ACL_REVISION1</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">MIN_ACL_REVISION</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">ACL_REVISION2</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">ACL_REVISION3</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">ACL_REVISION4</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">MAX_ACL_REVISION</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span> <span class="n">ACL_CONSTANTS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The security descriptor control flags (16-bit).</span>
<span class="cm"> *</span>
<span class="cm"> * SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the SID</span>
<span class="cm"> *	pointed to by the Owner field was provided by a defaulting mechanism</span>
<span class="cm"> *	rather than explicitly provided by the original provider of the</span>
<span class="cm"> *	security descriptor.  This may affect the treatment of the SID with</span>
<span class="cm"> *	respect to inheritance of an owner.</span>
<span class="cm"> *</span>
<span class="cm"> * SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the SID in</span>
<span class="cm"> *	the Group field was provided by a defaulting mechanism rather than</span>
<span class="cm"> *	explicitly provided by the original provider of the security</span>
<span class="cm"> *	descriptor.  This may affect the treatment of the SID with respect to</span>
<span class="cm"> *	inheritance of a primary group.</span>
<span class="cm"> *</span>
<span class="cm"> * SE_DACL_PRESENT - This boolean flag, when set, indicates that the security</span>
<span class="cm"> *	descriptor contains a discretionary ACL.  If this flag is set and the</span>
<span class="cm"> *	Dacl field of the SECURITY_DESCRIPTOR is null, then a null ACL is</span>
<span class="cm"> *	explicitly being specified.</span>
<span class="cm"> *</span>
<span class="cm"> * SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the ACL</span>
<span class="cm"> *	pointed to by the Dacl field was provided by a defaulting mechanism</span>
<span class="cm"> *	rather than explicitly provided by the original provider of the</span>
<span class="cm"> *	security descriptor.  This may affect the treatment of the ACL with</span>
<span class="cm"> *	respect to inheritance of an ACL.  This flag is ignored if the</span>
<span class="cm"> *	DaclPresent flag is not set.</span>
<span class="cm"> *</span>
<span class="cm"> * SE_SACL_PRESENT - This boolean flag, when set,  indicates that the security</span>
<span class="cm"> *	descriptor contains a system ACL pointed to by the Sacl field.  If this</span>
<span class="cm"> *	flag is set and the Sacl field of the SECURITY_DESCRIPTOR is null, then</span>
<span class="cm"> *	an empty (but present) ACL is being specified.</span>
<span class="cm"> *</span>
<span class="cm"> * SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the ACL</span>
<span class="cm"> *	pointed to by the Sacl field was provided by a defaulting mechanism</span>
<span class="cm"> *	rather than explicitly provided by the original provider of the</span>
<span class="cm"> *	security descriptor.  This may affect the treatment of the ACL with</span>
<span class="cm"> *	respect to inheritance of an ACL.  This flag is ignored if the</span>
<span class="cm"> *	SaclPresent flag is not set.</span>
<span class="cm"> *</span>
<span class="cm"> * SE_SELF_RELATIVE - This boolean flag, when set, indicates that the security</span>
<span class="cm"> *	descriptor is in self-relative form.  In this form, all fields of the</span>
<span class="cm"> *	security descriptor are contiguous in memory and all pointer fields are</span>
<span class="cm"> *	expressed as offsets from the beginning of the security descriptor.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SE_OWNER_DEFAULTED</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">),</span>
	<span class="n">SE_GROUP_DEFAULTED</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">),</span>
	<span class="n">SE_DACL_PRESENT</span>			<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0004</span><span class="p">),</span>
	<span class="n">SE_DACL_DEFAULTED</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0008</span><span class="p">),</span>

	<span class="n">SE_SACL_PRESENT</span>			<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0010</span><span class="p">),</span>
	<span class="n">SE_SACL_DEFAULTED</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0020</span><span class="p">),</span>

	<span class="n">SE_DACL_AUTO_INHERIT_REQ</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0100</span><span class="p">),</span>
	<span class="n">SE_SACL_AUTO_INHERIT_REQ</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0200</span><span class="p">),</span>
	<span class="n">SE_DACL_AUTO_INHERITED</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0400</span><span class="p">),</span>
	<span class="n">SE_SACL_AUTO_INHERITED</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0800</span><span class="p">),</span>

	<span class="n">SE_DACL_PROTECTED</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">),</span>
	<span class="n">SE_SACL_PROTECTED</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x2000</span><span class="p">),</span>
	<span class="n">SE_RM_CONTROL_VALID</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">),</span>
	<span class="n">SE_SELF_RELATIVE</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">)</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">le16</span> <span class="n">SECURITY_DESCRIPTOR_CONTROL</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Self-relative security descriptor. Contains the owner and group SIDs as well</span>
<span class="cm"> * as the sacl and dacl ACLs inside the security descriptor itself.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">revision</span><span class="p">;</span>	<span class="cm">/* Revision level of the security descriptor. */</span>
	<span class="n">u8</span> <span class="n">alignment</span><span class="p">;</span>
	<span class="n">SECURITY_DESCRIPTOR_CONTROL</span> <span class="n">control</span><span class="p">;</span> <span class="cm">/* Flags qualifying the type of</span>
<span class="cm">			   the descriptor as well as the following fields. */</span>
	<span class="n">le32</span> <span class="n">owner</span><span class="p">;</span>	<span class="cm">/* Byte offset to a SID representing an object&#39;s</span>
<span class="cm">			   owner. If this is NULL, no owner SID is present in</span>
<span class="cm">			   the descriptor. */</span>
	<span class="n">le32</span> <span class="n">group</span><span class="p">;</span>	<span class="cm">/* Byte offset to a SID representing an object&#39;s</span>
<span class="cm">			   primary group. If this is NULL, no primary group</span>
<span class="cm">			   SID is present in the descriptor. */</span>
	<span class="n">le32</span> <span class="n">sacl</span><span class="p">;</span>	<span class="cm">/* Byte offset to a system ACL. Only valid, if</span>
<span class="cm">			   SE_SACL_PRESENT is set in the control field. If</span>
<span class="cm">			   SE_SACL_PRESENT is set but sacl is NULL, a NULL ACL</span>
<span class="cm">			   is specified. */</span>
	<span class="n">le32</span> <span class="n">dacl</span><span class="p">;</span>	<span class="cm">/* Byte offset to a discretionary ACL. Only valid, if</span>
<span class="cm">			   SE_DACL_PRESENT is set in the control field. If</span>
<span class="cm">			   SE_DACL_PRESENT is set but dacl is NULL, a NULL ACL</span>
<span class="cm">			   (unconditionally granting access) is specified. */</span>
<span class="cm">/* sizeof() = 0x14 bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">SECURITY_DESCRIPTOR_RELATIVE</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Absolute security descriptor. Does not contain the owner and group SIDs, nor</span>
<span class="cm"> * the sacl and dacl ACLs inside the security descriptor. Instead, it contains</span>
<span class="cm"> * pointers to these structures in memory. Obviously, absolute security</span>
<span class="cm"> * descriptors are only useful for in memory representations of security</span>
<span class="cm"> * descriptors. On disk, a self-relative security descriptor is used.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">revision</span><span class="p">;</span>	<span class="cm">/* Revision level of the security descriptor. */</span>
	<span class="n">u8</span> <span class="n">alignment</span><span class="p">;</span>
	<span class="n">SECURITY_DESCRIPTOR_CONTROL</span> <span class="n">control</span><span class="p">;</span>	<span class="cm">/* Flags qualifying the type of</span>
<span class="cm">			   the descriptor as well as the following fields. */</span>
	<span class="n">SID</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>	<span class="cm">/* Points to a SID representing an object&#39;s owner. If</span>
<span class="cm">			   this is NULL, no owner SID is present in the</span>
<span class="cm">			   descriptor. */</span>
	<span class="n">SID</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>	<span class="cm">/* Points to a SID representing an object&#39;s primary</span>
<span class="cm">			   group. If this is NULL, no primary group SID is</span>
<span class="cm">			   present in the descriptor. */</span>
	<span class="n">ACL</span> <span class="o">*</span><span class="n">sacl</span><span class="p">;</span>	<span class="cm">/* Points to a system ACL. Only valid, if</span>
<span class="cm">			   SE_SACL_PRESENT is set in the control field. If</span>
<span class="cm">			   SE_SACL_PRESENT is set but sacl is NULL, a NULL ACL</span>
<span class="cm">			   is specified. */</span>
	<span class="n">ACL</span> <span class="o">*</span><span class="n">dacl</span><span class="p">;</span>	<span class="cm">/* Points to a discretionary ACL. Only valid, if</span>
<span class="cm">			   SE_DACL_PRESENT is set in the control field. If</span>
<span class="cm">			   SE_DACL_PRESENT is set but dacl is NULL, a NULL ACL</span>
<span class="cm">			   (unconditionally granting access) is specified. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">SECURITY_DESCRIPTOR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Current constants for security descriptors.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Current revision. */</span>
	<span class="n">SECURITY_DESCRIPTOR_REVISION</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SECURITY_DESCRIPTOR_REVISION1</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* The sizes of both the absolute and relative security descriptors is</span>
<span class="cm">	   the same as pointers, at least on ia32 architecture are 32-bit. */</span>
	<span class="n">SECURITY_DESCRIPTOR_MIN_LENGTH</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SECURITY_DESCRIPTOR</span><span class="p">),</span>
<span class="p">}</span> <span class="n">SECURITY_DESCRIPTOR_CONSTANTS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Security descriptor (0x50). A standard self-relative security</span>
<span class="cm"> * descriptor.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Can be resident or non-resident.</span>
<span class="cm"> * NOTE: Not used in NTFS 3.0+, as security descriptors are stored centrally</span>
<span class="cm"> * in FILE_Secure and the correct descriptor is found using the security_id</span>
<span class="cm"> * from the standard information attribute.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">SECURITY_DESCRIPTOR_RELATIVE</span> <span class="n">SECURITY_DESCRIPTOR_ATTR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * On NTFS 3.0+, all security descriptors are stored in FILE_Secure. Only one</span>
<span class="cm"> * referenced instance of each unique security descriptor is stored.</span>
<span class="cm"> *</span>
<span class="cm"> * FILE_Secure contains no unnamed data attribute, i.e. it has zero length. It</span>
<span class="cm"> * does, however, contain two indexes ($SDH and $SII) as well as a named data</span>
<span class="cm"> * stream ($SDS).</span>
<span class="cm"> *</span>
<span class="cm"> * Every unique security descriptor is assigned a unique security identifier</span>
<span class="cm"> * (security_id, not to be confused with a SID). The security_id is unique for</span>
<span class="cm"> * the NTFS volume and is used as an index into the $SII index, which maps</span>
<span class="cm"> * security_ids to the security descriptor&#39;s storage location within the $SDS</span>
<span class="cm"> * data attribute. The $SII index is sorted by ascending security_id.</span>
<span class="cm"> *</span>
<span class="cm"> * A simple hash is computed from each security descriptor. This hash is used</span>
<span class="cm"> * as an index into the $SDH index, which maps security descriptor hashes to</span>
<span class="cm"> * the security descriptor&#39;s storage location within the $SDS data attribute.</span>
<span class="cm"> * The $SDH index is sorted by security descriptor hash and is stored in a B+</span>
<span class="cm"> * tree. When searching $SDH (with the intent of determining whether or not a</span>
<span class="cm"> * new security descriptor is already present in the $SDS data stream), if a</span>
<span class="cm"> * matching hash is found, but the security descriptors do not match, the</span>
<span class="cm"> * search in the $SDH index is continued, searching for a next matching hash.</span>
<span class="cm"> *</span>
<span class="cm"> * When a precise match is found, the security_id coresponding to the security</span>
<span class="cm"> * descriptor in the $SDS attribute is read from the found $SDH index entry and</span>
<span class="cm"> * is stored in the $STANDARD_INFORMATION attribute of the file/directory to</span>
<span class="cm"> * which the security descriptor is being applied. The $STANDARD_INFORMATION</span>
<span class="cm"> * attribute is present in all base mft records (i.e. in all files and</span>
<span class="cm"> * directories).</span>
<span class="cm"> *</span>
<span class="cm"> * If a match is not found, the security descriptor is assigned a new unique</span>
<span class="cm"> * security_id and is added to the $SDS data attribute. Then, entries</span>
<span class="cm"> * referencing the this security descriptor in the $SDS data attribute are</span>
<span class="cm"> * added to the $SDH and $SII indexes.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Entries are never deleted from FILE_Secure, even if nothing</span>
<span class="cm"> * references an entry any more.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This header precedes each security descriptor in the $SDS data stream.</span>
<span class="cm"> * This is also the index entry data part of both the $SII and $SDH indexes.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">hash</span><span class="p">;</span>	  <span class="cm">/* Hash of the security descriptor. */</span>
	<span class="n">le32</span> <span class="n">security_id</span><span class="p">;</span> <span class="cm">/* The security_id assigned to the descriptor. */</span>
	<span class="n">le64</span> <span class="n">offset</span><span class="p">;</span>	  <span class="cm">/* Byte offset of this entry in the $SDS stream. */</span>
	<span class="n">le32</span> <span class="n">length</span><span class="p">;</span>	  <span class="cm">/* Size in bytes of this entry in $SDS stream. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">SECURITY_DESCRIPTOR_HEADER</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The $SDS data stream contains the security descriptors, aligned on 16-byte</span>
<span class="cm"> * boundaries, sorted by security_id in a B+ tree. Security descriptors cannot</span>
<span class="cm"> * cross 256kib boundaries (this restriction is imposed by the Windows cache</span>
<span class="cm"> * manager). Each security descriptor is contained in a SDS_ENTRY structure.</span>
<span class="cm"> * Also, each security descriptor is stored twice in the $SDS stream with a</span>
<span class="cm"> * fixed offset of 0x40000 bytes (256kib, the Windows cache manager&#39;s max size)</span>
<span class="cm"> * between them; i.e. if a SDS_ENTRY specifies an offset of 0x51d0, then the</span>
<span class="cm"> * the first copy of the security descriptor will be at offset 0x51d0 in the</span>
<span class="cm"> * $SDS data stream and the second copy will be at offset 0x451d0.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0	SECURITY_DESCRIPTOR_HEADER; -- Unfolded here as gcc doesn&#39;t like</span>
<span class="cm">				       unnamed structs. */</span>
	<span class="n">le32</span> <span class="n">hash</span><span class="p">;</span>	  <span class="cm">/* Hash of the security descriptor. */</span>
	<span class="n">le32</span> <span class="n">security_id</span><span class="p">;</span> <span class="cm">/* The security_id assigned to the descriptor. */</span>
	<span class="n">le64</span> <span class="n">offset</span><span class="p">;</span>	  <span class="cm">/* Byte offset of this entry in the $SDS stream. */</span>
	<span class="n">le32</span> <span class="n">length</span><span class="p">;</span>	  <span class="cm">/* Size in bytes of this entry in $SDS stream. */</span>
<span class="cm">/* 20*/</span>	<span class="n">SECURITY_DESCRIPTOR_RELATIVE</span> <span class="n">sid</span><span class="p">;</span> <span class="cm">/* The self-relative security</span>
<span class="cm">					     descriptor. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">SDS_ENTRY</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The index entry key used in the $SII index. The collation type is</span>
<span class="cm"> * COLLATION_NTOFS_ULONG.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">security_id</span><span class="p">;</span> <span class="cm">/* The security_id assigned to the descriptor. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">SII_INDEX_KEY</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The index entry key used in the $SDH index. The keys are sorted first by</span>
<span class="cm"> * hash and then by security_id. The collation rule is</span>
<span class="cm"> * COLLATION_NTOFS_SECURITY_HASH.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">hash</span><span class="p">;</span>	  <span class="cm">/* Hash of the security descriptor. */</span>
	<span class="n">le32</span> <span class="n">security_id</span><span class="p">;</span> <span class="cm">/* The security_id assigned to the descriptor. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">SDH_INDEX_KEY</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Volume name (0x60).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Always resident.</span>
<span class="cm"> * NOTE: Present only in FILE_Volume.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">ntfschar</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* The name of the volume in Unicode. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">VOLUME_NAME</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Possible flags for the volume (16-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">VOLUME_IS_DIRTY</span>			<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">),</span>
	<span class="n">VOLUME_RESIZE_LOG_FILE</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">),</span>
	<span class="n">VOLUME_UPGRADE_ON_MOUNT</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0004</span><span class="p">),</span>
	<span class="n">VOLUME_MOUNTED_ON_NT4</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0008</span><span class="p">),</span>

	<span class="n">VOLUME_DELETE_USN_UNDERWAY</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0010</span><span class="p">),</span>
	<span class="n">VOLUME_REPAIR_OBJECT_ID</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0020</span><span class="p">),</span>

	<span class="n">VOLUME_CHKDSK_UNDERWAY</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">),</span>
	<span class="n">VOLUME_MODIFIED_BY_CHKDSK</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">),</span>

	<span class="n">VOLUME_FLAGS_MASK</span>		<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0xc03f</span><span class="p">),</span>

	<span class="cm">/* To make our life easier when checking if we must mount read-only. */</span>
	<span class="n">VOLUME_MUST_MOUNT_RO_MASK</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0xc027</span><span class="p">),</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">le16</span> <span class="n">VOLUME_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Volume information (0x70).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Always resident.</span>
<span class="cm"> * NOTE: Present only in FILE_Volume.</span>
<span class="cm"> * NOTE: Windows 2000 uses NTFS 3.0 while Windows NT4 service pack 6a uses</span>
<span class="cm"> *	 NTFS 1.2. I haven&#39;t personally seen other values yet.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le64</span> <span class="n">reserved</span><span class="p">;</span>		<span class="cm">/* Not used (yet?). */</span>
	<span class="n">u8</span> <span class="n">major_ver</span><span class="p">;</span>		<span class="cm">/* Major version of the ntfs format. */</span>
	<span class="n">u8</span> <span class="n">minor_ver</span><span class="p">;</span>		<span class="cm">/* Minor version of the ntfs format. */</span>
	<span class="n">VOLUME_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Bit array of VOLUME_* flags. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">VOLUME_INFORMATION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Data attribute (0x80).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Can be resident or non-resident.</span>
<span class="cm"> *</span>
<span class="cm"> * Data contents of a file (i.e. the unnamed stream) or of a named stream.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>		<span class="cm">/* The file&#39;s data contents. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">DATA_ATTR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Index header flags (8-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * When index header is in an index root attribute:</span>
<span class="cm">	 */</span>
	<span class="n">SMALL_INDEX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* The index is small enough to fit inside the index</span>
<span class="cm">			    root attribute and there is no index allocation</span>
<span class="cm">			    attribute present. */</span>
	<span class="n">LARGE_INDEX</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* The index is too large to fit in the index root</span>
<span class="cm">			    attribute and/or an index allocation attribute is</span>
<span class="cm">			    present. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * When index header is in an index block, i.e. is part of index</span>
<span class="cm">	 * allocation attribute:</span>
<span class="cm">	 */</span>
	<span class="n">LEAF_NODE</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* This is a leaf node, i.e. there are no more nodes</span>
<span class="cm">			   branching off it. */</span>
	<span class="n">INDEX_NODE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* This node indexes other nodes, i.e. it is not a leaf</span>
<span class="cm">			   node. */</span>
	<span class="n">NODE_MASK</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* Mask for accessing the *_NODE bits. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">u8</span> <span class="n">INDEX_HEADER_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the header for indexes, describing the INDEX_ENTRY records, which</span>
<span class="cm"> * follow the INDEX_HEADER. Together the index header and the index entries</span>
<span class="cm"> * make up a complete index.</span>
<span class="cm"> *</span>
<span class="cm"> * IMPORTANT NOTE: The offset, length and size structure members are counted</span>
<span class="cm"> * relative to the start of the index header structure and not relative to the</span>
<span class="cm"> * start of the index root or index allocation structures themselves.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">entries_offset</span><span class="p">;</span>		<span class="cm">/* Byte offset to first INDEX_ENTRY</span>
<span class="cm">					   aligned to 8-byte boundary. */</span>
	<span class="n">le32</span> <span class="n">index_length</span><span class="p">;</span>		<span class="cm">/* Data size of the index in bytes,</span>
<span class="cm">					   i.e. bytes used from allocated</span>
<span class="cm">					   size, aligned to 8-byte boundary. */</span>
	<span class="n">le32</span> <span class="n">allocated_size</span><span class="p">;</span>		<span class="cm">/* Byte size of this index (block),</span>
<span class="cm">					   multiple of 8 bytes. */</span>
	<span class="cm">/* NOTE: For the index root attribute, the above two numbers are always</span>
<span class="cm">	   equal, as the attribute is resident and it is resized as needed. In</span>
<span class="cm">	   the case of the index allocation attribute the attribute is not</span>
<span class="cm">	   resident and hence the allocated_size is a fixed value and must</span>
<span class="cm">	   equal the index_block_size specified by the INDEX_ROOT attribute</span>
<span class="cm">	   corresponding to the INDEX_ALLOCATION attribute this INDEX_BLOCK</span>
<span class="cm">	   belongs to. */</span>
	<span class="n">INDEX_HEADER_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Bit field of INDEX_HEADER_FLAGS. */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="cm">/* Reserved/align to 8-byte boundary. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">INDEX_HEADER</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Index root (0x90).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Always resident.</span>
<span class="cm"> *</span>
<span class="cm"> * This is followed by a sequence of index entries (INDEX_ENTRY structures)</span>
<span class="cm"> * as described by the index header.</span>
<span class="cm"> *</span>
<span class="cm"> * When a directory is small enough to fit inside the index root then this</span>
<span class="cm"> * is the only attribute describing the directory. When the directory is too</span>
<span class="cm"> * large to fit in the index root, on the other hand, two additional attributes</span>
<span class="cm"> * are present: an index allocation attribute, containing sub-nodes of the B+</span>
<span class="cm"> * directory tree (see below), and a bitmap attribute, describing which virtual</span>
<span class="cm"> * cluster numbers (vcns) in the index allocation attribute are in use by an</span>
<span class="cm"> * index block.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The root directory (FILE_root) contains an entry for itself. Other</span>
<span class="cm"> * directories do not contain entries for themselves, though.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">ATTR_TYPE</span> <span class="n">type</span><span class="p">;</span>			<span class="cm">/* Type of the indexed attribute. Is</span>
<span class="cm">					   $FILE_NAME for directories, zero</span>
<span class="cm">					   for view indexes. No other values</span>
<span class="cm">					   allowed. */</span>
	<span class="n">COLLATION_RULE</span> <span class="n">collation_rule</span><span class="p">;</span>	<span class="cm">/* Collation rule used to sort the</span>
<span class="cm">					   index entries. If type is $FILE_NAME,</span>
<span class="cm">					   this must be COLLATION_FILE_NAME. */</span>
	<span class="n">le32</span> <span class="n">index_block_size</span><span class="p">;</span>		<span class="cm">/* Size of each index block in bytes (in</span>
<span class="cm">					   the index allocation attribute). */</span>
	<span class="n">u8</span> <span class="n">clusters_per_index_block</span><span class="p">;</span>	<span class="cm">/* Cluster size of each index block (in</span>
<span class="cm">					   the index allocation attribute), when</span>
<span class="cm">					   an index block is &gt;= than a cluster,</span>
<span class="cm">					   otherwise this will be the log of</span>
<span class="cm">					   the size (like how the encoding of</span>
<span class="cm">					   the mft record size and the index</span>
<span class="cm">					   record size found in the boot sector</span>
<span class="cm">					   work). Has to be a power of 2. */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="cm">/* Reserved/align to 8-byte boundary. */</span>
	<span class="n">INDEX_HEADER</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* Index header describing the</span>
<span class="cm">					   following index entries. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">INDEX_ROOT</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Index allocation (0xa0).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Always non-resident (doesn&#39;t make sense to be resident anyway!).</span>
<span class="cm"> *</span>
<span class="cm"> * This is an array of index blocks. Each index block starts with an</span>
<span class="cm"> * INDEX_BLOCK structure containing an index header, followed by a sequence of</span>
<span class="cm"> * index entries (INDEX_ENTRY structures), as described by the INDEX_HEADER.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn&#39;t like unnamed structs. */</span>
	<span class="n">NTFS_RECORD_TYPE</span> <span class="n">magic</span><span class="p">;</span>	<span class="cm">/* Magic is &quot;INDX&quot;. */</span>
	<span class="n">le16</span> <span class="n">usa_ofs</span><span class="p">;</span>		<span class="cm">/* See NTFS_RECORD definition. */</span>
	<span class="n">le16</span> <span class="n">usa_count</span><span class="p">;</span>		<span class="cm">/* See NTFS_RECORD definition. */</span>

<span class="cm">/*  8*/</span>	<span class="n">sle64</span> <span class="n">lsn</span><span class="p">;</span>		<span class="cm">/* $LogFile sequence number of the last</span>
<span class="cm">				   modification of this index block. */</span>
<span class="cm">/* 16*/</span>	<span class="n">leVCN</span> <span class="n">index_block_vcn</span><span class="p">;</span>	<span class="cm">/* Virtual cluster number of the index block.</span>
<span class="cm">				   If the cluster_size on the volume is &lt;= the</span>
<span class="cm">				   index_block_size of the directory,</span>
<span class="cm">				   index_block_vcn counts in units of clusters,</span>
<span class="cm">				   and in units of sectors otherwise. */</span>
<span class="cm">/* 24*/</span>	<span class="n">INDEX_HEADER</span> <span class="n">index</span><span class="p">;</span>	<span class="cm">/* Describes the following index entries. */</span>
<span class="cm">/* sizeof()= 40 (0x28) bytes */</span>
<span class="cm">/*</span>
<span class="cm"> * When creating the index block, we place the update sequence array at this</span>
<span class="cm"> * offset, i.e. before we start with the index entries. This also makes sense,</span>
<span class="cm"> * otherwise we could run into problems with the update sequence array</span>
<span class="cm"> * containing in itself the last two bytes of a sector which would mean that</span>
<span class="cm"> * multi sector transfer protection wouldn&#39;t work. As you can&#39;t protect data</span>
<span class="cm"> * by overwriting it since you then can&#39;t get it back...</span>
<span class="cm"> * When reading use the data from the ntfs record header.</span>
<span class="cm"> */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">INDEX_BLOCK</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">INDEX_BLOCK</span> <span class="n">INDEX_ALLOCATION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The system file FILE_Extend/$Reparse contains an index named $R listing</span>
<span class="cm"> * all reparse points on the volume. The index entry keys are as defined</span>
<span class="cm"> * below. Note, that there is no index data associated with the index entries.</span>
<span class="cm"> *</span>
<span class="cm"> * The index entries are sorted by the index key file_id. The collation rule is</span>
<span class="cm"> * COLLATION_NTOFS_ULONGS. FIXME: Verify whether the reparse_tag is not the</span>
<span class="cm"> * primary key / is not a key at all. (AIA)</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">reparse_tag</span><span class="p">;</span>	<span class="cm">/* Reparse point type (inc. flags). */</span>
	<span class="n">leMFT_REF</span> <span class="n">file_id</span><span class="p">;</span>	<span class="cm">/* Mft record of the file containing the</span>
<span class="cm">				   reparse point attribute. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">REPARSE_INDEX_KEY</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Quota flags (32-bit).</span>
<span class="cm"> *</span>
<span class="cm"> * The user quota flags.  Names explain meaning.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">QUOTA_FLAG_DEFAULT_LIMITS</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>
	<span class="n">QUOTA_FLAG_LIMIT_REACHED</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">),</span>
	<span class="n">QUOTA_FLAG_ID_DELETED</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000004</span><span class="p">),</span>

	<span class="n">QUOTA_FLAG_USER_MASK</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000007</span><span class="p">),</span>
	<span class="cm">/* This is a bit mask for the user quota flags. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * These flags are only present in the quota defaults index entry, i.e.</span>
<span class="cm">	 * in the entry where owner_id = QUOTA_DEFAULTS_ID.</span>
<span class="cm">	 */</span>
	<span class="n">QUOTA_FLAG_TRACKING_ENABLED</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000010</span><span class="p">),</span>
	<span class="n">QUOTA_FLAG_ENFORCEMENT_ENABLED</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000020</span><span class="p">),</span>
	<span class="n">QUOTA_FLAG_TRACKING_REQUESTED</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000040</span><span class="p">),</span>
	<span class="n">QUOTA_FLAG_LOG_THRESHOLD</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000080</span><span class="p">),</span>

	<span class="n">QUOTA_FLAG_LOG_LIMIT</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000100</span><span class="p">),</span>
	<span class="n">QUOTA_FLAG_OUT_OF_DATE</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000200</span><span class="p">),</span>
	<span class="n">QUOTA_FLAG_CORRUPT</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000400</span><span class="p">),</span>
	<span class="n">QUOTA_FLAG_PENDING_DELETES</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000800</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">le32</span> <span class="n">QUOTA_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The system file FILE_Extend/$Quota contains two indexes $O and $Q. Quotas</span>
<span class="cm"> * are on a per volume and per user basis.</span>
<span class="cm"> *</span>
<span class="cm"> * The $Q index contains one entry for each existing user_id on the volume. The</span>
<span class="cm"> * index key is the user_id of the user/group owning this quota control entry,</span>
<span class="cm"> * i.e. the key is the owner_id. The user_id of the owner of a file, i.e. the</span>
<span class="cm"> * owner_id, is found in the standard information attribute. The collation rule</span>
<span class="cm"> * for $Q is COLLATION_NTOFS_ULONG.</span>
<span class="cm"> *</span>
<span class="cm"> * The $O index contains one entry for each user/group who has been assigned</span>
<span class="cm"> * a quota on that volume. The index key holds the SID of the user_id the</span>
<span class="cm"> * entry belongs to, i.e. the owner_id. The collation rule for $O is</span>
<span class="cm"> * COLLATION_NTOFS_SID.</span>
<span class="cm"> *</span>
<span class="cm"> * The $O index entry data is the user_id of the user corresponding to the SID.</span>
<span class="cm"> * This user_id is used as an index into $Q to find the quota control entry</span>
<span class="cm"> * associated with the SID.</span>
<span class="cm"> *</span>
<span class="cm"> * The $Q index entry data is the quota control entry and is defined below.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">version</span><span class="p">;</span>		<span class="cm">/* Currently equals 2. */</span>
	<span class="n">QUOTA_FLAGS</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Flags describing this quota entry. */</span>
	<span class="n">le64</span> <span class="n">bytes_used</span><span class="p">;</span>	<span class="cm">/* How many bytes of the quota are in use. */</span>
	<span class="n">sle64</span> <span class="n">change_time</span><span class="p">;</span>	<span class="cm">/* Last time this quota entry was changed. */</span>
	<span class="n">sle64</span> <span class="n">threshold</span><span class="p">;</span>	<span class="cm">/* Soft quota (-1 if not limited). */</span>
	<span class="n">sle64</span> <span class="n">limit</span><span class="p">;</span>		<span class="cm">/* Hard quota (-1 if not limited). */</span>
	<span class="n">sle64</span> <span class="n">exceeded_time</span><span class="p">;</span>	<span class="cm">/* How long the soft quota has been exceeded. */</span>
	<span class="n">SID</span> <span class="n">sid</span><span class="p">;</span>		<span class="cm">/* The SID of the user/object associated with</span>
<span class="cm">				   this quota entry.  Equals zero for the quota</span>
<span class="cm">				   defaults entry (and in fact on a WinXP</span>
<span class="cm">				   volume, it is not present at all). */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">QUOTA_CONTROL_ENTRY</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Predefined owner_id values (32-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">QUOTA_INVALID_ID</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">),</span>
	<span class="n">QUOTA_DEFAULTS_ID</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>
	<span class="n">QUOTA_FIRST_USER_ID</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000100</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Current constants for quota control entries.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Current version. */</span>
	<span class="n">QUOTA_VERSION</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span> <span class="n">QUOTA_CONTROL_ENTRY_CONSTANTS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Index entry flags (16-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">INDEX_ENTRY_NODE</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="cm">/* This entry contains a</span>
<span class="cm">			sub-node, i.e. a reference to an index block in form of</span>
<span class="cm">			a virtual cluster number (see below). */</span>
	<span class="n">INDEX_ENTRY_END</span>  <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="cm">/* This signifies the last</span>
<span class="cm">			entry in an index block.  The index entry does not</span>
<span class="cm">			represent a file but it can point to a sub-node. */</span>

	<span class="n">INDEX_ENTRY_SPACE_FILLER</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">),</span> <span class="cm">/* gcc: Force</span>
<span class="cm">			enum bit width to 16-bit. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">le16</span> <span class="n">INDEX_ENTRY_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This the index entry header (see below).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*  0*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* Only valid when INDEX_ENTRY_END is not set. */</span>
			<span class="n">leMFT_REF</span> <span class="n">indexed_file</span><span class="p">;</span>	<span class="cm">/* The mft reference of the file</span>
<span class="cm">						   described by this index</span>
<span class="cm">						   entry. Used for directory</span>
<span class="cm">						   indexes. */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">dir</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* Used for views/indexes to find the entry&#39;s data. */</span>
			<span class="n">le16</span> <span class="n">data_offset</span><span class="p">;</span>	<span class="cm">/* Data byte offset from this</span>
<span class="cm">						   INDEX_ENTRY. Follows the</span>
<span class="cm">						   index key. */</span>
			<span class="n">le16</span> <span class="n">data_length</span><span class="p">;</span>	<span class="cm">/* Data length in bytes. */</span>
			<span class="n">le32</span> <span class="n">reservedV</span><span class="p">;</span>		<span class="cm">/* Reserved (zero). */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">vi</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">data</span><span class="p">;</span>
<span class="cm">/*  8*/</span>	<span class="n">le16</span> <span class="n">length</span><span class="p">;</span>		 <span class="cm">/* Byte size of this index entry, multiple of</span>
<span class="cm">				    8-bytes. */</span>
<span class="cm">/* 10*/</span>	<span class="n">le16</span> <span class="n">key_length</span><span class="p">;</span>	 <span class="cm">/* Byte size of the key value, which is in the</span>
<span class="cm">				    index entry. It follows field reserved. Not</span>
<span class="cm">				    multiple of 8-bytes. */</span>
<span class="cm">/* 12*/</span>	<span class="n">INDEX_ENTRY_FLAGS</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* Bit field of INDEX_ENTRY_* flags. */</span>
<span class="cm">/* 14*/</span>	<span class="n">le16</span> <span class="n">reserved</span><span class="p">;</span>		 <span class="cm">/* Reserved/align to 8-byte boundary. */</span>
<span class="cm">/* sizeof() = 16 bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">INDEX_ENTRY_HEADER</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is an index entry. A sequence of such entries follows each INDEX_HEADER</span>
<span class="cm"> * structure. Together they make up a complete index. The index follows either</span>
<span class="cm"> * an index root attribute or an index allocation attribute.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Before NTFS 3.0 only filename attributes were indexed.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0	INDEX_ENTRY_HEADER; -- Unfolded here as gcc dislikes unnamed structs. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* Only valid when INDEX_ENTRY_END is not set. */</span>
			<span class="n">leMFT_REF</span> <span class="n">indexed_file</span><span class="p">;</span>	<span class="cm">/* The mft reference of the file</span>
<span class="cm">						   described by this index</span>
<span class="cm">						   entry. Used for directory</span>
<span class="cm">						   indexes. */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">dir</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* Used for views/indexes to find the entry&#39;s data. */</span>
			<span class="n">le16</span> <span class="n">data_offset</span><span class="p">;</span>	<span class="cm">/* Data byte offset from this</span>
<span class="cm">						   INDEX_ENTRY. Follows the</span>
<span class="cm">						   index key. */</span>
			<span class="n">le16</span> <span class="n">data_length</span><span class="p">;</span>	<span class="cm">/* Data length in bytes. */</span>
			<span class="n">le32</span> <span class="n">reservedV</span><span class="p">;</span>		<span class="cm">/* Reserved (zero). */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">vi</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">le16</span> <span class="n">length</span><span class="p">;</span>		 <span class="cm">/* Byte size of this index entry, multiple of</span>
<span class="cm">				    8-bytes. */</span>
	<span class="n">le16</span> <span class="n">key_length</span><span class="p">;</span>	 <span class="cm">/* Byte size of the key value, which is in the</span>
<span class="cm">				    index entry. It follows field reserved. Not</span>
<span class="cm">				    multiple of 8-bytes. */</span>
	<span class="n">INDEX_ENTRY_FLAGS</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* Bit field of INDEX_ENTRY_* flags. */</span>
	<span class="n">le16</span> <span class="n">reserved</span><span class="p">;</span>		 <span class="cm">/* Reserved/align to 8-byte boundary. */</span>

<span class="cm">/* 16*/</span>	<span class="k">union</span> <span class="p">{</span>		<span class="cm">/* The key of the indexed attribute. NOTE: Only present</span>
<span class="cm">			   if INDEX_ENTRY_END bit in flags is not set. NOTE: On</span>
<span class="cm">			   NTFS versions before 3.0 the only valid key is the</span>
<span class="cm">			   FILE_NAME_ATTR. On NTFS 3.0+ the following</span>
<span class="cm">			   additional index keys are defined: */</span>
		<span class="n">FILE_NAME_ATTR</span> <span class="n">file_name</span><span class="p">;</span><span class="cm">/* $I30 index in directories. */</span>
		<span class="n">SII_INDEX_KEY</span> <span class="n">sii</span><span class="p">;</span>	<span class="cm">/* $SII index in $Secure. */</span>
		<span class="n">SDH_INDEX_KEY</span> <span class="n">sdh</span><span class="p">;</span>	<span class="cm">/* $SDH index in $Secure. */</span>
		<span class="n">GUID</span> <span class="n">object_id</span><span class="p">;</span>		<span class="cm">/* $O index in FILE_Extend/$ObjId: The</span>
<span class="cm">					   object_id of the mft record found in</span>
<span class="cm">					   the data part of the index. */</span>
		<span class="n">REPARSE_INDEX_KEY</span> <span class="n">reparse</span><span class="p">;</span>	<span class="cm">/* $R index in</span>
<span class="cm">						   FILE_Extend/$Reparse. */</span>
		<span class="n">SID</span> <span class="n">sid</span><span class="p">;</span>		<span class="cm">/* $O index in FILE_Extend/$Quota:</span>
<span class="cm">					   SID of the owner of the user_id. */</span>
		<span class="n">le32</span> <span class="n">owner_id</span><span class="p">;</span>		<span class="cm">/* $Q index in FILE_Extend/$Quota:</span>
<span class="cm">					   user_id of the owner of the quota</span>
<span class="cm">					   control entry in the data part of</span>
<span class="cm">					   the index. */</span>
	<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">key</span><span class="p">;</span>
	<span class="cm">/* The (optional) index data is inserted here when creating. */</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>typedef enum {                    /* SID string prefix. <em>/
SECURITY_NULL_SID_AUTHORITY    = {0, 0, 0, 0, 0, 0},   /</em> S-1-0 <em>/
SECURITY_WORLD_SID_AUTHORITY    = {0, 0, 0, 0, 0, 1},   /</em> S-1-1 <em>/
SECURITY_LOCAL_SID_AUTHORITY    = {0, 0, 0, 0, 0, 2},   /</em> S-1-2 <em>/
SECURITY_CREATOR_SID_AUTHORITY    = {0, 0, 0, 0, 0, 3},   /</em> S-1-3 <em>/
SECURITY_NON_UNIQUE_AUTHORITY    = {0, 0, 0, 0, 0, 4},   /</em> S-1-4 <em>/
SECURITY_NT_SID_AUTHORITY    = {0, 0, 0, 0, 0, 5},   /</em> S-1-5 */
} IDENTIFIER_AUTHORITIES;</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">INDEX_ENTRY</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Bitmap (0xb0).</span>
<span class="cm"> *</span>
<span class="cm"> * Contains an array of bits (aka a bitfield).</span>
<span class="cm"> *</span>
<span class="cm"> * When used in conjunction with the index allocation attribute, each bit</span>
<span class="cm"> * corresponds to one index block within the index allocation attribute. Thus</span>
<span class="cm"> * the number of bits in the bitmap * index block size / cluster size is the</span>
<span class="cm"> * number of clusters in the index allocation attribute.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">bitmap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>			<span class="cm">/* Array of bits. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">BITMAP_ATTR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The reparse point tag defines the type of the reparse point. It also</span>
<span class="cm"> * includes several flags, which further describe the reparse point.</span>
<span class="cm"> *</span>
<span class="cm"> * The reparse point tag is an unsigned 32-bit value divided in three parts:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. The least significant 16 bits (i.e. bits 0 to 15) specifiy the type of</span>
<span class="cm"> *    the reparse point.</span>
<span class="cm"> * 2. The 13 bits after this (i.e. bits 16 to 28) are reserved for future use.</span>
<span class="cm"> * 3. The most significant three bits are flags describing the reparse point.</span>
<span class="cm"> *    They are defined as follows:</span>
<span class="cm"> *	bit 29: Name surrogate bit. If set, the filename is an alias for</span>
<span class="cm"> *		another object in the system.</span>
<span class="cm"> *	bit 30: High-latency bit. If set, accessing the first byte of data will</span>
<span class="cm"> *		be slow. (E.g. the data is stored on a tape drive.)</span>
<span class="cm"> *	bit 31: Microsoft bit. If set, the tag is owned by Microsoft. User</span>
<span class="cm"> *		defined tags have to use zero here.</span>
<span class="cm"> *</span>
<span class="cm"> * These are the predefined reparse point tags:</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IO_REPARSE_TAG_IS_ALIAS</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x20000000</span><span class="p">),</span>
	<span class="n">IO_REPARSE_TAG_IS_HIGH_LATENCY</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x40000000</span><span class="p">),</span>
	<span class="n">IO_REPARSE_TAG_IS_MICROSOFT</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">),</span>

	<span class="n">IO_REPARSE_TAG_RESERVED_ZERO</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">),</span>
	<span class="n">IO_REPARSE_TAG_RESERVED_ONE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>
	<span class="n">IO_REPARSE_TAG_RESERVED_RANGE</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">),</span>

	<span class="n">IO_REPARSE_TAG_NSS</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x68000005</span><span class="p">),</span>
	<span class="n">IO_REPARSE_TAG_NSS_RECOVER</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x68000006</span><span class="p">),</span>
	<span class="n">IO_REPARSE_TAG_SIS</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x68000007</span><span class="p">),</span>
	<span class="n">IO_REPARSE_TAG_DFS</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x68000008</span><span class="p">),</span>

	<span class="n">IO_REPARSE_TAG_MOUNT_POINT</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x88000003</span><span class="p">),</span>

	<span class="n">IO_REPARSE_TAG_HSM</span>		<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xa8000004</span><span class="p">),</span>

	<span class="n">IO_REPARSE_TAG_SYMBOLIC_LINK</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xe8000000</span><span class="p">),</span>

	<span class="n">IO_REPARSE_TAG_VALID_VALUES</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xe000ffff</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Reparse point (0xc0).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Can be resident or non-resident.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">reparse_tag</span><span class="p">;</span>		<span class="cm">/* Reparse point type (inc. flags). */</span>
	<span class="n">le16</span> <span class="n">reparse_data_length</span><span class="p">;</span>	<span class="cm">/* Byte size of reparse data. */</span>
	<span class="n">le16</span> <span class="n">reserved</span><span class="p">;</span>			<span class="cm">/* Align to 8-byte boundary. */</span>
	<span class="n">u8</span> <span class="n">reparse_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>		<span class="cm">/* Meaning depends on reparse_tag. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">REPARSE_POINT</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Extended attribute (EA) information (0xd0).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Always resident. (Is this true???)</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le16</span> <span class="n">ea_length</span><span class="p">;</span>		<span class="cm">/* Byte size of the packed extended</span>
<span class="cm">				   attributes. */</span>
	<span class="n">le16</span> <span class="n">need_ea_count</span><span class="p">;</span>	<span class="cm">/* The number of extended attributes which have</span>
<span class="cm">				   the NEED_EA bit set. */</span>
	<span class="n">le32</span> <span class="n">ea_query_length</span><span class="p">;</span>	<span class="cm">/* Byte size of the buffer required to query</span>
<span class="cm">				   the extended attributes when calling</span>
<span class="cm">				   ZwQueryEaFile() in Windows NT/2k. I.e. the</span>
<span class="cm">				   byte size of the unpacked extended</span>
<span class="cm">				   attributes. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">EA_INFORMATION</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Extended attribute flags (8-bit).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NEED_EA</span>	<span class="o">=</span> <span class="mh">0x80</span>		<span class="cm">/* If set the file to which the EA belongs</span>
<span class="cm">				   cannot be interpreted without understanding</span>
<span class="cm">				   the associates extended attributes. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">u8</span> <span class="n">EA_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Extended attribute (EA) (0xe0).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Can be resident or non-resident.</span>
<span class="cm"> *</span>
<span class="cm"> * Like the attribute list and the index buffer list, the EA attribute value is</span>
<span class="cm"> * a sequence of EA_ATTR variable length records.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">le32</span> <span class="n">next_entry_offset</span><span class="p">;</span>	<span class="cm">/* Offset to the next EA_ATTR. */</span>
	<span class="n">EA_FLAGS</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Flags describing the EA. */</span>
	<span class="n">u8</span> <span class="n">ea_name_length</span><span class="p">;</span>	<span class="cm">/* Length of the name of the EA in bytes</span>
<span class="cm">				   excluding the &#39;\0&#39; byte terminator. */</span>
	<span class="n">le16</span> <span class="n">ea_value_length</span><span class="p">;</span>	<span class="cm">/* Byte size of the EA&#39;s value. */</span>
	<span class="n">u8</span> <span class="n">ea_name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>		<span class="cm">/* Name of the EA.  Note this is ASCII, not</span>
<span class="cm">				   Unicode and it is zero terminated. */</span>
	<span class="n">u8</span> <span class="n">ea_value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>		<span class="cm">/* The value of the EA.  Immediately follows</span>
<span class="cm">				   the name. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">EA_ATTR</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Property set (0xf0).</span>
<span class="cm"> *</span>
<span class="cm"> * Intended to support Native Structure Storage (NSS) - a feature removed from</span>
<span class="cm"> * NTFS 3.0 during beta testing.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/* Irrelevant as feature unused. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">PROPERTY_SET</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute: Logged utility stream (0x100).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Can be resident or non-resident.</span>
<span class="cm"> *</span>
<span class="cm"> * Operations on this attribute are logged to the journal ($LogFile) like</span>
<span class="cm"> * normal metadata changes.</span>
<span class="cm"> *</span>
<span class="cm"> * Used by the Encrypting File System (EFS). All encrypted files have this</span>
<span class="cm"> * attribute with the name $EFS.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/* Can be anything the creator chooses. */</span>
	<span class="cm">/* EFS uses it as follows: */</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>leVCN vcn;    /* If INDEX<em>ENTRY</em>NODE bit in flags is set, the last
       eight bytes of this index entry contain the virtual
       cluster number of the index block that holds the
       entries immediately preceding the current entry (the
       vcn references the corresponding cluster in the data
       of the non-resident index allocation attribute). If
       the key<em>length is zero, then the vcn immediately
       follows the INDEX</em>ENTRY<em>HEADER. Regardless of
       key</em>length, the address of the 8-byte boundary
       aligned vcn of INDEX<em>ENTRY{</em>HEADER} <em>ie is given by
       (char</em>)ie + le16<em>to</em>cpu(ie*)->length) - sizeof(VCN),
       where sizeof(VCN) can be hardcoded as 8 if wanted. */</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">LOGGED_UTILITY_STREAM</span><span class="p">,</span> <span class="n">EFS_ATTR</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_NTFS_LAYOUT_H */</span><span class="cp"></span>

</pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>FIXME: Type this info, verifying it along the way. (AIA)</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
