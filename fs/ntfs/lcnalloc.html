<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › lcnalloc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lcnalloc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * lcnalloc.h - Exports for NTFS kernel cluster (de)allocation.  Part of the</span>
<span class="cm"> *		Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004-2005 Anton Altaparmakov</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_NTFS_LCNALLOC_H</span>
<span class="cp">#define _LINUX_NTFS_LCNALLOC_H</span>

<span class="cp">#ifdef NTFS_RW</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>

<span class="cp">#include &quot;attrib.h&quot;</span>
<span class="cp">#include &quot;types.h&quot;</span>
<span class="cp">#include &quot;inode.h&quot;</span>
<span class="cp">#include &quot;runlist.h&quot;</span>
<span class="cp">#include &quot;volume.h&quot;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">FIRST_ZONE</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* For sanity checking. */</span>
	<span class="n">MFT_ZONE</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Allocate from $MFT zone. */</span>
	<span class="n">DATA_ZONE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Allocate from $DATA zone. */</span>
	<span class="n">LAST_ZONE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* For sanity checking. */</span>
<span class="p">}</span> <span class="n">NTFS_CLUSTER_ALLOCATION_ZONES</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">runlist_element</span> <span class="o">*</span><span class="n">ntfs_cluster_alloc</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">VCN</span> <span class="n">start_vcn</span><span class="p">,</span> <span class="k">const</span> <span class="n">s64</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">LCN</span> <span class="n">start_lcn</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">NTFS_CLUSTER_ALLOCATION_ZONES</span> <span class="n">zone</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">bool</span> <span class="n">is_extension</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">s64</span> <span class="n">__ntfs_cluster_free</span><span class="p">(</span><span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">,</span> <span class="k">const</span> <span class="n">VCN</span> <span class="n">start_vcn</span><span class="p">,</span>
		<span class="n">s64</span> <span class="n">count</span><span class="p">,</span> <span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">is_rollback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_cluster_free - free clusters on an ntfs volume</span>
<span class="cm"> * @ni:		ntfs inode whose runlist describes the clusters to free</span>
<span class="cm"> * @start_vcn:	vcn in the runlist of @ni at which to start freeing clusters</span>
<span class="cm"> * @count:	number of clusters to free or -1 for all clusters</span>
<span class="cm"> * @ctx:	active attribute search context if present or NULL if not</span>
<span class="cm"> *</span>
<span class="cm"> * Free @count clusters starting at the cluster @start_vcn in the runlist</span>
<span class="cm"> * described by the ntfs inode @ni.</span>
<span class="cm"> *</span>
<span class="cm"> * If @count is -1, all clusters from @start_vcn to the end of the runlist are</span>
<span class="cm"> * deallocated.  Thus, to completely free all clusters in a runlist, use</span>
<span class="cm"> * @start_vcn = 0 and @count = -1.</span>
<span class="cm"> *</span>
<span class="cm"> * If @ctx is specified, it is an active search context of @ni and its base mft</span>
<span class="cm"> * record.  This is needed when ntfs_cluster_free() encounters unmapped runlist</span>
<span class="cm"> * fragments and allows their mapping.  If you do not have the mft record</span>
<span class="cm"> * mapped, you can specify @ctx as NULL and ntfs_cluster_free() will perform</span>
<span class="cm"> * the necessary mapping and unmapping.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, ntfs_cluster_free() saves the state of @ctx on entry and restores it</span>
<span class="cm"> * before returning.  Thus, @ctx will be left pointing to the same attribute on</span>
<span class="cm"> * return as on entry.  However, the actual pointers in @ctx may point to</span>
<span class="cm"> * different memory locations on return, so you must remember to reset any</span>
<span class="cm"> * cached pointers from the @ctx, i.e. after the call to ntfs_cluster_free(),</span>
<span class="cm"> * you will probably want to do:</span>
<span class="cm"> *	m = ctx-&gt;mrec;</span>
<span class="cm"> *	a = ctx-&gt;attr;</span>
<span class="cm"> * Assuming you cache ctx-&gt;attr in a variable @a of type ATTR_RECORD * and that</span>
<span class="cm"> * you cache ctx-&gt;mrec in a variable @m of type MFT_RECORD *.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, ntfs_cluster_free() does not modify the runlist, so you have to remove</span>
<span class="cm"> * from the runlist or mark sparse the freed runs later.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of deallocated clusters (not counting sparse ones) on</span>
<span class="cm"> * success and -errno on error.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: If @ctx is supplied, regardless of whether success or failure is</span>
<span class="cm"> *	    returned, you need to check IS_ERR(@ctx-&gt;mrec) and if &#39;true&#39; the @ctx</span>
<span class="cm"> *	    is no longer valid, i.e. you need to either call</span>
<span class="cm"> *	    ntfs_attr_reinit_search_ctx() or ntfs_attr_put_search_ctx() on it.</span>
<span class="cm"> *	    In that case PTR_ERR(@ctx-&gt;mrec) will give you the error code for</span>
<span class="cm"> *	    why the mapping of the old inode failed.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: - The runlist described by @ni must be locked for writing on entry</span>
<span class="cm"> *	      and is locked on return.  Note the runlist may be modified when</span>
<span class="cm"> *	      needed runlist fragments need to be mapped.</span>
<span class="cm"> *	    - The volume lcn bitmap must be unlocked on entry and is unlocked</span>
<span class="cm"> *	      on return.</span>
<span class="cm"> *	    - This function takes the volume lcn bitmap lock for writing and</span>
<span class="cm"> *	      modifies the bitmap contents.</span>
<span class="cm"> *	    - If @ctx is NULL, the base mft record of @ni must not be mapped on</span>
<span class="cm"> *	      entry and it will be left unmapped on return.</span>
<span class="cm"> *	    - If @ctx is not NULL, the base mft record must be mapped on entry</span>
<span class="cm"> *	      and it will be left mapped on return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">ntfs_cluster_free</span><span class="p">(</span><span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">,</span> <span class="k">const</span> <span class="n">VCN</span> <span class="n">start_vcn</span><span class="p">,</span>
		<span class="n">s64</span> <span class="n">count</span><span class="p">,</span> <span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ntfs_cluster_free</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">start_vcn</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ntfs_cluster_free_from_rl_nolock</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">runlist_element</span> <span class="o">*</span><span class="n">rl</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_cluster_free_from_rl - free clusters from runlist</span>
<span class="cm"> * @vol:	mounted ntfs volume on which to free the clusters</span>
<span class="cm"> * @rl:		runlist describing the clusters to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free all the clusters described by the runlist @rl on the volume @vol.  In</span>
<span class="cm"> * the case of an error being returned, at least some of the clusters were not</span>
<span class="cm"> * freed.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success and -errno on error.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: - This function takes the volume lcn bitmap lock for writing and</span>
<span class="cm"> *	      modifies the bitmap contents.</span>
<span class="cm"> *	    - The caller must have locked the runlist @rl for reading or</span>
<span class="cm"> *	      writing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ntfs_cluster_free_from_rl</span><span class="p">(</span><span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">runlist_element</span> <span class="o">*</span><span class="n">rl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ntfs_cluster_free_from_rl_nolock</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">lcnbmp_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* defined _LINUX_NTFS_LCNALLOC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
