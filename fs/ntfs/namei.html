<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › namei.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>namei.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * namei.c - NTFS kernel directory inode operations. Part of the Linux-NTFS</span>
<span class="cm"> *	     project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2006 Anton Altaparmakov</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/exportfs.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;attrib.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;dir.h&quot;</span>
<span class="cp">#include &quot;mft.h&quot;</span>
<span class="cp">#include &quot;ntfs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_lookup - find the inode represented by a dentry in a directory inode</span>
<span class="cm"> * @dir_ino:	directory inode in which to look for the inode</span>
<span class="cm"> * @dent:	dentry representing the inode to look for</span>
<span class="cm"> * @nd:		lookup nameidata</span>
<span class="cm"> *</span>
<span class="cm"> * In short, ntfs_lookup() looks for the inode represented by the dentry @dent</span>
<span class="cm"> * in the directory inode @dir_ino and if found attaches the inode to the</span>
<span class="cm"> * dentry @dent.</span>
<span class="cm"> *</span>
<span class="cm"> * In more detail, the dentry @dent specifies which inode to look for by</span>
<span class="cm"> * supplying the name of the inode in @dent-&gt;d_name.name. ntfs_lookup()</span>
<span class="cm"> * converts the name to Unicode and walks the contents of the directory inode</span>
<span class="cm"> * @dir_ino looking for the converted Unicode name. If the name is found in the</span>
<span class="cm"> * directory, the corresponding inode is loaded by calling ntfs_iget() on its</span>
<span class="cm"> * inode number and the inode is associated with the dentry @dent via a call to</span>
<span class="cm"> * d_splice_alias().</span>
<span class="cm"> *</span>
<span class="cm"> * If the name is not found in the directory, a NULL inode is inserted into the</span>
<span class="cm"> * dentry @dent via a call to d_add(). The dentry is then termed a negative</span>
<span class="cm"> * dentry.</span>
<span class="cm"> *</span>
<span class="cm"> * Only if an actual error occurs, do we return an error via ERR_PTR().</span>
<span class="cm"> *</span>
<span class="cm"> * In order to handle the case insensitivity issues of NTFS with regards to the</span>
<span class="cm"> * dcache and the dcache requiring only one dentry per directory, we deal with</span>
<span class="cm"> * dentry aliases that only differ in case in -&gt;ntfs_lookup() while maintaining</span>
<span class="cm"> * a case sensitive dcache. This means that we get the full benefit of dcache</span>
<span class="cm"> * speed when the file/directory is looked up with the same case as returned by</span>
<span class="cm"> * -&gt;ntfs_readdir() but that a lookup for any other case (or for the short file</span>
<span class="cm"> * name) will not find anything in dcache and will enter -&gt;ntfs_lookup()</span>
<span class="cm"> * instead, where we search the directory for a fully matching file name</span>
<span class="cm"> * (including case) and if that is not found, we search for a file name that</span>
<span class="cm"> * matches with different case and if that has non-POSIX semantics we return</span>
<span class="cm"> * that. We actually do only one search (case sensitive) and keep tabs on</span>
<span class="cm"> * whether we have found a case insensitive match in the process.</span>
<span class="cm"> *</span>
<span class="cm"> * To simplify matters for us, we do not treat the short vs long filenames as</span>
<span class="cm"> * two hard links but instead if the lookup matches a short filename, we</span>
<span class="cm"> * return the dentry for the corresponding long filename instead.</span>
<span class="cm"> *</span>
<span class="cm"> * There are three cases we need to distinguish here:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) @dent perfectly matches (i.e. including case) a directory entry with a</span>
<span class="cm"> *    file name in the WIN32 or POSIX namespaces. In this case</span>
<span class="cm"> *    ntfs_lookup_inode_by_name() will return with name set to NULL and we</span>
<span class="cm"> *    just d_splice_alias() @dent.</span>
<span class="cm"> * 2) @dent matches (not including case) a directory entry with a file name in</span>
<span class="cm"> *    the WIN32 namespace. In this case ntfs_lookup_inode_by_name() will return</span>
<span class="cm"> *    with name set to point to a kmalloc()ed ntfs_name structure containing</span>
<span class="cm"> *    the properly cased little endian Unicode name. We convert the name to the</span>
<span class="cm"> *    current NLS code page, search if a dentry with this name already exists</span>
<span class="cm"> *    and if so return that instead of @dent.  At this point things are</span>
<span class="cm"> *    complicated by the possibility of &#39;disconnected&#39; dentries due to NFS</span>
<span class="cm"> *    which we deal with appropriately (see the code comments).  The VFS will</span>
<span class="cm"> *    then destroy the old @dent and use the one we returned.  If a dentry is</span>
<span class="cm"> *    not found, we allocate a new one, d_splice_alias() it, and return it as</span>
<span class="cm"> *    above.</span>
<span class="cm"> * 3) @dent matches either perfectly or not (i.e. we don&#39;t care about case) a</span>
<span class="cm"> *    directory entry with a file name in the DOS namespace. In this case</span>
<span class="cm"> *    ntfs_lookup_inode_by_name() will return with name set to point to a</span>
<span class="cm"> *    kmalloc()ed ntfs_name structure containing the mft reference (cpu endian)</span>
<span class="cm"> *    of the inode. We use the mft reference to read the inode and to find the</span>
<span class="cm"> *    file name in the WIN32 namespace corresponding to the matched short file</span>
<span class="cm"> *    name. We then convert the name to the current NLS code page, and proceed</span>
<span class="cm"> *    searching for a dentry with this name, etc, as in case 2), above.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: Caller must hold i_mutex on the directory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ntfs_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir_ino</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">NTFS_SB</span><span class="p">(</span><span class="n">dir_ino</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dent_inode</span><span class="p">;</span>
	<span class="n">ntfschar</span> <span class="o">*</span><span class="n">uname</span><span class="p">;</span>
	<span class="n">ntfs_name</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">MFT_REF</span> <span class="n">mref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dent_ino</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uname_len</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Looking up %s in directory inode 0x%lx.&quot;</span><span class="p">,</span>
			<span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dir_ino</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="cm">/* Convert the name of the dentry to Unicode. */</span>
	<span class="n">uname_len</span> <span class="o">=</span> <span class="n">ntfs_nlstoucs</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">uname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uname_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uname_len</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to convert name to &quot;</span>
					<span class="s">&quot;Unicode.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">uname_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mref</span> <span class="o">=</span> <span class="n">ntfs_lookup_inode_by_name</span><span class="p">(</span><span class="n">NTFS_I</span><span class="p">(</span><span class="n">dir_ino</span><span class="p">),</span> <span class="n">uname</span><span class="p">,</span> <span class="n">uname_len</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ntfs_name_cache</span><span class="p">,</span> <span class="n">uname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_MREF</span><span class="p">(</span><span class="n">mref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dent_ino</span> <span class="o">=</span> <span class="n">MREF</span><span class="p">(</span><span class="n">mref</span><span class="p">);</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Found inode 0x%lx. Calling ntfs_iget.&quot;</span><span class="p">,</span> <span class="n">dent_ino</span><span class="p">);</span>
		<span class="n">dent_inode</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">dent_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Consistency check. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">MSEQNO</span><span class="p">(</span><span class="n">mref</span><span class="p">)</span> <span class="o">==</span>
					<span class="n">NTFS_I</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq_no</span> <span class="o">||</span>
					<span class="n">dent_ino</span> <span class="o">==</span> <span class="n">FILE_MFT</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Perfect WIN32/POSIX match. -- Case 1. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.  (Case 1.)&quot;</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">d_splice_alias</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * We are too indented.  Handle imperfect</span>
<span class="cm">				 * matches and short file names further below.</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">handle_name</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Found stale reference to inode &quot;</span>
					<span class="s">&quot;0x%lx (reference sequence number = &quot;</span>
					<span class="s">&quot;0x%x, inode sequence number = 0x%x), &quot;</span>
					<span class="s">&quot;returning -EIO. Run chkdsk.&quot;</span><span class="p">,</span>
					<span class="n">dent_ino</span><span class="p">,</span> <span class="n">MSEQNO</span><span class="p">(</span><span class="n">mref</span><span class="p">),</span>
					<span class="n">NTFS_I</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq_no</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">);</span>
			<span class="n">dent_inode</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ntfs_iget(0x%lx) failed with &quot;</span>
					<span class="s">&quot;error code %li.&quot;</span><span class="p">,</span> <span class="n">dent_ino</span><span class="p">,</span>
					<span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="cm">/* Return the error code. */</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">)</span><span class="n">dent_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* It is guaranteed that @name is no longer allocated at this point. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MREF_ERR</span><span class="p">(</span><span class="n">mref</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entry was not found, adding negative dentry.&quot;</span><span class="p">);</span>
		<span class="cm">/* The dcache will handle negative entries. */</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">dent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Done.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ntfs_lookup_ino_by_name() failed with error &quot;</span>
			<span class="s">&quot;code %i.&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">MREF_ERR</span><span class="p">(</span><span class="n">mref</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">MREF_ERR</span><span class="p">(</span><span class="n">mref</span><span class="p">));</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>TODO: Consider moving this lot to a separate function! (AIA)</p></td><td class="code"><div class="highlight"><pre><span class="nl">handle_name:</span>
   <span class="p">{</span>
	<span class="n">MFT_RECORD</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">nls_name</span><span class="p">;</span>

	<span class="n">nls_name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">FILE_NAME_DOS</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* Case 2. */</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Case 2.&quot;</span><span class="p">);</span>
		<span class="n">nls_name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ntfs_ucstonls</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span>
				<span class="p">(</span><span class="n">ntfschar</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nls_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* if (name-&gt;type == FILE_NAME_DOS) */</span> <span class="p">{</span>		<span class="cm">/* Case 3. */</span>
		<span class="n">FILE_NAME_ATTR</span> <span class="o">*</span><span class="n">fn</span><span class="p">;</span>

		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Case 3.&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/* Find the WIN32 name corresponding to the matched DOS name. */</span>
		<span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
			<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ATTR_RECORD</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">val_len</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">AT_FILE_NAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Inode corrupt: No WIN32 &quot;</span>
						<span class="s">&quot;namespace counterpart to DOS &quot;</span>
						<span class="s">&quot;file name. Run chkdsk.&quot;</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Consistency checks. */</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">non_resident</span> <span class="o">||</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">eio_err_out</span><span class="p">;</span>
			<span class="n">val_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_length</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_offset</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">val_len</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">eio_err_out</span><span class="p">;</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="p">(</span><span class="n">FILE_NAME_ATTR</span><span class="o">*</span><span class="p">)((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span>
					<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_offset</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">file_name_length</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ntfschar</span><span class="p">)</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">FILE_NAME_ATTR</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">val_len</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">eio_err_out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">file_name_type</span> <span class="o">!=</span> <span class="n">FILE_NAME_WIN32</span><span class="p">);</span>

		<span class="cm">/* Convert the found WIN32 name to current NLS code page. */</span>
		<span class="n">nls_name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ntfs_ucstonls</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span>
				<span class="p">(</span><span class="n">ntfschar</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">file_name</span><span class="p">,</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">file_name_length</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nls_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">m</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check if a conversion error occurred. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">signed</span><span class="p">)</span><span class="n">nls_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">nls_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nls_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">nls_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">nls_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

	<span class="n">dent</span> <span class="o">=</span> <span class="n">d_add_ci</span><span class="p">(</span><span class="n">dent</span><span class="p">,</span> <span class="n">dent_inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nls_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">nls_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dent</span><span class="p">;</span>

<span class="nl">eio_err_out:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Illegal file name attribute. Run chkdsk.&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">dent_inode</span><span class="p">);</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed, returning error code %i.&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Inode operations for directories.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ntfs_dir_inode_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>	<span class="o">=</span> <span class="n">ntfs_lookup</span><span class="p">,</span>	<span class="cm">/* VFS: Lookup directory. */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_get_parent - find the dentry of the parent of a given directory dentry</span>
<span class="cm"> * @child_dent:		dentry of the directory whose parent directory to find</span>
<span class="cm"> *</span>
<span class="cm"> * Find the dentry for the parent directory of the directory specified by the</span>
<span class="cm"> * dentry @child_dent.  This function is called from</span>
<span class="cm"> * fs/exportfs/expfs.c::find_exported_dentry() which in turn is called from the</span>
<span class="cm"> * default -&gt;decode_fh() which is export_decode_fh() in the same file.</span>
<span class="cm"> *</span>
<span class="cm"> * The code is based on the ext3 -&gt;get_parent() implementation found in</span>
<span class="cm"> * fs/ext3/namei.c::ext3_get_parent().</span>
<span class="cm"> *</span>
<span class="cm"> * Note: ntfs_get_parent() is called with @child_dent-&gt;d_inode-&gt;i_mutex down.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the dentry of the parent directory on success or the error code on</span>
<span class="cm"> * error (IS_ERR() is true).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ntfs_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child_dent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span> <span class="o">=</span> <span class="n">child_dent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
	<span class="n">MFT_RECORD</span> <span class="o">*</span><span class="n">mrec</span><span class="p">;</span>
	<span class="n">ntfs_attr_search_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">ATTR_RECORD</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">FILE_NAME_ATTR</span> <span class="o">*</span><span class="n">fn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ino</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering for inode 0x%lx.&quot;</span><span class="p">,</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="cm">/* Get the mft record of the inode belonging to the child dentry. */</span>
	<span class="n">mrec</span> <span class="o">=</span> <span class="n">map_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mrec</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">)</span><span class="n">mrec</span><span class="p">;</span>
	<span class="cm">/* Find the first file name attribute in the mft record. */</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">ntfs_attr_get_search_ctx</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">mrec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">try_next:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_attr_lookup</span><span class="p">(</span><span class="n">AT_FILE_NAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CASE_SENSITIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;Inode 0x%lx does not have a &quot;</span>
					<span class="s">&quot;file name attribute.  Run chkdsk.&quot;</span><span class="p">,</span>
					<span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">attr</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">non_resident</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">try_next</span><span class="p">;</span>
	<span class="n">fn</span> <span class="o">=</span> <span class="p">(</span><span class="n">FILE_NAME_ATTR</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">attr</span> <span class="o">+</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_offset</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">fn</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resident</span><span class="p">.</span><span class="n">value_length</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">attr</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">try_next</span><span class="p">;</span>
	<span class="cm">/* Get the inode number of the parent directory. */</span>
	<span class="n">parent_ino</span> <span class="o">=</span> <span class="n">MREF_LE</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">parent_directory</span><span class="p">);</span>
	<span class="cm">/* Release the search context and the mft record of the child. */</span>
	<span class="n">ntfs_attr_put_search_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">unmap_mft_record</span><span class="p">(</span><span class="n">ni</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">d_obtain_alias</span><span class="p">(</span><span class="n">ntfs_iget</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">parent_ino</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ntfs_nfs_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u32</span> <span class="n">generation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ntfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">!=</span> <span class="n">generation</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESTALE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ntfs_fh_to_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">generic_fh_to_dentry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">fh_len</span><span class="p">,</span> <span class="n">fh_type</span><span class="p">,</span>
				    <span class="n">ntfs_nfs_get_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ntfs_fh_to_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">fh_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fh_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">generic_fh_to_parent</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">fh_len</span><span class="p">,</span> <span class="n">fh_type</span><span class="p">,</span>
				    <span class="n">ntfs_nfs_get_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Export operations allowing NFS exporting of mounted NTFS partitions.</span>
<span class="cm"> *</span>
<span class="cm"> * We use the default -&gt;encode_fh() for now.  Note that they</span>
<span class="cm"> * use 32 bits to store the inode number which is an unsigned long so on 64-bit</span>
<span class="cm"> * architectures is usually 64 bits so it would all fail horribly on huge</span>
<span class="cm"> * volumes.  I guess we need to define our own encode and decode fh functions</span>
<span class="cm"> * that store 64-bit inode numbers at some point but for now we will ignore the</span>
<span class="cm"> * problem...</span>
<span class="cm"> *</span>
<span class="cm"> * We also use the default -&gt;get_name() helper (used by -&gt;decode_fh() via</span>
<span class="cm"> * fs/exportfs/expfs.c::find_exported_dentry()) as that is completely fs</span>
<span class="cm"> * independent.</span>
<span class="cm"> *</span>
<span class="cm"> * The default -&gt;get_parent() just returns -EACCES so we have to provide our</span>
<span class="cm"> * own and the default -&gt;get_dentry() is incompatible with NTFS due to not</span>
<span class="cm"> * allowing the inode number 0 which is used in NTFS for the system file $MFT</span>
<span class="cm"> * and due to using iget() whereas NTFS needs ntfs_iget().</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">export_operations</span> <span class="n">ntfs_export_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_parent</span>	<span class="o">=</span> <span class="n">ntfs_get_parent</span><span class="p">,</span>	<span class="cm">/* Find the parent of a given</span>
<span class="cm">						   directory. */</span>
	<span class="p">.</span><span class="n">fh_to_dentry</span>	<span class="o">=</span> <span class="n">ntfs_fh_to_dentry</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fh_to_parent</span>	<span class="o">=</span> <span class="n">ntfs_fh_to_parent</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
