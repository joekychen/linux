<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › inode.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * inode.h - Defines for inode structures NTFS Linux kernel driver. Part of</span>
<span class="cm"> *	     the Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2007 Anton Altaparmakov</span>
<span class="cm"> * Copyright (c) 2002 Richard Russon</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_NTFS_INODE_H</span>
<span class="cp">#define _LINUX_NTFS_INODE_H</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#include &quot;layout.h&quot;</span>
<span class="cp">#include &quot;volume.h&quot;</span>
<span class="cp">#include &quot;types.h&quot;</span>
<span class="cp">#include &quot;runlist.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_ntfs_inode</span> <span class="n">ntfs_inode</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The NTFS in-memory inode structure. It is just used as an extension to the</span>
<span class="cm"> * fields already provided in the VFS inode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">_ntfs_inode</span> <span class="p">{</span>
	<span class="n">rwlock_t</span> <span class="n">size_lock</span><span class="p">;</span>	<span class="cm">/* Lock serializing access to inode sizes. */</span>
	<span class="n">s64</span> <span class="n">initialized_size</span><span class="p">;</span>	<span class="cm">/* Copy from the attribute record. */</span>
	<span class="n">s64</span> <span class="n">allocated_size</span><span class="p">;</span>	<span class="cm">/* Copy from the attribute record. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>	<span class="cm">/* NTFS specific flags describing this inode.</span>
<span class="cm">				   See ntfs_inode_state_bits below. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mft_no</span><span class="p">;</span>	<span class="cm">/* Number of the mft record / inode. */</span>
	<span class="n">u16</span> <span class="n">seq_no</span><span class="p">;</span>		<span class="cm">/* Sequence number of the mft record. */</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* Inode reference count for book keeping. */</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">;</span>	<span class="cm">/* Pointer to the ntfs volume of this inode. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * If NInoAttr() is true, the below fields describe the attribute which</span>
<span class="cm">	 * this fake inode belongs to. The actual inode of this attribute is</span>
<span class="cm">	 * pointed to by base_ntfs_ino and nr_extents is always set to -1 (see</span>
<span class="cm">	 * below). For real inodes, we also set the type (AT_DATA for files and</span>
<span class="cm">	 * AT_INDEX_ALLOCATION for directories), with the name = NULL and</span>
<span class="cm">	 * name_len = 0 for files and name = I30 (global constant) and</span>
<span class="cm">	 * name_len = 4 for directories.</span>
<span class="cm">	 */</span>
	<span class="n">ATTR_TYPE</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* Attribute type of this fake inode. */</span>
	<span class="n">ntfschar</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* Attribute name of this fake inode. */</span>
	<span class="n">u32</span> <span class="n">name_len</span><span class="p">;</span>		<span class="cm">/* Attribute name length of this fake inode. */</span>
	<span class="n">runlist</span> <span class="n">runlist</span><span class="p">;</span>	<span class="cm">/* If state has the NI_NonResident bit set,</span>
<span class="cm">				   the runlist of the unnamed data attribute</span>
<span class="cm">				   (if a file) or of the index allocation</span>
<span class="cm">				   attribute (directory) or of the attribute</span>
<span class="cm">				   described by the fake inode (if NInoAttr()).</span>
<span class="cm">				   If runlist.rl is NULL, the runlist has not</span>
<span class="cm">				   been read in yet or has been unmapped. If</span>
<span class="cm">				   NI_NonResident is clear, the attribute is</span>
<span class="cm">				   resident (file and fake inode) or there is</span>
<span class="cm">				   no $I30 index allocation attribute</span>
<span class="cm">				   (small directory). In the latter case</span>
<span class="cm">				   runlist.rl is always NULL.*/</span>
	<span class="cm">/*</span>
<span class="cm">	 * The following fields are only valid for real inodes and extent</span>
<span class="cm">	 * inodes.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mrec_lock</span><span class="p">;</span>	<span class="cm">/* Lock for serializing access to the</span>
<span class="cm">				   mft record belonging to this inode. */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>	<span class="cm">/* The page containing the mft record of the</span>
<span class="cm">				   inode. This should only be touched by the</span>
<span class="cm">				   (un)map_mft_record*() functions. */</span>
	<span class="kt">int</span> <span class="n">page_ofs</span><span class="p">;</span>		<span class="cm">/* Offset into the page at which the mft record</span>
<span class="cm">				   begins. This should only be touched by the</span>
<span class="cm">				   (un)map_mft_record*() functions. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Attribute list support (only for use by the attribute lookup</span>
<span class="cm">	 * functions). Setup during read_inode for all inodes with attribute</span>
<span class="cm">	 * lists. Only valid if NI_AttrList is set in state, and attr_list_rl is</span>
<span class="cm">	 * further only valid if NI_AttrListNonResident is set.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">attr_list_size</span><span class="p">;</span>	<span class="cm">/* Length of attribute list value in bytes. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">attr_list</span><span class="p">;</span>		<span class="cm">/* Attribute list value itself. */</span>
	<span class="n">runlist</span> <span class="n">attr_list_rl</span><span class="p">;</span>	<span class="cm">/* Run list for the attribute list value. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* It is a directory, $MFT, or an index inode. */</span>
			<span class="n">u32</span> <span class="n">block_size</span><span class="p">;</span>		<span class="cm">/* Size of an index block. */</span>
			<span class="n">u32</span> <span class="n">vcn_size</span><span class="p">;</span>		<span class="cm">/* Size of a vcn in this</span>
<span class="cm">						   index. */</span>
			<span class="n">COLLATION_RULE</span> <span class="n">collation_rule</span><span class="p">;</span> <span class="cm">/* The collation rule</span>
<span class="cm">						   for the index. */</span>
			<span class="n">u8</span> <span class="n">block_size_bits</span><span class="p">;</span> 	<span class="cm">/* Log2 of the above. */</span>
			<span class="n">u8</span> <span class="n">vcn_size_bits</span><span class="p">;</span>	<span class="cm">/* Log2 of the above. */</span>
		<span class="p">}</span> <span class="n">index</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* It is a compressed/sparse file/attribute inode. */</span>
			<span class="n">s64</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* Copy of compressed_size from</span>
<span class="cm">						   $DATA. */</span>
			<span class="n">u32</span> <span class="n">block_size</span><span class="p">;</span>		<span class="cm">/* Size of a compression block</span>
<span class="cm">						   (cb). */</span>
			<span class="n">u8</span> <span class="n">block_size_bits</span><span class="p">;</span>	<span class="cm">/* Log2 of the size of a cb. */</span>
			<span class="n">u8</span> <span class="n">block_clusters</span><span class="p">;</span>	<span class="cm">/* Number of clusters per cb. */</span>
		<span class="p">}</span> <span class="n">compressed</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">itype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">extent_lock</span><span class="p">;</span>	<span class="cm">/* Lock for accessing/modifying the</span>
<span class="cm">					   below . */</span>
	<span class="n">s32</span> <span class="n">nr_extents</span><span class="p">;</span>	<span class="cm">/* For a base mft record, the number of attached extent</span>
<span class="cm">			   inodes (0 if none), for extent records and for fake</span>
<span class="cm">			   inodes describing an attribute this is -1. */</span>
	<span class="k">union</span> <span class="p">{</span>		<span class="cm">/* This union is only used if nr_extents != 0. */</span>
		<span class="n">ntfs_inode</span> <span class="o">**</span><span class="n">extent_ntfs_inos</span><span class="p">;</span>	<span class="cm">/* For nr_extents &gt; 0, array of</span>
<span class="cm">						   the ntfs inodes of the extent</span>
<span class="cm">						   mft records belonging to</span>
<span class="cm">						   this base inode which have</span>
<span class="cm">						   been loaded. */</span>
		<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">base_ntfs_ino</span><span class="p">;</span>	<span class="cm">/* For nr_extents == -1, the</span>
<span class="cm">						   ntfs inode of the base mft</span>
<span class="cm">						   record. For fake inodes, the</span>
<span class="cm">						   real (base) inode to which</span>
<span class="cm">						   the attribute belongs. */</span>
	<span class="p">}</span> <span class="n">ext</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Defined bits for the state field in the ntfs_inode structure.</span>
<span class="cm"> * (f) = files only, (d) = directories only, (a) = attributes/fake inodes only</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">NI_Dirty</span><span class="p">,</span>		<span class="cm">/* 1: Mft record needs to be written to disk. */</span>
	<span class="n">NI_AttrList</span><span class="p">,</span>		<span class="cm">/* 1: Mft record contains an attribute list. */</span>
	<span class="n">NI_AttrListNonResident</span><span class="p">,</span>	<span class="cm">/* 1: Attribute list is non-resident. Implies</span>
<span class="cm">				      NI_AttrList is set. */</span>

	<span class="n">NI_Attr</span><span class="p">,</span>		<span class="cm">/* 1: Fake inode for attribute i/o.</span>
<span class="cm">				   0: Real inode or extent inode. */</span>

	<span class="n">NI_MstProtected</span><span class="p">,</span>	<span class="cm">/* 1: Attribute is protected by MST fixups.</span>
<span class="cm">				   0: Attribute is not protected by fixups. */</span>
	<span class="n">NI_NonResident</span><span class="p">,</span>		<span class="cm">/* 1: Unnamed data attr is non-resident (f).</span>
<span class="cm">				   1: Attribute is non-resident (a). */</span>
	<span class="n">NI_IndexAllocPresent</span> <span class="o">=</span> <span class="n">NI_NonResident</span><span class="p">,</span>	<span class="cm">/* 1: $I30 index alloc attr is</span>
<span class="cm">						   present (d). */</span>
	<span class="n">NI_Compressed</span><span class="p">,</span>		<span class="cm">/* 1: Unnamed data attr is compressed (f).</span>
<span class="cm">				   1: Create compressed files by default (d).</span>
<span class="cm">				   1: Attribute is compressed (a). */</span>
	<span class="n">NI_Encrypted</span><span class="p">,</span>		<span class="cm">/* 1: Unnamed data attr is encrypted (f).</span>
<span class="cm">				   1: Create encrypted files by default (d).</span>
<span class="cm">				   1: Attribute is encrypted (a). */</span>
	<span class="n">NI_Sparse</span><span class="p">,</span>		<span class="cm">/* 1: Unnamed data attr is sparse (f).</span>
<span class="cm">				   1: Create sparse files by default (d).</span>
<span class="cm">				   1: Attribute is sparse (a). */</span>
	<span class="n">NI_SparseDisabled</span><span class="p">,</span>	<span class="cm">/* 1: May not create sparse regions. */</span>
	<span class="n">NI_TruncateFailed</span><span class="p">,</span>	<span class="cm">/* 1: Last ntfs_truncate() call failed. */</span>
<span class="p">}</span> <span class="n">ntfs_inode_state_bits</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: We should be adding dirty mft records to a list somewhere and they</span>
<span class="cm"> * should be independent of the (ntfs/vfs) inode structure so that an inode can</span>
<span class="cm"> * be removed but the record can be left dirty for syncing later.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Macro tricks to expand the NInoFoo(), NInoSetFoo(), and NInoClearFoo()</span>
<span class="cm"> * functions.</span>
<span class="cm"> */</span>
<span class="cp">#define NINO_FNS(flag)					\</span>
<span class="cp">static inline int NIno##flag(ntfs_inode *ni)		\</span>
<span class="cp">{							\</span>
<span class="cp">	return test_bit(NI_##flag, &amp;(ni)-&gt;state);	\</span>
<span class="cp">}							\</span>
<span class="cp">static inline void NInoSet##flag(ntfs_inode *ni)	\</span>
<span class="cp">{							\</span>
<span class="cp">	set_bit(NI_##flag, &amp;(ni)-&gt;state);		\</span>
<span class="cp">}							\</span>
<span class="cp">static inline void NInoClear##flag(ntfs_inode *ni)	\</span>
<span class="cp">{							\</span>
<span class="cp">	clear_bit(NI_##flag, &amp;(ni)-&gt;state);		\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * As above for NInoTestSetFoo() and NInoTestClearFoo().</span>
<span class="cm"> */</span>
<span class="cp">#define TAS_NINO_FNS(flag)					\</span>
<span class="cp">static inline int NInoTestSet##flag(ntfs_inode *ni)		\</span>
<span class="cp">{								\</span>
<span class="cp">	return test_and_set_bit(NI_##flag, &amp;(ni)-&gt;state);	\</span>
<span class="cp">}								\</span>
<span class="cp">static inline int NInoTestClear##flag(ntfs_inode *ni)		\</span>
<span class="cp">{								\</span>
<span class="cp">	return test_and_clear_bit(NI_##flag, &amp;(ni)-&gt;state);	\</span>
<span class="cp">}</span>

<span class="cm">/* Emit the ntfs inode bitops functions. */</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">Dirty</span><span class="p">)</span>
<span class="n">TAS_NINO_FNS</span><span class="p">(</span><span class="n">Dirty</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">AttrList</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">AttrListNonResident</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">Attr</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">MstProtected</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">NonResident</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">IndexAllocPresent</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">Compressed</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">Encrypted</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">Sparse</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">SparseDisabled</span><span class="p">)</span>
<span class="n">NINO_FNS</span><span class="p">(</span><span class="n">TruncateFailed</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * The full structure containing a ntfs_inode and a vfs struct inode. Used for</span>
<span class="cm"> * all real and fake inodes but not for extent inodes which lack the vfs struct</span>
<span class="cm"> * inode.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">ntfs_inode</span> <span class="n">ntfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>		<span class="cm">/* The vfs inode structure. */</span>
<span class="p">}</span> <span class="n">big_ntfs_inode</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * NTFS_I - return the ntfs inode given a vfs inode</span>
<span class="cm"> * @inode:	VFS inode</span>
<span class="cm"> *</span>
<span class="cm"> * NTFS_I() returns the ntfs inode associated with the VFS @inode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ntfs_inode</span> <span class="o">*</span><span class="nf">NTFS_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ntfs_inode</span> <span class="o">*</span><span class="p">)</span><span class="n">list_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">big_ntfs_inode</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">VFS_I</span><span class="p">(</span><span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">big_ntfs_inode</span> <span class="o">*</span><span class="p">)</span><span class="n">ni</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_attr - ntfs in memory attribute structure</span>
<span class="cm"> * @mft_no:	mft record number of the base mft record of this attribute</span>
<span class="cm"> * @name:	Unicode name of the attribute (NULL if unnamed)</span>
<span class="cm"> * @name_len:	length of @name in Unicode characters (0 if unnamed)</span>
<span class="cm"> * @type:	attribute type (see layout.h)</span>
<span class="cm"> *</span>
<span class="cm"> * This structure exists only to provide a small structure for the</span>
<span class="cm"> * ntfs_{attr_}iget()/ntfs_test_inode()/ntfs_init_locked_inode() mechanism.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Elements are ordered by size to make the structure as compact as</span>
<span class="cm"> * possible on all architectures.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mft_no</span><span class="p">;</span>
	<span class="n">ntfschar</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="n">ATTR_TYPE</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ntfs_attr</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ntfs_test_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">,</span> <span class="n">ntfs_attr</span> <span class="o">*</span><span class="n">na</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ntfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mft_no</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ntfs_attr_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">base_vi</span><span class="p">,</span> <span class="n">ATTR_TYPE</span> <span class="n">type</span><span class="p">,</span>
		<span class="n">ntfschar</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="n">name_len</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ntfs_index_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">base_vi</span><span class="p">,</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">name_len</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ntfs_alloc_big_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ntfs_destroy_big_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ntfs_evict_big_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ntfs_init_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ntfs_init_big_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering.&quot;</span><span class="p">);</span>
	<span class="n">__ntfs_init_inode</span><span class="p">(</span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ni</span><span class="p">);</span>
	<span class="n">ni</span><span class="o">-&gt;</span><span class="n">mft_no</span> <span class="o">=</span> <span class="n">vi</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ntfs_new_extent_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mft_no</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ntfs_clear_extent_inode</span><span class="p">(</span><span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ntfs_read_inode_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ntfs_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>

<span class="cp">#ifdef NTFS_RW</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ntfs_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ntfs_truncate_vfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ntfs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ntfs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ntfs_commit_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">vi</span><span class="p">))</span>
		<span class="n">__ntfs_write_inode</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_NTFS_INODE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
