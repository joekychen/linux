<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › volume.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>volume.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * volume.h - Defines for volume structures in NTFS Linux kernel driver. Part</span>
<span class="cm"> *	      of the Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2006 Anton Altaparmakov</span>
<span class="cm"> * Copyright (c) 2002 Richard Russon</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_NTFS_VOLUME_H</span>
<span class="cp">#define _LINUX_NTFS_VOLUME_H</span>

<span class="cp">#include &lt;linux/rwsem.h&gt;</span>

<span class="cp">#include &quot;types.h&quot;</span>
<span class="cp">#include &quot;layout.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * The NTFS in memory super block structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: Reorder to have commonly used together element within the</span>
<span class="cm">	 * same cache line, aiming at a cache line size of 32 bytes. Aim for</span>
<span class="cm">	 * 64 bytes for less commonly used together elements. Put most commonly</span>
<span class="cm">	 * used elements to front of structure. Obviously do this only when the</span>
<span class="cm">	 * structure has stabilized... (AIA)</span>
<span class="cm">	 */</span>
	<span class="cm">/* Device specifics. */</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>		<span class="cm">/* Pointer back to the super_block. */</span>
	<span class="n">LCN</span> <span class="n">nr_blocks</span><span class="p">;</span>			<span class="cm">/* Number of sb-&gt;s_blocksize bytes</span>
<span class="cm">					   sized blocks on the device. */</span>
	<span class="cm">/* Configuration provided by user at mount time. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Miscellaneous flags, see below. */</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>			<span class="cm">/* uid that files will be mounted as. */</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>			<span class="cm">/* gid that files will be mounted as. */</span>
	<span class="n">umode_t</span> <span class="n">fmask</span><span class="p">;</span>			<span class="cm">/* The mask for file permissions. */</span>
	<span class="n">umode_t</span> <span class="n">dmask</span><span class="p">;</span>			<span class="cm">/* The mask for directory</span>
<span class="cm">					   permissions. */</span>
	<span class="n">u8</span> <span class="n">mft_zone_multiplier</span><span class="p">;</span>		<span class="cm">/* Initial mft zone multiplier. */</span>
	<span class="n">u8</span> <span class="n">on_errors</span><span class="p">;</span>			<span class="cm">/* What to do on filesystem errors. */</span>
	<span class="cm">/* NTFS bootsector provided information. */</span>
	<span class="n">u16</span> <span class="n">sector_size</span><span class="p">;</span>		<span class="cm">/* in bytes */</span>
	<span class="n">u8</span> <span class="n">sector_size_bits</span><span class="p">;</span>		<span class="cm">/* log2(sector_size) */</span>
	<span class="n">u32</span> <span class="n">cluster_size</span><span class="p">;</span>		<span class="cm">/* in bytes */</span>
	<span class="n">u32</span> <span class="n">cluster_size_mask</span><span class="p">;</span>		<span class="cm">/* cluster_size - 1 */</span>
	<span class="n">u8</span> <span class="n">cluster_size_bits</span><span class="p">;</span>		<span class="cm">/* log2(cluster_size) */</span>
	<span class="n">u32</span> <span class="n">mft_record_size</span><span class="p">;</span>		<span class="cm">/* in bytes */</span>
	<span class="n">u32</span> <span class="n">mft_record_size_mask</span><span class="p">;</span>	<span class="cm">/* mft_record_size - 1 */</span>
	<span class="n">u8</span> <span class="n">mft_record_size_bits</span><span class="p">;</span>	<span class="cm">/* log2(mft_record_size) */</span>
	<span class="n">u32</span> <span class="n">index_record_size</span><span class="p">;</span>		<span class="cm">/* in bytes */</span>
	<span class="n">u32</span> <span class="n">index_record_size_mask</span><span class="p">;</span>	<span class="cm">/* index_record_size - 1 */</span>
	<span class="n">u8</span> <span class="n">index_record_size_bits</span><span class="p">;</span>	<span class="cm">/* log2(index_record_size) */</span>
	<span class="n">LCN</span> <span class="n">nr_clusters</span><span class="p">;</span>		<span class="cm">/* Volume size in clusters == number of</span>
<span class="cm">					   bits in lcn bitmap. */</span>
	<span class="n">LCN</span> <span class="n">mft_lcn</span><span class="p">;</span>			<span class="cm">/* Cluster location of mft data. */</span>
	<span class="n">LCN</span> <span class="n">mftmirr_lcn</span><span class="p">;</span>		<span class="cm">/* Cluster location of copy of mft. */</span>
	<span class="n">u64</span> <span class="n">serial_no</span><span class="p">;</span>			<span class="cm">/* The volume serial number. */</span>
	<span class="cm">/* Mount specific NTFS information. */</span>
	<span class="n">u32</span> <span class="n">upcase_len</span><span class="p">;</span>			<span class="cm">/* Number of entries in upcase[]. */</span>
	<span class="n">ntfschar</span> <span class="o">*</span><span class="n">upcase</span><span class="p">;</span>		<span class="cm">/* The upcase table. */</span>

	<span class="n">s32</span> <span class="n">attrdef_size</span><span class="p">;</span>		<span class="cm">/* Size of the attribute definition</span>
<span class="cm">					   table in bytes. */</span>
	<span class="n">ATTR_DEF</span> <span class="o">*</span><span class="n">attrdef</span><span class="p">;</span>		<span class="cm">/* Table of attribute definitions.</span>
<span class="cm">					   Obtained from FILE_AttrDef. */</span>

<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/* Variables used by the cluster and mft allocators. */</span>
	<span class="n">s64</span> <span class="n">mft_data_pos</span><span class="p">;</span>		<span class="cm">/* Mft record number at which to</span>
<span class="cm">					   allocate the next mft record. */</span>
	<span class="n">LCN</span> <span class="n">mft_zone_start</span><span class="p">;</span>		<span class="cm">/* First cluster of the mft zone. */</span>
	<span class="n">LCN</span> <span class="n">mft_zone_end</span><span class="p">;</span>		<span class="cm">/* First cluster beyond the mft zone. */</span>
	<span class="n">LCN</span> <span class="n">mft_zone_pos</span><span class="p">;</span>		<span class="cm">/* Current position in the mft zone. */</span>
	<span class="n">LCN</span> <span class="n">data1_zone_pos</span><span class="p">;</span>		<span class="cm">/* Current position in the first data</span>
<span class="cm">					   zone. */</span>
	<span class="n">LCN</span> <span class="n">data2_zone_pos</span><span class="p">;</span>		<span class="cm">/* Current position in the second data</span>
<span class="cm">					   zone. */</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">mft_ino</span><span class="p">;</span>		<span class="cm">/* The VFS inode of $MFT. */</span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">mftbmp_ino</span><span class="p">;</span>	<span class="cm">/* Attribute inode for $MFT/$BITMAP. */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">mftbmp_lock</span><span class="p">;</span> <span class="cm">/* Lock for serializing accesses to the</span>
<span class="cm">					    mft record bitmap ($MFT/$BITMAP). */</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">mftmirr_ino</span><span class="p">;</span>	<span class="cm">/* The VFS inode of $MFTMirr. */</span>
	<span class="kt">int</span> <span class="n">mftmirr_size</span><span class="p">;</span>		<span class="cm">/* Size of mft mirror in mft records. */</span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">logfile_ino</span><span class="p">;</span>	<span class="cm">/* The VFS inode of $LogFile. */</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">lcnbmp_ino</span><span class="p">;</span>	<span class="cm">/* The VFS inode of $Bitmap. */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">lcnbmp_lock</span><span class="p">;</span> <span class="cm">/* Lock for serializing accesses to the</span>
<span class="cm">					    cluster bitmap ($Bitmap/$DATA). */</span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">vol_ino</span><span class="p">;</span>		<span class="cm">/* The VFS inode of $Volume. */</span>
	<span class="n">VOLUME_FLAGS</span> <span class="n">vol_flags</span><span class="p">;</span>		<span class="cm">/* Volume flags. */</span>
	<span class="n">u8</span> <span class="n">major_ver</span><span class="p">;</span>			<span class="cm">/* Ntfs major version of volume. */</span>
	<span class="n">u8</span> <span class="n">minor_ver</span><span class="p">;</span>			<span class="cm">/* Ntfs minor version of volume. */</span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">root_ino</span><span class="p">;</span>		<span class="cm">/* The VFS inode of the root</span>
<span class="cm">					   directory. */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">secure_ino</span><span class="p">;</span>	<span class="cm">/* The VFS inode of $Secure (NTFS3.0+</span>
<span class="cm">					   only, otherwise NULL). */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">extend_ino</span><span class="p">;</span>	<span class="cm">/* The VFS inode of $Extend (NTFS3.0+</span>
<span class="cm">					   only, otherwise NULL). */</span>
<span class="cp">#ifdef NTFS_RW</span>
	<span class="cm">/* $Quota stuff is NTFS3.0+ specific.  Unused/NULL otherwise. */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">quota_ino</span><span class="p">;</span>	<span class="cm">/* The VFS inode of $Quota. */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">quota_q_ino</span><span class="p">;</span>	<span class="cm">/* Attribute inode for $Quota/$Q. */</span>
	<span class="cm">/* $UsnJrnl stuff is NTFS3.0+ specific.  Unused/NULL otherwise. */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">usnjrnl_ino</span><span class="p">;</span>	<span class="cm">/* The VFS inode of $UsnJrnl. */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">usnjrnl_max_ino</span><span class="p">;</span>	<span class="cm">/* Attribute inode for $UsnJrnl/$Max. */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">usnjrnl_j_ino</span><span class="p">;</span>	<span class="cm">/* Attribute inode for $UsnJrnl/$J. */</span>
<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">nls_map</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ntfs_volume</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Defined bits for the flags field in the ntfs_volume structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">NV_Errors</span><span class="p">,</span>		<span class="cm">/* 1: Volume has errors, prevent remount rw. */</span>
	<span class="n">NV_ShowSystemFiles</span><span class="p">,</span>	<span class="cm">/* 1: Return system files in ntfs_readdir(). */</span>
	<span class="n">NV_CaseSensitive</span><span class="p">,</span>	<span class="cm">/* 1: Treat file names as case sensitive and</span>
<span class="cm">				      create filenames in the POSIX namespace.</span>
<span class="cm">				      Otherwise be case insensitive but still</span>
<span class="cm">				      create file names in POSIX namespace. */</span>
	<span class="n">NV_LogFileEmpty</span><span class="p">,</span>	<span class="cm">/* 1: $LogFile journal is empty. */</span>
	<span class="n">NV_QuotaOutOfDate</span><span class="p">,</span>	<span class="cm">/* 1: $Quota is out of date. */</span>
	<span class="n">NV_UsnJrnlStamped</span><span class="p">,</span>	<span class="cm">/* 1: $UsnJrnl has been stamped. */</span>
	<span class="n">NV_SparseEnabled</span><span class="p">,</span>	<span class="cm">/* 1: May create sparse files. */</span>
<span class="p">}</span> <span class="n">ntfs_volume_flags</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Macro tricks to expand the NVolFoo(), NVolSetFoo(), and NVolClearFoo()</span>
<span class="cm"> * functions.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFINE_NVOL_BIT_OPS(flag)					\</span>
<span class="cp">static inline int NVol##flag(ntfs_volume *vol)		\</span>
<span class="cp">{							\</span>
<span class="cp">	return test_bit(NV_##flag, &amp;(vol)-&gt;flags);	\</span>
<span class="cp">}							\</span>
<span class="cp">static inline void NVolSet##flag(ntfs_volume *vol)	\</span>
<span class="cp">{							\</span>
<span class="cp">	set_bit(NV_##flag, &amp;(vol)-&gt;flags);		\</span>
<span class="cp">}							\</span>
<span class="cp">static inline void NVolClear##flag(ntfs_volume *vol)	\</span>
<span class="cp">{							\</span>
<span class="cp">	clear_bit(NV_##flag, &amp;(vol)-&gt;flags);		\</span>
<span class="cp">}</span>

<span class="cm">/* Emit the ntfs volume bitops functions. */</span>
<span class="n">DEFINE_NVOL_BIT_OPS</span><span class="p">(</span><span class="n">Errors</span><span class="p">)</span>
<span class="n">DEFINE_NVOL_BIT_OPS</span><span class="p">(</span><span class="n">ShowSystemFiles</span><span class="p">)</span>
<span class="n">DEFINE_NVOL_BIT_OPS</span><span class="p">(</span><span class="n">CaseSensitive</span><span class="p">)</span>
<span class="n">DEFINE_NVOL_BIT_OPS</span><span class="p">(</span><span class="n">LogFileEmpty</span><span class="p">)</span>
<span class="n">DEFINE_NVOL_BIT_OPS</span><span class="p">(</span><span class="n">QuotaOutOfDate</span><span class="p">)</span>
<span class="n">DEFINE_NVOL_BIT_OPS</span><span class="p">(</span><span class="n">UsnJrnlStamped</span><span class="p">)</span>
<span class="n">DEFINE_NVOL_BIT_OPS</span><span class="p">(</span><span class="n">SparseEnabled</span><span class="p">)</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_NTFS_VOLUME_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
