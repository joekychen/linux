<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › unistr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>unistr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * unistr.c - NTFS Unicode string handling. Part of the Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2006 Anton Altaparmakov</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;types.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;ntfs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * IMPORTANT</span>
<span class="cm"> * =========</span>
<span class="cm"> *</span>
<span class="cm"> * All these routines assume that the Unicode characters are in little endian</span>
<span class="cm"> * encoding inside the strings!!!</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This is used by the name collation functions to quickly determine what</span>
<span class="cm"> * characters are (in)valid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">legal_ansi_char_array</span><span class="p">[</span><span class="mh">0x40</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span>

	<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span>

	<span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span>
	<span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>

	<span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span>
	<span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_are_names_equal - compare two Unicode names for equality</span>
<span class="cm"> * @s1:			name to compare to @s2</span>
<span class="cm"> * @s1_len:		length in Unicode characters of @s1</span>
<span class="cm"> * @s2:			name to compare to @s1</span>
<span class="cm"> * @s2_len:		length in Unicode characters of @s2</span>
<span class="cm"> * @ic:			ignore case bool</span>
<span class="cm"> * @upcase:		upcase table (only if @ic == IGNORE_CASE)</span>
<span class="cm"> * @upcase_size:	length in Unicode characters of @upcase (if present)</span>
<span class="cm"> *</span>
<span class="cm"> * Compare the names @s1 and @s2 and return &#39;true&#39; (1) if the names are</span>
<span class="cm"> * identical, or &#39;false&#39; (0) if they are not identical. If @ic is IGNORE_CASE,</span>
<span class="cm"> * the @upcase table is used to performa a case insensitive comparison.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">ntfs_are_names_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">s1_len</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">s2_len</span><span class="p">,</span> <span class="k">const</span> <span class="n">IGNORE_CASE_BOOL</span> <span class="n">ic</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">upcase</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">upcase_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s1_len</span> <span class="o">!=</span> <span class="n">s2_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span> <span class="o">==</span> <span class="n">CASE_SENSITIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">ntfs_ucsncmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s1_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">ntfs_ucsncasecmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s1_len</span><span class="p">,</span> <span class="n">upcase</span><span class="p">,</span> <span class="n">upcase_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_collate_names - collate two Unicode names</span>
<span class="cm"> * @name1:	first Unicode name to compare</span>
<span class="cm"> * @name2:	second Unicode name to compare</span>
<span class="cm"> * @err_val:	if @name1 contains an invalid character return this value</span>
<span class="cm"> * @ic:		either CASE_SENSITIVE or IGNORE_CASE</span>
<span class="cm"> * @upcase:	upcase table (ignored if @ic is CASE_SENSITIVE)</span>
<span class="cm"> * @upcase_len:	upcase table size (ignored if @ic is CASE_SENSITIVE)</span>
<span class="cm"> *</span>
<span class="cm"> * ntfs_collate_names collates two Unicode names and returns:</span>
<span class="cm"> *</span>
<span class="cm"> *  -1 if the first name collates before the second one,</span>
<span class="cm"> *   0 if the names match,</span>
<span class="cm"> *   1 if the second name collates before the first one, or</span>
<span class="cm"> * @err_val if an invalid character is found in @name1 during the comparison.</span>
<span class="cm"> *</span>
<span class="cm"> * The following characters are considered invalid: &#39;&quot;&#39;, &#39;*&#39;, &#39;&lt;&#39;, &#39;&gt;&#39; and &#39;?&#39;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ntfs_collate_names</span><span class="p">(</span><span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">name1</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">name1_len</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">name2</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">name2_len</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">err_val</span><span class="p">,</span> <span class="k">const</span> <span class="n">IGNORE_CASE_BOOL</span> <span class="n">ic</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">upcase</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">upcase_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">min_len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span>

	<span class="n">min_len</span> <span class="o">=</span> <span class="n">name1_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name1_len</span> <span class="o">&gt;</span> <span class="n">name2_len</span><span class="p">)</span>
		<span class="n">min_len</span> <span class="o">=</span> <span class="n">name2_len</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">;</span> <span class="o">++</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">name1</span><span class="o">++</span><span class="p">);</span>
		<span class="n">c2</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">name2</span><span class="o">++</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ic</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&lt;</span> <span class="n">upcase_len</span><span class="p">)</span>
				<span class="n">c1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">upcase</span><span class="p">[</span><span class="n">c1</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c2</span> <span class="o">&lt;</span> <span class="n">upcase_len</span><span class="p">)</span>
				<span class="n">c2</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">upcase</span><span class="p">[</span><span class="n">c2</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">&amp;&amp;</span> <span class="n">legal_ansi_char_array</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err_val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&lt;</span> <span class="n">c2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c2</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name1_len</span> <span class="o">&lt;</span> <span class="n">name2_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name1_len</span> <span class="o">==</span> <span class="n">name2_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* name1_len &gt; name2_len */</span>
	<span class="n">c1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">name1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">&amp;&amp;</span> <span class="n">legal_ansi_char_array</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err_val</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_ucsncmp - compare two little endian Unicode strings</span>
<span class="cm"> * @s1:		first string</span>
<span class="cm"> * @s2:		second string</span>
<span class="cm"> * @n:		maximum unicode characters to compare</span>
<span class="cm"> *</span>
<span class="cm"> * Compare the first @n characters of the Unicode strings @s1 and @s2,</span>
<span class="cm"> * The strings in little endian format and appropriate le16_to_cpu()</span>
<span class="cm"> * conversion is performed on non-little endian machines.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns an integer less than, equal to, or greater than zero</span>
<span class="cm"> * if @s1 (or the first @n Unicode characters thereof) is found, respectively,</span>
<span class="cm"> * to be less than, to match, or be greater than @s2.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ntfs_ucsncmp</span><span class="p">(</span><span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">c2</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&lt;</span> <span class="n">c2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c2</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_ucsncasecmp - compare two little endian Unicode strings, ignoring case</span>
<span class="cm"> * @s1:			first string</span>
<span class="cm"> * @s2:			second string</span>
<span class="cm"> * @n:			maximum unicode characters to compare</span>
<span class="cm"> * @upcase:		upcase table</span>
<span class="cm"> * @upcase_size:	upcase table size in Unicode characters</span>
<span class="cm"> *</span>
<span class="cm"> * Compare the first @n characters of the Unicode strings @s1 and @s2,</span>
<span class="cm"> * ignoring case. The strings in little endian format and appropriate</span>
<span class="cm"> * le16_to_cpu() conversion is performed on non-little endian machines.</span>
<span class="cm"> *</span>
<span class="cm"> * Each character is uppercased using the @upcase table before the comparison.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns an integer less than, equal to, or greater than zero</span>
<span class="cm"> * if @s1 (or the first @n Unicode characters thereof) is found, respectively,</span>
<span class="cm"> * to be less than, to match, or be greater than @s2.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ntfs_ucsncasecmp</span><span class="p">(</span><span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">upcase</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">upcase_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">c1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">upcase_size</span><span class="p">)</span>
			<span class="n">c1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">upcase</span><span class="p">[</span><span class="n">c1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">c2</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">upcase_size</span><span class="p">)</span>
			<span class="n">c2</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">upcase</span><span class="p">[</span><span class="n">c2</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&lt;</span> <span class="n">c2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c2</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ntfs_upcase_name</span><span class="p">(</span><span class="n">ntfschar</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="n">name_len</span><span class="p">,</span> <span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">upcase</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="n">upcase_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">u</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">name_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">u</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">upcase_len</span><span class="p">)</span>
			<span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">upcase</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ntfs_file_upcase_value</span><span class="p">(</span><span class="n">FILE_NAME_ATTR</span> <span class="o">*</span><span class="n">file_name_attr</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">upcase</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">upcase_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntfs_upcase_name</span><span class="p">((</span><span class="n">ntfschar</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">file_name_attr</span><span class="o">-&gt;</span><span class="n">file_name</span><span class="p">,</span>
			<span class="n">file_name_attr</span><span class="o">-&gt;</span><span class="n">file_name_length</span><span class="p">,</span> <span class="n">upcase</span><span class="p">,</span> <span class="n">upcase_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ntfs_file_compare_values</span><span class="p">(</span><span class="n">FILE_NAME_ATTR</span> <span class="o">*</span><span class="n">file_name_attr1</span><span class="p">,</span>
		<span class="n">FILE_NAME_ATTR</span> <span class="o">*</span><span class="n">file_name_attr2</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">err_val</span><span class="p">,</span> <span class="k">const</span> <span class="n">IGNORE_CASE_BOOL</span> <span class="n">ic</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">upcase</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">upcase_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ntfs_collate_names</span><span class="p">((</span><span class="n">ntfschar</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">file_name_attr1</span><span class="o">-&gt;</span><span class="n">file_name</span><span class="p">,</span>
			<span class="n">file_name_attr1</span><span class="o">-&gt;</span><span class="n">file_name_length</span><span class="p">,</span>
			<span class="p">(</span><span class="n">ntfschar</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">file_name_attr2</span><span class="o">-&gt;</span><span class="n">file_name</span><span class="p">,</span>
			<span class="n">file_name_attr2</span><span class="o">-&gt;</span><span class="n">file_name_length</span><span class="p">,</span>
			<span class="n">err_val</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">upcase</span><span class="p">,</span> <span class="n">upcase_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_nlstoucs - convert NLS string to little endian Unicode string</span>
<span class="cm"> * @vol:	ntfs volume which we are working with</span>
<span class="cm"> * @ins:	input NLS string buffer</span>
<span class="cm"> * @ins_len:	length of input string in bytes</span>
<span class="cm"> * @outs:	on return contains the allocated output Unicode string buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Convert the input string @ins, which is in whatever format the loaded NLS</span>
<span class="cm"> * map dictates, into a little endian, 2-byte Unicode string.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates the string and the caller is responsible for</span>
<span class="cm"> * calling kmem_cache_free(ntfs_name_cache, *@outs); when finished with it.</span>
<span class="cm"> *</span>
<span class="cm"> * On success the function returns the number of Unicode characters written to</span>
<span class="cm"> * the output string *@outs (&gt;= 0), not counting the terminating Unicode NULL</span>
<span class="cm"> * character. *@outs is set to the allocated output string buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * On error, a negative number corresponding to the error code is returned. In</span>
<span class="cm"> * that case the output string is not allocated. Both *@outs and *@outs_len</span>
<span class="cm"> * are then undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * This might look a bit odd due to fast path optimization...</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ntfs_nlstoucs</span><span class="p">(</span><span class="k">const</span> <span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ins</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">ins_len</span><span class="p">,</span> <span class="n">ntfschar</span> <span class="o">**</span><span class="n">outs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">nls</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span><span class="p">;</span>
	<span class="n">ntfschar</span> <span class="o">*</span><span class="n">ucs</span><span class="p">;</span>
	<span class="kt">wchar_t</span> <span class="n">wc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">wc_len</span><span class="p">;</span>

	<span class="cm">/* We do not trust outside sources. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ins</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ucs</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ntfs_name_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ucs</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">o</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ins_len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">wc_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">wc_len</span> <span class="o">=</span> <span class="n">nls</span><span class="o">-&gt;</span><span class="n">char2uni</span><span class="p">(</span><span class="n">ins</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">wc</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">wc_len</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
						<span class="n">o</span> <span class="o">&lt;</span> <span class="n">NTFS_MAX_NAME_LEN</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">wc</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">ucs</span><span class="p">[</span><span class="n">o</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">wc</span><span class="p">);</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span> <span class="cm">/* else if (!wc) */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="cm">/* else if (wc_len &lt; 0 ||</span>
<span class="cm">						o &gt;= NTFS_MAX_NAME_LEN) */</span>
				<span class="k">goto</span> <span class="n">name_err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ucs</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">outs</span> <span class="o">=</span> <span class="n">ucs</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* else if (!ucs) */</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to allocate buffer for converted &quot;</span>
				<span class="s">&quot;name from ntfs_name_cache.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* else if (!ins) */</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Received NULL pointer.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">name_err:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ntfs_name_cache</span><span class="p">,</span> <span class="n">ucs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wc_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Name using character set %s contains &quot;</span>
				<span class="s">&quot;characters that cannot be converted to &quot;</span>
				<span class="s">&quot;Unicode.&quot;</span><span class="p">,</span> <span class="n">nls</span><span class="o">-&gt;</span><span class="n">charset</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* if (o &gt;= NTFS_MAX_NAME_LEN) */</span> <span class="p">{</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Name is too long (maximum length for a &quot;</span>
				<span class="s">&quot;name on NTFS is %d Unicode characters.&quot;</span><span class="p">,</span>
				<span class="n">NTFS_MAX_NAME_LEN</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_ucstonls - convert little endian Unicode string to NLS string</span>
<span class="cm"> * @vol:	ntfs volume which we are working with</span>
<span class="cm"> * @ins:	input Unicode string buffer</span>
<span class="cm"> * @ins_len:	length of input string in Unicode characters</span>
<span class="cm"> * @outs:	on return contains the (allocated) output NLS string buffer</span>
<span class="cm"> * @outs_len:	length of output string buffer in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Convert the input little endian, 2-byte Unicode string @ins, of length</span>
<span class="cm"> * @ins_len into the string format dictated by the loaded NLS.</span>
<span class="cm"> *</span>
<span class="cm"> * If *@outs is NULL, this function allocates the string and the caller is</span>
<span class="cm"> * responsible for calling kfree(*@outs); when finished with it. In this case</span>
<span class="cm"> * @outs_len is ignored and can be 0.</span>
<span class="cm"> *</span>
<span class="cm"> * On success the function returns the number of bytes written to the output</span>
<span class="cm"> * string *@outs (&gt;= 0), not counting the terminating NULL byte. If the output</span>
<span class="cm"> * string buffer was allocated, *@outs is set to it.</span>
<span class="cm"> *</span>
<span class="cm"> * On error, a negative number corresponding to the error code is returned. In</span>
<span class="cm"> * that case the output string is not allocated. The contents of *@outs are</span>
<span class="cm"> * then undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * This might look a bit odd due to fast path optimization...</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ntfs_ucstonls</span><span class="p">(</span><span class="k">const</span> <span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="k">const</span> <span class="n">ntfschar</span> <span class="o">*</span><span class="n">ins</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">ins_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">outs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">outs_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">nls</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">nls_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">ns_len</span><span class="p">,</span> <span class="n">wc</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t trust outside sources. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ins</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="o">*</span><span class="n">outs</span><span class="p">;</span>
		<span class="n">ns_len</span> <span class="o">=</span> <span class="n">outs_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ns</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ns_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">conversion_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ns_len</span> <span class="o">=</span> <span class="n">ins_len</span> <span class="o">*</span> <span class="n">NLS_MAX_CHARSET_SIZE</span><span class="p">;</span>
			<span class="n">ns</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ns_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">mem_err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">o</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ins_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">retry:</span>			<span class="n">wc</span> <span class="o">=</span> <span class="n">nls</span><span class="o">-&gt;</span><span class="n">uni2char</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">ns</span> <span class="o">+</span> <span class="n">o</span><span class="p">,</span>
					<span class="n">ns_len</span> <span class="o">-</span> <span class="n">o</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">o</span> <span class="o">+=</span> <span class="n">wc</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wc</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span> <span class="o">&amp;&amp;</span> <span class="n">ns</span> <span class="o">!=</span> <span class="o">*</span><span class="n">outs</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>
				<span class="cm">/* Grow in multiples of 64 bytes. */</span>
				<span class="n">tc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="n">ns_len</span> <span class="o">+</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;</span>
						<span class="o">~</span><span class="mi">63</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">memcpy</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">ns_len</span><span class="p">);</span>
					<span class="n">ns_len</span> <span class="o">=</span> <span class="p">((</span><span class="n">ns_len</span> <span class="o">+</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">63</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
					<span class="n">ns</span> <span class="o">=</span> <span class="n">tc</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
				<span class="p">}</span> <span class="cm">/* No memory so goto conversion_error; */</span>
			<span class="p">}</span> <span class="cm">/* wc &lt; 0, real error. */</span>
			<span class="k">goto</span> <span class="n">conversion_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ns</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">outs</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* else (!ins) */</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Received NULL pointer.&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">conversion_err:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Unicode name contains characters that cannot be &quot;</span>
			<span class="s">&quot;converted to character set %s.  You might want to &quot;</span>
			<span class="s">&quot;try to use the mount option nls=utf8.&quot;</span><span class="p">,</span> <span class="n">nls</span><span class="o">-&gt;</span><span class="n">charset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span> <span class="o">!=</span> <span class="o">*</span><span class="n">outs</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">)</span>
		<span class="n">wc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">wc</span><span class="p">;</span>
<span class="nl">mem_err_out:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to allocate name!&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
