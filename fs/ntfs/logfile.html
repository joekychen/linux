<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › logfile.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>logfile.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * logfile.h - Defines for NTFS kernel journal ($LogFile) handling.  Part of</span>
<span class="cm"> *	       the Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000-2005 Anton Altaparmakov</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_NTFS_LOGFILE_H</span>
<span class="cp">#define _LINUX_NTFS_LOGFILE_H</span>

<span class="cp">#ifdef NTFS_RW</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>

<span class="cp">#include &quot;types.h&quot;</span>
<span class="cp">#include &quot;endian.h&quot;</span>
<span class="cp">#include &quot;layout.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Journal ($LogFile) organization:</span>
<span class="cm"> *</span>
<span class="cm"> * Two restart areas present in the first two pages (restart pages, one restart</span>
<span class="cm"> * area in each page).  When the volume is dismounted they should be identical,</span>
<span class="cm"> * except for the update sequence array which usually has a different update</span>
<span class="cm"> * sequence number.</span>
<span class="cm"> *</span>
<span class="cm"> * These are followed by log records organized in pages headed by a log record</span>
<span class="cm"> * header going up to log file size.  Not all pages contain log records when a</span>
<span class="cm"> * volume is first formatted, but as the volume ages, all records will be used.</span>
<span class="cm"> * When the log file fills up, the records at the beginning are purged (by</span>
<span class="cm"> * modifying the oldest_lsn to a higher value presumably) and writing begins</span>
<span class="cm"> * at the beginning of the file.  Effectively, the log file is viewed as a</span>
<span class="cm"> * circular entity.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Windows NT, 2000, and XP all use log file version 1.1 but they accept</span>
<span class="cm"> * versions &lt;= 1.x, including 0.-1.  (Yes, that is a minus one in there!)  We</span>
<span class="cm"> * probably only want to support 1.1 as this seems to be the current version</span>
<span class="cm"> * and we don&#39;t know how that differs from the older versions.  The only</span>
<span class="cm"> * exception is if the journal is clean as marked by the two restart pages</span>
<span class="cm"> * then it doesn&#39;t matter whether we are on an earlier version.  We can just</span>
<span class="cm"> * reinitialize the logfile and start again with version 1.1.</span>
<span class="cm"> */</span>

<span class="cm">/* Some $LogFile related constants. */</span>
<span class="cp">#define MaxLogFileSize		0x100000000ULL</span>
<span class="cp">#define DefaultLogPageSize	4096</span>
<span class="cp">#define MinLogRecordPages	48</span>

<span class="cm">/*</span>
<span class="cm"> * Log file restart page header (begins the restart area).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn&#39;t like unnamed structs. */</span>
<span class="cm">/*  0*/</span>	<span class="n">NTFS_RECORD_TYPE</span> <span class="n">magic</span><span class="p">;</span>	<span class="cm">/* The magic is &quot;RSTR&quot;. */</span>
<span class="cm">/*  4*/</span>	<span class="n">le16</span> <span class="n">usa_ofs</span><span class="p">;</span>		<span class="cm">/* See NTFS_RECORD definition in layout.h.</span>
<span class="cm">				   When creating, set this to be immediately</span>
<span class="cm">				   after this header structure (without any</span>
<span class="cm">				   alignment). */</span>
<span class="cm">/*  6*/</span>	<span class="n">le16</span> <span class="n">usa_count</span><span class="p">;</span>		<span class="cm">/* See NTFS_RECORD definition in layout.h. */</span>

<span class="cm">/*  8*/</span>	<span class="n">leLSN</span> <span class="n">chkdsk_lsn</span><span class="p">;</span>	<span class="cm">/* The last log file sequence number found by</span>
<span class="cm">				   chkdsk.  Only used when the magic is changed</span>
<span class="cm">				   to &quot;CHKD&quot;.  Otherwise this is zero. */</span>
<span class="cm">/* 16*/</span>	<span class="n">le32</span> <span class="n">system_page_size</span><span class="p">;</span>	<span class="cm">/* Byte size of system pages when the log file</span>
<span class="cm">				   was created, has to be &gt;= 512 and a power of</span>
<span class="cm">				   2.  Use this to calculate the required size</span>
<span class="cm">				   of the usa (usa_count) and add it to usa_ofs.</span>
<span class="cm">				   Then verify that the result is less than the</span>
<span class="cm">				   value of the restart_area_offset. */</span>
<span class="cm">/* 20*/</span>	<span class="n">le32</span> <span class="n">log_page_size</span><span class="p">;</span>	<span class="cm">/* Byte size of log file pages, has to be &gt;=</span>
<span class="cm">				   512 and a power of 2.  The default is 4096</span>
<span class="cm">				   and is used when the system page size is</span>
<span class="cm">				   between 4096 and 8192.  Otherwise this is</span>
<span class="cm">				   set to the system page size instead. */</span>
<span class="cm">/* 24*/</span>	<span class="n">le16</span> <span class="n">restart_area_offset</span><span class="p">;</span><span class="cm">/* Byte offset from the start of this header to</span>
<span class="cm">				   the RESTART_AREA.  Value has to be aligned</span>
<span class="cm">				   to 8-byte boundary.  When creating, set this</span>
<span class="cm">				   to be after the usa. */</span>
<span class="cm">/* 26*/</span>	<span class="n">sle16</span> <span class="n">minor_ver</span><span class="p">;</span>	<span class="cm">/* Log file minor version.  Only check if major</span>
<span class="cm">				   version is 1. */</span>
<span class="cm">/* 28*/</span>	<span class="n">sle16</span> <span class="n">major_ver</span><span class="p">;</span>	<span class="cm">/* Log file major version.  We only support</span>
<span class="cm">				   version 1.1. */</span>
<span class="cm">/* sizeof() = 30 (0x1e) bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">RESTART_PAGE_HEADER</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Constant for the log client indices meaning that there are no client records</span>
<span class="cm"> * in this particular client array.  Also inside the client records themselves,</span>
<span class="cm"> * this means that there are no client records preceding or following this one.</span>
<span class="cm"> */</span>
<span class="cp">#define LOGFILE_NO_CLIENT	cpu_to_le16(0xffff)</span>
<span class="cp">#define LOGFILE_NO_CLIENT_CPU	0xffff</span>

<span class="cm">/*</span>
<span class="cm"> * These are the so far known RESTART_AREA_* flags (16-bit) which contain</span>
<span class="cm"> * information about the log file in which they are present.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RESTART_VOLUME_IS_CLEAN</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x0002</span><span class="p">),</span>
	<span class="n">RESTART_SPACE_FILLER</span>	<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">),</span> <span class="cm">/* gcc: Force enum bit width to 16. */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">typedef</span> <span class="n">le16</span> <span class="n">RESTART_AREA_FLAGS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Log file restart area record.  The offset of this record is found by adding</span>
<span class="cm"> * the offset of the RESTART_PAGE_HEADER to the restart_area_offset value found</span>
<span class="cm"> * in it.  See notes at restart_area_offset above.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0*/</span>	<span class="n">leLSN</span> <span class="n">current_lsn</span><span class="p">;</span>	<span class="cm">/* The current, i.e. last LSN inside the log</span>
<span class="cm">				   when the restart area was last written.</span>
<span class="cm">				   This happens often but what is the interval?</span>
<span class="cm">				   Is it just fixed time or is it every time a</span>
<span class="cm">				   check point is written or somethine else?</span>
<span class="cm">				   On create set to 0. */</span>
<span class="cm">/*  8*/</span>	<span class="n">le16</span> <span class="n">log_clients</span><span class="p">;</span>	<span class="cm">/* Number of log client records in the array of</span>
<span class="cm">				   log client records which follows this</span>
<span class="cm">				   restart area.  Must be 1.  */</span>
<span class="cm">/* 10*/</span>	<span class="n">le16</span> <span class="n">client_free_list</span><span class="p">;</span>	<span class="cm">/* The index of the first free log client record</span>
<span class="cm">				   in the array of log client records.</span>
<span class="cm">				   LOGFILE_NO_CLIENT means that there are no</span>
<span class="cm">				   free log client records in the array.</span>
<span class="cm">				   If != LOGFILE_NO_CLIENT, check that</span>
<span class="cm">				   log_clients &gt; client_free_list.  On Win2k</span>
<span class="cm">				   and presumably earlier, on a clean volume</span>
<span class="cm">				   this is != LOGFILE_NO_CLIENT, and it should</span>
<span class="cm">				   be 0, i.e. the first (and only) client</span>
<span class="cm">				   record is free and thus the logfile is</span>
<span class="cm">				   closed and hence clean.  A dirty volume</span>
<span class="cm">				   would have left the logfile open and hence</span>
<span class="cm">				   this would be LOGFILE_NO_CLIENT.  On WinXP</span>
<span class="cm">				   and presumably later, the logfile is always</span>
<span class="cm">				   open, even on clean shutdown so this should</span>
<span class="cm">				   always be LOGFILE_NO_CLIENT. */</span>
<span class="cm">/* 12*/</span>	<span class="n">le16</span> <span class="n">client_in_use_list</span><span class="p">;</span><span class="cm">/* The index of the first in-use log client</span>
<span class="cm">				   record in the array of log client records.</span>
<span class="cm">				   LOGFILE_NO_CLIENT means that there are no</span>
<span class="cm">				   in-use log client records in the array.  If</span>
<span class="cm">				   != LOGFILE_NO_CLIENT check that log_clients</span>
<span class="cm">				   &gt; client_in_use_list.  On Win2k and</span>
<span class="cm">				   presumably earlier, on a clean volume this</span>
<span class="cm">				   is LOGFILE_NO_CLIENT, i.e. there are no</span>
<span class="cm">				   client records in use and thus the logfile</span>
<span class="cm">				   is closed and hence clean.  A dirty volume</span>
<span class="cm">				   would have left the logfile open and hence</span>
<span class="cm">				   this would be != LOGFILE_NO_CLIENT, and it</span>
<span class="cm">				   should be 0, i.e. the first (and only)</span>
<span class="cm">				   client record is in use.  On WinXP and</span>
<span class="cm">				   presumably later, the logfile is always</span>
<span class="cm">				   open, even on clean shutdown so this should</span>
<span class="cm">				   always be 0. */</span>
<span class="cm">/* 14*/</span>	<span class="n">RESTART_AREA_FLAGS</span> <span class="n">flags</span><span class="p">;</span><span class="cm">/* Flags modifying LFS behaviour.  On Win2k</span>
<span class="cm">				   and presumably earlier this is always 0.  On</span>
<span class="cm">				   WinXP and presumably later, if the logfile</span>
<span class="cm">				   was shutdown cleanly, the second bit,</span>
<span class="cm">				   RESTART_VOLUME_IS_CLEAN, is set.  This bit</span>
<span class="cm">				   is cleared when the volume is mounted by</span>
<span class="cm">				   WinXP and set when the volume is dismounted,</span>
<span class="cm">				   thus if the logfile is dirty, this bit is</span>
<span class="cm">				   clear.  Thus we don&#39;t need to check the</span>
<span class="cm">				   Windows version to determine if the logfile</span>
<span class="cm">				   is clean.  Instead if the logfile is closed,</span>
<span class="cm">				   we know it must be clean.  If it is open and</span>
<span class="cm">				   this bit is set, we also know it must be</span>
<span class="cm">				   clean.  If on the other hand the logfile is</span>
<span class="cm">				   open and this bit is clear, we can be almost</span>
<span class="cm">				   certain that the logfile is dirty. */</span>
<span class="cm">/* 16*/</span>	<span class="n">le32</span> <span class="n">seq_number_bits</span><span class="p">;</span>	<span class="cm">/* How many bits to use for the sequence</span>
<span class="cm">				   number.  This is calculated as 67 - the</span>
<span class="cm">				   number of bits required to store the logfile</span>
<span class="cm">				   size in bytes and this can be used in with</span>
<span class="cm">				   the specified file_size as a consistency</span>
<span class="cm">				   check. */</span>
<span class="cm">/* 20*/</span>	<span class="n">le16</span> <span class="n">restart_area_length</span><span class="p">;</span><span class="cm">/* Length of the restart area including the</span>
<span class="cm">				   client array.  Following checks required if</span>
<span class="cm">				   version matches.  Otherwise, skip them.</span>
<span class="cm">				   restart_area_offset + restart_area_length</span>
<span class="cm">				   has to be &lt;= system_page_size.  Also,</span>
<span class="cm">				   restart_area_length has to be &gt;=</span>
<span class="cm">				   client_array_offset + (log_clients *</span>
<span class="cm">				   sizeof(log client record)). */</span>
<span class="cm">/* 22*/</span>	<span class="n">le16</span> <span class="n">client_array_offset</span><span class="p">;</span><span class="cm">/* Offset from the start of this record to</span>
<span class="cm">				   the first log client record if versions are</span>
<span class="cm">				   matched.  When creating, set this to be</span>
<span class="cm">				   after this restart area structure, aligned</span>
<span class="cm">				   to 8-bytes boundary.  If the versions do not</span>
<span class="cm">				   match, this is ignored and the offset is</span>
<span class="cm">				   assumed to be (sizeof(RESTART_AREA) + 7) &amp;</span>
<span class="cm">				   ~7, i.e. rounded up to first 8-byte</span>
<span class="cm">				   boundary.  Either way, client_array_offset</span>
<span class="cm">				   has to be aligned to an 8-byte boundary.</span>
<span class="cm">				   Also, restart_area_offset +</span>
<span class="cm">				   client_array_offset has to be &lt;= 510.</span>
<span class="cm">				   Finally, client_array_offset + (log_clients</span>
<span class="cm">				   * sizeof(log client record)) has to be &lt;=</span>
<span class="cm">				   system_page_size.  On Win2k and presumably</span>
<span class="cm">				   earlier, this is 0x30, i.e. immediately</span>
<span class="cm">				   following this record.  On WinXP and</span>
<span class="cm">				   presumably later, this is 0x40, i.e. there</span>
<span class="cm">				   are 16 extra bytes between this record and</span>
<span class="cm">				   the client array.  This probably means that</span>
<span class="cm">				   the RESTART_AREA record is actually bigger</span>
<span class="cm">				   in WinXP and later. */</span>
<span class="cm">/* 24*/</span>	<span class="n">sle64</span> <span class="n">file_size</span><span class="p">;</span>	<span class="cm">/* Usable byte size of the log file.  If the</span>
<span class="cm">				   restart_area_offset + the offset of the</span>
<span class="cm">				   file_size are &gt; 510 then corruption has</span>
<span class="cm">				   occurred.  This is the very first check when</span>
<span class="cm">				   starting with the restart_area as if it</span>
<span class="cm">				   fails it means that some of the above values</span>
<span class="cm">				   will be corrupted by the multi sector</span>
<span class="cm">				   transfer protection.  The file_size has to</span>
<span class="cm">				   be rounded down to be a multiple of the</span>
<span class="cm">				   log_page_size in the RESTART_PAGE_HEADER and</span>
<span class="cm">				   then it has to be at least big enough to</span>
<span class="cm">				   store the two restart pages and 48 (0x30)</span>
<span class="cm">				   log record pages. */</span>
<span class="cm">/* 32*/</span>	<span class="n">le32</span> <span class="n">last_lsn_data_length</span><span class="p">;</span><span class="cm">/* Length of data of last LSN, not including</span>
<span class="cm">				   the log record header.  On create set to</span>
<span class="cm">				   0. */</span>
<span class="cm">/* 36*/</span>	<span class="n">le16</span> <span class="n">log_record_header_length</span><span class="p">;</span><span class="cm">/* Byte size of the log record header.</span>
<span class="cm">				   If the version matches then check that the</span>
<span class="cm">				   value of log_record_header_length is a</span>
<span class="cm">				   multiple of 8, i.e.</span>
<span class="cm">				   (log_record_header_length + 7) &amp; ~7 ==</span>
<span class="cm">				   log_record_header_length.  When creating set</span>
<span class="cm">				   it to sizeof(LOG_RECORD_HEADER), aligned to</span>
<span class="cm">				   8 bytes. */</span>
<span class="cm">/* 38*/</span>	<span class="n">le16</span> <span class="n">log_page_data_offset</span><span class="p">;</span><span class="cm">/* Offset to the start of data in a log record</span>
<span class="cm">				   page.  Must be a multiple of 8.  On create</span>
<span class="cm">				   set it to immediately after the update</span>
<span class="cm">				   sequence array of the log record page. */</span>
<span class="cm">/* 40*/</span>	<span class="n">le32</span> <span class="n">restart_log_open_count</span><span class="p">;</span><span class="cm">/* A counter that gets incremented every</span>
<span class="cm">				   time the logfile is restarted which happens</span>
<span class="cm">				   at mount time when the logfile is opened.</span>
<span class="cm">				   When creating set to a random value.  Win2k</span>
<span class="cm">				   sets it to the low 32 bits of the current</span>
<span class="cm">				   system time in NTFS format (see time.h). */</span>
<span class="cm">/* 44*/</span>	<span class="n">le32</span> <span class="n">reserved</span><span class="p">;</span>		<span class="cm">/* Reserved/alignment to 8-byte boundary. */</span>
<span class="cm">/* sizeof() = 48 (0x30) bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">RESTART_AREA</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Log client record.  The offset of this record is found by adding the offset</span>
<span class="cm"> * of the RESTART_AREA to the client_array_offset value found in it.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="cm">/*Ofs*/</span>
<span class="cm">/*  0*/</span>	<span class="n">leLSN</span> <span class="n">oldest_lsn</span><span class="p">;</span>	<span class="cm">/* Oldest LSN needed by this client.  On create</span>
<span class="cm">				   set to 0. */</span>
<span class="cm">/*  8*/</span>	<span class="n">leLSN</span> <span class="n">client_restart_lsn</span><span class="p">;</span><span class="cm">/* LSN at which this client needs to restart</span>
<span class="cm">				   the volume, i.e. the current position within</span>
<span class="cm">				   the log file.  At present, if clean this</span>
<span class="cm">				   should = current_lsn in restart area but it</span>
<span class="cm">				   probably also = current_lsn when dirty most</span>
<span class="cm">				   of the time.  At create set to 0. */</span>
<span class="cm">/* 16*/</span>	<span class="n">le16</span> <span class="n">prev_client</span><span class="p">;</span>	<span class="cm">/* The offset to the previous log client record</span>
<span class="cm">				   in the array of log client records.</span>
<span class="cm">				   LOGFILE_NO_CLIENT means there is no previous</span>
<span class="cm">				   client record, i.e. this is the first one.</span>
<span class="cm">				   This is always LOGFILE_NO_CLIENT. */</span>
<span class="cm">/* 18*/</span>	<span class="n">le16</span> <span class="n">next_client</span><span class="p">;</span>	<span class="cm">/* The offset to the next log client record in</span>
<span class="cm">				   the array of log client records.</span>
<span class="cm">				   LOGFILE_NO_CLIENT means there are no next</span>
<span class="cm">				   client records, i.e. this is the last one.</span>
<span class="cm">				   This is always LOGFILE_NO_CLIENT. */</span>
<span class="cm">/* 20*/</span>	<span class="n">le16</span> <span class="n">seq_number</span><span class="p">;</span>	<span class="cm">/* On Win2k and presumably earlier, this is set</span>
<span class="cm">				   to zero every time the logfile is restarted</span>
<span class="cm">				   and it is incremented when the logfile is</span>
<span class="cm">				   closed at dismount time.  Thus it is 0 when</span>
<span class="cm">				   dirty and 1 when clean.  On WinXP and</span>
<span class="cm">				   presumably later, this is always 0. */</span>
<span class="cm">/* 22*/</span>	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>		<span class="cm">/* Reserved/alignment. */</span>
<span class="cm">/* 28*/</span>	<span class="n">le32</span> <span class="n">client_name_length</span><span class="p">;</span><span class="cm">/* Length of client name in bytes.  Should</span>
<span class="cm">				   always be 8. */</span>
<span class="cm">/* 32*/</span>	<span class="n">ntfschar</span> <span class="n">client_name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span><span class="cm">/* Name of the client in Unicode.  Should</span>
<span class="cm">				   always be &quot;NTFS&quot; with the remaining bytes</span>
<span class="cm">				   set to 0. */</span>
<span class="cm">/* sizeof() = 160 (0xa0) bytes */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">LOG_CLIENT_RECORD</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">ntfs_check_logfile</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">log_vi</span><span class="p">,</span>
		<span class="n">RESTART_PAGE_HEADER</span> <span class="o">**</span><span class="n">rp</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">ntfs_is_logfile_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">log_vi</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">RESTART_PAGE_HEADER</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">ntfs_empty_logfile</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">log_vi</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* NTFS_RW */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_NTFS_LOGFILE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
