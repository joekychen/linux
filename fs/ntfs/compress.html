<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ntfs › compress.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>compress.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * compress.c - NTFS kernel compressed attributes handling.</span>
<span class="cm"> *		Part of the Linux-NTFS project.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2004 Anton Altaparmakov</span>
<span class="cm"> * Copyright (c) 2002 Richard Russon</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program/include file is distributed in the hope that it will be</span>
<span class="cm"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program (in the main directory of the Linux-NTFS</span>
<span class="cm"> * distribution in the file COPYING); if not, write to the Free Software</span>
<span class="cm"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;attrib.h&quot;</span>
<span class="cp">#include &quot;inode.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;ntfs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_compression_constants - enum of constants used in the compression code</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Token types and access mask. */</span>
	<span class="n">NTFS_SYMBOL_TOKEN</span>	<span class="o">=</span>	<span class="mi">0</span><span class="p">,</span>
	<span class="n">NTFS_PHRASE_TOKEN</span>	<span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
	<span class="n">NTFS_TOKEN_MASK</span>		<span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* Compression sub-block constants. */</span>
	<span class="n">NTFS_SB_SIZE_MASK</span>	<span class="o">=</span>	<span class="mh">0x0fff</span><span class="p">,</span>
	<span class="n">NTFS_SB_SIZE</span>		<span class="o">=</span>	<span class="mh">0x1000</span><span class="p">,</span>
	<span class="n">NTFS_SB_IS_COMPRESSED</span>	<span class="o">=</span>	<span class="mh">0x8000</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * The maximum compression block size is by definition 16 * the cluster</span>
<span class="cm">	 * size, with the maximum supported cluster size being 4kiB. Thus the</span>
<span class="cm">	 * maximum compression buffer size is 64kiB, so we use this when</span>
<span class="cm">	 * initializing the compression buffer.</span>
<span class="cm">	 */</span>
	<span class="n">NTFS_MAX_CB_SIZE</span>	<span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">}</span> <span class="n">ntfs_compression_constants</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_compression_buffer - one buffer for the decompression engine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ntfs_compression_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_cb_lock - spinlock which protects ntfs_compression_buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ntfs_cb_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * allocate_compression_buffers - allocate the decompression buffers</span>
<span class="cm"> *</span>
<span class="cm"> * Caller has to hold the ntfs_lock mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success or -ENOMEM if the allocations failed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">allocate_compression_buffers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ntfs_compression_buffer</span><span class="p">);</span>

	<span class="n">ntfs_compression_buffer</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">NTFS_MAX_CB_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_compression_buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_compression_buffers - free the decompression buffers</span>
<span class="cm"> *</span>
<span class="cm"> * Caller has to hold the ntfs_lock mutex.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">free_compression_buffers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ntfs_compression_buffer</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">ntfs_compression_buffer</span><span class="p">);</span>
	<span class="n">ntfs_compression_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zero_partial_compressed_page - zero out of bounds compressed page region</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zero_partial_compressed_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">s64</span> <span class="n">initialized_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">kp</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kp_ofs</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Zeroing page region outside initialized size.&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">s64</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">initialized_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * FIXME: Using clear_page() will become wrong when we get</span>
<span class="cm">		 * PAGE_CACHE_SIZE != PAGE_SIZE but for now there is no problem.</span>
<span class="cm">		 */</span>
		<span class="n">clear_page</span><span class="p">(</span><span class="n">kp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kp_ofs</span> <span class="o">=</span> <span class="n">initialized_size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">kp</span> <span class="o">+</span> <span class="n">kp_ofs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">kp_ofs</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * handle_bounds_compressed_page - test for&amp;handle out of bounds compressed page</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">handle_bounds_compressed_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">s64</span> <span class="n">initialized_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">initialized_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">initialized_size</span> <span class="o">&lt;</span> <span class="n">i_size</span><span class="p">))</span>
		<span class="n">zero_partial_compressed_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">initialized_size</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_decompress - decompress a compression block into an array of pages</span>
<span class="cm"> * @dest_pages:		destination array of pages</span>
<span class="cm"> * @dest_index:		current index into @dest_pages (IN/OUT)</span>
<span class="cm"> * @dest_ofs:		current offset within @dest_pages[@dest_index] (IN/OUT)</span>
<span class="cm"> * @dest_max_index:	maximum index into @dest_pages (IN)</span>
<span class="cm"> * @dest_max_ofs:	maximum offset within @dest_pages[@dest_max_index] (IN)</span>
<span class="cm"> * @xpage:		the target page (-1 if none) (IN)</span>
<span class="cm"> * @xpage_done:		set to 1 if xpage was completed successfully (IN/OUT)</span>
<span class="cm"> * @cb_start:		compression block to decompress (IN)</span>
<span class="cm"> * @cb_size:		size of compression block @cb_start in bytes (IN)</span>
<span class="cm"> * @i_size:		file size when we started the read (IN)</span>
<span class="cm"> * @initialized_size:	initialized file size when we started the read (IN)</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have disabled preemption. ntfs_decompress() reenables it when</span>
<span class="cm"> * the critical section is finished.</span>
<span class="cm"> *</span>
<span class="cm"> * This decompresses the compression block @cb_start into the array of</span>
<span class="cm"> * destination pages @dest_pages starting at index @dest_index into @dest_pages</span>
<span class="cm"> * and at offset @dest_pos into the page @dest_pages[@dest_index].</span>
<span class="cm"> *</span>
<span class="cm"> * When the page @dest_pages[@xpage] is completed, @xpage_done is set to 1.</span>
<span class="cm"> * If xpage is -1 or @xpage has not been completed, @xpage_done is not modified.</span>
<span class="cm"> *</span>
<span class="cm"> * @cb_start is a pointer to the compression block which needs decompressing</span>
<span class="cm"> * and @cb_size is the size of @cb_start in bytes (8-64kiB).</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if success or -EOVERFLOW on error in the compressed stream.</span>
<span class="cm"> * @xpage_done indicates whether the target page (@dest_pages[@xpage]) was</span>
<span class="cm"> * completed during the decompression of the compression block (@cb_start).</span>
<span class="cm"> *</span>
<span class="cm"> * Warning: This function *REQUIRES* PAGE_CACHE_SIZE &gt;= 4096 or it will blow up</span>
<span class="cm"> * unpredicatbly! You have been warned!</span>
<span class="cm"> *</span>
<span class="cm"> * Note to hackers: This function may not sleep until it has finished accessing</span>
<span class="cm"> * the compression block @cb_start as it is a per-CPU buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ntfs_decompress</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dest_pages</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dest_index</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">dest_ofs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">dest_max_index</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">dest_max_ofs</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">xpage</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">xpage_done</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="k">const</span> <span class="n">cb_start</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="n">cb_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">s64</span> <span class="n">initialized_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pointers into the compressed data, i.e. the compression block (cb),</span>
<span class="cm">	 * and the therein contained sub-blocks (sb).</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cb_end</span> <span class="o">=</span> <span class="n">cb_start</span> <span class="o">+</span> <span class="n">cb_size</span><span class="p">;</span> <span class="cm">/* End of cb. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb_start</span><span class="p">;</span>	<span class="cm">/* Current position in cb. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cb_sb_start</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>	<span class="cm">/* Beginning of the current sb in the cb. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cb_sb_end</span><span class="p">;</span>		<span class="cm">/* End of current sb / beginning of next sb. */</span>

	<span class="cm">/* Variables for uncompressed data / destination. */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>	<span class="cm">/* Current destination page being worked on. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dp_addr</span><span class="p">;</span>		<span class="cm">/* Current pointer into dp. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dp_sb_start</span><span class="p">;</span>	<span class="cm">/* Start of current sub-block in dp. */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dp_sb_end</span><span class="p">;</span>		<span class="cm">/* End of current sb in dp (dp_sb_start +</span>
<span class="cm">				   NTFS_SB_SIZE). */</span>
	<span class="n">u16</span> <span class="n">do_sb_start</span><span class="p">;</span>	<span class="cm">/* @dest_ofs when starting this sub-block. */</span>
	<span class="n">u16</span> <span class="n">do_sb_end</span><span class="p">;</span>		<span class="cm">/* @dest_ofs of end of this sb (do_sb_start +</span>
<span class="cm">				   NTFS_SB_SIZE). */</span>

	<span class="cm">/* Variables for tag and token parsing. */</span>
	<span class="n">u8</span> <span class="n">tag</span><span class="p">;</span>			<span class="cm">/* Current tag. */</span>
	<span class="kt">int</span> <span class="n">token</span><span class="p">;</span>		<span class="cm">/* Loop counter for the eight tokens in tag. */</span>

	<span class="cm">/* Need this because we can&#39;t sleep, so need two stages. */</span>
	<span class="kt">int</span> <span class="n">completed_pages</span><span class="p">[</span><span class="n">dest_max_index</span> <span class="o">-</span> <span class="o">*</span><span class="n">dest_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">nr_completed_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Default error code. */</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering, cb_size = 0x%x.&quot;</span><span class="p">,</span> <span class="n">cb_size</span><span class="p">);</span>
<span class="nl">do_next_sb:</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Beginning sub-block at offset = 0x%zx in the cb.&quot;</span><span class="p">,</span>
			<span class="n">cb</span> <span class="o">-</span> <span class="n">cb_start</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Have we reached the end of the compression block or the end of the</span>
<span class="cm">	 * decompressed data?  The latter can happen for example if the current</span>
<span class="cm">	 * position in the compression block is one byte before its end so the</span>
<span class="cm">	 * first two checks do not detect it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span> <span class="o">==</span> <span class="n">cb_end</span> <span class="o">||</span> <span class="o">!</span><span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">le16</span><span class="o">*</span><span class="p">)</span><span class="n">cb</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="o">*</span><span class="n">dest_index</span> <span class="o">==</span> <span class="n">dest_max_index</span> <span class="o">&amp;&amp;</span>
			<span class="o">*</span><span class="n">dest_ofs</span> <span class="o">==</span> <span class="n">dest_max_ofs</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Completed. Returning success (0).&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">return_error:</span>
		<span class="cm">/* We can sleep from now on, so we drop lock. */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_cb_lock</span><span class="p">);</span>
		<span class="cm">/* Second stage: finalize completed pages. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_completed_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_completed_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">di</span> <span class="o">=</span> <span class="n">completed_pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

				<span class="n">dp</span> <span class="o">=</span> <span class="n">dest_pages</span><span class="p">[</span><span class="n">di</span><span class="p">];</span>
				<span class="cm">/*</span>
<span class="cm">				 * If we are outside the initialized size, zero</span>
<span class="cm">				 * the out of bounds page range.</span>
<span class="cm">				 */</span>
				<span class="n">handle_bounds_compressed_page</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span>
						<span class="n">initialized_size</span><span class="p">);</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
				<span class="n">kunmap</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
				<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">di</span> <span class="o">==</span> <span class="n">xpage</span><span class="p">)</span>
					<span class="o">*</span><span class="n">xpage_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
				<span class="n">dest_pages</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup offsets for the current sub-block destination. */</span>
	<span class="n">do_sb_start</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest_ofs</span><span class="p">;</span>
	<span class="n">do_sb_end</span> <span class="o">=</span> <span class="n">do_sb_start</span> <span class="o">+</span> <span class="n">NTFS_SB_SIZE</span><span class="p">;</span>

	<span class="cm">/* Check that we are still within allowed boundaries. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dest_index</span> <span class="o">==</span> <span class="n">dest_max_index</span> <span class="o">&amp;&amp;</span> <span class="n">do_sb_end</span> <span class="o">&gt;</span> <span class="n">dest_max_ofs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>

	<span class="cm">/* Does the minimum size of a compressed sb overflow valid range? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">&gt;</span> <span class="n">cb_end</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>

	<span class="cm">/* Setup the current sub-block source pointers and validate range. */</span>
	<span class="n">cb_sb_start</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">cb_sb_end</span> <span class="o">=</span> <span class="n">cb_sb_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">le16</span><span class="o">*</span><span class="p">)</span><span class="n">cb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NTFS_SB_SIZE_MASK</span><span class="p">)</span>
			<span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb_sb_end</span> <span class="o">&gt;</span> <span class="n">cb_end</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>

	<span class="cm">/* Get the current destination page. */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">dest_pages</span><span class="p">[</span><span class="o">*</span><span class="n">dest_index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No page present. Skip decompression of this sub-block. */</span>
		<span class="n">cb</span> <span class="o">=</span> <span class="n">cb_sb_end</span><span class="p">;</span>

		<span class="cm">/* Advance destination position to next sub-block. */</span>
		<span class="o">*</span><span class="n">dest_ofs</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dest_ofs</span> <span class="o">+</span> <span class="n">NTFS_SB_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">dest_ofs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">++*</span><span class="n">dest_index</span> <span class="o">&gt;</span> <span class="n">dest_max_index</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_next_sb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We have a valid destination page. Setup the destination pointers. */</span>
	<span class="n">dp_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">+</span> <span class="n">do_sb_start</span><span class="p">;</span>

	<span class="cm">/* Now, we are ready to process the current sub-block (sb). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">le16</span><span class="o">*</span><span class="p">)</span><span class="n">cb</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NTFS_SB_IS_COMPRESSED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Found uncompressed sub-block.&quot;</span><span class="p">);</span>
		<span class="cm">/* This sb is not compressed, just copy it into destination. */</span>

		<span class="cm">/* Advance source position to first data byte. */</span>
		<span class="n">cb</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* An uncompressed sb must be full size. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cb_sb_end</span> <span class="o">-</span> <span class="n">cb</span> <span class="o">!=</span> <span class="n">NTFS_SB_SIZE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>

		<span class="cm">/* Copy the block and advance the source position. */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dp_addr</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">NTFS_SB_SIZE</span><span class="p">);</span>
		<span class="n">cb</span> <span class="o">+=</span> <span class="n">NTFS_SB_SIZE</span><span class="p">;</span>

		<span class="cm">/* Advance destination position to next sub-block. */</span>
		<span class="o">*</span><span class="n">dest_ofs</span> <span class="o">+=</span> <span class="n">NTFS_SB_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">dest_ofs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">finalize_page:</span>
			<span class="cm">/*</span>
<span class="cm">			 * First stage: add current page index to array of</span>
<span class="cm">			 * completed pages.</span>
<span class="cm">			 */</span>
			<span class="n">completed_pages</span><span class="p">[</span><span class="n">nr_completed_pages</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest_index</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++*</span><span class="n">dest_index</span> <span class="o">&gt;</span> <span class="n">dest_max_index</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">do_next_sb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Found compressed sub-block.&quot;</span><span class="p">);</span>
	<span class="cm">/* This sb is compressed, decompress it into destination. */</span>

	<span class="cm">/* Setup destination pointers. */</span>
	<span class="n">dp_sb_start</span> <span class="o">=</span> <span class="n">dp_addr</span><span class="p">;</span>
	<span class="n">dp_sb_end</span> <span class="o">=</span> <span class="n">dp_sb_start</span> <span class="o">+</span> <span class="n">NTFS_SB_SIZE</span><span class="p">;</span>

	<span class="cm">/* Forward to the first tag in the sub-block. */</span>
	<span class="n">cb</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nl">do_next_tag:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span> <span class="o">==</span> <span class="n">cb_sb_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if the decompressed sub-block was not full-length. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp_addr</span> <span class="o">&lt;</span> <span class="n">dp_sb_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nr_bytes</span> <span class="o">=</span> <span class="n">do_sb_end</span> <span class="o">-</span> <span class="o">*</span><span class="n">dest_ofs</span><span class="p">;</span>

			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Filling incomplete sub-block with &quot;</span>
					<span class="s">&quot;zeroes.&quot;</span><span class="p">);</span>
			<span class="cm">/* Zero remainder and update destination position. */</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">dp_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_bytes</span><span class="p">);</span>
			<span class="o">*</span><span class="n">dest_ofs</span> <span class="o">+=</span> <span class="n">nr_bytes</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* We have finished the current sub-block. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">dest_ofs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">finalize_page</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_next_sb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check we are still in range. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span> <span class="o">&gt;</span> <span class="n">cb_sb_end</span> <span class="o">||</span> <span class="n">dp_addr</span> <span class="o">&gt;</span> <span class="n">dp_sb_end</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>

	<span class="cm">/* Get the next tag and advance to first token. */</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="o">*</span><span class="n">cb</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Parse the eight tokens described by the tag. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">token</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">token</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">token</span><span class="o">++</span><span class="p">,</span> <span class="n">tag</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">lg</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">max_non_overlap</span><span class="p">;</span>
		<span class="k">register</span> <span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">dp_back_addr</span><span class="p">;</span>

		<span class="cm">/* Check if we are done / still in range. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cb</span> <span class="o">&gt;=</span> <span class="n">cb_sb_end</span> <span class="o">||</span> <span class="n">dp_addr</span> <span class="o">&gt;</span> <span class="n">dp_sb_end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Determine token type and parse appropriately.*/</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tag</span> <span class="o">&amp;</span> <span class="n">NTFS_TOKEN_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">NTFS_SYMBOL_TOKEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We have a symbol token, copy the symbol across, and</span>
<span class="cm">			 * advance the source and destination positions.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">dp_addr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">cb</span><span class="o">++</span><span class="p">;</span>
			<span class="o">++*</span><span class="n">dest_ofs</span><span class="p">;</span>

			<span class="cm">/* Continue with the next token. */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We have a phrase token. Make sure it is not the first tag in</span>
<span class="cm">		 * the sb as this is illegal and would confuse the code below.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp_addr</span> <span class="o">==</span> <span class="n">dp_sb_start</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Determine the number of bytes to go back (p) and the number</span>
<span class="cm">		 * of bytes to copy (l). We use an optimized algorithm in which</span>
<span class="cm">		 * we first calculate log2(current destination position in sb),</span>
<span class="cm">		 * which allows determination of l and p in O(1) rather than</span>
<span class="cm">		 * O(n). We just need an arch-optimized log2() function now.</span>
<span class="cm">		 */</span>
		<span class="n">lg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest_ofs</span> <span class="o">-</span> <span class="n">do_sb_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mh">0x10</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">lg</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Get the phrase token into i. */</span>
		<span class="n">pt</span> <span class="o">=</span> <span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">le16</span><span class="o">*</span><span class="p">)</span><span class="n">cb</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Calculate starting position of the byte sequence in</span>
<span class="cm">		 * the destination using the fact that p = (pt &gt;&gt; (12 - lg)) + 1</span>
<span class="cm">		 * and make sure we don&#39;t go too far back.</span>
<span class="cm">		 */</span>
		<span class="n">dp_back_addr</span> <span class="o">=</span> <span class="n">dp_addr</span> <span class="o">-</span> <span class="p">(</span><span class="n">pt</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">12</span> <span class="o">-</span> <span class="n">lg</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp_back_addr</span> <span class="o">&lt;</span> <span class="n">dp_sb_start</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>

		<span class="cm">/* Now calculate the length of the byte sequence. */</span>
		<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xfff</span> <span class="o">&gt;&gt;</span> <span class="n">lg</span><span class="p">))</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

		<span class="cm">/* Advance destination position and verify it is in range. */</span>
		<span class="o">*</span><span class="n">dest_ofs</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dest_ofs</span> <span class="o">&gt;</span> <span class="n">do_sb_end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">return_overflow</span><span class="p">;</span>

		<span class="cm">/* The number of non-overlapping bytes. */</span>
		<span class="n">max_non_overlap</span> <span class="o">=</span> <span class="n">dp_addr</span> <span class="o">-</span> <span class="n">dp_back_addr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">max_non_overlap</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The byte sequence doesn&#39;t overlap, just copy it. */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dp_addr</span><span class="p">,</span> <span class="n">dp_back_addr</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

			<span class="cm">/* Advance destination pointer. */</span>
			<span class="n">dp_addr</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The byte sequence does overlap, copy non-overlapping</span>
<span class="cm">			 * part and then do a slow byte by byte copy for the</span>
<span class="cm">			 * overlapping part. Also, advance the destination</span>
<span class="cm">			 * pointer.</span>
<span class="cm">			 */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dp_addr</span><span class="p">,</span> <span class="n">dp_back_addr</span><span class="p">,</span> <span class="n">max_non_overlap</span><span class="p">);</span>
			<span class="n">dp_addr</span> <span class="o">+=</span> <span class="n">max_non_overlap</span><span class="p">;</span>
			<span class="n">dp_back_addr</span> <span class="o">+=</span> <span class="n">max_non_overlap</span><span class="p">;</span>
			<span class="n">length</span> <span class="o">-=</span> <span class="n">max_non_overlap</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">length</span><span class="o">--</span><span class="p">)</span>
				<span class="o">*</span><span class="n">dp_addr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">dp_back_addr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Advance source position and continue with the next token. */</span>
		<span class="n">cb</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* No tokens left in the current tag. Continue with the next tag. */</span>
	<span class="k">goto</span> <span class="n">do_next_tag</span><span class="p">;</span>

<span class="nl">return_overflow:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Failed. Returning -EOVERFLOW.&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">return_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntfs_read_compressed_block - read a compressed block into the page cache</span>
<span class="cm"> * @page:	locked page in the compression block(s) we need to read</span>
<span class="cm"> *</span>
<span class="cm"> * When we are called the page has already been verified to be locked and the</span>
<span class="cm"> * attribute is known to be non-resident, not encrypted, but compressed.</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Determine which compression block(s) @page is in.</span>
<span class="cm"> * 2. Get hold of all pages corresponding to this/these compression block(s).</span>
<span class="cm"> * 3. Read the (first) compression block.</span>
<span class="cm"> * 4. Decompress it into the corresponding pages.</span>
<span class="cm"> * 5. Throw the compressed data away and proceed to 3. for the next compression</span>
<span class="cm"> *    block or return success if no more compression blocks left.</span>
<span class="cm"> *</span>
<span class="cm"> * Warning: We have to be careful what we do about existing pages. They might</span>
<span class="cm"> * have been written to so that we would lose data if we were to just overwrite</span>
<span class="cm"> * them with the out-of-date uncompressed data.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: For PAGE_CACHE_SIZE &gt; cb_size we are not doing the Right Thing(TM) at</span>
<span class="cm"> * the end of the file I think. We need to detect this case and zero the out</span>
<span class="cm"> * of bounds remainder of the page in question and mark it as handled. At the</span>
<span class="cm"> * moment we would just return -EIO on such a page. This bug will only become</span>
<span class="cm"> * apparent if pages are above 8kiB and the NTFS volume only uses 512 byte</span>
<span class="cm"> * clusters so is probably not going to be seen by anyone. Still this should</span>
<span class="cm"> * be fixed. (AIA)</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: Again for PAGE_CACHE_SIZE &gt; cb_size we are screwing up both in</span>
<span class="cm"> * handling sparse and compressed cbs. (AIA)</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: At the moment we don&#39;t do any zeroing out in the case that</span>
<span class="cm"> * initialized_size is less than data_size. This should be safe because of the</span>
<span class="cm"> * nature of the compression algorithm used. Just in case we check and output</span>
<span class="cm"> * an error message in read inode if the two sizes are not equal for a</span>
<span class="cm"> * compressed file. (AIA)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ntfs_read_compressed_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">initialized_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">ntfs_inode</span> <span class="o">*</span><span class="n">ni</span> <span class="o">=</span> <span class="n">NTFS_I</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">ntfs_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">runlist_element</span> <span class="o">*</span><span class="n">rl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">block_size_bits</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="o">*</span><span class="n">cb_pos</span><span class="p">,</span> <span class="o">*</span><span class="n">cb_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bhs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cb_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">itype</span><span class="p">.</span><span class="n">compressed</span><span class="p">.</span><span class="n">block_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cb_size_mask</span> <span class="o">=</span> <span class="n">cb_size</span> <span class="o">-</span> <span class="mi">1UL</span><span class="p">;</span>
	<span class="n">VCN</span> <span class="n">vcn</span><span class="p">;</span>
	<span class="n">LCN</span> <span class="n">lcn</span><span class="p">;</span>
	<span class="cm">/* The first wanted vcn (minimum alignment is PAGE_CACHE_SIZE). */</span>
	<span class="n">VCN</span> <span class="n">start_vcn</span> <span class="o">=</span> <span class="p">(((</span><span class="n">s64</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cb_size_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The first vcn after the last wanted vcn (minimum alignment is again</span>
<span class="cm">	 * PAGE_CACHE_SIZE.</span>
<span class="cm">	 */</span>
	<span class="n">VCN</span> <span class="n">end_vcn</span> <span class="o">=</span> <span class="p">((((</span><span class="n">s64</span><span class="p">)(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">cb_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="o">~</span><span class="n">cb_size_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span><span class="p">;</span>
	<span class="cm">/* Number of compression blocks (cbs) in the wanted vcn range. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_cbs</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_vcn</span> <span class="o">-</span> <span class="n">start_vcn</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span>
			<span class="o">&gt;&gt;</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">itype</span><span class="p">.</span><span class="n">compressed</span><span class="p">.</span><span class="n">block_size_bits</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Number of pages required to store the uncompressed data from all</span>
<span class="cm">	 * compression blocks (cbs) overlapping @page. Due to alignment</span>
<span class="cm">	 * guarantees of start_vcn and end_vcn, no need to round up here.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_vcn</span> <span class="o">-</span> <span class="n">start_vcn</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xpage</span><span class="p">,</span> <span class="n">max_page</span><span class="p">,</span> <span class="n">cur_page</span><span class="p">,</span> <span class="n">cur_ofs</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cb_clusters</span><span class="p">,</span> <span class="n">cb_max_ofs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">max_block</span><span class="p">,</span> <span class="n">cb_max_page</span><span class="p">,</span> <span class="n">bhs_size</span><span class="p">,</span> <span class="n">nr_bhs</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xpage_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Entering, page-&gt;index = 0x%lx, cb_size = 0x%x, nr_pages = &quot;</span>
			<span class="s">&quot;%i.&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">cb_size</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Bad things happen if we get here for anything that is not an</span>
<span class="cm">	 * unnamed $DATA attribute.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AT_DATA</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nr_pages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="cm">/* Allocate memory to store the buffer heads we need. */</span>
	<span class="n">bhs_size</span> <span class="o">=</span> <span class="n">cb_size</span> <span class="o">/</span> <span class="n">block_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">bhs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bhs_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pages</span> <span class="o">||</span> <span class="o">!</span><span class="n">bhs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bhs</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Failed to allocate internal buffers.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have already been given one page, this is the one we must do.</span>
<span class="cm">	 * Once again, the alignment guarantees keep it simple.</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">start_vcn</span> <span class="o">&lt;&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">xpage</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">pages</span><span class="p">[</span><span class="n">xpage</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The remaining pages need to be allocated and inserted into the page</span>
<span class="cm">	 * cache, alignment guarantees keep all the below much simpler. (-8</span>
<span class="cm">	 */</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ni</span><span class="p">));</span>
	<span class="n">initialized_size</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">initialized_size</span><span class="p">;</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">size_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">max_page</span> <span class="o">=</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">offset</span><span class="p">;</span>
	<span class="cm">/* Is the page fully outside i_size? (truncate in progress) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xpage</span> <span class="o">&gt;=</span> <span class="n">max_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bhs</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Compressed read outside i_size - truncated?&quot;</span><span class="p">);</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&lt;</span> <span class="n">max_page</span><span class="p">)</span>
		<span class="n">max_page</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_page</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">xpage</span><span class="p">)</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grab_cache_page_nowait</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We only (re)read the page if it isn&#39;t already read</span>
<span class="cm">			 * in and/or dirty or we would be losing data or at</span>
<span class="cm">			 * least wasting our time.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span>
					<span class="n">PageError</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have the runlist, and all the destination pages we need to fill.</span>
<span class="cm">	 * Now read the first compression block.</span>
<span class="cm">	 */</span>
	<span class="n">cur_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cur_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cb_clusters</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">itype</span><span class="p">.</span><span class="n">compressed</span><span class="p">.</span><span class="n">block_clusters</span><span class="p">;</span>
<span class="nl">do_next_cb:</span>
	<span class="n">nr_cbs</span><span class="o">--</span><span class="p">;</span>
	<span class="n">nr_bhs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Read all cb buffer heads one cluster at a time. */</span>
	<span class="n">rl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vcn</span> <span class="o">=</span> <span class="n">start_vcn</span><span class="p">,</span> <span class="n">start_vcn</span> <span class="o">+=</span> <span class="n">cb_clusters</span><span class="p">;</span> <span class="n">vcn</span> <span class="o">&lt;</span> <span class="n">start_vcn</span><span class="p">;</span>
			<span class="n">vcn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">is_retry</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rl</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">lock_retry_remap:</span>
			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">rl</span> <span class="o">=</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">rl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Seek to element containing target vcn. */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">rl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">vcn</span> <span class="o">&lt;=</span> <span class="n">vcn</span><span class="p">)</span>
				<span class="n">rl</span><span class="o">++</span><span class="p">;</span>
			<span class="n">lcn</span> <span class="o">=</span> <span class="n">ntfs_rl_vcn_to_lcn</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">vcn</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">lcn</span> <span class="o">=</span> <span class="n">LCN_RL_NOT_MAPPED</span><span class="p">;</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Reading vcn = 0x%llx, lcn = 0x%llx.&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">vcn</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lcn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lcn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * When we reach the first sparse cluster we have</span>
<span class="cm">			 * finished with the cb.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lcn</span> <span class="o">==</span> <span class="n">LCN_HOLE</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_retry</span> <span class="o">||</span> <span class="n">lcn</span> <span class="o">!=</span> <span class="n">LCN_RL_NOT_MAPPED</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">rl_err</span><span class="p">;</span>
			<span class="n">is_retry</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Attempt to map runlist, dropping lock for the</span>
<span class="cm">			 * duration.</span>
<span class="cm">			 */</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntfs_map_runlist</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">vcn</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">lock_retry_remap</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">map_rl_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">lcn</span> <span class="o">&lt;&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size_bits</span> <span class="o">&gt;&gt;</span> <span class="n">block_size_bits</span><span class="p">;</span>
		<span class="cm">/* Read the lcn from device in chunks of block_size bytes. */</span>
		<span class="n">max_block</span> <span class="o">=</span> <span class="n">block</span> <span class="o">+</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">cluster_size</span> <span class="o">&gt;&gt;</span> <span class="n">block_size_bits</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;block = 0x%x.&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="n">nr_bhs</span><span class="p">]</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">))))</span>
				<span class="k">goto</span> <span class="n">getblk_err</span><span class="p">;</span>
			<span class="n">nr_bhs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">max_block</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Release the lock if we took it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rl</span><span class="p">)</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Setup and initiate io on all buffer heads. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_bhs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbh</span> <span class="o">=</span> <span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_buffer</span><span class="p">(</span><span class="n">tbh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">tbh</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>
		<span class="n">tbh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
		<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">tbh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for io completion on all buffer heads. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_bhs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tbh</span> <span class="o">=</span> <span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">tbh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need an optimization barrier here, otherwise we start</span>
<span class="cm">		 * hitting the below fixup code when accessing a loopback</span>
<span class="cm">		 * mounted ntfs partition. This indicates either there is a</span>
<span class="cm">		 * race condition in the loop driver or, more likely, gcc</span>
<span class="cm">		 * overoptimises the code without the barrier and it doesn&#39;t</span>
<span class="cm">		 * do the Right Thing(TM).</span>
<span class="cm">		 */</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">tbh</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Buffer is unlocked but not &quot;</span>
					<span class="s">&quot;uptodate! Unplugging the disk queue &quot;</span>
					<span class="s">&quot;and rescheduling.&quot;</span><span class="p">);</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>
			<span class="n">io_schedule</span><span class="p">();</span>
			<span class="n">put_bh</span><span class="p">(</span><span class="n">tbh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">tbh</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">read_err</span><span class="p">;</span>
			<span class="n">ntfs_warning</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Buffer is now uptodate. Good.&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the compression buffer. We must not sleep any more</span>
<span class="cm">	 * until we are finished with it.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_cb_lock</span><span class="p">);</span>
	<span class="n">cb</span> <span class="o">=</span> <span class="n">ntfs_compression_buffer</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cb</span><span class="p">);</span>

	<span class="n">cb_pos</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">cb_end</span> <span class="o">=</span> <span class="n">cb</span> <span class="o">+</span> <span class="n">cb_size</span><span class="p">;</span>

	<span class="cm">/* Copy the buffer heads into the contiguous buffer. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_bhs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cb_pos</span><span class="p">,</span> <span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
		<span class="n">cb_pos</span> <span class="o">+=</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Just a precaution. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb_pos</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">cb</span> <span class="o">+</span> <span class="n">cb_size</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u16</span><span class="o">*</span><span class="p">)</span><span class="n">cb_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Reset cb_pos back to the beginning. */</span>
	<span class="n">cb_pos</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>

	<span class="cm">/* We now have both source (if present) and destination. */</span>
	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Successfully read the compression block.&quot;</span><span class="p">);</span>

	<span class="cm">/* The last page and maximum offset within it for the current cb. */</span>
	<span class="n">cb_max_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur_page</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">cur_ofs</span> <span class="o">+</span> <span class="n">cb_size</span><span class="p">;</span>
	<span class="n">cb_max_ofs</span> <span class="o">=</span> <span class="n">cb_max_page</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="n">cb_max_page</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* Catch end of file inside a compression block. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb_max_page</span> <span class="o">&gt;</span> <span class="n">max_page</span><span class="p">)</span>
		<span class="n">cb_max_page</span> <span class="o">=</span> <span class="n">max_page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcn</span> <span class="o">==</span> <span class="n">start_vcn</span> <span class="o">-</span> <span class="n">cb_clusters</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Sparse cb, zero out page range overlapping the cb. */</span>
		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Found sparse compression block.&quot;</span><span class="p">);</span>
		<span class="cm">/* We can sleep from now on, so we drop lock. */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_cb_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cb_max_ofs</span><span class="p">)</span>
			<span class="n">cb_max_page</span><span class="o">--</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">cur_page</span> <span class="o">&lt;</span> <span class="n">cb_max_page</span><span class="p">;</span> <span class="n">cur_page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">cur_page</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * FIXME: Using clear_page() will become wrong</span>
<span class="cm">				 * when we get PAGE_CACHE_SIZE != PAGE_SIZE but</span>
<span class="cm">				 * for now there is no problem.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">cur_ofs</span><span class="p">))</span>
					<span class="n">clear_page</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
				<span class="k">else</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">cur_ofs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							<span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span>
							<span class="n">cur_ofs</span><span class="p">);</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cur_page</span> <span class="o">==</span> <span class="n">xpage</span><span class="p">)</span>
					<span class="n">xpage_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">pages</span><span class="p">[</span><span class="n">cur_page</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cb_pos</span> <span class="o">+=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">cur_ofs</span><span class="p">;</span>
			<span class="n">cur_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cb_pos</span> <span class="o">&gt;=</span> <span class="n">cb_end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If we have a partial final page, deal with it now. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cb_max_ofs</span> <span class="o">&amp;&amp;</span> <span class="n">cb_pos</span> <span class="o">&lt;</span> <span class="n">cb_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">cur_page</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">cur_ofs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">cb_max_ofs</span> <span class="o">-</span> <span class="n">cur_ofs</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * No need to update cb_pos at this stage:</span>
<span class="cm">			 *	cb_pos += cb_max_ofs - cur_ofs;</span>
<span class="cm">			 */</span>
			<span class="n">cur_ofs</span> <span class="o">=</span> <span class="n">cb_max_ofs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vcn</span> <span class="o">==</span> <span class="n">start_vcn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We can&#39;t sleep so we need two stages. */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur2_page</span> <span class="o">=</span> <span class="n">cur_page</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_ofs2</span> <span class="o">=</span> <span class="n">cur_ofs</span><span class="p">;</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">cb_pos2</span> <span class="o">=</span> <span class="n">cb_pos</span><span class="p">;</span>

		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Found uncompressed compression block.&quot;</span><span class="p">);</span>
		<span class="cm">/* Uncompressed cb, copy it to the destination pages. */</span>
		<span class="cm">/*</span>
<span class="cm">		 * TODO: As a big optimization, we could detect this case</span>
<span class="cm">		 * before we read all the pages and use block_read_full_page()</span>
<span class="cm">		 * on all full pages instead (we still have to treat partial</span>
<span class="cm">		 * pages especially but at least we are getting rid of the</span>
<span class="cm">		 * synchronous io for the majority of pages.</span>
<span class="cm">		 * Or if we choose not to do the read-ahead/-behind stuff, we</span>
<span class="cm">		 * could just return block_read_full_page(pages[xpage]) as long</span>
<span class="cm">		 * as PAGE_CACHE_SIZE &lt;= cb_size.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cb_max_ofs</span><span class="p">)</span>
			<span class="n">cb_max_page</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/* First stage: copy data into destination pages. */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">cur_page</span> <span class="o">&lt;</span> <span class="n">cb_max_page</span><span class="p">;</span> <span class="n">cur_page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">cur_page</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">cur_ofs</span><span class="p">,</span> <span class="n">cb_pos</span><span class="p">,</span>
						<span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">cur_ofs</span><span class="p">);</span>
			<span class="n">cb_pos</span> <span class="o">+=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">cur_ofs</span><span class="p">;</span>
			<span class="n">cur_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cb_pos</span> <span class="o">&gt;=</span> <span class="n">cb_end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If we have a partial final page, deal with it now. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cb_max_ofs</span> <span class="o">&amp;&amp;</span> <span class="n">cb_pos</span> <span class="o">&lt;</span> <span class="n">cb_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">cur_page</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">cur_ofs</span><span class="p">,</span> <span class="n">cb_pos</span><span class="p">,</span>
						<span class="n">cb_max_ofs</span> <span class="o">-</span> <span class="n">cur_ofs</span><span class="p">);</span>
			<span class="n">cb_pos</span> <span class="o">+=</span> <span class="n">cb_max_ofs</span> <span class="o">-</span> <span class="n">cur_ofs</span><span class="p">;</span>
			<span class="n">cur_ofs</span> <span class="o">=</span> <span class="n">cb_max_ofs</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* We can sleep from now on, so drop lock. */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntfs_cb_lock</span><span class="p">);</span>
		<span class="cm">/* Second stage: finalize pages. */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">cur2_page</span> <span class="o">&lt;</span> <span class="n">cb_max_page</span><span class="p">;</span> <span class="n">cur2_page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">cur2_page</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If we are outside the initialized size, zero</span>
<span class="cm">				 * the out of bounds page range.</span>
<span class="cm">				 */</span>
				<span class="n">handle_bounds_compressed_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span>
						<span class="n">initialized_size</span><span class="p">);</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cur2_page</span> <span class="o">==</span> <span class="n">xpage</span><span class="p">)</span>
					<span class="n">xpage_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">pages</span><span class="p">[</span><span class="n">cur2_page</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cb_pos2</span> <span class="o">+=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">cur_ofs2</span><span class="p">;</span>
			<span class="n">cur_ofs2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cb_pos2</span> <span class="o">&gt;=</span> <span class="n">cb_end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Compressed cb, decompress it into the destination page(s). */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prev_cur_page</span> <span class="o">=</span> <span class="n">cur_page</span><span class="p">;</span>

		<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Found compressed compression block.&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ntfs_decompress</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_ofs</span><span class="p">,</span>
				<span class="n">cb_max_page</span><span class="p">,</span> <span class="n">cb_max_ofs</span><span class="p">,</span> <span class="n">xpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xpage_done</span><span class="p">,</span>
				<span class="n">cb_pos</span><span class="p">,</span>	<span class="n">cb_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">cb_pos</span> <span class="o">-</span> <span class="n">cb</span><span class="p">),</span> <span class="n">i_size</span><span class="p">,</span>
				<span class="n">initialized_size</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can sleep from now on, lock already dropped by</span>
<span class="cm">		 * ntfs_decompress().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ntfs_decompress() failed in inode &quot;</span>
					<span class="s">&quot;0x%lx with error code %i. Skipping &quot;</span>
					<span class="s">&quot;this compression block.&quot;</span><span class="p">,</span>
					<span class="n">ni</span><span class="o">-&gt;</span><span class="n">mft_no</span><span class="p">,</span> <span class="o">-</span><span class="n">err</span><span class="p">);</span>
			<span class="cm">/* Release the unfinished pages. */</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">prev_cur_page</span> <span class="o">&lt;</span> <span class="n">cur_page</span><span class="p">;</span> <span class="n">prev_cur_page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">prev_cur_page</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">prev_cur_page</span> <span class="o">!=</span> <span class="n">xpage</span><span class="p">)</span>
						<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="n">pages</span><span class="p">[</span><span class="n">prev_cur_page</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Release the buffer heads. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_bhs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* Do we have more work to do? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_cbs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">do_next_cb</span><span class="p">;</span>

	<span class="cm">/* We no longer need the list of buffer heads. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bhs</span><span class="p">);</span>

	<span class="cm">/* Clean up if we have any pages left. Should never happen. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cur_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cur_page</span> <span class="o">&lt;</span> <span class="n">max_page</span><span class="p">;</span> <span class="n">cur_page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">cur_page</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Still have pages left! &quot;</span>
					<span class="s">&quot;Terminating them with extreme &quot;</span>
					<span class="s">&quot;prejudice.  Inode 0x%lx, page index &quot;</span>
					<span class="s">&quot;0x%lx.&quot;</span><span class="p">,</span> <span class="n">ni</span><span class="o">-&gt;</span><span class="n">mft_no</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_page</span> <span class="o">!=</span> <span class="n">xpage</span><span class="p">)</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">cur_page</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We no longer need the list of pages. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="cm">/* If we have completed the requested page, we return success. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">xpage_done</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ntfs_debug</span><span class="p">(</span><span class="s">&quot;Failed. Returning error code %s.&quot;</span><span class="p">,</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOVERFLOW</span> <span class="o">?</span>
			<span class="s">&quot;EOVERFLOW&quot;</span> <span class="o">:</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">?</span> <span class="s">&quot;EIO&quot;</span> <span class="o">:</span> <span class="s">&quot;unknown error&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

<span class="nl">read_err:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;IO error while reading compressed data.&quot;</span><span class="p">);</span>
	<span class="cm">/* Release the buffer heads. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_bhs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

<span class="nl">map_rl_err:</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ntfs_map_runlist() failed. Cannot read &quot;</span>
			<span class="s">&quot;compression block.&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

<span class="nl">rl_err:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ntfs_rl_vcn_to_lcn() failed. Cannot read &quot;</span>
			<span class="s">&quot;compression block.&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

<span class="nl">getblk_err:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ni</span><span class="o">-&gt;</span><span class="n">runlist</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ntfs_error</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;getblk() failed. Cannot read compression block.&quot;</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bhs</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">cur_page</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_page</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">xpage</span><span class="p">)</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
