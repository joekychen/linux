<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › aio.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>aio.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	An async IO implementation for Linux</span>
<span class="cm"> *	Written by Benjamin LaHaise &lt;bcrl@kvack.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Implements an efficient asynchronous io interface.</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright 2000, 2001, 2002 Red Hat, Inc.  All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *	See ../COPYING for licensing terms.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/aio_abi.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>

<span class="cp">#define DEBUG 0</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_context.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/aio.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/eventfd.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>

<span class="cp">#include &lt;asm/kmap_types.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#if DEBUG &gt; 1</span>
<span class="cp">#define dprintk		printk</span>
<span class="cp">#else</span>
<span class="cp">#define dprintk(x...)	do { ; } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*------ sysctl variables----*/</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">aio_nr_lock</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">aio_nr</span><span class="p">;</span>		<span class="cm">/* current system wide number of aio requests */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">aio_max_nr</span> <span class="o">=</span> <span class="mh">0x10000</span><span class="p">;</span> <span class="cm">/* system wide maximum number of aio requests */</span>
<span class="cm">/*----end sysctl variables---*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span>	<span class="o">*</span><span class="n">kiocb_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span>	<span class="o">*</span><span class="n">kioctx_cachep</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">aio_wq</span><span class="p">;</span>

<span class="cm">/* Used for rare fput completion. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">aio_fput_routine</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">fput_work</span><span class="p">,</span> <span class="n">aio_fput_routine</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">fput_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">fput_head</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">aio_kick_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">aio_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* aio_setup</span>
<span class="cm"> *	Creates the slab caches used by the aio routines, panic on</span>
<span class="cm"> *	failure as this is done early during the boot sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">aio_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kiocb_cachep</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">kiocb</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">);</span>
	<span class="n">kioctx_cachep</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">kioctx</span><span class="p">,</span><span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">);</span>

	<span class="n">aio_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;aio&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* used to limit concurrency */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">aio_wq</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;aio_setup: sizeof(struct page) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">aio_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">aio_free_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aio_ring_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">vm_munmap</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">internal_pages</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">aio_setup_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aio_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aio_ring_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nr_events</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">max_reqs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="cm">/* Compensate for the ring buffer&#39;s head/tail overlap entry */</span>
	<span class="n">nr_events</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* 1 is required, 2 for good luck */</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aio_ring</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_event</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_events</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">nr_events</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">nr_pages</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aio_ring</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_event</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">internal_pages</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="n">AIO_RING_PAGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_size</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;attempting mmap of %lu bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_size</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_base</span> <span class="o">=</span> <span class="n">do_mmap_pgoff</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_size</span><span class="p">,</span> 
					<span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span>
					<span class="n">MAP_ANONYMOUS</span><span class="o">|</span><span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aio_free_ring</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;mmap address: 0x%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> 
					<span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">!=</span> <span class="n">nr_pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">aio_free_ring</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="n">nr_events</span><span class="p">;</span>		<span class="cm">/* trusted copy */</span>

	<span class="n">ring</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="n">nr_events</span><span class="p">;</span>	<span class="cm">/* user copy */</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">user_id</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">AIO_RING_MAGIC</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">compat_features</span> <span class="o">=</span> <span class="n">AIO_RING_COMPAT_FEATURES</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">incompat_features</span> <span class="o">=</span> <span class="n">AIO_RING_INCOMPAT_FEATURES</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">aio_ring</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* aio_ring_event: returns a pointer to the event at the given index from</span>
<span class="cm"> * kmap_atomic().  Release the pointer with put_aio_ring_event();</span>
<span class="cm"> */</span>
<span class="cp">#define AIO_EVENTS_PER_PAGE	(PAGE_SIZE / sizeof(struct io_event))</span>
<span class="cp">#define AIO_EVENTS_FIRST_PAGE	((PAGE_SIZE - sizeof(struct aio_ring)) / sizeof(struct io_event))</span>
<span class="cp">#define AIO_EVENTS_OFFSET	(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)</span>

<span class="cp">#define aio_ring_event(info, nr) ({					\</span>
<span class="cp">	unsigned pos = (nr) + AIO_EVENTS_OFFSET;			\</span>
<span class="cp">	struct io_event *__event;					\</span>
<span class="cp">	__event = kmap_atomic(						\</span>
<span class="cp">			(info)-&gt;ring_pages[pos / AIO_EVENTS_PER_PAGE]); \</span>
<span class="cp">	__event += pos % AIO_EVENTS_PER_PAGE;				\</span>
<span class="cp">	__event;							\</span>
<span class="cp">})</span>

<span class="cp">#define put_aio_ring_event(event) do {		\</span>
<span class="cp">	struct io_event *__event = (event);	\</span>
<span class="cp">	(void)__event;				\</span>
<span class="cp">	kunmap_atomic((void *)((unsigned long)__event &amp; PAGE_MASK)); \</span>
<span class="cp">} while(0)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ctx_rcu_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kioctx</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kioctx_cachep</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* __put_ioctx</span>
<span class="cm"> *	Called when the last user of an aio context has gone away,</span>
<span class="cm"> *	and the struct needs to be freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__put_ioctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">nr_events</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">max_reqs</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="p">);</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">aio_free_ring</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">mmdrop</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_events</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aio_nr_lock</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">aio_nr</span> <span class="o">-</span> <span class="n">nr_events</span> <span class="o">&gt;</span> <span class="n">aio_nr</span><span class="p">);</span>
		<span class="n">aio_nr</span> <span class="o">-=</span> <span class="n">nr_events</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aio_nr_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;__put_ioctx: freeing %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">rcu_head</span><span class="p">,</span> <span class="n">ctx_rcu_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">try_get_ioctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">kioctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kioctx</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_ioctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">kioctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kioctx</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kioctx</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)))</span>
		<span class="n">__put_ioctx</span><span class="p">(</span><span class="n">kioctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ioctx_alloc</span>
<span class="cm"> *	Allocates and initializes an ioctx.  Returns an ERR_PTR if it failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="nf">ioctx_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr_events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Prevent overflows */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nr_events</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mh">0x10000000U</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_event</span><span class="p">)))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">nr_events</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mh">0x10000000U</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ENOMEM: nr_events too high</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_events</span> <span class="o">||</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">nr_events</span> <span class="o">&gt;</span> <span class="n">aio_max_nr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">kioctx_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">max_reqs</span> <span class="o">=</span> <span class="n">nr_events</span><span class="p">;</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">.</span><span class="n">ring_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">active_reqs</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="n">aio_kick_handler</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aio_setup_ring</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_freectx</span><span class="p">;</span>

	<span class="cm">/* limit the number of system wide aios */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aio_nr_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aio_nr</span> <span class="o">+</span> <span class="n">nr_events</span> <span class="o">&gt;</span> <span class="n">aio_max_nr</span> <span class="o">||</span>
	    <span class="n">aio_nr</span> <span class="o">+</span> <span class="n">nr_events</span> <span class="o">&lt;</span> <span class="n">aio_nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aio_nr_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">aio_nr</span> <span class="o">+=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">max_reqs</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aio_nr_lock</span><span class="p">);</span>

	<span class="cm">/* now link into global list. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_lock</span><span class="p">);</span>
	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_lock</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;aio: allocated ioctx %p[%ld]: mm=%p mask=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">user_id</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">.</span><span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>

<span class="nl">out_cleanup:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">aio_free_ring</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="nl">out_freectx:</span>
	<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kioctx_cachep</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;aio: error allocating ioctx %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* kill_ctx</span>
<span class="cm"> *	Cancels all outstanding aio requests on an aio context.  Used </span>
<span class="cm"> *	when the processes owning a context have all exited to encourage </span>
<span class="cm"> *	the rapid destruction of the kioctx.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kill_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cancel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_event</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">io_event</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">active_reqs</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">active_reqs</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span> <span class="o">=</span> <span class="n">list_kiocb</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_list</span><span class="p">);</span>
		<span class="n">cancel</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_cancel</span><span class="p">;</span>
		<span class="n">kiocbSetCancelled</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cancel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_users</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
			<span class="n">cancel</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_task_state</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
		<span class="n">io_schedule</span><span class="p">();</span>
		<span class="n">set_task_state</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__set_task_state</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* wait_on_sync_kiocb:</span>
<span class="cm"> *	Waits on the given sync kiocb to complete.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">wait_on_sync_kiocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_users</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_users</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">io_schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_user_data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_on_sync_kiocb</span><span class="p">);</span>

<span class="cm">/* exit_aio: called when the last user of mm goes away.  At this point, </span>
<span class="cm"> * there is no way for any new requests to be submited or any of the </span>
<span class="cm"> * io_* syscalls to be called on the context.  However, there may be </span>
<span class="cm"> * outstanding requests which hold references to the context; as they </span>
<span class="cm"> * go away, they will call put_ioctx and release any pinned memory</span>
<span class="cm"> * associated with the request (held via struct page * references).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">exit_aio</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_list</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kioctx</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">kill_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
				<span class="s">&quot;exit_aio:ioctx still alive: %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">),</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t need to bother with munmap() here -</span>
<span class="cm">		 * exit_mmap(mm) is coming and it&#39;ll unmap everything.</span>
<span class="cm">		 * Since aio_free_ring() uses non-zero -&gt;mmap_size</span>
<span class="cm">		 * as indicator that it needs to unmap the area,</span>
<span class="cm">		 * just set it to 0; aio_free_ring() is the only</span>
<span class="cm">		 * place that uses -&gt;mmap_size, so it&#39;s safe.</span>
<span class="cm">		 * That way we get all munmap done to current-&gt;mm -</span>
<span class="cm">		 * all other callers have ctx-&gt;mm == current-&gt;mm.</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">.</span><span class="n">mmap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">put_ioctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* aio_get_req</span>
<span class="cm"> *	Allocate a slot for an aio request.  Increments the users count</span>
<span class="cm"> * of the kioctx so that the kioctx stays around until all requests are</span>
<span class="cm"> * complete.  Returns NULL if no requests are free.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns with kiocb-&gt;users set to 2.  The io submit code path holds</span>
<span class="cm"> * an extra reference while submitting the i/o.</span>
<span class="cm"> * This prevents races between the aio code path referencing the</span>
<span class="cm"> * req (after submitting it) and aio_complete() freeing the req.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="nf">__aio_get_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">kiocb_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_users</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_cancel</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_retry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_dtor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_iovec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct kiocb&#39;s are allocated in batches to reduce the number of</span>
<span class="cm"> * times the ctx lock is acquired and released.</span>
<span class="cm"> */</span>
<span class="cp">#define KIOCB_BATCH_SIZE	32L</span>
<span class="k">struct</span> <span class="n">kiocb_batch</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* number of requests left to allocate */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kiocb_batch_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">,</span> <span class="kt">long</span> <span class="n">total</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kiocb_batch_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">ki_batch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_batch</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_list</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kiocb_cachep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">))</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a batch of kiocbs.  This avoids taking and dropping the</span>
<span class="cm"> * context lock a lot during setup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kiocb_batch_refill</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">allocated</span><span class="p">,</span> <span class="n">to_alloc</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">avail</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">called_fput</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aio_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>

	<span class="n">to_alloc</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">KIOCB_BATCH_SIZE</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">allocated</span> <span class="o">&lt;</span> <span class="n">to_alloc</span><span class="p">;</span> <span class="n">allocated</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">__aio_get_req</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
			<span class="cm">/* allocation failed, go with what we&#39;ve got */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_batch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="n">ring</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">.</span><span class="n">ring_pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">avail</span> <span class="o">=</span> <span class="n">aio_ring_avail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">called_fput</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Handle a potential starvation case.  It is possible that</span>
<span class="cm">		 * we hold the last reference on a struct file, causing us</span>
<span class="cm">		 * to delay the final fput to non-irq context.  In this case,</span>
<span class="cm">		 * ctx-&gt;reqs_active is artificially high.  Calling the fput</span>
<span class="cm">		 * routine here may free up a slot in the event completion</span>
<span class="cm">		 * ring, allowing this allocation to succeed.</span>
<span class="cm">		 */</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
		<span class="n">aio_fput_routine</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="n">called_fput</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">allocated</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Trim back the number of requests. */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">ki_batch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_batch</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kiocb_cachep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">allocated</span> <span class="o">&lt;=</span> <span class="n">avail</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">ki_batch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">active_reqs</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">allocated</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="nf">aio_get_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kiocb_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kiocb_batch_refill</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">batch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span><span class="p">,</span> <span class="n">ki_batch</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_batch</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">req</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">really_put_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">eventfd_ctx_put</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_dtor</span><span class="p">)</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_dtor</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_iovec</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_inline_vec</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_iovec</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kiocb_cachep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">))</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">aio_fput_routine</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fput_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fput_head</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">list_kiocb</span><span class="p">(</span><span class="n">fput_head</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_ctx</span><span class="p">;</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fput_lock</span><span class="p">);</span>

		<span class="cm">/* Complete the fput(s) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_filp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">);</span>

		<span class="cm">/* Link the iocb into the context&#39;s free list */</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
		<span class="n">really_put_req</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * at that point ctx might&#39;ve been killed, but actual</span>
<span class="cm">		 * freeing is RCU&#39;d</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fput_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fput_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* __aio_put_req</span>
<span class="cm"> *	Returns true if this put was the last user of the request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__aio_put_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;aio_put(%p): f_count=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">req</span><span class="p">,</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">));</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_users</span><span class="o">--</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_users</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_users</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_list</span><span class="p">);</span>		<span class="cm">/* remove from active_reqs */</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_cancel</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_retry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to optimize the aio and eventfd file* puts, by avoiding to</span>
<span class="cm">	 * schedule work in case it is not final fput() time. In normal cases,</span>
<span class="cm">	 * we would not be holding the last reference to the file*, so</span>
<span class="cm">	 * this function will be executed w/out any aio kthread wakeup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fput_atomic</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fput_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_head</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fput_lock</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fput_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_filp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">really_put_req</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* aio_put_req</span>
<span class="cm"> *	Returns true if this put was the last user of the kiocb,</span>
<span class="cm"> *	false if the request is still in use.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">aio_put_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__aio_put_req</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">aio_put_req</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="nf">lookup_ioctx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctx_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * RCU protects us against accessing freed memory but</span>
<span class="cm">		 * we have to be careful not to get a reference when the</span>
<span class="cm">		 * reference count already dropped to 0 (ctx-&gt;dead test</span>
<span class="cm">		 * is unreliable because of races).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">ctx_id</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">&amp;&amp;</span> <span class="n">try_get_ioctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)){</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue up a kiocb to be retried. Assumes that the kiocb</span>
<span class="cm"> * has already been marked as kicked, and places it on</span>
<span class="cm"> * the retry run list for the corresponding ioctx, if it</span>
<span class="cm"> * isn&#39;t already queued. Returns 1 if it actually queued</span>
<span class="cm"> * the kiocb (to tell the caller to activate the work</span>
<span class="cm"> * queue to process it), or 0, if it found that it was</span>
<span class="cm"> * already queued.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__queue_kicked_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_ctx</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* aio_run_iocb</span>
<span class="cm"> *	This is the core aio execution routine. It is</span>
<span class="cm"> *	invoked both for initial i/o submission and</span>
<span class="cm"> *	subsequent retries via the aio_kick_handler.</span>
<span class="cm"> *	Expects to be invoked with iocb-&gt;ki_ctx-&gt;lock</span>
<span class="cm"> *	already held. The lock is released and reacquired</span>
<span class="cm"> *	as needed during processing.</span>
<span class="cm"> *</span>
<span class="cm"> * Calls the iocb retry method (already setup for the</span>
<span class="cm"> * iocb on initial submission) for operation specific</span>
<span class="cm"> * handling, but takes care of most of common retry</span>
<span class="cm"> * execution details for a given iocb. The retry method</span>
<span class="cm"> * needs to be non-blocking as far as possible, to avoid</span>
<span class="cm"> * holding up other iocbs waiting to be serviced by the</span>
<span class="cm"> * retry kernel thread.</span>
<span class="cm"> *</span>
<span class="cm"> * The trickier parts in this code have to do with</span>
<span class="cm"> * ensuring that only one retry instance is in progress</span>
<span class="cm"> * for a given iocb at any time. Providing that guarantee</span>
<span class="cm"> * simplifies the coding of individual aio operations as</span>
<span class="cm"> * it avoids various potential races.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">aio_run_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_ctx</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">retry</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">retry</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_retry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;aio_run_iocb: iocb-&gt;ki_retry = NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want the next retry iteration for this</span>
<span class="cm">	 * operation to start until this one has returned and</span>
<span class="cm">	 * updated the iocb state. However, wait_queue functions</span>
<span class="cm">	 * can trigger a kick_iocb from interrupt context in the</span>
<span class="cm">	 * meantime, indicating that data is available for the next</span>
<span class="cm">	 * iteration. We want to remember that and enable the</span>
<span class="cm">	 * next retry iteration _after_ we are through with</span>
<span class="cm">	 * this one.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So, in order to be able to register a &quot;kick&quot;, but</span>
<span class="cm">	 * prevent it from being queued now, we clear the kick</span>
<span class="cm">	 * flag, but make the kick code *think* that the iocb is</span>
<span class="cm">	 * still on the run list until we are actually done.</span>
<span class="cm">	 * When we are done with this iteration, we check if</span>
<span class="cm">	 * the iocb was kicked in the meantime and if so, queue</span>
<span class="cm">	 * it up afresh.</span>
<span class="cm">	 */</span>

	<span class="n">kiocbClearKicked</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is so that aio_complete knows it doesn&#39;t need to</span>
<span class="cm">	 * pull the iocb off the run list (We can&#39;t just call</span>
<span class="cm">	 * INIT_LIST_HEAD because we don&#39;t want a kick_iocb to</span>
<span class="cm">	 * queue this on the run list yet)</span>
<span class="cm">	 */</span>
	<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="cm">/* Quit retrying if the i/o has been cancelled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kiocbIsCancelled</span><span class="p">(</span><span class="n">iocb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="n">aio_complete</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* must not access the iocb after this */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are all set to call the retry method in async</span>
<span class="cm">	 * context.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">retry</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBRETRY</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There&#39;s no easy way to restart the syscall since other AIO&#39;s</span>
<span class="cm">		 * may be already running. Just fail this IO with EINTR.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTNOINTR</span> <span class="o">||</span>
			     <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="n">aio_complete</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">EIOCBRETRY</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * OK, now that we are done with this iteration</span>
<span class="cm">		 * and know that there is more left to go,</span>
<span class="cm">		 * this is where we let go so that a subsequent</span>
<span class="cm">		 * &quot;kick&quot; can start the next iteration</span>
<span class="cm">		 */</span>

		<span class="cm">/* will make __queue_kicked_iocb succeed from here on */</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">);</span>
		<span class="cm">/* we must queue the next iteration ourselves, if it</span>
<span class="cm">		 * has already been kicked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kiocbIsKicked</span><span class="p">(</span><span class="n">iocb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__queue_kicked_iocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * __queue_kicked_iocb will always return 1 here, because</span>
<span class="cm">			 * iocb-&gt;ki_run_list is empty at this point so it should</span>
<span class="cm">			 * be safe to unconditionally queue the context into the</span>
<span class="cm">			 * work queue.</span>
<span class="cm">			 */</span>
			<span class="n">aio_queue_work</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __aio_run_iocbs:</span>
<span class="cm"> * 	Process all pending retries queued on the ioctx</span>
<span class="cm"> * 	run list.</span>
<span class="cm"> * Assumes it is operating within the aio issuer&#39;s mm</span>
<span class="cm"> * context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__aio_run_iocbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">run_list</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">run_list</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">run_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iocb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">run_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span><span class="p">,</span>
			<span class="n">ki_run_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Hold an extra reference while retrying i/o.</span>
<span class="cm">		 */</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_users</span><span class="o">++</span><span class="p">;</span>       <span class="cm">/* grab extra reference */</span>
		<span class="n">aio_run_iocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>
		<span class="n">__aio_put_req</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>
 	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">aio_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if someone is waiting, get the work started right</span>
<span class="cm">	 * away, otherwise, use a longer delay</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">))</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">aio_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * aio_run_all_iocbs:</span>
<span class="cm"> *	Process all pending retries queued on the ioctx</span>
<span class="cm"> *	run list, and keep running them until the list</span>
<span class="cm"> *	stays empty.</span>
<span class="cm"> * Assumes it is operating within the aio issuer&#39;s mm context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">aio_run_all_iocbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__aio_run_iocbs</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
		<span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * aio_kick_handler:</span>
<span class="cm"> * 	Work queue handler triggered to process pending</span>
<span class="cm"> * 	retries on an ioctx. Takes on the aio issuer&#39;s</span>
<span class="cm"> *	mm context before running the iocbs, so that</span>
<span class="cm"> *	copy_xxx_user operates on the issuer&#39;s address</span>
<span class="cm"> *      space.</span>
<span class="cm"> * Run on aiod&#39;s context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">aio_kick_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kioctx</span><span class="p">,</span> <span class="n">wq</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">requeue</span><span class="p">;</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">USER_DS</span><span class="p">);</span>
	<span class="n">use_mm</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="n">requeue</span> <span class="o">=</span><span class="n">__aio_run_iocbs</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
 	<span class="n">unuse_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * we&#39;re in a worker thread already; no point using non-zero delay</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">requeue</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">aio_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Called by kick_iocb to queue the kiocb for retry</span>
<span class="cm"> * and if required activate the aio work queue to process</span>
<span class="cm"> * it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">try_queue_kicked_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="k">struct</span> <span class="n">kioctx</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">run</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* set this inside the lock so that we can&#39;t race with aio_run_iocb()</span>
<span class="cm">	 * testing it and putting the iocb on the run list under the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kiocbTryKick</span><span class="p">(</span><span class="n">iocb</span><span class="p">))</span>
		<span class="n">run</span> <span class="o">=</span> <span class="n">__queue_kicked_iocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">run</span><span class="p">)</span>
		<span class="n">aio_queue_work</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kick_iocb:</span>
<span class="cm"> *      Called typically from a wait queue callback context</span>
<span class="cm"> *      to trigger a retry of the iocb.</span>
<span class="cm"> *      The retry is usually executed by aio workqueue</span>
<span class="cm"> *      threads (See aio_kick_handler).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kick_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* sync iocbs are easy: they can only ever be executing from a </span>
<span class="cm">	 * single context. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_sync_kiocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kiocbSetKicked</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>
	        <span class="n">wake_up_process</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_obj</span><span class="p">.</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">try_queue_kicked_iocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kick_iocb</span><span class="p">);</span>

<span class="cm">/* aio_complete</span>
<span class="cm"> *	Called when the io request on the given iocb is complete.</span>
<span class="cm"> *	Returns true if this is the last user of the request.  The </span>
<span class="cm"> *	only other user of the request can be the cancellation code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">aio_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="kt">long</span> <span class="n">res</span><span class="p">,</span> <span class="kt">long</span> <span class="n">res2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aio_ring_info</span>	<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aio_ring</span>	<span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_event</span>	<span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tail</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Special case handling for sync iocbs:</span>
<span class="cm">	 *  - events go directly into the iocb for fast handling</span>
<span class="cm">	 *  - the sync task with the iocb in its stack holds the single iocb</span>
<span class="cm">	 *    ref, no other paths have a way to get another ref</span>
<span class="cm">	 *  - the sync task helpfully left a reference to itself in the iocb</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_sync_kiocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_users</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_user_data</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_users</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_obj</span><span class="p">.</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">;</span>

	<span class="cm">/* add a completion event to the ring buffer.</span>
<span class="cm">	 * must be done holding ctx-&gt;ctx_lock to prevent</span>
<span class="cm">	 * other code from messing with the tail</span>
<span class="cm">	 * pointer since we might be called from irq</span>
<span class="cm">	 * context.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">.</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_run_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * cancelled requests don&#39;t get events, userland was given one</span>
<span class="cm">	 * when the event got cancelled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kiocbIsCancelled</span><span class="p">(</span><span class="n">iocb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">put_rq</span><span class="p">;</span>

	<span class="n">ring</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">tail</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">aio_ring_event</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">tail</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_obj</span><span class="p">.</span><span class="n">user</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_user_data</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">res2</span> <span class="o">=</span> <span class="n">res2</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;aio_complete: %p[%lu]: %p: %p %Lx %lx %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ctx</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_obj</span><span class="p">.</span><span class="n">user</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_user_data</span><span class="p">,</span>
		<span class="n">res</span><span class="p">,</span> <span class="n">res2</span><span class="p">);</span>

	<span class="cm">/* after flagging the request as done, we</span>
<span class="cm">	 * must never even look at it again</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>	<span class="cm">/* make event visible before updating tail */</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>

	<span class="n">put_aio_ring_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;added to ring %p at [%lu]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the user asked us to deliver the result through an</span>
<span class="cm">	 * eventfd. The eventfd_signal() function is safe to be called</span>
<span class="cm">	 * from IRQ context.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">eventfd_signal</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">put_rq:</span>
	<span class="cm">/* everything turned out well, dispose of the aiocb. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__aio_put_req</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to order our ring_info tail store above and test</span>
<span class="cm">	 * of the wait list below outside the wait lock.  This is</span>
<span class="cm">	 * like in wake_up_bit() where clearing a bit has to be</span>
<span class="cm">	 * ordered with the unlocked test.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">aio_complete</span><span class="p">);</span>

<span class="cm">/* aio_read_evt</span>
<span class="cm"> *	Pull an event off of the ioctx&#39;s event ring.  Returns the number of </span>
<span class="cm"> *	events fetched (0 or 1 ;-)</span>
<span class="cm"> *	FIXME: make this use cmpxchg.</span>
<span class="cm"> *	TODO: make the ringbuffer user mmap()able (requires FIXME).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">aio_read_evt</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ioctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_event</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aio_ring_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioctx</span><span class="o">-&gt;</span><span class="n">ring_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aio_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ring</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;in aio_read_evt h%lu t%lu m%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">);</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">%</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">io_event</span> <span class="o">*</span><span class="n">evp</span> <span class="o">=</span> <span class="n">aio_ring_event</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ent</span> <span class="o">=</span> <span class="o">*</span><span class="n">evp</span><span class="p">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>
		<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* finish reading the event before updatng the head */</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">put_aio_ring_event</span><span class="p">(</span><span class="n">evp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ring_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;leaving aio_read_evt: %d  h%lu t%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">aio_timeout</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">timed_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">timeout_func</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">aio_timeout</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aio_timeout</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">to</span><span class="o">-&gt;</span><span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">aio_timeout</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_timer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">timeout_func</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">to</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_timeout</span><span class="p">(</span><span class="kt">long</span> <span class="n">start_jiffies</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aio_timeout</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">start_jiffies</span> <span class="o">+</span> <span class="n">timespec_to_jiffies</span><span class="p">(</span><span class="n">ts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">to</span><span class="o">-&gt;</span><span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">aio_timeout</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_singleshot_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			<span class="kt">long</span> <span class="n">min_nr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">io_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span>			<span class="n">start_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_event</span>		<span class="n">ent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">aio_timeout</span>	<span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* needed to zero any padding within an entry (there shouldn&#39;t be </span>
<span class="cm">	 * any, but C is fun!</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ent</span><span class="p">));</span>
<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">aio_read_evt</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;read event: %Lx %Lx %Lx %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ent</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">res</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">res2</span><span class="p">);</span>

		<span class="cm">/* Could we split the check in two? */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ent</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;aio: lost an event due to EFAULT.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Good, event copied to userland, update counts. */</span>
		<span class="n">event</span> <span class="o">++</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">min_nr</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* End fast path */</span>

	<span class="cm">/* racey check, but it gets redone */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retry</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">aio_run_all_iocbs</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec</span>	<span class="n">ts</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">))))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">set_timeout</span><span class="p">(</span><span class="n">start_jiffies</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">add_wait_queue_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">set_task_state</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">aio_read_evt</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min_nr</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">to</span><span class="p">.</span><span class="n">timed_out</span><span class="p">)</span>	<span class="cm">/* Only check after read evt */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* Try to only show up in io wait if there are ops</span>
<span class="cm">			 *  in flight */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">reqs_active</span><span class="p">)</span>
				<span class="n">io_schedule</span><span class="p">();</span>
			<span class="k">else</span>
				<span class="n">schedule</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*ret = aio_read_evt(ctx, &amp;ent);*/</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span>

		<span class="n">set_task_state</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ent</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;aio: lost an event due to EFAULT.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Good, event copied to userland, update counts. */</span>
		<span class="n">event</span> <span class="o">++</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">clear_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">destroy_timer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Take an ioctx and remove it from the list of ioctx&#39;s.  Protects </span>
<span class="cm"> * against races with itself via -&gt;dead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">io_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ioctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_dead</span><span class="p">;</span>

	<span class="cm">/* delete the entry from the list is someone else hasn&#39;t already */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_lock</span><span class="p">);</span>
	<span class="n">was_dead</span> <span class="o">=</span> <span class="n">ioctx</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">;</span>
	<span class="n">ioctx</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_lock</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;aio_release(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ioctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">was_dead</span><span class="p">))</span>
		<span class="n">put_ioctx</span><span class="p">(</span><span class="n">ioctx</span><span class="p">);</span>	<span class="cm">/* twice for the list */</span>

	<span class="n">kill_ctx</span><span class="p">(</span><span class="n">ioctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wake up any waiters.  The setting of ctx-&gt;dead must be seen</span>
<span class="cm">	 * by other CPUs at this point.  Right now, we rely on the</span>
<span class="cm">	 * locking done by the above calls to ensure this consistency.</span>
<span class="cm">	 */</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioctx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* sys_io_setup:</span>
<span class="cm"> *	Create an aio_context capable of receiving at least nr_events.</span>
<span class="cm"> *	ctxp must not point to an aio_context that already exists, and</span>
<span class="cm"> *	must be initialized to 0 prior to the call.  On successful</span>
<span class="cm"> *	creation of the aio_context, *ctxp is filled in with the resulting </span>
<span class="cm"> *	handle.  May fail with -EINVAL if *ctxp is not initialized,</span>
<span class="cm"> *	if the specified nr_events exceeds internal limits.  May fail </span>
<span class="cm"> *	with -EAGAIN if the specified nr_events exceeds the user&#39;s limit </span>
<span class="cm"> *	of available events.  May fail with -ENOMEM if insufficient kernel</span>
<span class="cm"> *	resources are available.  May fail with -EFAULT if an invalid</span>
<span class="cm"> *	pointer is passed for ctxp.  Will fail with -ENOSYS if not</span>
<span class="cm"> *	implemented.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">io_setup</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="n">nr_events</span><span class="p">,</span> <span class="n">aio_context_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">ctxp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ioctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctxp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctx</span> <span class="o">||</span> <span class="n">nr_events</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EINVAL: io_setup: ctx %lu nr_events %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		         <span class="n">ctx</span><span class="p">,</span> <span class="n">nr_events</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ioctx</span> <span class="o">=</span> <span class="n">ioctx_alloc</span><span class="p">(</span><span class="n">nr_events</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ioctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ioctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ioctx</span><span class="o">-&gt;</span><span class="n">user_id</span><span class="p">,</span> <span class="n">ctxp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">io_destroy</span><span class="p">(</span><span class="n">ioctx</span><span class="p">);</span>
		<span class="n">put_ioctx</span><span class="p">(</span><span class="n">ioctx</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sys_io_destroy:</span>
<span class="cm"> *	Destroy the aio_context specified.  May cancel any outstanding </span>
<span class="cm"> *	AIOs and block on completion.  Will fail with -ENOSYS if not</span>
<span class="cm"> *	implemented.  May fail with -EINVAL if the context pointed to</span>
<span class="cm"> *	is invalid.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">io_destroy</span><span class="p">,</span> <span class="n">aio_context_t</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ioctx</span> <span class="o">=</span> <span class="n">lookup_ioctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">ioctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">io_destroy</span><span class="p">(</span><span class="n">ioctx</span><span class="p">);</span>
		<span class="n">put_ioctx</span><span class="p">(</span><span class="n">ioctx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EINVAL: io_destroy: invalid context id</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">aio_advance_iovec</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_iovec</span><span class="p">[</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_cur_seg</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_cur_seg</span> <span class="o">&lt;</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_nr_segs</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">ssize_t</span> <span class="n">this</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+=</span> <span class="n">this</span><span class="p">;</span>
		<span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-=</span> <span class="n">this</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_left</span> <span class="o">-=</span> <span class="n">this</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">-=</span> <span class="n">this</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_cur_seg</span><span class="o">++</span><span class="p">;</span>
			<span class="n">iov</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* the caller should not have done more io than what fit in</span>
<span class="cm">	 * the remaining iovecs */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">aio_rw_vect_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">rw_op</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">opcode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_opcode</span> <span class="o">==</span> <span class="n">IOCB_CMD_PREADV</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_opcode</span> <span class="o">==</span> <span class="n">IOCB_CMD_PREAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rw_op</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_read</span><span class="p">;</span>
		<span class="n">opcode</span> <span class="o">=</span> <span class="n">IOCB_CMD_PREADV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rw_op</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_write</span><span class="p">;</span>
		<span class="n">opcode</span> <span class="o">=</span> <span class="n">IOCB_CMD_PWRITEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This matches the pread()/pwrite() logic */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rw_op</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_iovec</span><span class="p">[</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_cur_seg</span><span class="p">],</span>
			    <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_nr_segs</span> <span class="o">-</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_cur_seg</span><span class="p">,</span>
			    <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">aio_advance_iovec</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* retry all partial writes.  retry partial reads as long as its a</span>
<span class="cm">	 * regular file. */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_left</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">IOCB_CMD_PWRITEV</span> <span class="o">||</span>
		  <span class="p">(</span><span class="o">!</span><span class="n">S_ISFIFO</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))));</span>

	<span class="cm">/* This means we must have transferred all that we could */</span>
	<span class="cm">/* No need to retry anymore */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_nbytes</span> <span class="o">-</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_left</span><span class="p">;</span>

	<span class="cm">/* If we managed to write some out we return that, rather than</span>
<span class="cm">	 * the eventual error. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">IOCB_CMD_PWRITEV</span>
	    <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBRETRY</span>
	    <span class="o">&amp;&amp;</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_nbytes</span> <span class="o">-</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_left</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_nbytes</span> <span class="o">-</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_left</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">aio_fdsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_fsync</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_fsync</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">aio_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_fsync</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_fsync</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">aio_setup_vectored_rw</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">compat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">compat</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_rw_copy_check_uvector</span><span class="p">(</span><span class="n">type</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">compat_iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_buf</span><span class="p">,</span>
				<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_nbytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_inline_vec</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_iovec</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rw_copy_check_uvector</span><span class="p">(</span><span class="n">type</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_buf</span><span class="p">,</span>
				<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_nbytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_inline_vec</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_iovec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rw_verify_area</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_nr_segs</span> <span class="o">=</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_nbytes</span><span class="p">;</span>
	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_cur_seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* ki_nbytes/left now reflect bytes instead of segs */</span>
	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_nbytes</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_left</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">aio_setup_single_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">=</span> <span class="n">rw_verify_area</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_iovec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_inline_vec</span><span class="p">;</span>
	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_iovec</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_buf</span><span class="p">;</span>
	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_iovec</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_nr_segs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_cur_seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * aio_setup_iocb:</span>
<span class="cm"> *	Performs the initial checks and aio retry method</span>
<span class="cm"> *	setup for the kiocb at the time of io submission.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">aio_setup_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">compat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_opcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IOCB_CMD_PREAD</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_buf</span><span class="p">,</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_left</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">aio_setup_single_vector</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">kiocb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_read</span><span class="p">)</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_retry</span> <span class="o">=</span> <span class="n">aio_rw_vect_retry</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOCB_CMD_PWRITE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_buf</span><span class="p">,</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_left</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">aio_setup_single_vector</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">kiocb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_write</span><span class="p">)</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_retry</span> <span class="o">=</span> <span class="n">aio_rw_vect_retry</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOCB_CMD_PREADV</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">aio_setup_vectored_rw</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">kiocb</span><span class="p">,</span> <span class="n">compat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_read</span><span class="p">)</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_retry</span> <span class="o">=</span> <span class="n">aio_rw_vect_retry</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOCB_CMD_PWRITEV</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">aio_setup_vectored_rw</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">kiocb</span><span class="p">,</span> <span class="n">compat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_write</span><span class="p">)</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_retry</span> <span class="o">=</span> <span class="n">aio_rw_vect_retry</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOCB_CMD_FDSYNC</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_fsync</span><span class="p">)</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_retry</span> <span class="o">=</span> <span class="n">aio_fdsync</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOCB_CMD_FSYNC</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">aio_fsync</span><span class="p">)</span>
			<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_retry</span> <span class="o">=</span> <span class="n">aio_fsync</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;EINVAL: io_submit: no operation provided</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_retry</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">io_submit_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_iocb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb_batch</span> <span class="o">*</span><span class="n">batch</span><span class="p">,</span>
			 <span class="n">bool</span> <span class="n">compat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* enforce forwards compatibility on users */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_reserved1</span> <span class="o">||</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_reserved2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EINVAL: io_submit: reserve field set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* prevent overflows */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
	    <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_buf</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_buf</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_nbytes</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_nbytes</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_nbytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	   <span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EINVAL: io_submit: overflow check</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_fildes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="n">req</span> <span class="o">=</span> <span class="n">aio_get_req</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">batch</span><span class="p">);</span>  <span class="cm">/* returns with 2 references to req */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_filp</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_FLAG_RESFD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the IOCB_FLAG_RESFD flag of aio_flags is set, get an</span>
<span class="cm">		 * instance of the file* now. The file descriptor must be</span>
<span class="cm">		 * an eventfd() fd, and will be signaled for each completed</span>
<span class="cm">		 * event using the eventfd_signal() function.</span>
<span class="cm">		 */</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span> <span class="o">=</span> <span class="n">eventfd_ctx_fdget</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_resfd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span><span class="p">);</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_eventfd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_put_req</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_iocb</span><span class="o">-&gt;</span><span class="n">aio_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;EFAULT: aio_key</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put_req</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_obj</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user_iocb</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_user_data</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_data</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_offset</span><span class="p">;</span>

	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_buf</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_left</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_nbytes</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_nbytes</span><span class="p">;</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">ki_opcode</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_lio_opcode</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">aio_setup_iocb</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">compat</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_req</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We could have raced with io_destroy() and are currently holding a</span>
<span class="cm">	 * reference to ctx which should be destroyed. We cannot submit IO</span>
<span class="cm">	 * since ctx gets freed as soon as io_submit() puts its reference.  The</span>
<span class="cm">	 * check here is reliable: io_destroy() sets ctx-&gt;dead before waiting</span>
<span class="cm">	 * for outstanding IO and the barrier between these two is realized by</span>
<span class="cm">	 * unlock of mm-&gt;ioctx_lock and lock of ctx-&gt;ctx_lock.  Analogously we</span>
<span class="cm">	 * increment ctx-&gt;reqs_active before checking for ctx-&gt;dead and the</span>
<span class="cm">	 * barrier is realized by unlock and lock of ctx-&gt;ctx_lock. Thus if we</span>
<span class="cm">	 * don&#39;t see ctx-&gt;dead set here, io_destroy() waits for our IO to</span>
<span class="cm">	 * finish.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put_req</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">aio_run_iocb</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* drain the run list */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">__aio_run_iocbs</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
			<span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="n">aio_put_req</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>	<span class="cm">/* drop extra ref to req */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_put_req:</span>
	<span class="n">aio_put_req</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>	<span class="cm">/* drop extra ref to req */</span>
	<span class="n">aio_put_req</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>	<span class="cm">/* drop i/o ref to req */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="n">do_io_submit</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx_id</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">iocb</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__user</span> <span class="o">*</span><span class="n">iocbpp</span><span class="p">,</span> <span class="n">bool</span> <span class="n">compat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kiocb_batch</span> <span class="n">batch</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="n">LONG_MAX</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iocbpp</span><span class="p">)))</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">LONG_MAX</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iocbpp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">iocbpp</span><span class="p">,</span> <span class="p">(</span><span class="n">nr</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iocbpp</span><span class="p">)))))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">lookup_ioctx</span><span class="p">(</span><span class="n">ctx_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EINVAL: io_submit: invalid context id</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kiocb_batch_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>

	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * AKPM: should this return a partial result if some of the IOs were</span>
<span class="cm">	 * successfully submitted?</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iocb</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_iocb</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">iocb</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">user_iocb</span><span class="p">,</span> <span class="n">iocbpp</span> <span class="o">+</span> <span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">user_iocb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">io_submit_one</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">user_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="p">,</span> <span class="n">compat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="n">kiocb_batch_free</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="p">);</span>
	<span class="n">put_ioctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sys_io_submit:</span>
<span class="cm"> *	Queue the nr iocbs pointed to by iocbpp for processing.  Returns</span>
<span class="cm"> *	the number of iocbs queued.  May return -EINVAL if the aio_context</span>
<span class="cm"> *	specified by ctx_id is invalid, if nr is &lt; 0, if the iocb at</span>
<span class="cm"> *	*iocbpp[0] is not properly initialized, if the operation specified</span>
<span class="cm"> *	is invalid for the file descriptor in the iocb.  May fail with</span>
<span class="cm"> *	-EFAULT if any of the data structures point to invalid data.  May</span>
<span class="cm"> *	fail with -EBADF if the file descriptor specified in the first</span>
<span class="cm"> *	iocb is invalid.  May fail with -EAGAIN if insufficient resources</span>
<span class="cm"> *	are available to queue any iocbs.  Will return 0 if nr is 0.  Will</span>
<span class="cm"> *	fail with -ENOSYS if not implemented.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">io_submit</span><span class="p">,</span> <span class="n">aio_context_t</span><span class="p">,</span> <span class="n">ctx_id</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">iocb</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">iocbpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_io_submit</span><span class="p">(</span><span class="n">ctx_id</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">iocbpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* lookup_kiocb</span>
<span class="cm"> *	Finds a given iocb for cancellation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">lookup_kiocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span> <span class="n">__user</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="cm">/* TODO: use a hash or array, this sucks. */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">active_reqs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span> <span class="o">=</span> <span class="n">list_kiocb</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_obj</span><span class="p">.</span><span class="n">user</span> <span class="o">==</span> <span class="n">iocb</span> <span class="o">&amp;&amp;</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">kiocb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sys_io_cancel:</span>
<span class="cm"> *	Attempts to cancel an iocb previously passed to io_submit.  If</span>
<span class="cm"> *	the operation is successfully cancelled, the resulting event is</span>
<span class="cm"> *	copied into the memory pointed to by result without being placed</span>
<span class="cm"> *	into the completion queue and 0 is returned.  May fail with</span>
<span class="cm"> *	-EFAULT if any of the data structures pointed to are invalid.</span>
<span class="cm"> *	May fail with -EINVAL if aio_context specified by ctx_id is</span>
<span class="cm"> *	invalid.  May fail with -EAGAIN if the iocb specified was not</span>
<span class="cm"> *	cancelled.  Will fail with -ENOSYS if not implemented.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">io_cancel</span><span class="p">,</span> <span class="n">aio_context_t</span><span class="p">,</span> <span class="n">ctx_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">io_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cancel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_event</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">aio_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">lookup_ioctx</span><span class="p">(</span><span class="n">ctx_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">kiocb</span> <span class="o">=</span> <span class="n">lookup_kiocb</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kiocb</span> <span class="o">&amp;&amp;</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_cancel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cancel</span> <span class="o">=</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_cancel</span><span class="p">;</span>
		<span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_users</span> <span class="o">++</span><span class="p">;</span>
		<span class="n">kiocbSetCancelled</span><span class="p">(</span><span class="n">kiocb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cancel</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ctx_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">cancel</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">io_event</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;calling cancel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_obj</span><span class="p">.</span><span class="n">user</span><span class="p">;</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">kiocb</span><span class="o">-&gt;</span><span class="n">ki_user_data</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">kiocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Cancellation succeeded -- copy the result</span>
<span class="cm">			 * into the user&#39;s buffer.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">put_ioctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* io_getevents:</span>
<span class="cm"> *	Attempts to read at least min_nr events and up to nr events from</span>
<span class="cm"> *	the completion queue for the aio_context specified by ctx_id. If</span>
<span class="cm"> *	it succeeds, the number of read events is returned. May fail with</span>
<span class="cm"> *	-EINVAL if ctx_id is invalid, if min_nr is out of range, if nr is</span>
<span class="cm"> *	out of range, if timeout is out of range.  May fail with -EFAULT</span>
<span class="cm"> *	if any of the memory specified is invalid.  May return 0 or</span>
<span class="cm"> *	&lt; min_nr if the timeout specified by timeout has elapsed</span>
<span class="cm"> *	before sufficient events are available, where timeout == NULL</span>
<span class="cm"> *	specifies an infinite timeout. Note that the timeout pointed to by</span>
<span class="cm"> *	timeout is relative and will be updated if not NULL and the</span>
<span class="cm"> *	operation blocks. Will fail with -ENOSYS if not implemented.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">io_getevents</span><span class="p">,</span> <span class="n">aio_context_t</span><span class="p">,</span> <span class="n">ctx_id</span><span class="p">,</span>
		<span class="kt">long</span><span class="p">,</span> <span class="n">min_nr</span><span class="p">,</span>
		<span class="kt">long</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">io_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kioctx</span> <span class="o">*</span><span class="n">ioctx</span> <span class="o">=</span> <span class="n">lookup_ioctx</span><span class="p">(</span><span class="n">ctx_id</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ioctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">min_nr</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&amp;&amp;</span> <span class="n">min_nr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">read_events</span><span class="p">(</span><span class="n">ioctx</span><span class="p">,</span> <span class="n">min_nr</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="n">put_ioctx</span><span class="p">(</span><span class="n">ioctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">asmlinkage_protect</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ctx_id</span><span class="p">,</span> <span class="n">min_nr</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
