<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › afs › callback.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>callback.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2002, 2007 Red Hat, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software may be freely redistributed under the terms of the</span>
<span class="cm"> * GNU General Public License.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *          David Howells &lt;dhowells@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/circ_buf.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">unsigned afs_vnode_update_timeout = 10;</span>
<span class="cp">#endif  /*  0  */</span>

<span class="cp">#define afs_breakring_space(server) \</span>
<span class="cp">	CIRC_SPACE((server)-&gt;cb_break_head, (server)-&gt;cb_break_tail,	\</span>
<span class="cp">		   ARRAY_SIZE((server)-&gt;cb_break))</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>static void afs<em>callback</em>updater(struct work_struct *);</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">afs_callback_update_worker</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * allow the fileserver to request callback state (re-)initialisation</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">afs_init_callback_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="n">vnode</span><span class="p">;</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;{%p}&quot;</span><span class="p">,</span> <span class="n">server</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>

	<span class="cm">/* kill all the promises on record from this server */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_promises</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">vnode</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_promises</span><span class="p">.</span><span class="n">rb_node</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">afs_vnode</span><span class="p">,</span> <span class="n">cb_promise</span><span class="p">);</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;UNPROMISE { vid=%x:%u uq=%u}&quot;</span><span class="p">,</span>
		       <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">vid</span><span class="p">,</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">vnode</span><span class="p">,</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">unique</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promise</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_promises</span><span class="p">);</span>
		<span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handle the data invalidation side of a callback being broken</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">afs_broken_callback_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="n">vnode</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_vnode</span><span class="p">,</span> <span class="n">cb_broken_work</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AFS_VNODE_DELETED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* we&#39;re only interested in dealing with a broken callback on *this*</span>
<span class="cm">	 * vnode and only if no-one else has dealt with it yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">validate_lock</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* someone else is dealing with it */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AFS_VNODE_CB_BROKEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">afs_clear_permits</span><span class="p">(</span><span class="n">vnode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">afs_vnode_fetch_status</span><span class="p">(</span><span class="n">vnode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AFS_VNODE_DELETED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* if the vnode&#39;s data version number changed then its contents</span>
<span class="cm">		 * are different */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">AFS_VNODE_ZAP_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">afs_zap_data</span><span class="p">(</span><span class="n">vnode</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">validate_lock</span><span class="p">);</span>

	<span class="cm">/* avoid the potential race whereby the mutex_trylock() in this</span>
<span class="cm">	 * function happens again between the clear_bit() and the</span>
<span class="cm">	 * mutex_unlock() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">AFS_VNODE_CB_BROKEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;requeue&quot;</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">afs_callback_update_worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_broken_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * actually break a callback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">afs_break_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="n">vnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">AFS_VNODE_CB_BROKEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;break callback&quot;</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promise</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_promises</span><span class="p">);</span>
			<span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>

		<span class="n">queue_work</span><span class="p">(</span><span class="n">afs_callback_update_worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_broken_work</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">granted_locks</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">pending_locks</span><span class="p">))</span>
			<span class="n">afs_lock_may_be_available</span><span class="p">(</span><span class="n">vnode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allow the fileserver to explicitly break one callback</span>
<span class="cm"> * - happens when</span>
<span class="cm"> *   - the backing file is changed</span>
<span class="cm"> *   - a lock is released</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">afs_break_one_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">afs_fid</span> <span class="o">*</span><span class="n">fid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="n">vnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;find&quot;</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">fs_lock</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">fs_vnodes</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vnode</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_vnode</span><span class="p">,</span> <span class="n">server_rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fid</span><span class="o">-&gt;</span><span class="n">vid</span> <span class="o">&lt;</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">vid</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fid</span><span class="o">-&gt;</span><span class="n">vid</span> <span class="o">&gt;</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">vid</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fid</span><span class="o">-&gt;</span><span class="n">vnode</span> <span class="o">&lt;</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">vnode</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fid</span><span class="o">-&gt;</span><span class="n">vnode</span> <span class="o">&gt;</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">vnode</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fid</span><span class="o">-&gt;</span><span class="n">unique</span> <span class="o">&lt;</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">unique</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fid</span><span class="o">-&gt;</span><span class="n">unique</span> <span class="o">&gt;</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">unique</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* not found so we just ignore it (it may have moved to another</span>
<span class="cm">	 * server) */</span>
<span class="nl">not_available:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;not avail&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">fs_lock</span><span class="p">);</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;found&quot;</span><span class="p">);</span>
	<span class="n">ASSERTCMP</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">==</span><span class="p">,</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">igrab</span><span class="p">(</span><span class="n">AFS_VNODE_TO_I</span><span class="p">(</span><span class="n">vnode</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">not_available</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">fs_lock</span><span class="p">);</span>

	<span class="n">afs_break_callback</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">vnode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allow the fileserver to break callback promises</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">afs_break_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">afs_callback</span> <span class="n">callbacks</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;%p,%zu,&quot;</span><span class="p">,</span> <span class="n">server</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">server</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERTCMP</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="o">&lt;=</span><span class="p">,</span> <span class="n">AFSCBMAX</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">callbacks</span><span class="o">++</span><span class="p">,</span> <span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- Fid { vl=%08x n=%u u=%u }  CB { v=%u x=%u t=%u }&quot;</span><span class="p">,</span>
		       <span class="n">callbacks</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">vid</span><span class="p">,</span>
		       <span class="n">callbacks</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">vnode</span><span class="p">,</span>
		       <span class="n">callbacks</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">.</span><span class="n">unique</span><span class="p">,</span>
		       <span class="n">callbacks</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span>
		       <span class="n">callbacks</span><span class="o">-&gt;</span><span class="n">expiry</span><span class="p">,</span>
		       <span class="n">callbacks</span><span class="o">-&gt;</span><span class="n">type</span>
		       <span class="p">);</span>
		<span class="n">afs_break_one_callback</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callbacks</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * record the callback for breaking</span>
<span class="cm"> * - the caller must hold server-&gt;cb_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">afs_do_give_up_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="n">vnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">afs_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;%p,%p&quot;</span><span class="p">,</span> <span class="n">server</span><span class="p">,</span> <span class="n">vnode</span><span class="p">);</span>

	<span class="n">cb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break</span><span class="p">[</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_head</span><span class="p">];</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fid</span>		<span class="o">=</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">version</span>	<span class="o">=</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_version</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">expiry</span>	<span class="o">=</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_expiry</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">type</span>	<span class="o">=</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_type</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_head</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* defer the breaking of callbacks to try and collect as many as</span>
<span class="cm">	 * possible to ship in one operation */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_n</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span> <span class="p">...</span> <span class="n">AFSCBMAX</span> <span class="o">-</span> <span class="mi">1</span>:
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">afs_callback_update_worker</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_work</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFSCBMAX</span>:
		<span class="n">afs_flush_callback_breaks</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_promises</span><span class="p">.</span><span class="n">rb_node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promise</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_promises</span><span class="p">);</span>
	<span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * discard the callback on a deleted item</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">afs_discard_callback_on_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="n">vnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">;</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; [not promised]&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">server</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_promises</span><span class="p">.</span><span class="n">rb_node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promise</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_promises</span><span class="p">);</span>
		<span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * give up the callback registered for a vnode on the file server when the</span>
<span class="cm"> * inode is being cleared</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">afs_give_up_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="n">vnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">;</span>

	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">myself</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span><span class="p">);</span>

	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;GIVE UP INODE %p&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; [not promised]&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">server</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span> <span class="o">&amp;&amp;</span> <span class="n">afs_breakring_space</span><span class="p">(</span><span class="n">server</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myself</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span> <span class="o">||</span>
			    <span class="n">afs_breakring_space</span><span class="p">(</span><span class="n">server</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myself</span><span class="p">);</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* of course, it&#39;s always possible for the server to break this vnode&#39;s</span>
<span class="cm">	 * callback first... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">cb_promised</span><span class="p">)</span>
		<span class="n">afs_do_give_up_callback</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">vnode</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_lock</span><span class="p">);</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dispatch a deferred give up callbacks operation</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">afs_dispatch_give_up_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_server</span><span class="p">,</span> <span class="n">cb_break_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="cm">/* tell the fileserver to discard the callback promises it has</span>
<span class="cm">	 * - in the event of ENOMEM or some other error, we just forget that we</span>
<span class="cm">	 *   had callbacks entirely, and the server will call us later to break</span>
<span class="cm">	 *   them</span>
<span class="cm">	 */</span>
	<span class="n">afs_fs_give_up_callbacks</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">afs_async_call</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * flush the outstanding callback breaks on a server</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">afs_flush_callback_breaks</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_work</span><span class="p">);</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">afs_callback_update_worker</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">cb_break_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * update a bunch of callbacks</span>
<span class="c"> */</span>
<span class="c">static void afs_callback_updater(struct work_struct *work)</span>
<span class="c">{</span>
<span class="c">	struct afs_server *server;</span>
<span class="c">	struct afs_vnode *vnode, *xvnode;</span>
<span class="c">	time_t now;</span>
<span class="c">	long timeout;</span>
<span class="c">	int ret;</span>

<span class="c">	server = container_of(work, struct afs_server, updater);</span>

<span class="c">	_enter(&quot;&quot;);</span>

<span class="c">	now = get_seconds();</span>

<span class="c">	/* find the first vnode to update */</span>
<span class="c">	spin_lock(&amp;server-&gt;cb_lock);</span>
<span class="c">	for (;;) {</span>
<span class="c">		if (RB_EMPTY_ROOT(&amp;server-&gt;cb_promises)) {</span>
<span class="c">			spin_unlock(&amp;server-&gt;cb_lock);</span>
<span class="c">			_leave(&quot; [nothing]&quot;);</span>
<span class="c">			return;</span>
<span class="c">		}</span>

<span class="c">		vnode = rb_entry(rb_first(&amp;server-&gt;cb_promises),</span>
<span class="c">				 struct afs_vnode, cb_promise);</span>
<span class="c">		if (atomic_read(&amp;vnode-&gt;usage) &gt; 0)</span>
<span class="c">			break;</span>
<span class="c">		rb_erase(&amp;vnode-&gt;cb_promise, &amp;server-&gt;cb_promises);</span>
<span class="c">		vnode-&gt;cb_promised = false;</span>
<span class="c">	}</span>

<span class="c">	timeout = vnode-&gt;update_at - now;</span>
<span class="c">	if (timeout &gt; 0) {</span>
<span class="c">		queue_delayed_work(afs_vnode_update_worker,</span>
<span class="c">				   &amp;afs_vnode_update, timeout * HZ);</span>
<span class="c">		spin_unlock(&amp;server-&gt;cb_lock);</span>
<span class="c">		_leave(&quot; [nothing]&quot;);</span>
<span class="c">		return;</span>
<span class="c">	}</span>

<span class="c">	list_del_init(&amp;vnode-&gt;update);</span>
<span class="c">	atomic_inc(&amp;vnode-&gt;usage);</span>
<span class="c">	spin_unlock(&amp;server-&gt;cb_lock);</span>

<span class="c">	/* we can now perform the update */</span>
<span class="c">	_debug(&quot;update %s&quot;, vnode-&gt;vldb.name);</span>
<span class="c">	vnode-&gt;state = AFS_VL_UPDATING;</span>
<span class="c">	vnode-&gt;upd_rej_cnt = 0;</span>
<span class="c">	vnode-&gt;upd_busy_cnt = 0;</span>

<span class="c">	ret = afs_vnode_update_record(vl, &amp;vldb);</span>
<span class="c">	switch (ret) {</span>
<span class="c">	case 0:</span>
<span class="c">		afs_vnode_apply_update(vl, &amp;vldb);</span>
<span class="c">		vnode-&gt;state = AFS_VL_UPDATING;</span>
<span class="c">		break;</span>
<span class="c">	case -ENOMEDIUM:</span>
<span class="c">		vnode-&gt;state = AFS_VL_VOLUME_DELETED;</span>
<span class="c">		break;</span>
<span class="c">	default:</span>
<span class="c">		vnode-&gt;state = AFS_VL_UNCERTAIN;</span>
<span class="c">		break;</span>
<span class="c">	}</span>

<span class="c">	/* and then reschedule */</span>
<span class="c">	_debug(&quot;reschedule&quot;);</span>
<span class="c">	vnode-&gt;update_at = get_seconds() + afs_vnode_update_timeout;</span>

<span class="c">	spin_lock(&amp;server-&gt;cb_lock);</span>

<span class="c">	if (!list_empty(&amp;server-&gt;cb_promises)) {</span>
<span class="c">		/* next update in 10 minutes, but wait at least 1 second more</span>
<span class="c">		 * than the newest record already queued so that we don&#39;t spam</span>
<span class="c">		 * the VL server suddenly with lots of requests</span>
<span class="c">		 */</span>
<span class="c">		xvnode = list_entry(server-&gt;cb_promises.prev,</span>
<span class="c">				    struct afs_vnode, update);</span>
<span class="c">		if (vnode-&gt;update_at &lt;= xvnode-&gt;update_at)</span>
<span class="c">			vnode-&gt;update_at = xvnode-&gt;update_at + 1;</span>
<span class="c">		xvnode = list_entry(server-&gt;cb_promises.next,</span>
<span class="c">				    struct afs_vnode, update);</span>
<span class="c">		timeout = xvnode-&gt;update_at - now;</span>
<span class="c">		if (timeout &lt; 0)</span>
<span class="c">			timeout = 0;</span>
<span class="c">	} else {</span>
<span class="c">		timeout = afs_vnode_update_timeout;</span>
<span class="c">	}</span>

<span class="c">	list_add_tail(&amp;vnode-&gt;update, &amp;server-&gt;cb_promises);</span>

<span class="c">	_debug(&quot;timeout %ld&quot;, timeout);</span>
<span class="c">	queue_delayed_work(afs_vnode_update_worker,</span>
<span class="c">			   &amp;afs_vnode_update, timeout * HZ);</span>
<span class="c">	spin_unlock(&amp;server-&gt;cb_lock);</span>
<span class="c">	afs_put_vnode(vl);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * initialise the callback update process</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">afs_callback_update_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">afs_callback_update_worker</span> <span class="o">=</span>
		<span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;kafs_callbackd&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">afs_callback_update_worker</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * shut down the callback update process</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">afs_callback_update_kill</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">afs_callback_update_worker</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
