<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › afs › internal.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>internal.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* internal AFS stuff</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, 2007 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/rxrpc.h&gt;</span>
<span class="cp">#include &lt;linux/key.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fscache.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>

<span class="cp">#include &quot;afs.h&quot;</span>
<span class="cp">#include &quot;afs_vl.h&quot;</span>

<span class="cp">#define AFS_CELL_MAX_ADDRS 15</span>

<span class="k">struct</span> <span class="n">pagevec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">afs_call</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">AFS_VL_NEW</span><span class="p">,</span>			<span class="cm">/* new, uninitialised record */</span>
	<span class="n">AFS_VL_CREATING</span><span class="p">,</span>		<span class="cm">/* creating record */</span>
	<span class="n">AFS_VL_VALID</span><span class="p">,</span>			<span class="cm">/* record is pending */</span>
	<span class="n">AFS_VL_NO_VOLUME</span><span class="p">,</span>		<span class="cm">/* no such volume available */</span>
	<span class="n">AFS_VL_UPDATING</span><span class="p">,</span>		<span class="cm">/* update in progress */</span>
	<span class="n">AFS_VL_VOLUME_DELETED</span><span class="p">,</span>		<span class="cm">/* volume was deleted */</span>
	<span class="n">AFS_VL_UNCERTAIN</span><span class="p">,</span>		<span class="cm">/* uncertain state (update failed) */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">afs_vlocation_state_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">afs_mount_params</span> <span class="p">{</span>
	<span class="n">bool</span>			<span class="n">rwpath</span><span class="p">;</span>		<span class="cm">/* T if the parent should be considered R/W */</span>
	<span class="n">bool</span>			<span class="n">force</span><span class="p">;</span>		<span class="cm">/* T to force cell type */</span>
	<span class="n">bool</span>			<span class="n">autocell</span><span class="p">;</span>	<span class="cm">/* T if set auto mount operation */</span>
	<span class="n">afs_voltype_t</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* type of volume requested */</span>
	<span class="kt">int</span>			<span class="n">volnamesz</span><span class="p">;</span>	<span class="cm">/* size of volume name */</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">volname</span><span class="p">;</span>	<span class="cm">/* name of volume to mount */</span>
	<span class="k">struct</span> <span class="n">afs_cell</span>		<span class="o">*</span><span class="n">cell</span><span class="p">;</span>		<span class="cm">/* cell in which to find volume */</span>
	<span class="k">struct</span> <span class="n">afs_volume</span>	<span class="o">*</span><span class="n">volume</span><span class="p">;</span>	<span class="cm">/* volume record */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* key to use for secure mounting */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * definition of how to wait for the completion of an operation</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="p">{</span>
	<span class="cm">/* RxRPC received message notification */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rx_wakeup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="n">call</span><span class="p">);</span>

	<span class="cm">/* synchronous call waiter and call dispatched notification */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wait</span><span class="p">)(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="n">call</span><span class="p">);</span>

	<span class="cm">/* asynchronous call completion */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">async_complete</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">reply</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="n">afs_sync_call</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="n">afs_async_call</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * a record of an in-progress RxRPC call</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_call</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">afs_call_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>	<span class="cm">/* type of call */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="n">wait_mode</span><span class="p">;</span>	<span class="cm">/* completion wait mode */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">waitq</span><span class="p">;</span>		<span class="cm">/* processes awaiting completion */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">async_work</span><span class="p">;</span>	<span class="cm">/* asynchronous work processor */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>		<span class="cm">/* actual work processor */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">rx_queue</span><span class="p">;</span>	<span class="cm">/* received packets */</span>
	<span class="k">struct</span> <span class="n">rxrpc_call</span>	<span class="o">*</span><span class="n">rxcall</span><span class="p">;</span>	<span class="cm">/* RxRPC call handle */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* security for this call */</span>
	<span class="k">struct</span> <span class="n">afs_server</span>	<span class="o">*</span><span class="n">server</span><span class="p">;</span>	<span class="cm">/* server affected by incoming CM call */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">request</span><span class="p">;</span>	<span class="cm">/* request data (first part) */</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span><span class="p">;</span>	<span class="cm">/* page set */</span>
	<span class="k">struct</span> <span class="n">afs_writeback</span>	<span class="o">*</span><span class="n">wb</span><span class="p">;</span>		<span class="cm">/* writeback being performed */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">buffer</span><span class="p">;</span>	<span class="cm">/* reply receive buffer */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">reply</span><span class="p">;</span>		<span class="cm">/* reply buffer (first part) */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">reply2</span><span class="p">;</span>	<span class="cm">/* reply buffer (second part) */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">reply3</span><span class="p">;</span>	<span class="cm">/* reply buffer (third part) */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">reply4</span><span class="p">;</span>	<span class="cm">/* reply buffer (fourth part) */</span>
	<span class="n">pgoff_t</span>			<span class="n">first</span><span class="p">;</span>		<span class="cm">/* first page in mapping to deal with */</span>
	<span class="n">pgoff_t</span>			<span class="n">last</span><span class="p">;</span>		<span class="cm">/* last page in mapping to deal with */</span>
	<span class="k">enum</span> <span class="p">{</span>					<span class="cm">/* call state */</span>
		<span class="n">AFS_CALL_REQUESTING</span><span class="p">,</span>	<span class="cm">/* request is being sent for outgoing call */</span>
		<span class="n">AFS_CALL_AWAIT_REPLY</span><span class="p">,</span>	<span class="cm">/* awaiting reply to outgoing call */</span>
		<span class="n">AFS_CALL_AWAIT_OP_ID</span><span class="p">,</span>	<span class="cm">/* awaiting op ID on incoming call */</span>
		<span class="n">AFS_CALL_AWAIT_REQUEST</span><span class="p">,</span>	<span class="cm">/* awaiting request data on incoming call */</span>
		<span class="n">AFS_CALL_REPLYING</span><span class="p">,</span>	<span class="cm">/* replying to incoming call */</span>
		<span class="n">AFS_CALL_AWAIT_ACK</span><span class="p">,</span>	<span class="cm">/* awaiting final ACK of incoming call */</span>
		<span class="n">AFS_CALL_COMPLETE</span><span class="p">,</span>	<span class="cm">/* successfully completed */</span>
		<span class="n">AFS_CALL_BUSY</span><span class="p">,</span>		<span class="cm">/* server was busy */</span>
		<span class="n">AFS_CALL_ABORTED</span><span class="p">,</span>	<span class="cm">/* call was aborted */</span>
		<span class="n">AFS_CALL_ERROR</span><span class="p">,</span>		<span class="cm">/* call failed due to error */</span>
	<span class="p">}</span>			<span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error code */</span>
	<span class="kt">unsigned</span>		<span class="n">request_size</span><span class="p">;</span>	<span class="cm">/* size of request data */</span>
	<span class="kt">unsigned</span>		<span class="n">reply_max</span><span class="p">;</span>	<span class="cm">/* maximum size of reply */</span>
	<span class="kt">unsigned</span>		<span class="n">reply_size</span><span class="p">;</span>	<span class="cm">/* current size of reply */</span>
	<span class="kt">unsigned</span>		<span class="n">first_offset</span><span class="p">;</span>	<span class="cm">/* offset into mapping[first] */</span>
	<span class="kt">unsigned</span>		<span class="n">last_to</span><span class="p">;</span>	<span class="cm">/* amount of mapping[last] */</span>
	<span class="kt">unsigned</span>		<span class="n">offset</span><span class="p">;</span>		<span class="cm">/* offset into received data store */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">unmarshall</span><span class="p">;</span>	<span class="cm">/* unmarshalling phase */</span>
	<span class="n">bool</span>			<span class="n">incoming</span><span class="p">;</span>	<span class="cm">/* T if incoming call */</span>
	<span class="n">bool</span>			<span class="n">send_pages</span><span class="p">;</span>	<span class="cm">/* T if data from mapping should be sent */</span>
	<span class="n">u16</span>			<span class="n">service_id</span><span class="p">;</span>	<span class="cm">/* RxRPC service ID to call */</span>
	<span class="n">__be16</span>			<span class="n">port</span><span class="p">;</span>		<span class="cm">/* target UDP port */</span>
	<span class="n">__be32</span>			<span class="n">operation_ID</span><span class="p">;</span>	<span class="cm">/* operation ID for an incoming call */</span>
	<span class="n">u32</span>			<span class="n">count</span><span class="p">;</span>		<span class="cm">/* count for use in unmarshalling */</span>
	<span class="n">__be32</span>			<span class="n">tmp</span><span class="p">;</span>		<span class="cm">/* place to extract temporary data */</span>
	<span class="n">afs_dataversion_t</span>	<span class="n">store_version</span><span class="p">;</span>	<span class="cm">/* updated version expected from store */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">afs_call_type</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* deliver request or reply data to an call</span>
<span class="cm">	 * - returning an error will cause the call to be aborted</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">deliver</span><span class="p">)(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		       <span class="n">bool</span> <span class="n">last</span><span class="p">);</span>

	<span class="cm">/* map an abort code to an error number */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">abort_to_error</span><span class="p">)(</span><span class="n">u32</span> <span class="n">abort_code</span><span class="p">);</span>

	<span class="cm">/* clean up a call */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="n">call</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * record of an outstanding writeback on a vnode</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_writeback</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in vnode-&gt;writebacks */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">writer</span><span class="p">;</span>		<span class="cm">/* work item to perform the writeback */</span>
	<span class="k">struct</span> <span class="n">afs_vnode</span>	<span class="o">*</span><span class="n">vnode</span><span class="p">;</span>		<span class="cm">/* vnode to which this write applies */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* owner of this write */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">waitq</span><span class="p">;</span>		<span class="cm">/* completion and ready wait queue */</span>
	<span class="n">pgoff_t</span>			<span class="n">first</span><span class="p">;</span>		<span class="cm">/* first page in batch */</span>
	<span class="n">pgoff_t</span>			<span class="n">point</span><span class="p">;</span>		<span class="cm">/* last page in current store op */</span>
	<span class="n">pgoff_t</span>			<span class="n">last</span><span class="p">;</span>		<span class="cm">/* last page in batch (inclusive) */</span>
	<span class="kt">unsigned</span>		<span class="n">offset_first</span><span class="p">;</span>	<span class="cm">/* offset into first page of start of write */</span>
	<span class="kt">unsigned</span>		<span class="n">to_last</span><span class="p">;</span>	<span class="cm">/* offset into last page of end of write */</span>
	<span class="kt">int</span>			<span class="n">num_conflicts</span><span class="p">;</span>	<span class="cm">/* count of conflicting writes in list */</span>
	<span class="kt">int</span>			<span class="n">usage</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">conflicts</span><span class="p">;</span>	<span class="cm">/* T if has dependent conflicts */</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">AFS_WBACK_SYNCING</span><span class="p">,</span>		<span class="cm">/* synchronisation being performed */</span>
		<span class="n">AFS_WBACK_PENDING</span><span class="p">,</span>		<span class="cm">/* write pending */</span>
		<span class="n">AFS_WBACK_CONFLICTING</span><span class="p">,</span>		<span class="cm">/* conflicting writes posted */</span>
		<span class="n">AFS_WBACK_WRITING</span><span class="p">,</span>		<span class="cm">/* writing back */</span>
		<span class="n">AFS_WBACK_COMPLETE</span>		<span class="cm">/* the writeback record has been unlinked */</span>
	<span class="p">}</span> <span class="n">state</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * AFS superblock private data</span>
<span class="cm"> * - there&#39;s one superblock per volume</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_super_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">afs_volume</span>	<span class="o">*</span><span class="n">volume</span><span class="p">;</span>	<span class="cm">/* volume record */</span>
	<span class="kt">char</span>			<span class="n">rwparent</span><span class="p">;</span>	<span class="cm">/* T if parent is R/W AFS volume */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">afs_super_info</span> <span class="o">*</span><span class="nf">AFS_FS_S</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">afs_fs_type</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * entry in the cached cell catalogue</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_cache_cell</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="n">name</span><span class="p">[</span><span class="n">AFS_MAXCELLNAME</span><span class="p">];</span>	<span class="cm">/* cell name (padded with NULs) */</span>
	<span class="k">struct</span> <span class="n">in_addr</span>	<span class="n">vl_servers</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>		<span class="cm">/* cached cell VL servers */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * AFS cell record</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_cell</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* main cell list link */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">anonymous_key</span><span class="p">;</span>	<span class="cm">/* anonymous user key for this cell */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">proc_link</span><span class="p">;</span>	<span class="cm">/* /proc cell list link */</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span>	<span class="o">*</span><span class="n">proc_dir</span><span class="p">;</span>	<span class="cm">/* /proc dir for this cell */</span>
<span class="cp">#ifdef CONFIG_AFS_FSCACHE</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>		<span class="cm">/* caching cookie */</span>
<span class="cp">#endif</span>

	<span class="cm">/* server record management */</span>
	<span class="n">rwlock_t</span>		<span class="n">servers_lock</span><span class="p">;</span>	<span class="cm">/* active server list lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">servers</span><span class="p">;</span>	<span class="cm">/* active server list */</span>

	<span class="cm">/* volume location record management */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">vl_sem</span><span class="p">;</span>		<span class="cm">/* volume management serialisation semaphore */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">vl_list</span><span class="p">;</span>	<span class="cm">/* cell&#39;s active VL record list */</span>
	<span class="n">spinlock_t</span>		<span class="n">vl_lock</span><span class="p">;</span>	<span class="cm">/* vl_list lock */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">vl_naddrs</span><span class="p">;</span>	<span class="cm">/* number of VL servers in addr list */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">vl_curr_svix</span><span class="p">;</span>	<span class="cm">/* current server index */</span>
	<span class="k">struct</span> <span class="n">in_addr</span>		<span class="n">vl_addrs</span><span class="p">[</span><span class="n">AFS_CELL_MAX_ADDRS</span><span class="p">];</span>	<span class="cm">/* cell VL server addresses */</span>

	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* cell name - must go last */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * entry in the cached volume location catalogue</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_cache_vlocation</span> <span class="p">{</span>
	<span class="cm">/* volume name (lowercase, padded with NULs) */</span>
	<span class="kt">uint8_t</span>			<span class="n">name</span><span class="p">[</span><span class="n">AFS_MAXVOLNAME</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="kt">uint8_t</span>			<span class="n">nservers</span><span class="p">;</span>	<span class="cm">/* number of entries used in servers[] */</span>
	<span class="kt">uint8_t</span>			<span class="n">vidmask</span><span class="p">;</span>	<span class="cm">/* voltype mask for vid[] */</span>
	<span class="kt">uint8_t</span>			<span class="n">srvtmask</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* voltype masks for servers[] */</span>
<span class="cp">#define AFS_VOL_VTM_RW	0x01 </span><span class="cm">/* R/W version of the volume is available (on this server) */</span><span class="cp"></span>
<span class="cp">#define AFS_VOL_VTM_RO	0x02 </span><span class="cm">/* R/O version of the volume is available (on this server) */</span><span class="cp"></span>
<span class="cp">#define AFS_VOL_VTM_BAK	0x04 </span><span class="cm">/* backup version of the volume is available (on this server) */</span><span class="cp"></span>

	<span class="n">afs_volid_t</span>		<span class="n">vid</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* volume IDs for R/W, R/O and Bak volumes */</span>
	<span class="k">struct</span> <span class="n">in_addr</span>		<span class="n">servers</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* fileserver addresses */</span>
	<span class="kt">time_t</span>			<span class="n">rtime</span><span class="p">;</span>		<span class="cm">/* last retrieval time */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * volume -&gt; vnode hash table entry</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_cache_vhash</span> <span class="p">{</span>
	<span class="n">afs_voltype_t</span>		<span class="n">vtype</span><span class="p">;</span>		<span class="cm">/* which volume variation */</span>
	<span class="kt">uint8_t</span>			<span class="n">hash_bucket</span><span class="p">;</span>	<span class="cm">/* which hash bucket this represents */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * AFS volume location record</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_vlocation</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="kt">time_t</span>			<span class="n">time_of_death</span><span class="p">;</span>	<span class="cm">/* time at which put reduced usage to 0 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in cell volume location list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">grave</span><span class="p">;</span>		<span class="cm">/* link in master graveyard list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">update</span><span class="p">;</span>		<span class="cm">/* link in master update list */</span>
	<span class="k">struct</span> <span class="n">afs_cell</span>		<span class="o">*</span><span class="n">cell</span><span class="p">;</span>		<span class="cm">/* cell to which volume belongs */</span>
<span class="cp">#ifdef CONFIG_AFS_FSCACHE</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>		<span class="cm">/* caching cookie */</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">afs_cache_vlocation</span> <span class="n">vldb</span><span class="p">;</span>	<span class="cm">/* volume information DB record */</span>
	<span class="k">struct</span> <span class="n">afs_volume</span>	<span class="o">*</span><span class="n">vols</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* volume access record pointer (index by type) */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">waitq</span><span class="p">;</span>		<span class="cm">/* status change waitqueue */</span>
	<span class="kt">time_t</span>			<span class="n">update_at</span><span class="p">;</span>	<span class="cm">/* time at which record should be updated */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* access lock */</span>
	<span class="n">afs_vlocation_state_t</span>	<span class="n">state</span><span class="p">;</span>		<span class="cm">/* volume location state */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">upd_rej_cnt</span><span class="p">;</span>	<span class="cm">/* ENOMEDIUM count during update */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">upd_busy_cnt</span><span class="p">;</span>	<span class="cm">/* EBUSY count during update */</span>
	<span class="n">bool</span>			<span class="n">valid</span><span class="p">;</span>		<span class="cm">/* T if valid */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * AFS fileserver record</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_server</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="kt">time_t</span>			<span class="n">time_of_death</span><span class="p">;</span>	<span class="cm">/* time at which put reduced usage to 0 */</span>
	<span class="k">struct</span> <span class="n">in_addr</span>		<span class="n">addr</span><span class="p">;</span>		<span class="cm">/* server address */</span>
	<span class="k">struct</span> <span class="n">afs_cell</span>		<span class="o">*</span><span class="n">cell</span><span class="p">;</span>		<span class="cm">/* cell in which server resides */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in cell&#39;s server list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">grave</span><span class="p">;</span>		<span class="cm">/* link in master graveyard list */</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">master_rb</span><span class="p">;</span>	<span class="cm">/* link in master by-addr tree */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">sem</span><span class="p">;</span>		<span class="cm">/* access lock */</span>

	<span class="cm">/* file service access */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">fs_vnodes</span><span class="p">;</span>	<span class="cm">/* vnodes backed by this server (ordered by FID) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">fs_act_jif</span><span class="p">;</span>	<span class="cm">/* time at which last activity occurred */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">fs_dead_jif</span><span class="p">;</span>	<span class="cm">/* time at which no longer to be considered dead */</span>
	<span class="n">spinlock_t</span>		<span class="n">fs_lock</span><span class="p">;</span>	<span class="cm">/* access lock */</span>
	<span class="kt">int</span>			<span class="n">fs_state</span><span class="p">;</span>      	<span class="cm">/* 0 or reason FS currently marked dead (-errno) */</span>

	<span class="cm">/* callback promise management */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">cb_promises</span><span class="p">;</span>	<span class="cm">/* vnode expiration list (ordered earliest first) */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">cb_updater</span><span class="p">;</span>	<span class="cm">/* callback updater */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">cb_break_work</span><span class="p">;</span>	<span class="cm">/* collected break dispatcher */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">cb_break_waitq</span><span class="p">;</span>	<span class="cm">/* space available in cb_break waitqueue */</span>
	<span class="n">spinlock_t</span>		<span class="n">cb_lock</span><span class="p">;</span>	<span class="cm">/* access lock */</span>
	<span class="k">struct</span> <span class="n">afs_callback</span>	<span class="n">cb_break</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* ring of callbacks awaiting breaking */</span>
	<span class="n">atomic_t</span>		<span class="n">cb_break_n</span><span class="p">;</span>	<span class="cm">/* number of pending breaks */</span>
	<span class="n">u8</span>			<span class="n">cb_break_head</span><span class="p">;</span>	<span class="cm">/* head of callback breaking ring */</span>
	<span class="n">u8</span>			<span class="n">cb_break_tail</span><span class="p">;</span>	<span class="cm">/* tail of callback breaking ring */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * AFS volume access record</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_volume</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">afs_cell</span>		<span class="o">*</span><span class="n">cell</span><span class="p">;</span>		<span class="cm">/* cell to which belongs (unrefd ptr) */</span>
	<span class="k">struct</span> <span class="n">afs_vlocation</span>	<span class="o">*</span><span class="n">vlocation</span><span class="p">;</span>	<span class="cm">/* volume location */</span>
<span class="cp">#ifdef CONFIG_AFS_FSCACHE</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>		<span class="cm">/* caching cookie */</span>
<span class="cp">#endif</span>
	<span class="n">afs_volid_t</span>		<span class="n">vid</span><span class="p">;</span>		<span class="cm">/* volume ID */</span>
	<span class="n">afs_voltype_t</span>		<span class="n">type</span><span class="p">;</span>		<span class="cm">/* type of volume */</span>
	<span class="kt">char</span>			<span class="n">type_force</span><span class="p">;</span>	<span class="cm">/* force volume type (suppress R/O -&gt; R/W) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">nservers</span><span class="p">;</span>	<span class="cm">/* number of server slots filled */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">rjservers</span><span class="p">;</span>	<span class="cm">/* number of servers discarded due to -ENOMEDIUM */</span>
	<span class="k">struct</span> <span class="n">afs_server</span>	<span class="o">*</span><span class="n">servers</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* servers on which volume resides (ordered) */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">server_sem</span><span class="p">;</span>	<span class="cm">/* lock for accessing current server */</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span>	<span class="n">bdi</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * vnode catalogue entry</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_cache_vnode</span> <span class="p">{</span>
	<span class="n">afs_vnodeid_t</span>		<span class="n">vnode_id</span><span class="p">;</span>	<span class="cm">/* vnode ID */</span>
	<span class="kt">unsigned</span>		<span class="n">vnode_unique</span><span class="p">;</span>	<span class="cm">/* vnode ID uniquifier */</span>
	<span class="n">afs_dataversion_t</span>	<span class="n">data_version</span><span class="p">;</span>	<span class="cm">/* data version */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * AFS inode private data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_vnode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="n">vfs_inode</span><span class="p">;</span>	<span class="cm">/* the VFS&#39;s inode record */</span>

	<span class="k">struct</span> <span class="n">afs_volume</span>	<span class="o">*</span><span class="n">volume</span><span class="p">;</span>	<span class="cm">/* volume on which vnode resides */</span>
	<span class="k">struct</span> <span class="n">afs_server</span>	<span class="o">*</span><span class="n">server</span><span class="p">;</span>	<span class="cm">/* server currently supplying this file */</span>
	<span class="k">struct</span> <span class="n">afs_fid</span>		<span class="n">fid</span><span class="p">;</span>		<span class="cm">/* the file identifier for this inode */</span>
	<span class="k">struct</span> <span class="n">afs_file_status</span>	<span class="n">status</span><span class="p">;</span>		<span class="cm">/* AFS status info for this file */</span>
<span class="cp">#ifdef CONFIG_AFS_FSCACHE</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>		<span class="cm">/* caching cookie */</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">afs_permits</span>	<span class="o">*</span><span class="n">permits</span><span class="p">;</span>	<span class="cm">/* cache of permits so far obtained */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">permits_lock</span><span class="p">;</span>	<span class="cm">/* lock for altering permits list */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">validate_lock</span><span class="p">;</span>	<span class="cm">/* lock for validating this vnode */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">update_waitq</span><span class="p">;</span>	<span class="cm">/* status fetch waitqueue */</span>
	<span class="kt">int</span>			<span class="n">update_cnt</span><span class="p">;</span>	<span class="cm">/* number of outstanding ops that will update the</span>
<span class="cm">						 * status */</span>
	<span class="n">spinlock_t</span>		<span class="n">writeback_lock</span><span class="p">;</span>	<span class="cm">/* lock for writebacks */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* waitqueue/flags lock */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define AFS_VNODE_CB_BROKEN	0		</span><span class="cm">/* set if vnode&#39;s callback was broken */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_UNSET		1		</span><span class="cm">/* set if vnode attributes not yet set */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_MODIFIED	2		</span><span class="cm">/* set if vnode&#39;s data modified */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_ZAP_DATA	3		</span><span class="cm">/* set if vnode&#39;s data should be invalidated */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_DELETED	4		</span><span class="cm">/* set if vnode deleted on server */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_MOUNTPOINT	5		</span><span class="cm">/* set if vnode is a mountpoint symlink */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_LOCKING	6		</span><span class="cm">/* set if waiting for lock on vnode */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_READLOCKED	7		</span><span class="cm">/* set if vnode is read-locked on the server */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_WRITELOCKED	8		</span><span class="cm">/* set if vnode is write-locked on the server */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_UNLOCKING	9		</span><span class="cm">/* set if vnode is being unlocked on the server */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_AUTOCELL	10		</span><span class="cm">/* set if Vnode is an auto mount point */</span><span class="cp"></span>
<span class="cp">#define AFS_VNODE_PSEUDODIR	11		</span><span class="cm">/* set if Vnode is a pseudo directory */</span><span class="cp"></span>

	<span class="kt">long</span>			<span class="n">acl_order</span><span class="p">;</span>	<span class="cm">/* ACL check count (callback break count) */</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">writebacks</span><span class="p">;</span>	<span class="cm">/* alterations in pagecache that need writing */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pending_locks</span><span class="p">;</span>	<span class="cm">/* locks waiting to be granted */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">granted_locks</span><span class="p">;</span>	<span class="cm">/* locks granted on this file */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">lock_work</span><span class="p">;</span>	<span class="cm">/* work to be done in locking */</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">unlock_key</span><span class="p">;</span>	<span class="cm">/* key to be used in unlocking */</span>

	<span class="cm">/* outstanding callback notification on this file */</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">server_rb</span><span class="p">;</span>	<span class="cm">/* link in server-&gt;fs_vnodes */</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">cb_promise</span><span class="p">;</span>	<span class="cm">/* link in server-&gt;cb_promises */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">cb_broken_work</span><span class="p">;</span>	<span class="cm">/* work to be done on callback break */</span>
	<span class="kt">time_t</span>			<span class="n">cb_expires</span><span class="p">;</span>	<span class="cm">/* time at which callback expires */</span>
	<span class="kt">time_t</span>			<span class="n">cb_expires_at</span><span class="p">;</span>	<span class="cm">/* time used to order cb_promise */</span>
	<span class="kt">unsigned</span>		<span class="n">cb_version</span><span class="p">;</span>	<span class="cm">/* callback version */</span>
	<span class="kt">unsigned</span>		<span class="n">cb_expiry</span><span class="p">;</span>	<span class="cm">/* callback expiry time */</span>
	<span class="n">afs_callback_type_t</span>	<span class="n">cb_type</span><span class="p">;</span>	<span class="cm">/* type of callback */</span>
	<span class="n">bool</span>			<span class="n">cb_promised</span><span class="p">;</span>	<span class="cm">/* true if promise still holds */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cached security record for one user&#39;s attempt to access a vnode</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_permit</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">key</span>		<span class="o">*</span><span class="n">key</span><span class="p">;</span>		<span class="cm">/* RxRPC ticket holding a security context */</span>
	<span class="n">afs_access_t</span>		<span class="n">access_mask</span><span class="p">;</span>	<span class="cm">/* access mask for this key */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cache of security records from attempts to access a vnode</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_permits</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">rcu</span><span class="p">;</span>		<span class="cm">/* disposal procedure */</span>
	<span class="kt">int</span>			<span class="n">count</span><span class="p">;</span>		<span class="cm">/* number of records */</span>
	<span class="k">struct</span> <span class="n">afs_permit</span>	<span class="n">permits</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* the permits so far examined */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * record of one of a system&#39;s set of network interfaces</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_interface</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_addr</span>	<span class="n">address</span><span class="p">;</span>	<span class="cm">/* IPv4 address bound to interface */</span>
	<span class="k">struct</span> <span class="n">in_addr</span>	<span class="n">netmask</span><span class="p">;</span>	<span class="cm">/* netmask applied to address */</span>
	<span class="kt">unsigned</span>	<span class="n">mtu</span><span class="p">;</span>		<span class="cm">/* MTU of interface */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * UUID definition [internet draft]</span>
<span class="cm"> * - the timestamp is a 60-bit value, split 32/16/12, and goes in 100ns</span>
<span class="cm"> *   increments since midnight 15th October 1582</span>
<span class="cm"> *   - add AFS_UUID_TO_UNIX_TIME to convert unix time in 100ns units to UUID</span>
<span class="cm"> *     time</span>
<span class="cm"> * - the clock sequence is a 14-bit counter to avoid duplicate times</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">afs_uuid</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">time_low</span><span class="p">;</span>			<span class="cm">/* low part of timestamp */</span>
	<span class="n">u16</span>		<span class="n">time_mid</span><span class="p">;</span>			<span class="cm">/* mid part of timestamp */</span>
	<span class="n">u16</span>		<span class="n">time_hi_and_version</span><span class="p">;</span>		<span class="cm">/* high part of timestamp and version  */</span>
<span class="cp">#define AFS_UUID_TO_UNIX_TIME	0x01b21dd213814000ULL</span>
<span class="cp">#define AFS_UUID_TIMEHI_MASK	0x0fff</span>
<span class="cp">#define AFS_UUID_VERSION_TIME	0x1000	</span><span class="cm">/* time-based UUID */</span><span class="cp"></span>
<span class="cp">#define AFS_UUID_VERSION_NAME	0x3000	</span><span class="cm">/* name-based UUID */</span><span class="cp"></span>
<span class="cp">#define AFS_UUID_VERSION_RANDOM	0x4000	</span><span class="cm">/* (pseudo-)random generated UUID */</span><span class="cp"></span>
	<span class="n">u8</span>		<span class="n">clock_seq_hi_and_reserved</span><span class="p">;</span>	<span class="cm">/* clock seq hi and variant */</span>
<span class="cp">#define AFS_UUID_CLOCKHI_MASK	0x3f</span>
<span class="cp">#define AFS_UUID_VARIANT_STD	0x80</span>
	<span class="n">u8</span>		<span class="n">clock_seq_low</span><span class="p">;</span>			<span class="cm">/* clock seq low */</span>
	<span class="n">u8</span>		<span class="n">node</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>			<span class="cm">/* spatially unique node ID (MAC addr) */</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * cache.c</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_AFS_FSCACHE</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fscache_netfs</span> <span class="n">afs_cache_netfs</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fscache_cookie_def</span> <span class="n">afs_cell_cache_index_def</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fscache_cookie_def</span> <span class="n">afs_vlocation_cache_index_def</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fscache_cookie_def</span> <span class="n">afs_volume_cache_index_def</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fscache_cookie_def</span> <span class="n">afs_vnode_cache_index_def</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define afs_cell_cache_index_def	(*(struct fscache_cookie_def *) NULL)</span>
<span class="cp">#define afs_vlocation_cache_index_def	(*(struct fscache_cookie_def *) NULL)</span>
<span class="cp">#define afs_volume_cache_index_def	(*(struct fscache_cookie_def *) NULL)</span>
<span class="cp">#define afs_vnode_cache_index_def	(*(struct fscache_cookie_def *) NULL)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * callback.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_init_callback_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_broken_callback_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_break_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">afs_callback</span><span class="p">[]);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_discard_callback_on_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_give_up_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_dispatch_give_up_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_flush_callback_breaks</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">afs_callback_update_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_callback_update_kill</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * cell.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">afs_proc_cells_sem</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">afs_proc_cells</span><span class="p">;</span>

<span class="cp">#define afs_get_cell(C) do { atomic_inc(&amp;(C)-&gt;usage); } while(0)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_cell_init</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="n">afs_cell_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="n">afs_cell_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="n">afs_grab_cell</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_put_cell</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_cell_purge</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * cmservice.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">afs_cm_incoming_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * dir.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">afs_dir_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">afs_fs_dentry_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">afs_dir_file_operations</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * file.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">afs_fs_aops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">afs_file_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">afs_file_operations</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_page_filler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * flock.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">afs_kill_lock_manager</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_lock_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_lock_may_be_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_flock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * fsclient.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_fetch_file_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_volsync</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_give_up_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_fetch_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">off_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">afs_fid</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_file_status</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">afs_callback</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">afs_fid</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_file_status</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_store_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_writeback</span> <span class="o">*</span><span class="p">,</span>
			     <span class="n">pgoff_t</span><span class="p">,</span> <span class="n">pgoff_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_get_volume_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">afs_volume_status</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_set_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="n">afs_lock_type_t</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_extend_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_release_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * inode.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">afs_iget_autocell</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">afs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">afs_fid</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_file_status</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">afs_callback</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_zap_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_drop_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * main.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">afs_wq</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_uuid</span> <span class="n">afs_uuid</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * misc.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_abort_to_error</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * mntpt.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">afs_mntpt_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">afs_autocell_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">afs_mntpt_file_operations</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">afs_d_automount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_mntpt_check_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_mntpt_kill_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * proc.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_proc_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_proc_cell_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_proc_cell_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * rxrpc.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_open_socket</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_close_socket</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_make_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="n">afs_alloc_flat_call</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">afs_call_type</span> <span class="o">*</span><span class="p">,</span>
					    <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_flat_call_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_transfer_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_send_empty_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_send_simple_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_extract_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
			    <span class="kt">size_t</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * security.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_clear_permits</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_cache_permit</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_zap_permits</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">afs_request_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * server.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">afs_server_peer_lock</span><span class="p">;</span>

<span class="cp">#define afs_get_server(S)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	_debug(&quot;GET SERVER %d&quot;, atomic_read(&amp;(S)-&gt;usage));	\</span>
<span class="cp">	atomic_inc(&amp;(S)-&gt;usage);				\</span>
<span class="cp">} while(0)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">afs_lookup_server</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">afs_find_server</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_put_server</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">afs_purge_servers</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * super.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_fs_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * use-rtnetlink.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_get_ipv4_interfaces</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_interface</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_get_MAC_address</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * vlclient.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vl_get_entry_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_cache_vlocation</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vl_get_entry_by_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
				  <span class="n">afs_volid_t</span><span class="p">,</span> <span class="n">afs_voltype_t</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">afs_cache_vlocation</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">afs_wait_mode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * vlocation.c</span>
<span class="cm"> */</span>
<span class="cp">#define afs_get_vlocation(V) do { atomic_inc(&amp;(V)-&gt;usage); } while(0)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">afs_vlocation_update_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_vlocation</span> <span class="o">*</span><span class="n">afs_vlocation_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_cell</span> <span class="o">*</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
						  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_put_vlocation</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vlocation</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_vlocation_purge</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * vnode.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="nf">AFS_FS_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_vnode</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">AFS_VNODE_TO_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="n">vnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_vnode_finalise_status_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_fetch_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_fetch_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">off_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			    <span class="n">umode_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_fid</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_file_status</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">afs_callback</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_server</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			    <span class="n">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_fid</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">afs_file_status</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_server</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_store_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_writeback</span> <span class="o">*</span><span class="p">,</span> <span class="n">pgoff_t</span><span class="p">,</span> <span class="n">pgoff_t</span><span class="p">,</span>
				<span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_get_volume_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">afs_volume_status</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_set_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">,</span>
			      <span class="n">afs_lock_type_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_extend_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_vnode_release_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * volume.c</span>
<span class="cm"> */</span>
<span class="cp">#define afs_get_volume(V) do { atomic_inc(&amp;(V)-&gt;usage); } while(0)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_put_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_volume</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_volume</span> <span class="o">*</span><span class="n">afs_volume_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_mount_params</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="n">afs_volume_pick_fileserver</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_volume_release_fileserver</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">afs_server</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * write.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_put_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_writeback</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">afs_pages_written_back</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">afs_call</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">afs_file_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_writeback_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">afs_vnode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">afs_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>


<span class="cm">/*****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * debug tracing</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">afs_debug</span><span class="p">;</span>

<span class="cp">#define dbgprintk(FMT,...) \</span>
<span class="cp">	printk(&quot;[%-6.6s] &quot;FMT&quot;\n&quot;, current-&gt;comm ,##__VA_ARGS__)</span>

<span class="cp">#define kenter(FMT,...)	dbgprintk(&quot;==&gt; %s(&quot;FMT&quot;)&quot;,__func__ ,##__VA_ARGS__)</span>
<span class="cp">#define kleave(FMT,...)	dbgprintk(&quot;&lt;== %s()&quot;FMT&quot;&quot;,__func__ ,##__VA_ARGS__)</span>
<span class="cp">#define kdebug(FMT,...)	dbgprintk(&quot;    &quot;FMT ,##__VA_ARGS__)</span>


<span class="cp">#if defined(__KDEBUG)</span>
<span class="cp">#define _enter(FMT,...)	kenter(FMT,##__VA_ARGS__)</span>
<span class="cp">#define _leave(FMT,...)	kleave(FMT,##__VA_ARGS__)</span>
<span class="cp">#define _debug(FMT,...)	kdebug(FMT,##__VA_ARGS__)</span>

<span class="cp">#elif defined(CONFIG_AFS_DEBUG)</span>
<span class="cp">#define AFS_DEBUG_KENTER	0x01</span>
<span class="cp">#define AFS_DEBUG_KLEAVE	0x02</span>
<span class="cp">#define AFS_DEBUG_KDEBUG	0x04</span>

<span class="cp">#define _enter(FMT,...)					\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (unlikely(afs_debug &amp; AFS_DEBUG_KENTER))	\</span>
<span class="cp">		kenter(FMT,##__VA_ARGS__);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define _leave(FMT,...)					\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (unlikely(afs_debug &amp; AFS_DEBUG_KLEAVE))	\</span>
<span class="cp">		kleave(FMT,##__VA_ARGS__);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define _debug(FMT,...)					\</span>
<span class="cp">do {							\</span>
<span class="cp">	if (unlikely(afs_debug &amp; AFS_DEBUG_KDEBUG))	\</span>
<span class="cp">		kdebug(FMT,##__VA_ARGS__);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#else</span>
<span class="cp">#define _enter(FMT,...)	no_printk(&quot;==&gt; %s(&quot;FMT&quot;)&quot;,__func__ ,##__VA_ARGS__)</span>
<span class="cp">#define _leave(FMT,...)	no_printk(&quot;&lt;== %s()&quot;FMT&quot;&quot;,__func__ ,##__VA_ARGS__)</span>
<span class="cp">#define _debug(FMT,...)	no_printk(&quot;    &quot;FMT ,##__VA_ARGS__)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * debug assertion checking</span>
<span class="cm"> */</span>
<span class="cp">#if 1 </span><span class="c1">// defined(__KDEBUGALL)</span>

<span class="cp">#define ASSERT(X)						\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (unlikely(!(X))) {					\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);				\</span>
<span class="cp">		printk(KERN_ERR &quot;AFS: Assertion failed\n&quot;);	\</span>
<span class="cp">		BUG();						\</span>
<span class="cp">	}							\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTCMP(X, OP, Y)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (unlikely(!((X) OP (Y)))) {					\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);					\</span>
<span class="cp">		printk(KERN_ERR &quot;AFS: Assertion failed\n&quot;);		\</span>
<span class="cp">		printk(KERN_ERR &quot;%lu &quot; #OP &quot; %lu is false\n&quot;,		\</span>
<span class="cp">		       (unsigned long)(X), (unsigned long)(Y));		\</span>
<span class="cp">		printk(KERN_ERR &quot;0x%lx &quot; #OP &quot; 0x%lx is false\n&quot;,	\</span>
<span class="cp">		       (unsigned long)(X), (unsigned long)(Y));		\</span>
<span class="cp">		BUG();							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTRANGE(L, OP1, N, OP2, H)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (unlikely(!((L) OP1 (N)) || !((N) OP2 (H)))) {		\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);					\</span>
<span class="cp">		printk(KERN_ERR &quot;AFS: Assertion failed\n&quot;);		\</span>
<span class="cp">		printk(KERN_ERR &quot;%lu &quot;#OP1&quot; %lu &quot;#OP2&quot; %lu is false\n&quot;,	\</span>
<span class="cp">		       (unsigned long)(L), (unsigned long)(N),		\</span>
<span class="cp">		       (unsigned long)(H));				\</span>
<span class="cp">		printk(KERN_ERR &quot;0x%lx &quot;#OP1&quot; 0x%lx &quot;#OP2&quot; 0x%lx is false\n&quot;, \</span>
<span class="cp">		       (unsigned long)(L), (unsigned long)(N),		\</span>
<span class="cp">		       (unsigned long)(H));				\</span>
<span class="cp">		BUG();							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTIF(C, X)						\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (unlikely((C) &amp;&amp; !(X))) {				\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);				\</span>
<span class="cp">		printk(KERN_ERR &quot;AFS: Assertion failed\n&quot;);	\</span>
<span class="cp">		BUG();						\</span>
<span class="cp">	}							\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTIFCMP(C, X, OP, Y)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (unlikely((C) &amp;&amp; !((X) OP (Y)))) {				\</span>
<span class="cp">		printk(KERN_ERR &quot;\n&quot;);					\</span>
<span class="cp">		printk(KERN_ERR &quot;AFS: Assertion failed\n&quot;);		\</span>
<span class="cp">		printk(KERN_ERR &quot;%lu &quot; #OP &quot; %lu is false\n&quot;,		\</span>
<span class="cp">		       (unsigned long)(X), (unsigned long)(Y));		\</span>
<span class="cp">		printk(KERN_ERR &quot;0x%lx &quot; #OP &quot; 0x%lx is false\n&quot;,	\</span>
<span class="cp">		       (unsigned long)(X), (unsigned long)(Y));		\</span>
<span class="cp">		BUG();							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while(0)</span>

<span class="cp">#else</span>

<span class="cp">#define ASSERT(X)				\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTCMP(X, OP, Y)			\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTRANGE(L, OP1, N, OP2, H)		\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTIF(C, X)				\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#define ASSERTIFCMP(C, X, OP, Y)		\</span>
<span class="cp">do {						\</span>
<span class="cp">} while(0)</span>

<span class="cp">#endif </span><span class="cm">/* __KDEBUGALL */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
