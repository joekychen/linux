<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › namei.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>namei.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/namei.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Some corrections by tytso.</span>
<span class="cm"> */</span>

<span class="cm">/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname</span>
<span class="cm"> * lookup logic.</span>
<span class="cm"> */</span>
<span class="cm">/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/ima.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/device_cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/fs_struct.h&gt;</span>
<span class="cp">#include &lt;linux/posix_acl.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>
<span class="cp">#include &quot;mount.h&quot;</span>

<span class="cm">/* [Feb-1997 T. Schoebel-Theuer]</span>
<span class="cm"> * Fundamental changes in the pathname lookup mechanisms (namei)</span>
<span class="cm"> * were necessary because of omirr.  The reason is that omirr needs</span>
<span class="cm"> * to know the _real_ pathname, not the user-supplied one, in case</span>
<span class="cm"> * of symlinks (and also when transname replacements occur).</span>
<span class="cm"> *</span>
<span class="cm"> * The new code replaces the old recursive symlink resolution with</span>
<span class="cm"> * an iterative one (in case of non-nested symlink chains).  It does</span>
<span class="cm"> * this with calls to &lt;fs&gt;_follow_link().</span>
<span class="cm"> * As a side effect, dir_namei(), _namei() and follow_link() are now </span>
<span class="cm"> * replaced with a single function lookup_dentry() that can handle all </span>
<span class="cm"> * the special cases of the former code.</span>
<span class="cm"> *</span>
<span class="cm"> * With the new dcache, the pathname is stored at each inode, at least as</span>
<span class="cm"> * long as the refcount of the inode is positive.  As a side effect, the</span>
<span class="cm"> * size of the dcache depends on the inode cache and thus is dynamic.</span>
<span class="cm"> *</span>
<span class="cm"> * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink</span>
<span class="cm"> * resolution to correspond with current state of the code.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the symlink resolution is not *completely* iterative.</span>
<span class="cm"> * There is still a significant amount of tail- and mid- recursion in</span>
<span class="cm"> * the algorithm.  Also, note that &lt;fs&gt;_readlink() is not used in</span>
<span class="cm"> * lookup_dentry(): lookup_dentry() on the result of &lt;fs&gt;_readlink()</span>
<span class="cm"> * may return different results than &lt;fs&gt;_follow_link().  Many virtual</span>
<span class="cm"> * filesystems (including /proc) exhibit this behavior.</span>
<span class="cm"> */</span>

<span class="cm">/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:</span>
<span class="cm"> * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL</span>
<span class="cm"> * and the name already exists in form of a symlink, try to create the new</span>
<span class="cm"> * name indicated by the symlink. The old code always complained that the</span>
<span class="cm"> * name already exists, due to not following the symlink even if its target</span>
<span class="cm"> * is nonexistent.  The new semantics affects also mknod() and link() when</span>
<span class="cm"> * the name is a symlink pointing to a non-existent name.</span>
<span class="cm"> *</span>
<span class="cm"> * I don&#39;t know which semantics is the right one, since I have no access</span>
<span class="cm"> * to standards. But I found by trial that HP-UX 9.0 has the full &quot;new&quot;</span>
<span class="cm"> * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the</span>
<span class="cm"> * &quot;old&quot; one. Personally, I think the new semantics is much more logical.</span>
<span class="cm"> * Note that &quot;ln old new&quot; where &quot;new&quot; is a symlink pointing to a non-existing</span>
<span class="cm"> * file does succeed in both HP-UX and SunOs, but not in Solaris</span>
<span class="cm"> * and in the old Linux semantics.</span>
<span class="cm"> */</span>

<span class="cm">/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink</span>
<span class="cm"> * semantics.  See the comments in &quot;open_namei&quot; and &quot;do_link&quot; below.</span>
<span class="cm"> *</span>
<span class="cm"> * [10-Sep-98 Alan Modra] Another symlink change.</span>
<span class="cm"> */</span>

<span class="cm">/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:</span>
<span class="cm"> *	inside the path - always follow.</span>
<span class="cm"> *	in the last component in creation/removal/renaming - never follow.</span>
<span class="cm"> *	if LOOKUP_FOLLOW passed - follow.</span>
<span class="cm"> *	if the pathname has trailing slashes - follow.</span>
<span class="cm"> *	otherwise - don&#39;t follow.</span>
<span class="cm"> * (applied in that order).</span>
<span class="cm"> *</span>
<span class="cm"> * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT</span>
<span class="cm"> * restored for 2.4. This is the last surviving part of old 4.2BSD bug.</span>
<span class="cm"> * During the 2.4 we need to fix the userland stuff depending on it -</span>
<span class="cm"> * hopefully we will be able to get rid of that wart in 2.5. So far only</span>
<span class="cm"> * XEmacs seems to be relying on it...</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)</span>
<span class="cm"> * implemented.  Let&#39;s see if raised priority of -&gt;s_vfs_rename_mutex gives</span>
<span class="cm"> * any extra contention...</span>
<span class="cm"> */</span>

<span class="cm">/* In order to reduce some races, while at the same time doing additional</span>
<span class="cm"> * checking and hopefully speeding things up, we copy filenames to the</span>
<span class="cm"> * kernel data space before using them..</span>
<span class="cm"> *</span>
<span class="cm"> * POSIX.1 2.4: an empty pathname is invalid (ENOENT).</span>
<span class="cm"> * PATH_MAX includes the nul terminator --RR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">getname_flags</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">empty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">__getname</span><span class="p">(),</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">strncpy_from_user</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* The empty path is special. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
			<span class="o">*</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_EMPTY</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">PATH_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">audit_getname</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">error:</span>
	<span class="n">__putname</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">getname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">getname_flags</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
<span class="kt">void</span> <span class="nf">putname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">audit_dummy_context</span><span class="p">()))</span>
		<span class="n">audit_putname</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__putname</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">putname</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_acl</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FS_POSIX_ACL</span>
	<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span><span class="n">acl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_NOT_BLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acl</span> <span class="o">=</span> <span class="n">get_cached_acl_rcu</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ACL_TYPE_ACCESS</span><span class="p">);</span>
	        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acl</span><span class="p">)</span>
	                <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="cm">/* no -&gt;get_acl() calls in RCU mode... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acl</span> <span class="o">==</span> <span class="n">ACL_NOT_CACHED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
	        <span class="k">return</span> <span class="n">posix_acl_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">acl</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAY_NOT_BLOCK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">acl</span> <span class="o">=</span> <span class="n">get_cached_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ACL_TYPE_ACCESS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A filesystem can force a ACL callback by just never filling the</span>
<span class="cm">	 * ACL cache. But normally you&#39;d fill the cache either at inode</span>
<span class="cm">	 * instantiation time, or on the first -&gt;get_acl call.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the filesystem doesn&#39;t have a get_acl() function at all, we&#39;ll</span>
<span class="cm">	 * just create the negative cache entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acl</span> <span class="o">==</span> <span class="n">ACL_NOT_CACHED</span><span class="p">)</span> <span class="p">{</span>
	        <span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">get_acl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">acl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">get_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ACL_TYPE_ACCESS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">acl</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">acl</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		        <span class="n">set_cached_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ACL_TYPE_ACCESS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		        <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acl</span><span class="p">)</span> <span class="p">{</span>
	        <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">posix_acl_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">acl</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	        <span class="n">posix_acl_release</span><span class="p">(</span><span class="n">acl</span><span class="p">);</span>
	        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This does the basic permission checking</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acl_permission_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">current_fsuid</span><span class="p">(),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">)))</span>
		<span class="n">mode</span> <span class="o">&gt;&gt;=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIXACL</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IRWXG</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">check_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_group_p</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">))</span>
			<span class="n">mode</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the DACs are ok we don&#39;t need any capability check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAY_READ</span> <span class="o">|</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * generic_permission -  check for access rights on a Posix-like filesystem</span>
<span class="cm"> * @inode:	inode to check access rights for</span>
<span class="cm"> * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC, ...)</span>
<span class="cm"> *</span>
<span class="cm"> * Used to check for read/write/execute permissions on a file.</span>
<span class="cm"> * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions</span>
<span class="cm"> * for filesystem access without changing the &quot;normal&quot; uids which</span>
<span class="cm"> * are used for other things.</span>
<span class="cm"> *</span>
<span class="cm"> * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk</span>
<span class="cm"> * request cannot be satisfied (eg. requires blocking or too much complexity).</span>
<span class="cm"> * It would then be called again in ref-walk mode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">generic_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do the basic permission checks.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">acl_permission_check</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* DACs are overridable for directories */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">CAP_DAC_OVERRIDE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">CAP_DAC_READ_SEARCH</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read/write DACs are always overridable.</span>
<span class="cm">	 * Executable DACs are overridable when there is</span>
<span class="cm">	 * at least one exec bit set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_EXEC</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IXUGO</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">CAP_DAC_OVERRIDE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Searching includes executable on directories, else just read.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">MAY_READ</span> <span class="o">|</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">MAY_READ</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">CAP_DAC_READ_SEARCH</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We _really_ want to just do &quot;generic_permission()&quot; without</span>
<span class="cm"> * even looking at the inode-&gt;i_op values. So we keep a cache</span>
<span class="cm"> * flag in inode-&gt;i_opflags, that says &quot;this has not special</span>
<span class="cm"> * permission function, use the fast case&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_opflags</span> <span class="o">&amp;</span> <span class="n">IOP_FASTPERM</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">permission</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

		<span class="cm">/* This gets set once for the inode lifetime */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_opflags</span> <span class="o">|=</span> <span class="n">IOP_FASTPERM</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">generic_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * inode_permission  -  check for access rights to a given inode</span>
<span class="cm"> * @inode:	inode to check permission on</span>
<span class="cm"> * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC, ...)</span>
<span class="cm"> *</span>
<span class="cm"> * Used to check for read/write/execute permissions on an inode.</span>
<span class="cm"> * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions</span>
<span class="cm"> * for filesystem access without changing the &quot;normal&quot; uids which</span>
<span class="cm"> * are used for other things.</span>
<span class="cm"> *</span>
<span class="cm"> * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Nobody gets write access to a read-only fs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_RDONLY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Nobody gets write access to an immutable file.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_IMMUTABLE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">do_inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">devcgroup_inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">security_inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * path_get - get a reference to a path</span>
<span class="cm"> * @path: path to get the reference to</span>
<span class="cm"> *</span>
<span class="cm"> * Given a path increment the reference count to the dentry and the vfsmount.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">path_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mntget</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">dget</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">path_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * path_put - put a reference to a path</span>
<span class="cm"> * @path: path to put the reference to</span>
<span class="cm"> *</span>
<span class="cm"> * Given a path decrement the reference count to the dentry and the vfsmount.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">path_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">path_put</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Path walking has 2 modes, rcu-walk and ref-walk (see</span>
<span class="cm"> * Documentation/filesystems/path-lookup.txt).  In situations when we can&#39;t</span>
<span class="cm"> * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab</span>
<span class="cm"> * normal reference counts on dentries and vfsmounts to transition to rcu-walk</span>
<span class="cm"> * mode.  Refcounts are grabbed at the last known good point before rcu-walk</span>
<span class="cm"> * got stuck, so ref-walk may continue from there. If this is not successful</span>
<span class="cm"> * (eg. a seqcount has changed), then failure is returned and it&#39;s up to caller</span>
<span class="cm"> * to restart the path walk from the beginning in ref-walk mode.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * unlazy_walk - try to switch to ref-walk mode.</span>
<span class="cm"> * @nd: nameidata pathwalk data</span>
<span class="cm"> * @dentry: child of nd-&gt;path.dentry or NULL</span>
<span class="cm"> * Returns: 0 on success, -ECHILD on failure</span>
<span class="cm"> *</span>
<span class="cm"> * unlazy_walk attempts to legitimize the current nd-&gt;path, nd-&gt;root and dentry</span>
<span class="cm"> * for ref-walk mode.  @dentry must be a path found by a do_lookup call on</span>
<span class="cm"> * @nd or NULL.  Must be called from rcu-walk context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlazy_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want_root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_ROOT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">want_root</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">!=</span> <span class="n">fs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">||</span>
				<span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">fs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_root</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__d_rcu_to_refcount</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_parent</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">!=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_parent</span><span class="p">;</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__d_rcu_to_refcount</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_child</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the sequence check on the child dentry passed, then</span>
<span class="cm">		 * the child has not been removed from its parent. This</span>
<span class="cm">		 * means the parent dentry must be valid and able to take</span>
<span class="cm">		 * a reference at this point.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">);</span>
		<span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">want_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mntget</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_RCU</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_child:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="nl">err_parent:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="nl">err_root:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">want_root</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * release_open_intent - free up open intent resources</span>
<span class="cm"> * @nd: pointer to nameidata</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">release_open_intent</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">file</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">put_filp</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">d_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * complete_walk - successful completion of path walk</span>
<span class="cm"> * @nd:  pointer nameidata</span>
<span class="cm"> *</span>
<span class="cm"> * If we had been in RCU mode, drop out of it and legitimize nd-&gt;path.</span>
<span class="cm"> * Revalidate the final result, unless we&#39;d already done that during</span>
<span class="cm"> * the path walk or the filesystem doesn&#39;t ask for it.  Return 0 on</span>
<span class="cm"> * success, -error on failure.  In case of failure caller does not</span>
<span class="cm"> * need to drop nd-&gt;path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">complete_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_RCU</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_ROOT</span><span class="p">))</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">__d_rcu_to_refcount</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">!=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">mntget</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_JUMPED</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_REVALIDATE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">fs_flags</span> <span class="o">&amp;</span> <span class="n">FS_REVAL_DOT</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Note: we do not d_invalidate() */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">d_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>

	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">set_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span>
		<span class="n">get_fs_root</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">link_path_walk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">set_root_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">fs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">__read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span> <span class="nf">__vfs_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_root</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
		<span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_JUMPED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">link_path_walk</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">path_put_conditional</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">!=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">path_to_nameidata</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">)</span>
			<span class="n">mntput</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">put_link</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">put_link</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span>
<span class="nf">follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span>
		<span class="n">mntget</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">total_link_count</span> <span class="o">&gt;=</span> <span class="mi">40</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ELOOP</span><span class="p">);</span> <span class="cm">/* no -&gt;put_link(), please */</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">total_link_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">touch_atime</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_follow_link</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span> <span class="cm">/* no -&gt;put_link(), please */</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span> <span class="o">=</span> <span class="n">LAST_BIND</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">follow_link</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">nd_get_link</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">__vfs_follow_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span> <span class="o">==</span> <span class="n">LAST_BIND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_JUMPED</span><span class="p">;</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">follow_link</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* stepped on a _really_ weird one */</span>
				<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">follow_up_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mountpoint</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mountpoint</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">mountpoint</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">follow_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mountpoint</span><span class="p">;</span>

	<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mntget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">mountpoint</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">);</span>
	<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">mountpoint</span><span class="p">;</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform an automount</span>
<span class="cm"> * - return -EISDIR to tell follow_managed() to stop and return the path we</span>
<span class="cm"> *   were called with.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">follow_automount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="o">*</span><span class="n">need_mntput</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_automount</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EREMOTE</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t want to mount if someone&#39;s just doing a stat -</span>
<span class="cm">	 * unless they&#39;re stat&#39;ing a directory and appended a &#39;/&#39; to</span>
<span class="cm">	 * the name.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do, however, want to mount if someone wants to open or</span>
<span class="cm">	 * create a file of any type under the mountpoint, wants to</span>
<span class="cm">	 * traverse through the mountpoint or wants to open the</span>
<span class="cm">	 * mounted directory.  Also, autofs may mark negative dentries</span>
<span class="cm">	 * as being automount points.  These will need the attentions</span>
<span class="cm">	 * of the daemon to instantiate them before they can be used.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LOOKUP_PARENT</span> <span class="o">|</span> <span class="n">LOOKUP_DIRECTORY</span> <span class="o">|</span>
		     <span class="n">LOOKUP_OPEN</span> <span class="o">|</span> <span class="n">LOOKUP_CREATE</span> <span class="o">|</span> <span class="n">LOOKUP_AUTOMOUNT</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">total_link_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">total_link_count</span> <span class="o">&gt;=</span> <span class="mi">40</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>

	<span class="n">mnt</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_automount</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The filesystem is allowed to return -EISDIR here to indicate</span>
<span class="cm">		 * it doesn&#39;t want to automount.  For instance, autofs would do</span>
<span class="cm">		 * this so that its userspace daemon can mount on this dentry.</span>
<span class="cm">		 *</span>
<span class="cm">		 * However, we can only permit this if it&#39;s a terminal point in</span>
<span class="cm">		 * the path being looked up; if it wasn&#39;t then the remainder of</span>
<span class="cm">		 * the path is inaccessible and we should say so.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EISDIR</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_PARENT</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EREMOTE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt</span><span class="p">)</span> <span class="cm">/* mount collision */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">need_mntput</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* lock_mount() may release path-&gt;mnt on error */</span>
		<span class="n">mntget</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
		<span class="o">*</span><span class="n">need_mntput</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">finish_automount</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EBUSY</span>:
		<span class="cm">/* Someone else made a mount here whilst we were busy */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">path_put</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a dentry that is managed in some way.</span>
<span class="cm"> * - Flagged for transit management (autofs)</span>
<span class="cm"> * - Flagged as mountpoint</span>
<span class="cm"> * - Flagged as automount point</span>
<span class="cm"> *</span>
<span class="cm"> * This may only be called in refwalk mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Serialization is taken care of in namespace.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">follow_managed</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span> <span class="cm">/* held by caller, must be left alone */</span>
	<span class="kt">unsigned</span> <span class="n">managed</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">need_mntput</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Given that we&#39;re not holding a lock here, we retain the value in a</span>
<span class="cm">	 * local variable for each dentry as we look at it so that we don&#39;t see</span>
<span class="cm">	 * the components of that value change under us */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">managed</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span><span class="p">),</span>
	       <span class="n">managed</span> <span class="o">&amp;=</span> <span class="n">DCACHE_MANAGED_DENTRY</span><span class="p">,</span>
	       <span class="n">unlikely</span><span class="p">(</span><span class="n">managed</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Allow the filesystem to manage the transit without i_mutex</span>
<span class="cm">		 * being held. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">managed</span> <span class="o">&amp;</span> <span class="n">DCACHE_MANAGE_TRANSIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_manage</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_manage</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Transit to a mounted filesystem. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">managed</span> <span class="o">&amp;</span> <span class="n">DCACHE_MOUNTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mounted</span> <span class="o">=</span> <span class="n">lookup_mnt</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mounted</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">need_mntput</span><span class="p">)</span>
					<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mounted</span><span class="p">;</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">mounted</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">);</span>
				<span class="n">need_mntput</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Something is mounted on this dentry in another</span>
<span class="cm">			 * namespace and/or whatever was mounted there in this</span>
<span class="cm">			 * namespace got unmounted before we managed to get the</span>
<span class="cm">			 * vfsmount_lock */</span>
		<span class="p">}</span>

		<span class="cm">/* Handle an automount point */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">managed</span> <span class="o">&amp;</span> <span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">follow_automount</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">need_mntput</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We didn&#39;t change the current path point */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_mntput</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">mnt</span><span class="p">)</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">need_mntput</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">follow_down_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mounted</span><span class="p">;</span>

	<span class="n">mounted</span> <span class="o">=</span> <span class="n">lookup_mnt</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mounted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mounted</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">mounted</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">managed_dentry_might_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_MANAGE_TRANSIT</span> <span class="o">&amp;&amp;</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_manage</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if</span>
<span class="cm"> * we meet a managed dentry that would need blocking.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">__follow_mount_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">inode</span> <span class="o">**</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mounted</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t forget we might have a non-mountpoint managed dentry</span>
<span class="cm">		 * that wants to block transit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">managed_dentry_might_block</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">mounted</span> <span class="o">=</span> <span class="n">__lookup_mnt</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mounted</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mounted</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">mounted</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_JUMPED</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update the inode too. We don&#39;t need to re-check the</span>
<span class="cm">		 * dentry sequence number here after this d_inode read,</span>
<span class="cm">		 * because a mount-point is always pinned.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">follow_mount_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mounted</span><span class="p">;</span>
		<span class="n">mounted</span> <span class="o">=</span> <span class="n">__lookup_mnt</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mounted</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mounted</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">mounted</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">follow_dotdot_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_root_rcu</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">dentry</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

			<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">follow_up_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">follow_mount_rcu</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_RCU</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_ROOT</span><span class="p">))</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Follow down to the covering mount currently visible to userspace.  At each</span>
<span class="cm"> * point, the filesystem owning that dentry may be queried as to whether the</span>
<span class="cm"> * caller is permitted to proceed or not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">follow_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">managed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">managed</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span><span class="p">),</span>
	       <span class="n">unlikely</span><span class="p">(</span><span class="n">managed</span> <span class="o">&amp;</span> <span class="n">DCACHE_MANAGED_DENTRY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Allow the filesystem to manage the transit without i_mutex</span>
<span class="cm">		 * being held.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We indicate to the filesystem if someone is trying to mount</span>
<span class="cm">		 * something here.  This gives autofs the chance to deny anyone</span>
<span class="cm">		 * other than its daemon the right to mount on its</span>
<span class="cm">		 * superstructure.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The filesystem may sleep at this point.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">managed</span> <span class="o">&amp;</span> <span class="n">DCACHE_MANAGE_TRANSIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_manage</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_manage</span><span class="p">(</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EISDIR</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Transit to a mounted filesystem. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">managed</span> <span class="o">&amp;</span> <span class="n">DCACHE_MOUNTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mounted</span> <span class="o">=</span> <span class="n">lookup_mnt</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mounted</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mounted</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">mounted</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Don&#39;t handle automount points here */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Skip to top of mountpoint pile in refwalk mode for follow_dotdot()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">follow_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mounted</span> <span class="o">=</span> <span class="n">lookup_mnt</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mounted</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mounted</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">mounted</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">follow_dotdot</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_root</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">dentry</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* rare case of legitimate dget_parent()... */</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget_parent</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">follow_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">follow_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This looks up the name in dcache, possibly revalidates the old dentry and</span>
<span class="cm"> * allocates a new one if not found or not valid.  In the need_lookup argument</span>
<span class="cm"> * returns whether i_op-&gt;lookup is necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * dir-&gt;d_inode-&gt;i_mutex must be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">lookup_dcache</span><span class="p">(</span><span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">need_lookup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="o">*</span><span class="n">need_lookup</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d_need_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">need_lookup</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_REVALIDATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">d_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_invalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
					<span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

		<span class="o">*</span><span class="n">need_lookup</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call i_op-&gt;lookup on the dentry.  The dentry must be negative but may be</span>
<span class="cm"> * hashed if it was pouplated with DCACHE_NEED_LOOKUP.</span>
<span class="cm"> *</span>
<span class="cm"> * dir-&gt;d_inode-&gt;i_mutex must be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">lookup_real</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t create child dentry for a dead directory. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_DEADDIR</span><span class="p">(</span><span class="n">dir</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">old</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__lookup_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">need_lookup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_dcache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">need_lookup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_lookup</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">lookup_real</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  It&#39;s more convoluted than I&#39;d like it to be, but... it&#39;s still fairly</span>
<span class="cm"> *  small and for now I&#39;d prefer to have fast path as straight as possible.</span>
<span class="cm"> *  It _is_ time-critical.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup_fast</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">**</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_reval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Rename seqlock is not required here because in the off chance</span>
<span class="cm">	 * of a false negative due to a concurrent rename, we&#39;re going to</span>
<span class="cm">	 * do the non-racy lookup, below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">__d_lookup_rcu</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlazy</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This sequence count validates that the inode matches</span>
<span class="cm">		 * the dentry name information from lookup.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This sequence count validates that the parent had no</span>
<span class="cm">		 * changes while we did the lookup of the dentry above.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The memory barrier in read_seqcount_begin of child is</span>
<span class="cm">		 *  enough, we can use __read_seqcount_retry here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">d_need_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">unlazy</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_REVALIDATE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">d_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">)</span>
					<span class="n">need_reval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">unlazy</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">__follow_mount_rcu</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">inode</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">unlazy</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unlazy</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlazy:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlazy_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">dentry</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">__d_lookup</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">need_lookup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">d_need_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">need_lookup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_REVALIDATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">need_reval</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">d_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_invalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">need_lookup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">follow_managed</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">path_put_conditional</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_JUMPED</span><span class="p">;</span>
	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">need_lookup:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fast lookup failed, do it the slow way */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup_slow</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">!=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">__lookup_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">follow_managed</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">path_put_conditional</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_JUMPED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">may_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">MAY_EXEC</span><span class="o">|</span><span class="n">MAY_NOT_BLOCK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlazy_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">handle_dots</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">LAST_DOTDOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">follow_dotdot_rcu</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">follow_dotdot</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">terminate_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_RCU</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_ROOT</span><span class="p">))</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do we need to follow links? We _really_ want to be able</span>
<span class="cm"> * to do this check without having to look at inode-&gt;i_op,</span>
<span class="cm"> * so we keep a cache of &quot;no, this doesn&#39;t need follow_link&quot;</span>
<span class="cm"> * for the common case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">should_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">follow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_opflags</span> <span class="o">&amp;</span> <span class="n">IOP_NOFOLLOW</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">follow_link</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">follow</span><span class="p">;</span>

		<span class="cm">/* This gets set once for the inode lifetime */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_opflags</span> <span class="o">|=</span> <span class="n">IOP_NOFOLLOW</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">walk_component</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">follow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has</span>
<span class="cm">	 * to be able to know about the current root directory and</span>
<span class="cm">	 * parent relationships.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LAST_NORM</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">handle_dots</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">lookup_fast</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">lookup_slow</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

		<span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_path_put</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">should_follow_link</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">follow</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">unlazy_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path_to_nameidata</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_path_put:</span>
	<span class="n">path_to_nameidata</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">terminate_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This limits recursive symlink follows to 8, while</span>
<span class="cm"> * limiting consecutive symlinks to 40.</span>
<span class="cm"> *</span>
<span class="cm"> * Without that kind of total limit, nasty chains of consecutive</span>
<span class="cm"> * symlinks can cause almost arbitrarily long lookups.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nested_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">link_count</span> <span class="o">&gt;=</span> <span class="n">MAX_NESTED_LINKS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">path_put_conditional</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="n">MAX_NESTED_LINKS</span><span class="p">);</span>

	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">depth</span><span class="o">++</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">link_count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">path</span> <span class="n">link</span> <span class="o">=</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">follow_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">walk_component</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span>
					     <span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">);</span>
		<span class="n">put_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">link_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">depth</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We really don&#39;t want to look at inode-&gt;i_op-&gt;lookup</span>
<span class="cm"> * when we don&#39;t have to. So we keep a cache bit in</span>
<span class="cm"> * the inode -&gt;i_opflags field that says &quot;yes, we can</span>
<span class="cm"> * do lookup on this inode&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">can_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_opflags</span> <span class="o">&amp;</span> <span class="n">IOP_LOOKUP</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We do this once for the lifetime of the inode */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_opflags</span> <span class="o">|=</span> <span class="n">IOP_LOOKUP</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We can do the critical dentry name comparison and hashing</span>
<span class="cm"> * operations one word at a time, but we are limited to:</span>
<span class="cm"> *</span>
<span class="cm"> * - Architectures with fast unaligned word accesses. We could</span>
<span class="cm"> *   do a &quot;get_unaligned()&quot; if this helps and is sufficiently</span>
<span class="cm"> *   fast.</span>
<span class="cm"> *</span>
<span class="cm"> * - Little-endian machines (so that we can generate the mask</span>
<span class="cm"> *   of low bytes efficiently). Again, we *could* do a byte</span>
<span class="cm"> *   swapping load on big-endian architectures if that is not</span>
<span class="cm"> *   expensive enough to make the optimization worthless.</span>
<span class="cm"> *</span>
<span class="cm"> * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we</span>
<span class="cm"> *   do not trap on the (extremely unlikely) case of a page</span>
<span class="cm"> *   crossing operation.</span>
<span class="cm"> *</span>
<span class="cm"> * - Furthermore, we need an efficient 64-bit compile for the</span>
<span class="cm"> *   64-bit case in order to generate the &quot;number of bytes in</span>
<span class="cm"> *   the final mask&quot;. Again, that could be replaced with a</span>
<span class="cm"> *   efficient population count instruction or similar.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_DCACHE_WORD_ACCESS</span>

<span class="cp">#include &lt;asm/word-at-a-time.h&gt;</span>

<span class="cp">#ifdef CONFIG_64BIT</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fold_hash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hash</span> <span class="o">+=</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else	</span><span class="cm">/* 32-bit case */</span><span class="cp"></span>

<span class="cp">#define fold_hash(x) (x)</span>

<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">full_name_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">load_unaligned_zeropad</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">hash</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span>
		<span class="n">hash</span> <span class="o">*=</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="mi">0ul</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">hash</span> <span class="o">+=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">fold_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">full_name_hash</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the length and hash of the path component, and</span>
<span class="cm"> * return the length of the component;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hash_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hashp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">word_at_a_time</span> <span class="n">constants</span> <span class="o">=</span> <span class="n">WORD_AT_A_TIME_CONSTANTS</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">load_unaligned_zeropad</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="n">len</span><span class="p">);</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">REPEAT_BYTE</span><span class="p">(</span><span class="sc">&#39;/&#39;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">has_zero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">constants</span><span class="p">)</span> <span class="o">|</span> <span class="n">has_zero</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">constants</span><span class="p">)));</span>

	<span class="n">adata</span> <span class="o">=</span> <span class="n">prep_zero_mask</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">constants</span><span class="p">);</span>
	<span class="n">bdata</span> <span class="o">=</span> <span class="n">prep_zero_mask</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">constants</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">create_zero_mask</span><span class="p">(</span><span class="n">adata</span> <span class="o">|</span> <span class="n">bdata</span><span class="p">);</span>

	<span class="n">hash</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">zero_bytemask</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="o">*</span><span class="n">hashp</span> <span class="o">=</span> <span class="n">fold_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="n">find_zero</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">full_name_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">init_name_hash</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">partial_name_hash</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="o">++</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">end_name_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">full_name_hash</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We know there&#39;s a real path component here of at least</span>
<span class="cm"> * one character.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hash_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hashp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">init_name_hash</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">partial_name_hash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
		<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">name</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
	<span class="o">*</span><span class="n">hashp</span> <span class="o">=</span> <span class="n">end_name_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Name resolution.</span>
<span class="cm"> * This is the basic name resolution function, turning a pathname into</span>
<span class="cm"> * the final dentry. We expect &#39;base&#39; to be positive and a directory.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 and nd will have valid dentry and mnt on success.</span>
<span class="cm"> * Returns error and drops reference to input namei data on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">link_path_walk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="o">==</span><span class="sc">&#39;/&#39;</span><span class="p">)</span>
		<span class="n">name</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* At this point we know we have a real path component. */</span>
	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qstr</span> <span class="n">this</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">may_lookup</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
 		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">hash_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="p">.</span><span class="n">hash</span><span class="p">);</span>
		<span class="n">this</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">this</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">type</span> <span class="o">=</span> <span class="n">LAST_NORM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="k">switch</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">type</span> <span class="o">=</span> <span class="n">LAST_DOTDOT</span><span class="p">;</span>
					<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_JUMPED</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">type</span> <span class="o">=</span> <span class="n">LAST_DOT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">LAST_NORM</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_JUMPED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_HASH</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">this</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">[</span><span class="n">len</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">last_component</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it wasn&#39;t NUL, we know it was &#39;/&#39;. Skip that</span>
<span class="cm">		 * slash, and continue until no more slashes.</span>
<span class="cm">		 */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">[</span><span class="n">len</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">last_component</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">walk_component</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nested_symlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_lookup</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span> 
		<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* here ends the main loop */</span>

<span class="nl">last_component:</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">terminate_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">path_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">**</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span> <span class="o">=</span> <span class="n">LAST_ROOT</span><span class="p">;</span> <span class="cm">/* if there are only slashes... */</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_JUMPED</span><span class="p">;</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_ROOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">__read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="o">==</span><span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">set_root_rcu</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">set_root</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
			<span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dfd</span> <span class="o">==</span> <span class="n">AT_FDCWD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

			<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>

			<span class="k">do</span> <span class="p">{</span>
				<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
				<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">fs</span><span class="o">-&gt;</span><span class="n">pwd</span><span class="p">;</span>
				<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">__read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">get_fs_pwd</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

		<span class="n">file</span> <span class="o">=</span> <span class="n">fget_raw_light</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

		<span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">fput_fail</span><span class="p">;</span>

			<span class="n">retval</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fput_fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fput_needed</span><span class="p">)</span>
				<span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">__read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
			<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
			<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fput_fail:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out_fail:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lookup_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span> <span class="o">==</span> <span class="n">LAST_NORM</span> <span class="o">&amp;&amp;</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">.</span><span class="n">len</span><span class="p">])</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_FOLLOW</span> <span class="o">|</span> <span class="n">LOOKUP_DIRECTORY</span><span class="p">;</span>

	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_PARENT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">walk_component</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span><span class="p">,</span>
					<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">path_lookupat</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Path walking is largely split up into 2 different synchronisation</span>
<span class="cm">	 * schemes, rcu-walk and ref-walk (explained in</span>
<span class="cm">	 * Documentation/filesystems/path-lookup.txt). These share much of the</span>
<span class="cm">	 * path walk code, but some things particularly setup, cleanup, and</span>
<span class="cm">	 * following mounts are sufficiently divergent that functions are</span>
<span class="cm">	 * duplicated. Typically there is a function foo(), and its RCU</span>
<span class="cm">	 * analogue, foo_rcu().</span>
<span class="cm">	 *</span>
<span class="cm">	 * -ECHILD is the error number of choice (just to avoid clashes) that</span>
<span class="cm">	 * is returned if some aspect of an rcu-walk fails. Such an error must</span>
<span class="cm">	 * be handled by restarting a traditional ref-walk (which will always</span>
<span class="cm">	 * be able to complete).</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">path_init</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_PARENT</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">total_link_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">link_path_walk</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_PARENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">lookup_last</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">path</span> <span class="n">link</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_PARENT</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">follow_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">lookup_last</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="n">put_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">complete_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_DIRECTORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_ROOT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_path_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">path_lookupat</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_RCU</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">path_lookupat</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">path_lookupat</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_REVAL</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">audit_dummy_context</span><span class="p">()))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">&amp;&amp;</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
				<span class="n">audit_inode</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kern_path_parent</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_path_lookup</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">LOOKUP_PARENT</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kern_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">do_path_lookup</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair</span>
<span class="cm"> * @dentry:  pointer to dentry of the base directory</span>
<span class="cm"> * @mnt: pointer to vfs mount of the base directory</span>
<span class="cm"> * @name: pointer to file name</span>
<span class="cm"> * @flags: lookup flags</span>
<span class="cm"> * @path: pointer to struct path to fill</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vfs_path_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">nd</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">nd</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_PARENT</span><span class="p">);</span>
	<span class="cm">/* the first argument of do_path_lookup() is ignored with LOOKUP_ROOT */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">do_path_lookup</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restricted form of lookup. Doesn&#39;t follow links, single-component only,</span>
<span class="cm"> * needs parent already locked. Doesn&#39;t follow mounts.</span>
<span class="cm"> * SMP-safe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">lookup_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__lookup_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lookup_one_len - filesystem helper to lookup single pathname component</span>
<span class="cm"> * @name:	pathname component to lookup</span>
<span class="cm"> * @base:	base directory to lookup from</span>
<span class="cm"> * @len:	maximum length @len should be interpreted to</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this routine is purely a helper for filesystem usage and should</span>
<span class="cm"> * not be called by generic code.  Also note that by using this function the</span>
<span class="cm"> * nameidata argument is passed to the filesystem methods and a filesystem</span>
<span class="cm"> * using this helper needs to be prepared for that.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">lookup_one_len</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">this</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>

	<span class="n">this</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">this</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">this</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * See if the low-level filesystem might want</span>
<span class="cm">	 * to use its own hash..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_HASH</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__lookup_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">user_path_at_empty</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">empty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">getname_flags</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">empty</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_PARENT</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">do_path_lookup</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">);</span>
		<span class="n">putname</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">user_path_at</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">user_path_at_empty</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">user_path_parent</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_path_lookup</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">LOOKUP_PARENT</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">putname</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * It&#39;s inline, so penalty for filesystems that don&#39;t use sticky bit is</span>
<span class="cm"> * minimal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_sticky</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kuid_t</span> <span class="n">fsuid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_ISVTX</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">fsuid</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">fsuid</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">inode_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">CAP_FOWNER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Check whether we can remove a link victim from directory dir, check</span>
<span class="cm"> *  whether the type of victim is right.</span>
<span class="cm"> *  1. We can&#39;t do it if dir is read-only (done in permission())</span>
<span class="cm"> *  2. We should have write and exec permissions on dir</span>
<span class="cm"> *  3. We can&#39;t remove anything from append-only dir</span>
<span class="cm"> *  4. We can&#39;t do anything with immutable dir (done in permission())</span>
<span class="cm"> *  5. If the sticky bit on dir is set we should either</span>
<span class="cm"> *	a. be owner of dir, or</span>
<span class="cm"> *	b. be owner of victim, or</span>
<span class="cm"> *	c. have CAP_FOWNER capability</span>
<span class="cm"> *  6. If the victim is append-only or immutable we can&#39;t do antyhing with</span>
<span class="cm"> *     links pointing to it.</span>
<span class="cm"> *  7. If we were asked to remove a directory and victim isn&#39;t one - ENOTDIR.</span>
<span class="cm"> *  8. If we were asked to remove a non-directory and victim isn&#39;t one - EISDIR.</span>
<span class="cm"> *  9. We can&#39;t remove a root or mountpoint.</span>
<span class="cm"> * 10. We don&#39;t allow removal of NFS sillyrenamed files; it&#39;s handled by</span>
<span class="cm"> *     nfs_async_unlink().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">victim</span><span class="p">,</span><span class="kt">int</span> <span class="n">isdir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">audit_inode_child</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_sticky</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">||</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">||</span>
	    <span class="n">IS_IMMUTABLE</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_SWAPFILE</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isdir</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">victim</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DEADDIR</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NFSFS_RENAMED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*	Check whether we can create an object with dentry child in directory</span>
<span class="cm"> *  dir.</span>
<span class="cm"> *  1. We can&#39;t do it if child already exists (open has special treatment for</span>
<span class="cm"> *     this case, but since we are inlined it&#39;s OK)</span>
<span class="cm"> *  2. We can&#39;t do it if dir is read-only (done in permission())</span>
<span class="cm"> *  3. We should have write and exec permissions on dir</span>
<span class="cm"> *  4. We can&#39;t do it if dir is immutable (done in permission())</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">may_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DEADDIR</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * p1 and p2 should be directories on the same fs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">lock_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_vfs_rename_mutex</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">d_ancestor</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_CHILD</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">d_ancestor</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_CHILD</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_CHILD</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_vfs_rename_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vfs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>	<span class="cm">/* shouldn&#39;t it be ENOSYS? */</span>
	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="n">S_IALLUGO</span><span class="p">;</span>
	<span class="n">mode</span> <span class="o">|=</span> <span class="n">S_IFREG</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fsnotify_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">acc_mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* O_PATH? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acc_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">acc_mode</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NODEV</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="cm">/*FALLTHRU*/</span>
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
		<span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">O_TRUNC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">acc_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * An append-only file must be opened in append mode for writing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span>  <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">O_RDONLY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* O_NOATIME can only be set by the owner or superuser */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">O_NOATIME</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">inode_owner_or_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">get_write_access</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Refuse to truncate files with mandatory locks held on them.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">locks_verify_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_truncate</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">do_truncate</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">ATTR_MTIME</span><span class="o">|</span><span class="n">ATTR_CTIME</span><span class="o">|</span><span class="n">ATTR_OPEN</span><span class="p">,</span>
				    <span class="n">filp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_write_access</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">open_to_namei_flags</span><span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">flag</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle the last step of open()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">do_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">open_flags</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">open_flag</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">open_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">will_truncate</span> <span class="o">=</span> <span class="n">open_flag</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">acc_mode</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">acc_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">symlink_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">save_parent</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="n">bool</span> <span class="n">retried</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_PARENT</span><span class="p">;</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LAST_DOTDOT</span>:
	<span class="k">case</span> <span class="n">LAST_DOT</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">handle_dots</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">last_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="cm">/* fallthrough */</span>
	<span class="k">case</span> <span class="n">LAST_ROOT</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">complete_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">audit_inode</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">open_flag</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LAST_BIND</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">complete_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">audit_inode</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">open_flag</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">.</span><span class="n">len</span><span class="p">])</span>
			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_FOLLOW</span> <span class="o">|</span> <span class="n">LOOKUP_DIRECTORY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">open_flag</span> <span class="o">&amp;</span> <span class="n">O_PATH</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">))</span>
			<span class="n">symlink_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* we _can_ be in RCU mode here */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">lookup_fast</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">lookup_slow</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

			<span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">finish_lookup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* create side of things */</span>
	<span class="cm">/*</span>
<span class="cm">	 * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED has been</span>
<span class="cm">	 * cleared when we got to the last component we are about to look up</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">complete_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="n">audit_inode</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
	<span class="cm">/* trailing slashes? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">.</span><span class="n">len</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

<span class="nl">retry_lookup:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_hash</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">;</span>

	<span class="cm">/* Negative dentry, just create the file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIXACL</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
			<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * This write is needed to ensure that a</span>
<span class="cm">		 * rw-&gt;ro transition does not occur between</span>
<span class="cm">		 * the time when the file is created and when</span>
<span class="cm">		 * a permanent write count is taken through</span>
<span class="cm">		 * the &#39;struct file&#39; in nameidata_to_filp().</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_mutex_unlock</span><span class="p">;</span>
		<span class="n">want_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Don&#39;t check for write permission, don&#39;t truncate */</span>
		<span class="n">open_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">O_TRUNC</span><span class="p">;</span>
		<span class="n">will_truncate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">acc_mode</span> <span class="o">=</span> <span class="n">MAY_OPEN</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_mknod</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_mutex_unlock</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_create</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_mutex_unlock</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">common</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It already exists.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">audit_inode</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">open_flag</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_dput</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">follow_managed</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_dput</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_JUMPED</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
<span class="nl">finish_lookup:</span>
	<span class="cm">/* we _can_ be in RCU mode here */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path_to_nameidata</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">should_follow_link</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">!</span><span class="n">symlink_ok</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">unlazy_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span> <span class="o">||</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path_to_nameidata</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">save_parent</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
		<span class="n">save_parent</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="cm">/* Why this, you ask?  _Now_ we might have grown LOOKUP_JUMPED... */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">complete_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">save_parent</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">open_flag</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_DIRECTORY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="n">audit_inode</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
<span class="nl">ok:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">will_truncate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">will_truncate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="n">want_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">common:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">may_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">acc_mode</span><span class="p">,</span> <span class="n">open_flag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="n">filp</span> <span class="o">=</span> <span class="n">nameidata_to_filp</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EOPENSTALE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">save_parent</span><span class="p">.</span><span class="n">dentry</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">retried</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">save_parent</span><span class="p">.</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">save_parent</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="n">save_parent</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">save_parent</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want_write</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
			<span class="n">want_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retried</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry_lookup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ima_file_check</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">acc_mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">will_truncate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">handle_truncate</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
				<span class="n">filp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">want_write</span><span class="p">)</span>
		<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">save_parent</span><span class="p">);</span>
	<span class="n">terminate_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">filp</span><span class="p">;</span>

<span class="nl">exit_mutex_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="nl">exit_dput:</span>
	<span class="n">path_put_conditional</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="n">filp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">path_openat</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">open_flags</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">get_empty_filp</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENFILE</span><span class="p">);</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">open_flag</span><span class="p">;</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">open_to_namei_flags</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">open_flag</span><span class="p">);</span>
	<span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">create_mode</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">path_init</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_PARENT</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_filp</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">total_link_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">link_path_walk</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_filp</span><span class="p">;</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">do_last</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* trailing symlink */</span>
		<span class="k">struct</span> <span class="n">path</span> <span class="n">link</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">path_put_conditional</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
			<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ELOOP</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_PARENT</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LOOKUP_OPEN</span><span class="o">|</span><span class="n">LOOKUP_CREATE</span><span class="o">|</span><span class="n">LOOKUP_EXCL</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">follow_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">do_last</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
		<span class="n">put_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_ROOT</span><span class="p">))</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="n">release_open_intent</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EOPENSTALE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ECHILD</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESTALE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">filp</span><span class="p">;</span>

<span class="nl">out_filp:</span>
	<span class="n">filp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">do_filp_open</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">open_flags</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">path_openat</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_RCU</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">filp</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ECHILD</span><span class="p">)))</span>
		<span class="n">filp</span> <span class="o">=</span> <span class="n">path_openat</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">filp</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESTALE</span><span class="p">)))</span>
		<span class="n">filp</span> <span class="o">=</span> <span class="n">path_openat</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_REVAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">filp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">do_file_open_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">open_flags</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="n">nd</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">nd</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_ROOT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">follow_link</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">intent</span> <span class="o">&amp;</span> <span class="n">LOOKUP_OPEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ELOOP</span><span class="p">);</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">path_openat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_RCU</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ECHILD</span><span class="p">)))</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">path_openat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESTALE</span><span class="p">)))</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">path_openat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_REVAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">kern_path_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EEXIST</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">do_path_lookup</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">LOOKUP_PARENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Yucky last component or no last component at all?</span>
<span class="cm">	 * (foo/., foo/.., /////)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">last_type</span> <span class="o">!=</span> <span class="n">LAST_NORM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">nd</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_PARENT</span><span class="p">;</span>
	<span class="n">nd</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_CREATE</span> <span class="o">|</span> <span class="n">LOOKUP_EXCL</span><span class="p">;</span>
	<span class="n">nd</span><span class="p">.</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">O_EXCL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do the final lookup.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">eexist</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Special case - lookup gave negative, but... we had foo/bar/</span>
<span class="cm">	 * From the vfs_mknod() POV we just have a negative dentry -</span>
<span class="cm">	 * all is fine. Let&#39;s be bastards - you had / on the end, you&#39;ve</span>
<span class="cm">	 * been asking for (non-existent) directory. -ENOENT for you.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">is_dir</span> <span class="o">&amp;&amp;</span> <span class="n">nd</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">nd</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">len</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="nl">eexist:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EEXIST</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kern_path_create</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">user_path_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">pathname</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">kern_path_create</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">is_dir</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">user_path_create</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vfs_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_MKNOD</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">mknod</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">devcgroup_inode_mknod</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_mknod</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">mknod</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fsnotify_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_mknod</span><span class="p">(</span><span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* zero mode translates to S_IFREG */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">mknodat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
		<span class="kt">unsigned</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">user_path_create</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIXACL</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
		<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">may_mknod</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_mknod</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>: <span class="k">case</span> <span class="n">S_IFREG</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_create</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span><span class="n">dentry</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">S_IFCHR</span>: <span class="k">case</span> <span class="n">S_IFBLK</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_mknod</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span><span class="n">dentry</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span>
					<span class="n">new_decode_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">S_IFIFO</span>: <span class="k">case</span> <span class="n">S_IFSOCK</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_mknod</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span><span class="n">dentry</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_drop_write:</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">out_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">mknod</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_mknodat</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vfs_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">max_links</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_max_links</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">mkdir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">S_IRWXUGO</span><span class="o">|</span><span class="n">S_ISVTX</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_mkdir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_links</span> <span class="o">&amp;&amp;</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;=</span> <span class="n">max_links</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMLINK</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fsnotify_mkdir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">mkdirat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">user_path_create</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIXACL</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
		<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_mkdir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_mkdir</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="nl">out_drop_write:</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">out_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">mkdir</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_mkdirat</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The dentry_unhash() helper will try to drop the dentry early: we</span>
<span class="cm"> * should have a usage count of 1 if we&#39;re the only user of this</span>
<span class="cm"> * dentry, and if that is true (possibly after pruning the dcache),</span>
<span class="cm"> * then we drop the dentry now.</span>
<span class="cm"> *</span>
<span class="cm"> * A low-level filesystem can, if it choses, legally</span>
<span class="cm"> * do a</span>
<span class="cm"> *</span>
<span class="cm"> *	if (!d_unhashed(dentry))</span>
<span class="cm"> *		return -EBUSY;</span>
<span class="cm"> *</span>
<span class="cm"> * if it cannot handle the case of removing a directory</span>
<span class="cm"> * that is still in use by something else..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">dentry_unhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vfs_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">may_delete</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">rmdir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_rmdir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">rmdir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DEAD</span><span class="p">;</span>
	<span class="n">dont_mount</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">d_delete</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">do_rmdir</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">user_path_parent</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">last_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LAST_DOTDOT</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LAST_DOT</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LAST_ROOT</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nd</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_PARENT</span><span class="p">;</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit3</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_rmdir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit4</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_rmdir</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
<span class="nl">exit4:</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">exit3:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="nl">exit2:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="nl">exit1:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">rmdir</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">pathname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_rmdir</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vfs_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">may_delete</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">unlink</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_unlink</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">unlink</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
				<span class="n">dont_mount</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="cm">/* We don&#39;t d_delete() NFS sillyrenamed files--they still exist. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NFSFS_RENAMED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fsnotify_link_count</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="n">d_delete</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make sure that the actual truncation of the file will occur outside its</span>
<span class="cm"> * directory&#39;s i_mutex.  Truncate can take a long time if there is a lot of</span>
<span class="cm"> * writeout happening, and we don&#39;t want to prevent access to the directory</span>
<span class="cm"> * while waiting on the I/O.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">do_unlinkat</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">user_path_parent</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">last_type</span> <span class="o">!=</span> <span class="n">LAST_NORM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>

	<span class="n">nd</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_PARENT</span><span class="p">;</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Why not before? Because we want correct error value */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">nd</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">len</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">slashes</span><span class="p">;</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">slashes</span><span class="p">;</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_unlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit3</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_unlink</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
<span class="nl">exit3:</span>
		<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="nl">exit2:</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>	<span class="cm">/* truncate the inode here */</span>
<span class="nl">exit1:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">slashes:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">:</span>
		<span class="n">S_ISDIR</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EISDIR</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">unlinkat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AT_REMOVEDIR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">AT_REMOVEDIR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">do_rmdir</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">do_unlinkat</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">unlink</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">pathname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_unlinkat</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vfs_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">symlink</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_symlink</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">oldname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">symlink</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">oldname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fsnotify_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">symlinkat</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">newdfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">newname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">from</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">oldname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">from</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">user_path_create</span><span class="p">(</span><span class="n">newdfd</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_putname</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_symlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_symlink</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
<span class="nl">out_drop_write:</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">out_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
<span class="nl">out_putname:</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">symlink</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">newname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_symlinkat</span><span class="p">(</span><span class="n">oldname</span><span class="p">,</span> <span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">newname</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vfs_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">max_links</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_max_links</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A link to an append-only or immutable file cannot be created.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_IMMUTABLE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_link</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="cm">/* Make sure we don&#39;t allow creating hardlink to an unlinked file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span>  <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_links</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;=</span> <span class="n">max_links</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMLINK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fsnotify_link</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hardlinks are often used in delicate situations.  We avoid</span>
<span class="cm"> * security-related surprises by not following symlinks on the</span>
<span class="cm"> * newname.  --KAB</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t follow them on the oldname either to be compatible</span>
<span class="cm"> * with linux 2.0, and to avoid hard-linking to directories</span>
<span class="cm"> * and other special files.  --ADM</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">linkat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">olddfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">newdfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">old_path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">how</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">AT_SYMLINK_FOLLOW</span> <span class="o">|</span> <span class="n">AT_EMPTY_PATH</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * To use null names we require CAP_DAC_READ_SEARCH</span>
<span class="cm">	 * This ensures that not everyone will be able to create</span>
<span class="cm">	 * handlink using the passed filedescriptor.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT_EMPTY_PATH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_DAC_READ_SEARCH</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="n">how</span> <span class="o">=</span> <span class="n">LOOKUP_EMPTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AT_SYMLINK_FOLLOW</span><span class="p">)</span>
		<span class="n">how</span> <span class="o">|=</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">user_path_at</span><span class="p">(</span><span class="n">olddfd</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">new_dentry</span> <span class="o">=</span> <span class="n">user_path_create</span><span class="p">(</span><span class="n">newdfd</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">!=</span> <span class="n">new_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">new_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_link</span><span class="p">(</span><span class="n">old_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_path</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_link</span><span class="p">(</span><span class="n">old_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">new_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
<span class="nl">out_drop_write:</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">new_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">out_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_path</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_path</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">newname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_linkat</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The worst of all namespace operations - renaming directory. &quot;Perverted&quot;</span>
<span class="cm"> * doesn&#39;t even start to describe it. Somebody in UCB had a heck of a trip...</span>
<span class="cm"> * Problems:</span>
<span class="cm"> *	a) we can get into loop creation. Check is done in is_subdir().</span>
<span class="cm"> *	b) race potential - two innocent renames can create a loop together.</span>
<span class="cm"> *	   That&#39;s where 4.4 screws up. Current fix: serialization on</span>
<span class="cm"> *	   sb-&gt;s_vfs_rename_mutex. We might be more accurate, but that&#39;s another</span>
<span class="cm"> *	   story.</span>
<span class="cm"> *	c) we have to lock _three_ objects - parents and victim (if it exists).</span>
<span class="cm"> *	   And that - after we got -&gt;i_mutex on parents (until then we don&#39;t know</span>
<span class="cm"> *	   whether the target exists).  Solution: try to be smart with locking</span>
<span class="cm"> *	   order for inodes.  We rely on the fact that tree topology may change</span>
<span class="cm"> *	   only under -&gt;s_vfs_rename_mutex _and_ that parent of the object we</span>
<span class="cm"> *	   move will be locked.  Thus we can rank directories by the tree</span>
<span class="cm"> *	   (ancestors first) and rank all non-directories after them.</span>
<span class="cm"> *	   That works since everybody except rename does &quot;lock parent, lookup,</span>
<span class="cm"> *	   lock child&quot; and rename is under -&gt;s_vfs_rename_mutex.</span>
<span class="cm"> *	   HOWEVER, it relies on the assumption that any object with -&gt;lookup()</span>
<span class="cm"> *	   has no more than 1 dentry.  If &quot;hybrid&quot; objects will ever appear,</span>
<span class="cm"> *	   we&#39;d better make sure that there&#39;s no link(2) for them.</span>
<span class="cm"> *	d) conversion from fhandle to dentry may come in the wrong moment - when</span>
<span class="cm"> *	   we are removing the target. Solution: we will have to grab -&gt;i_mutex</span>
<span class="cm"> *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on</span>
<span class="cm"> *	   -&gt;i_mutex on parents, which works but leads to some truly excessive</span>
<span class="cm"> *	   locking].</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vfs_rename_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">max_links</span> <span class="o">=</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_max_links</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are going to change the parent - check write permissions,</span>
<span class="cm">	 * we&#39;ll need to flip &#39;..&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_dir</span> <span class="o">!=</span> <span class="n">old_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_rename</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dget</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">)</span> <span class="o">||</span> <span class="n">d_mountpoint</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMLINK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_links</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">new_dir</span> <span class="o">!=</span> <span class="n">old_dir</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;=</span> <span class="n">max_links</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
		<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">rename</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DEAD</span><span class="p">;</span>
		<span class="n">dont_mount</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">fs_flags</span> <span class="o">&amp;</span> <span class="n">FS_RENAME_DOES_D_MOVE</span><span class="p">))</span>
			<span class="n">d_move</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">,</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">vfs_rename_other</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_rename</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dget</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">)</span><span class="o">||</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">rename</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
		<span class="n">dont_mount</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">fs_flags</span> <span class="o">&amp;</span> <span class="n">FS_RENAME_DOES_D_MOVE</span><span class="p">))</span>
		<span class="n">d_move</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vfs_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_dir</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">==</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
 		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 
	<span class="n">error</span> <span class="o">=</span> <span class="n">may_delete</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">is_dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">may_create</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">may_delete</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">,</span> <span class="n">is_dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">rename</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">old_name</span> <span class="o">=</span> <span class="n">fsnotify_oldname_init</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_rename_dir</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span><span class="n">old_dentry</span><span class="p">,</span><span class="n">new_dir</span><span class="p">,</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_rename_other</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span><span class="n">old_dentry</span><span class="p">,</span><span class="n">new_dir</span><span class="p">,</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fsnotify_move</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">is_dir</span><span class="p">,</span>
			      <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">);</span>
	<span class="n">fsnotify_oldname_free</span><span class="p">(</span><span class="n">old_name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">renameat</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">olddfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">newdfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">newname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">trap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">oldnd</span><span class="p">,</span> <span class="n">newnd</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">user_path_parent</span><span class="p">(</span><span class="n">olddfd</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">user_path_parent</span><span class="p">(</span><span class="n">newdfd</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldnd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">!=</span> <span class="n">newnd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>

	<span class="n">old_dir</span> <span class="o">=</span> <span class="n">oldnd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldnd</span><span class="p">.</span><span class="n">last_type</span> <span class="o">!=</span> <span class="n">LAST_NORM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>

	<span class="n">new_dir</span> <span class="o">=</span> <span class="n">newnd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newnd</span><span class="p">.</span><span class="n">last_type</span> <span class="o">!=</span> <span class="n">LAST_NORM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit2</span><span class="p">;</span>

	<span class="n">oldnd</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_PARENT</span><span class="p">;</span>
	<span class="n">newnd</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOOKUP_PARENT</span><span class="p">;</span>
	<span class="n">newnd</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LOOKUP_RENAME_TARGET</span><span class="p">;</span>

	<span class="n">trap</span> <span class="o">=</span> <span class="n">lock_rename</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">);</span>

	<span class="n">old_dentry</span> <span class="o">=</span> <span class="n">lookup_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldnd</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit3</span><span class="p">;</span>
	<span class="cm">/* source must exist */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit4</span><span class="p">;</span>
	<span class="cm">/* unless the source is a directory trailing slashes give -ENOTDIR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldnd</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">oldnd</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">len</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">exit4</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnd</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">newnd</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">len</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">exit4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* source should not be ancestor of target */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_dentry</span> <span class="o">==</span> <span class="n">trap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit4</span><span class="p">;</span>
	<span class="n">new_dentry</span> <span class="o">=</span> <span class="n">lookup_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newnd</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit4</span><span class="p">;</span>
	<span class="cm">/* target should not be an ancestor of source */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_dentry</span> <span class="o">==</span> <span class="n">trap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit5</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">oldnd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit5</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_path_rename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldnd</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">newnd</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit6</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_rename</span><span class="p">(</span><span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span>
				   <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
<span class="nl">exit6:</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">oldnd</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">exit5:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
<span class="nl">exit4:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">);</span>
<span class="nl">exit3:</span>
	<span class="n">unlock_rename</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">);</span>
<span class="nl">exit2:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newnd</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
<span class="nl">exit1:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldnd</span><span class="p">.</span><span class="n">path</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">rename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">newname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_renameat</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">newname</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vfs_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">buflen</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A helper for -&gt;readlink().  This should be used *ONLY* for symlinks that</span>
<span class="cm"> * have -&gt;follow_link() touching nd only in nd_set_link().  Using (or not</span>
<span class="cm"> * using) it for any given inode is up to filesystem.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">generic_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="n">nd</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">nd</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cookie</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">follow_link</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cookie</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cookie</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">vfs_readlink</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">nd_get_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">put_link</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">put_link</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">vfs_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__vfs_follow_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* get the link contents into pagecache */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page_getlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ppage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">read_mapping_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ppage</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">nd_terminate_link</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">page_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">page_getlink</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">vfs_readlink</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="n">buflen</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">page_follow_link_light</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">page_getlink</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">page_put_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__page_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">AOP_FLAG_UNINTERRUPTIBLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nofs</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">AOP_FLAG_NOFS</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pagecache_write_begin</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				<span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pagecache_write_end</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
							<span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">page_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__page_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			<span class="o">!</span><span class="p">(</span><span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">__GFP_FS</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">page_symlink_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span>	<span class="o">=</span> <span class="n">generic_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span>	<span class="o">=</span> <span class="n">page_follow_link_light</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_link</span>	<span class="o">=</span> <span class="n">page_put_link</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">user_path_at</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">follow_down_one</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">follow_down</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">follow_up</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_write_access</span><span class="p">);</span> <span class="cm">/* binfmt_aout */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">getname</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lock_rename</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lookup_one_len</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">page_follow_link_light</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">page_put_link</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">page_readlink</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__page_symlink</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">page_symlink</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">page_symlink_inode_operations</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kern_path</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_path_lookup</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_permission</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unlock_rename</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_create</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_follow_link</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_link</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_mkdir</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_mknod</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_permission</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_readlink</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_rename</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_rmdir</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_symlink</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_unlink</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dentry_unhash</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_readlink</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
