<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ufs › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ufs/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998</span>
<span class="cm"> * Daniel Pirkl &lt;daniel.pirkl@email.cz&gt;</span>
<span class="cm"> * Charles University, Faculty of Mathematics and Physics</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/ext2/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/minix/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  Goal-directed block allocation by Stephen Tweedie (sct@dcs.ed.ac.uk), 1993</span>
<span class="cm"> *  Big-endian to little-endian byte-swapping/bitmaps by</span>
<span class="cm"> *        David S. Miller (davem@caip.rutgers.edu), 1995</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>

<span class="cp">#include &quot;ufs_fs.h&quot;</span>
<span class="cp">#include &quot;ufs.h&quot;</span>
<span class="cp">#include &quot;swab.h&quot;</span>
<span class="cp">#include &quot;util.h&quot;</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">ufs_frag_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">frag</span><span class="p">,</span> <span class="n">bool</span> <span class="n">needs_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufs_block_to_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">i_block</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_sb_private_info</span> <span class="o">*</span><span class="n">uspi</span> <span class="o">=</span> <span class="n">UFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_uspi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ptrs_bits</span> <span class="o">=</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbshift</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">long</span> <span class="n">direct_blocks</span> <span class="o">=</span> <span class="n">UFS_NDADDR</span><span class="p">,</span>
		<span class="n">indirect_blocks</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">,</span>
		<span class="n">double_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;ptrs=uspi-&gt;s_apb = %d,double_blocks=%ld </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ptrs</span><span class="p">,</span><span class="n">double_blocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&lt;</span> <span class="n">direct_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">direct_blocks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">indirect_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">UFS_IND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">indirect_blocks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">double_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">UFS_DIND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="n">ptrs_bits</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">double_blocks</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">ptrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">UFS_TIND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="n">ptrs_bits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ufs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ufs_block_to_path&quot;</span><span class="p">,</span> <span class="s">&quot;block &gt; big&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns the location of the fragment from</span>
<span class="cm"> * the beginning of the filesystem.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">ufs_frag_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">frag</span><span class="p">,</span> <span class="n">bool</span> <span class="n">needs_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_inode_info</span> <span class="o">*</span><span class="n">ufsi</span> <span class="o">=</span> <span class="n">UFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_sb_private_info</span> <span class="o">*</span><span class="n">uspi</span> <span class="o">=</span> <span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_uspi</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbmask</span><span class="o">&gt;&gt;</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbshift</span><span class="o">-</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ufs_block_to_path</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">frag</span> <span class="o">&gt;&gt;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">,</span> <span class="n">offsets</span><span class="p">);</span>
	<span class="n">u64</span>  <span class="n">ret</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
	<span class="n">__fs32</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">__fs64</span> <span class="n">u2_block</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;: frag = %llu  depth = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">frag</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;: uspi-&gt;s_fpbshift = %d ,uspi-&gt;s_apbmask = %x, mask=%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">,</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbmask</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needs_lock</span><span class="p">)</span>
		<span class="n">lock_ufs</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UFS_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">UFS_TYPE_UFS2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ufs2</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_data</span><span class="p">[</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
		<span class="n">sector_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>

		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">shift</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">block</span> <span class="o">=</span> <span class="p">((</span><span class="n">__fs32</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)[</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">frag</span> <span class="o">&amp;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbmask</span><span class="p">));</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">ufs2:</span>
	<span class="n">u2_block</span> <span class="o">=</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">u2_i_data</span><span class="p">[</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u2_block</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>


	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
		<span class="n">sector_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>


		<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span><span class="p">)</span> <span class="o">+</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">u2_block</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">temp</span> <span class="o">+</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">shift</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">u2_block</span> <span class="o">=</span> <span class="p">((</span><span class="n">__fs64</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)[</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u2_block</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">u2_block</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="p">(</span><span class="n">frag</span> <span class="o">&amp;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbmask</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needs_lock</span><span class="p">)</span>
		<span class="n">unlock_ufs</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufs_inode_getfrag() - allocate new fragment(s)</span>
<span class="cm"> * @inode - pointer to inode</span>
<span class="cm"> * @fragment - number of `fragment&#39; which hold pointer</span>
<span class="cm"> *   to new allocated fragment(s)</span>
<span class="cm"> * @new_fragment - number of new allocated fragment(s)</span>
<span class="cm"> * @required - how many fragment(s) we require</span>
<span class="cm"> * @err - we set it if something wrong</span>
<span class="cm"> * @phys - pointer to where we save physical number of new allocated fragments,</span>
<span class="cm"> *   NULL if we allocate not data(indirect blocks for example).</span>
<span class="cm"> * @new - we set it if we allocate new block</span>
<span class="cm"> * @locked_page - for ufs_new_fragments()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">ufs_inode_getfrag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">fragment</span><span class="p">,</span>
		  <span class="n">sector_t</span> <span class="n">new_fragment</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">required</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span>
		  <span class="kt">long</span> <span class="o">*</span><span class="n">phys</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_inode_info</span> <span class="o">*</span><span class="n">ufsi</span> <span class="o">=</span> <span class="n">UFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_sb_private_info</span> <span class="o">*</span><span class="n">uspi</span> <span class="o">=</span> <span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_uspi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blockoff</span><span class="p">,</span> <span class="n">lastblockoff</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">lastfrag</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">lastblock</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;ENTER, ino %lu, fragment %llu, new_fragment %llu, required %u, &quot;</span>
	     <span class="s">&quot;metadata %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fragment</span><span class="p">,</span>
	     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_fragment</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="o">!</span><span class="n">phys</span><span class="p">);</span>

        <span class="cm">/* TODO : to be done for write support</span>
<span class="cm">        if ( (flags &amp; UFS_TYPE_MASK) == UFS_TYPE_UFS2)</span>
<span class="cm">             goto ufs2;</span>
<span class="cm">         */</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">ufs_fragstoblks</span> <span class="p">(</span><span class="n">fragment</span><span class="p">);</span>
	<span class="n">blockoff</span> <span class="o">=</span> <span class="n">ufs_fragnum</span> <span class="p">(</span><span class="n">fragment</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">ufs_get_direct_data_ptr</span><span class="p">(</span><span class="n">uspi</span><span class="p">,</span> <span class="n">ufsi</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>

	<span class="n">goal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">lastfrag</span> <span class="o">=</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_lastfrag</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">fragment</span> <span class="o">&lt;</span> <span class="n">lastfrag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;EXIT, result %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lastblock</span> <span class="o">=</span> <span class="n">ufs_fragstoblks</span> <span class="p">(</span><span class="n">lastfrag</span><span class="p">);</span>
	<span class="n">lastblockoff</span> <span class="o">=</span> <span class="n">ufs_fragnum</span> <span class="p">(</span><span class="n">lastfrag</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We will extend file into new block beyond last allocated block</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastblock</span> <span class="o">&lt;</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must reallocate last allocated block</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastblockoff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p2</span> <span class="o">=</span> <span class="n">ufs_get_direct_data_ptr</span><span class="p">(</span><span class="n">uspi</span><span class="p">,</span> <span class="n">ufsi</span><span class="p">,</span> <span class="n">lastblock</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_new_fragments</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">lastfrag</span><span class="p">,</span>
						<span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p2</span><span class="p">),</span>
						<span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpb</span> <span class="o">-</span> <span class="n">lastblockoff</span><span class="p">,</span>
						<span class="n">err</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lastfrag</span> <span class="o">!=</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_lastfrag</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lastfrag</span> <span class="o">=</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_lastfrag</span><span class="p">;</span>
			
		<span class="p">}</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					 <span class="n">ufs_get_direct_data_ptr</span><span class="p">(</span><span class="n">uspi</span><span class="p">,</span> <span class="n">ufsi</span><span class="p">,</span>
								 <span class="n">lastblock</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="n">goal</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpb</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_new_fragments</span> <span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">fragment</span> <span class="o">-</span> <span class="n">blockoff</span><span class="p">,</span> 
					 <span class="n">goal</span><span class="p">,</span> <span class="n">required</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">,</span>
					 <span class="n">err</span><span class="p">,</span>
					 <span class="n">phys</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">locked_page</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lastblock</span> <span class="o">==</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We will extend last allocated block</span>
<span class="cm">	 */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_new_fragments</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">fragment</span> <span class="o">-</span>
					<span class="p">(</span><span class="n">blockoff</span> <span class="o">-</span> <span class="n">lastblockoff</span><span class="p">),</span>
					<span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span>
					<span class="n">required</span> <span class="o">+</span>  <span class="p">(</span><span class="n">blockoff</span> <span class="o">-</span> <span class="n">lastblockoff</span><span class="p">),</span>
					<span class="n">err</span><span class="p">,</span> <span class="n">phys</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">locked_page</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* (lastblock &gt; block) */</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We will allocate new block before last allocated block</span>
<span class="cm">	 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
						 <span class="n">ufs_get_direct_data_ptr</span><span class="p">(</span><span class="n">uspi</span><span class="p">,</span> <span class="n">ufsi</span><span class="p">,</span> <span class="n">block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
				<span class="n">goal</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpb</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_new_fragments</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">fragment</span> <span class="o">-</span> <span class="n">blockoff</span><span class="p">,</span>
					<span class="n">goal</span><span class="p">,</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpb</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span>
					<span class="n">phys</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">locked_page</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">blockoff</span> <span class="o">&amp;&amp;</span> <span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">blockoff</span> <span class="o">&amp;&amp;</span> <span class="n">lastfrag</span> <span class="o">!=</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_lastfrag</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ufs_sync_inode</span> <span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;EXIT, result %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

     <span class="cm">/* This part : To be implemented ....</span>
<span class="cm">        Required only for writing, not required for READ-ONLY.</span>
<span class="cm">ufs2:</span>

<span class="cm">	u2_block = ufs_fragstoblks(fragment);</span>
<span class="cm">	u2_blockoff = ufs_fragnum(fragment);</span>
<span class="cm">	p = ufsi-&gt;i_u1.u2_i_data + block;</span>
<span class="cm">	goal = 0;</span>

<span class="cm">repeat2:</span>
<span class="cm">	tmp = fs32_to_cpu(sb, *p);</span>
<span class="cm">	lastfrag = ufsi-&gt;i_lastfrag;</span>

<span class="cm">     */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufs_inode_getblock() - allocate new block</span>
<span class="cm"> * @inode - pointer to inode</span>
<span class="cm"> * @bh - pointer to block which hold &quot;pointer&quot; to new allocated block</span>
<span class="cm"> * @fragment - number of `fragment&#39; which hold pointer</span>
<span class="cm"> *   to new allocated block</span>
<span class="cm"> * @new_fragment - number of new allocated fragment</span>
<span class="cm"> *  (block will hold this fragment and also uspi-&gt;s_fpb-1)</span>
<span class="cm"> * @err - see ufs_inode_getfrag()</span>
<span class="cm"> * @phys - see ufs_inode_getfrag()</span>
<span class="cm"> * @new - see ufs_inode_getfrag()</span>
<span class="cm"> * @locked_page - see ufs_inode_getfrag()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">ufs_inode_getblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
		  <span class="n">u64</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">new_fragment</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span>
		  <span class="kt">long</span> <span class="o">*</span><span class="n">phys</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_sb_private_info</span> <span class="o">*</span><span class="n">uspi</span> <span class="o">=</span> <span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_uspi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blockoff</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">ufs_fragstoblks</span> <span class="p">(</span><span class="n">fragment</span><span class="p">);</span>
	<span class="n">blockoff</span> <span class="o">=</span> <span class="n">ufs_fragnum</span> <span class="p">(</span><span class="n">fragment</span><span class="p">);</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;ENTER, ino %lu, fragment %llu, new_fragment %llu, metadata %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fragment</span><span class="p">,</span>
	     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_fragment</span><span class="p">,</span> <span class="o">!</span><span class="n">phys</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ll_rw_block</span> <span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">fs_magic</span> <span class="o">==</span> <span class="n">UFS2_MAGIC</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__fs64</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">block</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__fs32</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">block</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">fs_magic</span> <span class="o">==</span> <span class="n">UFS2_MAGIC</span> <span class="o">?</span>
		      <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="p">((</span><span class="n">__fs64</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)[</span><span class="n">block</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">:</span>
		      <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="p">((</span><span class="n">__fs32</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)[</span><span class="n">block</span><span class="o">-</span><span class="mi">1</span><span class="p">]))))</span>
		<span class="n">goal</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpb</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">goal</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpb</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ufs_new_fragments</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ufs_blknum</span><span class="p">(</span><span class="n">new_fragment</span><span class="p">),</span> <span class="n">goal</span><span class="p">,</span>
				<span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpb</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ufs_data_ptr_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>		


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">;</span>
		<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;result %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">tmp</span> <span class="o">+</span> <span class="n">blockoff</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufs_getfrag_block() - `get_block_t&#39; function, interface between UFS and</span>
<span class="cm"> * readpage, writepage and so on</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ufs_getfrag_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">fragment</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_sb_info</span> <span class="o">*</span> <span class="n">sbi</span> <span class="o">=</span> <span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ufs_sb_private_info</span> <span class="o">*</span> <span class="n">uspi</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_uspi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">,</span><span class="n">phys</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">phys64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">needs_lock</span> <span class="o">=</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mutex_owner</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">create</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phys64</span> <span class="o">=</span> <span class="n">ufs_frag_map</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">needs_lock</span><span class="p">);</span>
		<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;phys64 = %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">phys64</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phys64</span><span class="p">)</span>
			<span class="n">map_bh</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">phys64</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

        <span class="cm">/* This code entered only while writing ....? */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needs_lock</span><span class="p">)</span>
		<span class="n">lock_ufs</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;ENTER, ino %lu, fragment %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fragment</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fragment</span> <span class="o">&gt;</span>
	    <span class="p">((</span><span class="n">UFS_NDADDR</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apb</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_2apb</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_3apb</span><span class="p">)</span>
	     <span class="o">&lt;&lt;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">abort_too_big</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">fragment</span><span class="p">;</span>
	  
	<span class="cm">/*</span>
<span class="cm">	 * ok, these macros clean the logic up a bit and make</span>
<span class="cm">	 * it much more readable:</span>
<span class="cm">	 */</span>
<span class="cp">#define GET_INODE_DATABLOCK(x) \</span>
<span class="cp">	ufs_inode_getfrag(inode, x, fragment, 1, &amp;err, &amp;phys, &amp;new,\</span>
<span class="cp">			  bh_result-&gt;b_page)</span>
<span class="cp">#define GET_INODE_PTR(x) \</span>
<span class="cp">	ufs_inode_getfrag(inode, x, fragment, uspi-&gt;s_fpb, &amp;err, NULL, NULL,\</span>
<span class="cp">			  bh_result-&gt;b_page)</span>
<span class="cp">#define GET_INDIRECT_DATABLOCK(x) \</span>
<span class="cp">	ufs_inode_getblock(inode, bh, x, fragment,	\</span>
<span class="cp">			  &amp;err, &amp;phys, &amp;new, bh_result-&gt;b_page)</span>
<span class="cp">#define GET_INDIRECT_PTR(x) \</span>
<span class="cp">	ufs_inode_getblock(inode, bh, x, fragment,	\</span>
<span class="cp">			  &amp;err, NULL, NULL, NULL)</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">UFS_NDIR_FRAGMENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">GET_INODE_DATABLOCK</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ptr</span> <span class="o">-=</span> <span class="n">UFS_NDIR_FRAGMENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbshift</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">GET_INODE_PTR</span><span class="p">(</span><span class="n">UFS_IND_FRAGMENT</span> <span class="o">+</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;&gt;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbshift</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">get_indirect</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ptr</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbshift</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_2apbshift</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">GET_INODE_PTR</span><span class="p">(</span><span class="n">UFS_DIND_FRAGMENT</span> <span class="o">+</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;&gt;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_2apbshift</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">get_double</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ptr</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_2apbshift</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fpbshift</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">GET_INODE_PTR</span><span class="p">(</span><span class="n">UFS_TIND_FRAGMENT</span> <span class="o">+</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;&gt;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_3apbshift</span><span class="p">));</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">GET_INDIRECT_PTR</span><span class="p">((</span><span class="n">ptr</span> <span class="o">&gt;&gt;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_2apbshift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbmask</span><span class="p">);</span>
<span class="nl">get_double:</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">GET_INDIRECT_PTR</span><span class="p">((</span><span class="n">ptr</span> <span class="o">&gt;&gt;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbshift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbmask</span><span class="p">);</span>
<span class="nl">get_indirect:</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">GET_INDIRECT_DATABLOCK</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_apbmask</span><span class="p">);</span>

<span class="cp">#undef GET_INODE_DATABLOCK</span>
<span class="cp">#undef GET_INODE_PTR</span>
<span class="cp">#undef GET_INDIRECT_DATABLOCK</span>
<span class="cp">#undef GET_INDIRECT_PTR</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
	<span class="n">map_bh</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>
<span class="nl">abort:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needs_lock</span><span class="p">)</span>
		<span class="n">unlock_ufs</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">abort_too_big:</span>
	<span class="n">ufs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ufs_get_block&quot;</span><span class="p">,</span> <span class="s">&quot;block &gt; big&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufs_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span><span class="n">ufs_getfrag_block</span><span class="p">,</span><span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">block_read_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span><span class="n">ufs_getfrag_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ufs_prepare_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ufs_getfrag_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">block_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span>
				<span class="n">ufs_getfrag_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
			<span class="n">vmtruncate</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">ufs_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">generic_block_bmap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span><span class="n">block</span><span class="p">,</span><span class="n">ufs_getfrag_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ufs_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span> <span class="o">=</span> <span class="n">ufs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span> <span class="o">=</span> <span class="n">ufs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span> <span class="o">=</span> <span class="n">ufs_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span> <span class="o">=</span> <span class="n">generic_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span> <span class="o">=</span> <span class="n">ufs_bmap</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufs_set_inode_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_file_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_file_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_aops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_dir_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_aops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_fast_symlink_inode_operations</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_symlink_inode_operations</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufs_aops</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
				   <span class="n">ufs_get_inode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">UFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufs1_read_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufs_inode</span> <span class="o">*</span><span class="n">ufs_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_inode_info</span> <span class="o">*</span><span class="n">ufsi</span> <span class="o">=</span> <span class="n">UFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy data to the in-core inode.</span>
<span class="cm">	 */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">fs16_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_mode</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fs16_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_nlink</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ufs_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ufs_read_inode&quot;</span><span class="p">,</span> <span class="s">&quot;inode %lu has zero nlink</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * Linux now has 32-bit uid and gid, so we can support EFT.</span>
<span class="cm">	 */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">ufs_get_inode_uid</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">ufs_get_inode_gid</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_blocks</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_gen</span><span class="p">);</span>
	<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_flags</span><span class="p">);</span>
	<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_shadow</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u3</span><span class="p">.</span><span class="n">ui_sun</span><span class="p">.</span><span class="n">ui_shadow</span><span class="p">);</span>
	<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_oeftflag</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u3</span><span class="p">.</span><span class="n">ui_sun</span><span class="p">.</span><span class="n">ui_oeftflag</span><span class="p">);</span>

	
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_symlink</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_symlink</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufs2_read_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufs2_inode</span> <span class="o">*</span><span class="n">ufs2_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_inode_info</span> <span class="o">*</span><span class="n">ufsi</span> <span class="o">=</span> <span class="n">UFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;Reading ufs2 inode, ino %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy data to the in-core inode.</span>
<span class="cm">	 */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">fs16_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_mode</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fs16_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_nlink</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ufs_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ufs_read_inode&quot;</span><span class="p">,</span> <span class="s">&quot;inode %lu has zero nlink</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

        <span class="cm">/*</span>
<span class="cm">         * Linux now has 32-bit uid and gid, so we can support EFT.</span>
<span class="cm">         */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_uid</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_gid</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_atime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_ctime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_mtime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_atimensec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_ctimensec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_mtimensec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">fs64_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_blocks</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_gen</span><span class="p">);</span>
	<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	ufsi-&gt;i_shadow = fs32_to_cpu(sb, ufs_inode-&gt;ui_u3.ui_sun.ui_shadow);</span>
<span class="cm">	ufsi-&gt;i_oeftflag = fs32_to_cpu(sb, ufs_inode-&gt;ui_u3.ui_sun.ui_oeftflag);</span>
<span class="cm">	*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">u2_i_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_symlink</span><span class="p">,</span> <span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_symlink</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ufs2_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ufs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_inode_info</span> <span class="o">*</span><span class="n">ufsi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_sb_private_info</span> <span class="o">*</span><span class="n">uspi</span> <span class="o">=</span> <span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_uspi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;ENTER, ino %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">UFS_ROOTINO</span> <span class="o">||</span> <span class="n">ino</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_ncg</span> <span class="o">*</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_ipg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ufs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ufs_read_inode&quot;</span><span class="p">,</span> <span class="s">&quot;bad inode number (%lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">ufsi</span> <span class="o">=</span> <span class="n">UFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_sbbase</span> <span class="o">+</span> <span class="n">ufs_inotofsba</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ufs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ufs_read_inode&quot;</span><span class="p">,</span> <span class="s">&quot;unable to read inode %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">UFS_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">UFS_TYPE_UFS2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ufs2_inode</span> <span class="o">*</span><span class="n">ufs2_inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ufs2_inode</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ufs2_read_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				      <span class="n">ufs2_inode</span> <span class="o">+</span> <span class="n">ufs_inotofsbo</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ufs_inode</span> <span class="o">*</span><span class="n">ufs_inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ufs_inode</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ufs1_read_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				      <span class="n">ufs_inode</span> <span class="o">+</span> <span class="n">ufs_inotofsbo</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_lastfrag</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_fshift</span><span class="p">;</span>
	<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_dir_start_lookup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_osync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ufs_set_inode_ops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

<span class="nl">bad_inode:</span>
	<span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufs1_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufs_inode</span> <span class="o">*</span><span class="n">ufs_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">ufs_inode_info</span> <span class="o">*</span><span class="n">ufsi</span> <span class="o">=</span> <span class="n">UFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_mode</span> <span class="o">=</span> <span class="n">cpu_to_fs16</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_nlink</span> <span class="o">=</span> <span class="n">cpu_to_fs16</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>

	<span class="n">ufs_set_inode_uid</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">ufs_set_inode_gid</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
		
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">cpu_to_fs64</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_atime</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_ctime</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_mtime</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_blocks</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_flags</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_gen</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">UFS_UID_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">UFS_UID_EFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u3</span><span class="p">.</span><span class="n">ui_sun</span><span class="p">.</span><span class="n">ui_shadow</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_shadow</span><span class="p">);</span>
		<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u3</span><span class="p">.</span><span class="n">ui_sun</span><span class="p">.</span><span class="n">ui_oeftflag</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_oeftflag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* ufs_inode-&gt;ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode-&gt;i_rdev); */</span>
		<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">.</span><span class="n">ui_db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">,</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_data</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">,</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_symlink</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">memset</span> <span class="p">(</span><span class="n">ufs_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufs2_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufs2_inode</span> <span class="o">*</span><span class="n">ufs_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">ufs_inode_info</span> <span class="o">*</span><span class="n">ufsi</span> <span class="o">=</span> <span class="n">UFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_mode</span> <span class="o">=</span> <span class="n">cpu_to_fs16</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_nlink</span> <span class="o">=</span> <span class="n">cpu_to_fs16</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>

	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_uid</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_gid</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>

	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">cpu_to_fs64</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_atime</span> <span class="o">=</span> <span class="n">cpu_to_fs64</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_atimensec</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_ctime</span> <span class="o">=</span> <span class="n">cpu_to_fs64</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_ctimensec</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_mtime</span> <span class="o">=</span> <span class="n">cpu_to_fs64</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_mtimensec</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_blocks</span> <span class="o">=</span> <span class="n">cpu_to_fs64</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_flags</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
	<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_gen</span> <span class="o">=</span> <span class="n">cpu_to_fs32</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* ufs_inode-&gt;ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode-&gt;i_rdev); */</span>
		<span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">.</span><span class="n">ui_db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">u2_i_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">,</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">u2_i_data</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_addr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">,</span> <span class="n">ufsi</span><span class="o">-&gt;</span><span class="n">i_u1</span><span class="p">.</span><span class="n">i_symlink</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">ufs_inode</span><span class="o">-&gt;</span><span class="n">ui_u2</span><span class="p">.</span><span class="n">ui_symlink</span><span class="p">));</span>
 	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">memset</span> <span class="p">(</span><span class="n">ufs_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs2_inode</span><span class="p">));</span>
	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufs_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_sb_private_info</span> <span class="o">*</span><span class="n">uspi</span> <span class="o">=</span> <span class="n">UFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_uspi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>

	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;ENTER, ino %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&lt;</span> <span class="n">UFS_ROOTINO</span> <span class="o">||</span>
	    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_ncg</span> <span class="o">*</span> <span class="n">uspi</span><span class="o">-&gt;</span><span class="n">s_ipg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ufs_warning</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ufs_read_inode&quot;</span><span class="p">,</span> <span class="s">&quot;bad inode number (%lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ufs_inotofsba</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ufs_warning</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ufs_read_inode&quot;</span><span class="p">,</span> <span class="s">&quot;unable to read inode %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uspi</span><span class="o">-&gt;</span><span class="n">fs_magic</span> <span class="o">==</span> <span class="n">UFS2_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ufs2_inode</span> <span class="o">*</span><span class="n">ufs2_inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ufs2_inode</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

		<span class="n">ufs2_update_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				  <span class="n">ufs2_inode</span> <span class="o">+</span> <span class="n">ufs_inotofsbo</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ufs_inode</span> <span class="o">*</span><span class="n">ufs_inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ufs_inode</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

		<span class="n">ufs1_update_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ufs_inode</span> <span class="o">+</span> <span class="n">ufs_inotofsbo</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">));</span>
	<span class="p">}</span>
		
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_sync</span><span class="p">)</span>
		<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	
	<span class="n">UFSD</span><span class="p">(</span><span class="s">&quot;EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ufs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">lock_ufs</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ufs_update_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">);</span>
	<span class="n">unlock_ufs</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ufs_sync_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ufs_update_inode</span> <span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ufs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">want_delete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">want_delete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">want_delete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">old_i_size</span><span class="p">;</span>
		<span class="cm">/*UFS_I(inode)-&gt;i_dtime = CURRENT_TIME;*/</span>
		<span class="n">lock_ufs</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ufs_update_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="n">old_i_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">&amp;&amp;</span> <span class="n">ufs_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">old_i_size</span><span class="p">))</span>
			<span class="n">ufs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;ufs_truncate failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">unlock_ufs</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">invalidate_inode_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">want_delete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_ufs</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">ufs_free_inode</span> <span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">unlock_ufs</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
