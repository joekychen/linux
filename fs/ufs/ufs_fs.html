<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ufs › ufs_fs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ufs_fs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/include/linux/ufs_fs.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996</span>
<span class="cm"> * Adrian Rodriguez (adrian@franklins-tower.rutgers.edu)</span>
<span class="cm"> * Laboratory for Computer Science Research Computing Facility</span>
<span class="cm"> * Rutgers, The State University of New Jersey</span>
<span class="cm"> *</span>
<span class="cm"> * Clean swab support by Fare &lt;fare@tunes.org&gt;</span>
<span class="cm"> * just hope no one is using NNUUXXI on __?64 structure elements</span>
<span class="cm"> * 64-bit clean thanks to Maciej W. Rozycki &lt;macro@ds2.pg.gda.pl&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 4.4BSD (FreeBSD) support added on February 1st 1998 by</span>
<span class="cm"> * Niels Kristian Bech Jensen &lt;nkbj@image.dk&gt; partially based</span>
<span class="cm"> * on code by Martin von Loewis &lt;martin@mira.isdn.cs.tu-berlin.de&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * NeXTstep support added on February 5th 1998 by</span>
<span class="cm"> * Niels Kristian Bech Jensen &lt;nkbj@image.dk&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Write support by Daniel Pirkl &lt;daniel.pirkl@email.cz&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * HP/UX hfs filesystem support added by</span>
<span class="cm"> * Martin K. Petersen &lt;mkp@mkp.net&gt;, August 1999</span>
<span class="cm"> *</span>
<span class="cm"> * UFS2 (of FreeBSD 5.x) support added by</span>
<span class="cm"> * Niraj Kumar &lt;niraj17@iitbombay.org&gt;  , Jan 2004</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_UFS_FS_H</span>
<span class="cp">#define __LINUX_UFS_FS_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>

<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="k">typedef</span> <span class="n">__u64</span> <span class="n">__bitwise</span> <span class="n">__fs64</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u32</span> <span class="n">__bitwise</span> <span class="n">__fs32</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">__u16</span> <span class="n">__bitwise</span> <span class="n">__fs16</span><span class="p">;</span>

<span class="cp">#define UFS_BBLOCK 0</span>
<span class="cp">#define UFS_BBSIZE 8192</span>
<span class="cp">#define UFS_SBLOCK 8192</span>
<span class="cp">#define UFS_SBSIZE 8192</span>

<span class="cp">#define UFS_SECTOR_SIZE 512</span>
<span class="cp">#define UFS_SECTOR_BITS 9</span>
<span class="cp">#define UFS_MAGIC  0x00011954</span>
<span class="cp">#define UFS_MAGIC_BW 0x0f242697</span>
<span class="cp">#define UFS2_MAGIC 0x19540119</span>
<span class="cp">#define UFS_CIGAM  0x54190100 </span><span class="cm">/* byteswapped MAGIC */</span><span class="cp"></span>

<span class="cm">/* Copied from FreeBSD */</span>
<span class="cm">/*</span>
<span class="cm"> * Each disk drive contains some number of filesystems.</span>
<span class="cm"> * A filesystem consists of a number of cylinder groups.</span>
<span class="cm"> * Each cylinder group has inodes and data.</span>
<span class="cm"> *</span>
<span class="cm"> * A filesystem is described by its super-block, which in turn</span>
<span class="cm"> * describes the cylinder groups.  The super-block is critical</span>
<span class="cm"> * data and is replicated in each cylinder group to protect against</span>
<span class="cm"> * catastrophic loss.  This is done at `newfs&#39; time and the critical</span>
<span class="cm"> * super-block data does not change, so the copies need not be</span>
<span class="cm"> * referenced further unless disaster strikes.</span>
<span class="cm"> *</span>
<span class="cm"> * For filesystem fs, the offsets of the various blocks of interest</span>
<span class="cm"> * are given in the super block as:</span>
<span class="cm"> *      [fs-&gt;fs_sblkno]         Super-block</span>
<span class="cm"> *      [fs-&gt;fs_cblkno]         Cylinder group block</span>
<span class="cm"> *      [fs-&gt;fs_iblkno]         Inode blocks</span>
<span class="cm"> *      [fs-&gt;fs_dblkno]         Data blocks</span>
<span class="cm"> * The beginning of cylinder group cg in fs, is given by</span>
<span class="cm"> * the ``cgbase(fs, cg)&#39;&#39; macro.</span>
<span class="cm"> *</span>
<span class="cm"> * Depending on the architecture and the media, the superblock may</span>
<span class="cm"> * reside in any one of four places. For tiny media where every block</span>
<span class="cm"> * counts, it is placed at the very front of the partition. Historically,</span>
<span class="cm"> * UFS1 placed it 8K from the front to leave room for the disk label and</span>
<span class="cm"> * a small bootstrap. For UFS2 it got moved to 64K from the front to leave</span>
<span class="cm"> * room for the disk label and a bigger bootstrap, and for really piggy</span>
<span class="cm"> * systems we check at 256K from the front if the first three fail. In</span>
<span class="cm"> * all cases the size of the superblock will be SBLOCKSIZE. All values are</span>
<span class="cm"> * given in byte-offset form, so they do not imply a sector size. The</span>
<span class="cm"> * SBLOCKSEARCH specifies the order in which the locations should be searched.</span>
<span class="cm"> */</span>
<span class="cp">#define SBLOCK_FLOPPY        0</span>
<span class="cp">#define SBLOCK_UFS1       8192</span>
<span class="cp">#define SBLOCK_UFS2      65536</span>
<span class="cp">#define SBLOCK_PIGGY    262144</span>
<span class="cp">#define SBLOCKSIZE        8192</span>
<span class="cp">#define SBLOCKSEARCH \</span>
<span class="cp">        { SBLOCK_UFS2, SBLOCK_UFS1, SBLOCK_FLOPPY, SBLOCK_PIGGY, -1 }</span>


<span class="cm">/* HP specific MAGIC values */</span>

<span class="cp">#define UFS_MAGIC_LFN   0x00095014 </span><span class="cm">/* fs supports filenames &gt; 14 chars */</span><span class="cp"></span>
<span class="cp">#define UFS_CIGAM_LFN   0x14500900 </span><span class="cm">/* srahc 41 &lt; semanelif stroppus sf */</span><span class="cp"></span>

<span class="cp">#define UFS_MAGIC_SEC   0x00612195 </span><span class="cm">/* B1 security fs */</span><span class="cp"></span>
<span class="cp">#define UFS_CIGAM_SEC   0x95216100</span>

<span class="cp">#define UFS_MAGIC_FEA   0x00195612 </span><span class="cm">/* fs_featurebits supported */</span><span class="cp"></span>
<span class="cp">#define UFS_CIGAM_FEA   0x12561900</span>

<span class="cp">#define UFS_MAGIC_4GB   0x05231994 </span><span class="cm">/* fs &gt; 4 GB &amp;&amp; fs_featurebits */</span><span class="cp"></span>
<span class="cp">#define UFS_CIGAM_4GB   0x94192305</span>

<span class="cm">/* Seems somebody at HP goofed here. B1 and lfs are both 0x2 !?! */</span>
<span class="cp">#define UFS_FSF_LFN     0x00000001 </span><span class="cm">/* long file names */</span><span class="cp"></span>
<span class="cp">#define UFS_FSF_B1      0x00000002 </span><span class="cm">/* B1 security */</span><span class="cp"></span>
<span class="cp">#define UFS_FSF_LFS     0x00000002 </span><span class="cm">/* large files */</span><span class="cp"></span>
<span class="cp">#define UFS_FSF_LUID    0x00000004 </span><span class="cm">/* large UIDs */</span><span class="cp"></span>

<span class="cm">/* End of HP stuff */</span>


<span class="cp">#define UFS_BSIZE	8192</span>
<span class="cp">#define UFS_MINBSIZE	4096</span>
<span class="cp">#define UFS_FSIZE	1024</span>
<span class="cp">#define UFS_MAXFRAG	(UFS_BSIZE / UFS_FSIZE)</span>

<span class="cp">#define UFS_NDADDR 12</span>
<span class="cp">#define UFS_NINDIR 3</span>

<span class="cp">#define UFS_IND_BLOCK	(UFS_NDADDR + 0)</span>
<span class="cp">#define UFS_DIND_BLOCK	(UFS_NDADDR + 1)</span>
<span class="cp">#define UFS_TIND_BLOCK	(UFS_NDADDR + 2)</span>

<span class="cp">#define UFS_NDIR_FRAGMENT (UFS_NDADDR &lt;&lt; uspi-&gt;s_fpbshift)</span>
<span class="cp">#define UFS_IND_FRAGMENT (UFS_IND_BLOCK &lt;&lt; uspi-&gt;s_fpbshift)</span>
<span class="cp">#define UFS_DIND_FRAGMENT (UFS_DIND_BLOCK &lt;&lt; uspi-&gt;s_fpbshift)</span>
<span class="cp">#define UFS_TIND_FRAGMENT (UFS_TIND_BLOCK &lt;&lt; uspi-&gt;s_fpbshift)</span>

<span class="cp">#define UFS_ROOTINO 2</span>
<span class="cp">#define UFS_FIRST_INO (UFS_ROOTINO + 1)</span>

<span class="cp">#define UFS_USEEFT  ((__u16)65535)</span>

<span class="cm">/* fs_clean values */</span>
<span class="cp">#define UFS_FSOK      0x7c269d38</span>
<span class="cp">#define UFS_FSACTIVE  ((__s8)0x00)</span>
<span class="cp">#define UFS_FSCLEAN   ((__s8)0x01)</span>
<span class="cp">#define UFS_FSSTABLE  ((__s8)0x02)</span>
<span class="cp">#define UFS_FSOSF1    ((__s8)0x03)	</span><span class="cm">/* is this correct for DEC OSF/1? */</span><span class="cp"></span>
<span class="cp">#define UFS_FSBAD     ((__s8)0xff)</span>

<span class="cm">/* Solaris-specific fs_clean values */</span>
<span class="cp">#define UFS_FSSUSPEND ((__s8)0xfe)	</span><span class="cm">/* temporarily suspended */</span><span class="cp"></span>
<span class="cp">#define UFS_FSLOG     ((__s8)0xfd)	</span><span class="cm">/* logging fs */</span><span class="cp"></span>
<span class="cp">#define UFS_FSFIX     ((__s8)0xfc)	</span><span class="cm">/* being repaired while mounted */</span><span class="cp"></span>

<span class="cm">/* From here to next blank line, s_flags for ufs_sb_info */</span>
<span class="cm">/* directory entry encoding */</span>
<span class="cp">#define UFS_DE_MASK		0x00000010	</span><span class="cm">/* mask for the following */</span><span class="cp"></span>
<span class="cp">#define UFS_DE_OLD		0x00000000</span>
<span class="cp">#define UFS_DE_44BSD		0x00000010</span>
<span class="cm">/* uid encoding */</span>
<span class="cp">#define UFS_UID_MASK		0x00000060	</span><span class="cm">/* mask for the following */</span><span class="cp"></span>
<span class="cp">#define UFS_UID_OLD		0x00000000</span>
<span class="cp">#define UFS_UID_44BSD		0x00000020</span>
<span class="cp">#define UFS_UID_EFT		0x00000040</span>
<span class="cm">/* superblock state encoding */</span>
<span class="cp">#define UFS_ST_MASK		0x00000700	</span><span class="cm">/* mask for the following */</span><span class="cp"></span>
<span class="cp">#define UFS_ST_OLD		0x00000000</span>
<span class="cp">#define UFS_ST_44BSD		0x00000100</span>
<span class="cp">#define UFS_ST_SUN		0x00000200 </span><span class="cm">/* Solaris */</span><span class="cp"></span>
<span class="cp">#define UFS_ST_SUNOS		0x00000300</span>
<span class="cp">#define UFS_ST_SUNx86		0x00000400 </span><span class="cm">/* Solaris x86 */</span><span class="cp"></span>
<span class="cm">/*cylinder group encoding */</span>
<span class="cp">#define UFS_CG_MASK		0x00003000	</span><span class="cm">/* mask for the following */</span><span class="cp"></span>
<span class="cp">#define UFS_CG_OLD		0x00000000</span>
<span class="cp">#define UFS_CG_44BSD		0x00002000</span>
<span class="cp">#define UFS_CG_SUN		0x00001000</span>
<span class="cm">/* filesystem type encoding */</span>
<span class="cp">#define UFS_TYPE_MASK		0x00010000	</span><span class="cm">/* mask for the following */</span><span class="cp"></span>
<span class="cp">#define UFS_TYPE_UFS1		0x00000000</span>
<span class="cp">#define UFS_TYPE_UFS2		0x00010000</span>


<span class="cm">/* fs_inodefmt options */</span>
<span class="cp">#define UFS_42INODEFMT	-1</span>
<span class="cp">#define UFS_44INODEFMT	2</span>

<span class="cm">/*</span>
<span class="cm"> * MINFREE gives the minimum acceptable percentage of file system</span>
<span class="cm"> * blocks which may be free. If the freelist drops below this level</span>
<span class="cm"> * only the superuser may continue to allocate blocks. This may</span>
<span class="cm"> * be set to 0 if no reserve of free blocks is deemed necessary,</span>
<span class="cm"> * however throughput drops by fifty percent if the file system</span>
<span class="cm"> * is run at between 95% and 100% full; thus the minimum default</span>
<span class="cm"> * value of fs_minfree is 5%. However, to get good clustering</span>
<span class="cm"> * performance, 10% is a better choice. hence we use 10% as our</span>
<span class="cm"> * default value. With 10% free space, fragmentation is not a</span>
<span class="cm"> * problem, so we choose to optimize for time.</span>
<span class="cm"> */</span>
<span class="cp">#define UFS_MINFREE         5</span>
<span class="cp">#define UFS_DEFAULTOPT      UFS_OPTTIME</span>

<span class="cm">/*</span>
<span class="cm"> * Turn file system block numbers into disk block addresses.</span>
<span class="cm"> * This maps file system blocks to device size blocks.</span>
<span class="cm"> */</span>
<span class="cp">#define ufs_fsbtodb(uspi, b)	((b) &lt;&lt; (uspi)-&gt;s_fsbtodb)</span>
<span class="cp">#define	ufs_dbtofsb(uspi, b)	((b) &gt;&gt; (uspi)-&gt;s_fsbtodb)</span>

<span class="cm">/*</span>
<span class="cm"> * Cylinder group macros to locate things in cylinder groups.</span>
<span class="cm"> * They calc file system addresses of cylinder group data structures.</span>
<span class="cm"> */</span>
<span class="cp">#define	ufs_cgbase(c)	(uspi-&gt;s_fpg * (c))</span>
<span class="cp">#define ufs_cgstart(c)	((uspi)-&gt;fs_magic == UFS2_MAGIC ?  ufs_cgbase(c) : \</span>
<span class="cp">	(ufs_cgbase(c)  + uspi-&gt;s_cgoffset * ((c) &amp; ~uspi-&gt;s_cgmask)))</span>
<span class="cp">#define	ufs_cgsblock(c)	(ufs_cgstart(c) + uspi-&gt;s_sblkno)	</span><span class="cm">/* super blk */</span><span class="cp"></span>
<span class="cp">#define	ufs_cgcmin(c)	(ufs_cgstart(c) + uspi-&gt;s_cblkno)	</span><span class="cm">/* cg block */</span><span class="cp"></span>
<span class="cp">#define	ufs_cgimin(c)	(ufs_cgstart(c) + uspi-&gt;s_iblkno)	</span><span class="cm">/* inode blk */</span><span class="cp"></span>
<span class="cp">#define	ufs_cgdmin(c)	(ufs_cgstart(c) + uspi-&gt;s_dblkno)	</span><span class="cm">/* 1st data */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Macros for handling inode numbers:</span>
<span class="cm"> *     inode number to file system block offset.</span>
<span class="cm"> *     inode number to cylinder group number.</span>
<span class="cm"> *     inode number to file system block address.</span>
<span class="cm"> */</span>
<span class="cp">#define	ufs_inotocg(x)		((x) / uspi-&gt;s_ipg)</span>
<span class="cp">#define	ufs_inotocgoff(x)	((x) % uspi-&gt;s_ipg)</span>
<span class="cp">#define	ufs_inotofsba(x)	(((u64)ufs_cgimin(ufs_inotocg(x))) + ufs_inotocgoff(x) / uspi-&gt;s_inopf)</span>
<span class="cp">#define	ufs_inotofsbo(x)	((x) % uspi-&gt;s_inopf)</span>

<span class="cm">/*</span>
<span class="cm"> * Compute the cylinder and rotational position of a cyl block addr.</span>
<span class="cm"> */</span>
<span class="cp">#define ufs_cbtocylno(bno) \</span>
<span class="cp">	((bno) * uspi-&gt;s_nspf / uspi-&gt;s_spc)</span>
<span class="cp">#define ufs_cbtorpos(bno)				      \</span>
<span class="cp">	((UFS_SB(sb)-&gt;s_flags &amp; UFS_CG_SUN) ?		      \</span>
<span class="cp">	 (((((bno) * uspi-&gt;s_nspf % uspi-&gt;s_spc) %	      \</span>
<span class="cp">	    uspi-&gt;s_nsect) *				      \</span>
<span class="cp">	   uspi-&gt;s_nrpos) / uspi-&gt;s_nsect)		      \</span>
<span class="cp">	 :						      \</span>
<span class="cp">	((((bno) * uspi-&gt;s_nspf % uspi-&gt;s_spc / uspi-&gt;s_nsect \</span>
<span class="cp">	* uspi-&gt;s_trackskew + (bno) * uspi-&gt;s_nspf % uspi-&gt;s_spc \</span>
<span class="cp">	% uspi-&gt;s_nsect * uspi-&gt;s_interleave) % uspi-&gt;s_nsect \</span>
<span class="cp">	  * uspi-&gt;s_nrpos) / uspi-&gt;s_npsect))</span>

<span class="cm">/*</span>
<span class="cm"> * The following macros optimize certain frequently calculated</span>
<span class="cm"> * quantities by using shifts and masks in place of divisions</span>
<span class="cm"> * modulos and multiplications.</span>
<span class="cm"> */</span>
<span class="cp">#define ufs_blkoff(loc)		((loc) &amp; uspi-&gt;s_qbmask)</span>
<span class="cp">#define ufs_fragoff(loc)	((loc) &amp; uspi-&gt;s_qfmask)</span>
<span class="cp">#define ufs_lblktosize(blk)	((blk) &lt;&lt; uspi-&gt;s_bshift)</span>
<span class="cp">#define ufs_lblkno(loc)		((loc) &gt;&gt; uspi-&gt;s_bshift)</span>
<span class="cp">#define ufs_numfrags(loc)	((loc) &gt;&gt; uspi-&gt;s_fshift)</span>
<span class="cp">#define ufs_blkroundup(size)	(((size) + uspi-&gt;s_qbmask) &amp; uspi-&gt;s_bmask)</span>
<span class="cp">#define ufs_fragroundup(size)	(((size) + uspi-&gt;s_qfmask) &amp; uspi-&gt;s_fmask)</span>
<span class="cp">#define ufs_fragstoblks(frags)	((frags) &gt;&gt; uspi-&gt;s_fpbshift)</span>
<span class="cp">#define ufs_blkstofrags(blks)	((blks) &lt;&lt; uspi-&gt;s_fpbshift)</span>
<span class="cp">#define ufs_fragnum(fsb)	((fsb) &amp; uspi-&gt;s_fpbmask)</span>
<span class="cp">#define ufs_blknum(fsb)		((fsb) &amp; ~uspi-&gt;s_fpbmask)</span>

<span class="cp">#define	UFS_MAXNAMLEN 255</span>
<span class="cp">#define UFS_MAXMNTLEN 512</span>
<span class="cp">#define UFS2_MAXMNTLEN 468</span>
<span class="cp">#define UFS2_MAXVOLLEN 32</span>
<span class="cp">#define UFS_MAXCSBUFS 31</span>
<span class="cp">#define UFS_LINK_MAX 32000</span>
<span class="cm">/*</span>
<span class="cm">#define	UFS2_NOCSPTRS	((128 / sizeof(void *)) - 4)</span>
<span class="cm">*/</span>
<span class="cp">#define	UFS2_NOCSPTRS	28</span>

<span class="cm">/*</span>
<span class="cm"> * UFS_DIR_PAD defines the directory entries boundaries</span>
<span class="cm"> * (must be a multiple of 4)</span>
<span class="cm"> */</span>
<span class="cp">#define UFS_DIR_PAD			4</span>
<span class="cp">#define UFS_DIR_ROUND			(UFS_DIR_PAD - 1)</span>
<span class="cp">#define UFS_DIR_REC_LEN(name_len)	(((name_len) + 1 + 8 + UFS_DIR_ROUND) &amp; ~UFS_DIR_ROUND)</span>

<span class="k">struct</span> <span class="n">ufs_timeval</span> <span class="p">{</span>
	<span class="n">__fs32</span>	<span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">tv_usec</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ufs_dir_entry</span> <span class="p">{</span>
	<span class="n">__fs32</span>  <span class="n">d_ino</span><span class="p">;</span>			<span class="cm">/* inode number of this entry */</span>
	<span class="n">__fs16</span>  <span class="n">d_reclen</span><span class="p">;</span>		<span class="cm">/* length of this entry */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__fs16</span>	<span class="n">d_namlen</span><span class="p">;</span>		<span class="cm">/* actual length of d_name */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span>	<span class="n">d_type</span><span class="p">;</span>		<span class="cm">/* file type */</span>
			<span class="n">__u8</span>	<span class="n">d_namlen</span><span class="p">;</span>	<span class="cm">/* length of string in d_name */</span>
		<span class="p">}</span> <span class="n">d_44</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">d_u</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">d_name</span><span class="p">[</span><span class="n">UFS_MAXNAMLEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/* file name */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ufs_csum</span> <span class="p">{</span>
	<span class="n">__fs32</span>	<span class="n">cs_ndir</span><span class="p">;</span>	<span class="cm">/* number of directories */</span>
	<span class="n">__fs32</span>	<span class="n">cs_nbfree</span><span class="p">;</span>	<span class="cm">/* number of free blocks */</span>
	<span class="n">__fs32</span>	<span class="n">cs_nifree</span><span class="p">;</span>	<span class="cm">/* number of free inodes */</span>
	<span class="n">__fs32</span>	<span class="n">cs_nffree</span><span class="p">;</span>	<span class="cm">/* number of free frags */</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ufs2_csum_total</span> <span class="p">{</span>
	<span class="n">__fs64</span>	<span class="n">cs_ndir</span><span class="p">;</span>	<span class="cm">/* number of directories */</span>
	<span class="n">__fs64</span>	<span class="n">cs_nbfree</span><span class="p">;</span>	<span class="cm">/* number of free blocks */</span>
	<span class="n">__fs64</span>	<span class="n">cs_nifree</span><span class="p">;</span>	<span class="cm">/* number of free inodes */</span>
	<span class="n">__fs64</span>	<span class="n">cs_nffree</span><span class="p">;</span>	<span class="cm">/* number of free frags */</span>
	<span class="n">__fs64</span>   <span class="n">cs_numclusters</span><span class="p">;</span>	<span class="cm">/* number of free clusters */</span>
	<span class="n">__fs64</span>   <span class="n">cs_spare</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* future expansion */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ufs_csum_core</span> <span class="p">{</span>
	<span class="n">__u64</span>	<span class="n">cs_ndir</span><span class="p">;</span>	<span class="cm">/* number of directories */</span>
	<span class="n">__u64</span>	<span class="n">cs_nbfree</span><span class="p">;</span>	<span class="cm">/* number of free blocks */</span>
	<span class="n">__u64</span>	<span class="n">cs_nifree</span><span class="p">;</span>	<span class="cm">/* number of free inodes */</span>
	<span class="n">__u64</span>	<span class="n">cs_nffree</span><span class="p">;</span>	<span class="cm">/* number of free frags */</span>
	<span class="n">__u64</span>   <span class="n">cs_numclusters</span><span class="p">;</span>	<span class="cm">/* number of free clusters */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * File system flags</span>
<span class="cm"> */</span>
<span class="cp">#define UFS_UNCLEAN      0x01    </span><span class="cm">/* file system not clean at mount (unused) */</span><span class="cp"></span>
<span class="cp">#define UFS_DOSOFTDEP    0x02    </span><span class="cm">/* file system using soft dependencies */</span><span class="cp"></span>
<span class="cp">#define UFS_NEEDSFSCK    0x04    </span><span class="cm">/* needs sync fsck (FreeBSD compat, unused) */</span><span class="cp"></span>
<span class="cp">#define UFS_INDEXDIRS    0x08    </span><span class="cm">/* kernel supports indexed directories */</span><span class="cp"></span>
<span class="cp">#define UFS_ACLS         0x10    </span><span class="cm">/* file system has ACLs enabled */</span><span class="cp"></span>
<span class="cp">#define UFS_MULTILABEL   0x20    </span><span class="cm">/* file system is MAC multi-label */</span><span class="cp"></span>
<span class="cp">#define UFS_FLAGS_UPDATED 0x80   </span><span class="cm">/* flags have been moved to new location */</span><span class="cp"></span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * This is the actual superblock, as it is laid out on the disk.</span>
<span class="c"> * Do NOT use this structure, because of sizeof(ufs_super_block) &gt; 512 and</span>
<span class="c"> * it may occupy several blocks, use</span>
<span class="c"> * struct ufs_super_block_(first,second,third) instead.</span>
<span class="c"> */</span>
<span class="c">struct ufs_super_block {</span>
<span class="c">	union {</span>
<span class="c">		struct {</span>
<span class="c">			__fs32	fs_link;	/* UNUSED */</span>
<span class="c">		} fs_42;</span>
<span class="c">		struct {</span>
<span class="c">			__fs32	fs_state;	/* file system state flag */</span>
<span class="c">		} fs_sun;</span>
<span class="c">	} fs_u0;</span>
<span class="c">	__fs32	fs_rlink;	/* UNUSED */</span>
<span class="c">	__fs32	fs_sblkno;	/* addr of super-block in filesys */</span>
<span class="c">	__fs32	fs_cblkno;	/* offset of cyl-block in filesys */</span>
<span class="c">	__fs32	fs_iblkno;	/* offset of inode-blocks in filesys */</span>
<span class="c">	__fs32	fs_dblkno;	/* offset of first data after cg */</span>
<span class="c">	__fs32	fs_cgoffset;	/* cylinder group offset in cylinder */</span>
<span class="c">	__fs32	fs_cgmask;	/* used to calc mod fs_ntrak */</span>
<span class="c">	__fs32	fs_time;	/* last time written -- time_t */</span>
<span class="c">	__fs32	fs_size;	/* number of blocks in fs */</span>
<span class="c">	__fs32	fs_dsize;	/* number of data blocks in fs */</span>
<span class="c">	__fs32	fs_ncg;		/* number of cylinder groups */</span>
<span class="c">	__fs32	fs_bsize;	/* size of basic blocks in fs */</span>
<span class="c">	__fs32	fs_fsize;	/* size of frag blocks in fs */</span>
<span class="c">	__fs32	fs_frag;	/* number of frags in a block in fs */</span>
<span class="c">/* these are configuration parameters */</span>
<span class="c">	__fs32	fs_minfree;	/* minimum percentage of free blocks */</span>
<span class="c">	__fs32	fs_rotdelay;	/* num of ms for optimal next block */</span>
<span class="c">	__fs32	fs_rps;		/* disk revolutions per second */</span>
<span class="c">/* these fields can be computed from the others */</span>
<span class="c">	__fs32	fs_bmask;	/* ``blkoff&#39;&#39; calc of blk offsets */</span>
<span class="c">	__fs32	fs_fmask;	/* ``fragoff&#39;&#39; calc of frag offsets */</span>
<span class="c">	__fs32	fs_bshift;	/* ``lblkno&#39;&#39; calc of logical blkno */</span>
<span class="c">	__fs32	fs_fshift;	/* ``numfrags&#39;&#39; calc number of frags */</span>
<span class="c">/* these are configuration parameters */</span>
<span class="c">	__fs32	fs_maxcontig;	/* max number of contiguous blks */</span>
<span class="c">	__fs32	fs_maxbpg;	/* max number of blks per cyl group */</span>
<span class="c">/* these fields can be computed from the others */</span>
<span class="c">	__fs32	fs_fragshift;	/* block to frag shift */</span>
<span class="c">	__fs32	fs_fsbtodb;	/* fsbtodb and dbtofsb shift constant */</span>
<span class="c">	__fs32	fs_sbsize;	/* actual size of super block */</span>
<span class="c">	__fs32	fs_csmask;	/* csum block offset */</span>
<span class="c">	__fs32	fs_csshift;	/* csum block number */</span>
<span class="c">	__fs32	fs_nindir;	/* value of NINDIR */</span>
<span class="c">	__fs32	fs_inopb;	/* value of INOPB */</span>
<span class="c">	__fs32	fs_nspf;	/* value of NSPF */</span>
<span class="c">/* yet another configuration parameter */</span>
<span class="c">	__fs32	fs_optim;	/* optimization preference, see below */</span>
<span class="c">/* these fields are derived from the hardware */</span>
<span class="c">	union {</span>
<span class="c">		struct {</span>
<span class="c">			__fs32	fs_npsect;	/* # sectors/track including spares */</span>
<span class="c">		} fs_sun;</span>
<span class="c">		struct {</span>
<span class="c">			__fs32	fs_state;	/* file system state time stamp */</span>
<span class="c">		} fs_sunx86;</span>
<span class="c">	} fs_u1;</span>
<span class="c">	__fs32	fs_interleave;	/* hardware sector interleave */</span>
<span class="c">	__fs32	fs_trackskew;	/* sector 0 skew, per track */</span>
<span class="c">/* a unique id for this filesystem (currently unused and unmaintained) */</span>
<span class="c">/* In 4.3 Tahoe this space is used by fs_headswitch and fs_trkseek */</span>
<span class="c">/* Neither of those fields is used in the Tahoe code right now but */</span>
<span class="c">/* there could be problems if they are.                            */</span>
<span class="c">	__fs32	fs_id[2];	/* file system id */</span>
<span class="c">/* sizes determined by number of cylinder groups and their sizes */</span>
<span class="c">	__fs32	fs_csaddr;	/* blk addr of cyl grp summary area */</span>
<span class="c">	__fs32	fs_cssize;	/* size of cyl grp summary area */</span>
<span class="c">	__fs32	fs_cgsize;	/* cylinder group size */</span>
<span class="c">/* these fields are derived from the hardware */</span>
<span class="c">	__fs32	fs_ntrak;	/* tracks per cylinder */</span>
<span class="c">	__fs32	fs_nsect;	/* sectors per track */</span>
<span class="c">	__fs32	fs_spc;		/* sectors per cylinder */</span>
<span class="c">/* this comes from the disk driver partitioning */</span>
<span class="c">	__fs32	fs_ncyl;	/* cylinders in file system */</span>
<span class="c">/* these fields can be computed from the others */</span>
<span class="c">	__fs32	fs_cpg;		/* cylinders per group */</span>
<span class="c">	__fs32	fs_ipg;		/* inodes per cylinder group */</span>
<span class="c">	__fs32	fs_fpg;		/* blocks per group * fs_frag */</span>
<span class="c">/* this data must be re-computed after crashes */</span>
<span class="c">	struct ufs_csum fs_cstotal;	/* cylinder summary information */</span>
<span class="c">/* these fields are cleared at mount time */</span>
<span class="c">	__s8	fs_fmod;	/* super block modified flag */</span>
<span class="c">	__s8	fs_clean;	/* file system is clean flag */</span>
<span class="c">	__s8	fs_ronly;	/* mounted read-only flag */</span>
<span class="c">	__s8	fs_flags;</span>
<span class="c">	union {</span>
<span class="c">		struct {</span>
<span class="c">			__s8	fs_fsmnt[UFS_MAXMNTLEN];/* name mounted on */</span>
<span class="c">			__fs32	fs_cgrotor;	/* last cg searched */</span>
<span class="c">			__fs32	fs_csp[UFS_MAXCSBUFS];/*list of fs_cs info buffers */</span>
<span class="c">			__fs32	fs_maxcluster;</span>
<span class="c">			__fs32	fs_cpc;		/* cyl per cycle in postbl */</span>
<span class="c">			__fs16	fs_opostbl[16][8]; /* old rotation block list head */</span>
<span class="c">		} fs_u1;</span>
<span class="c">		struct {</span>
<span class="c">			__s8  fs_fsmnt[UFS2_MAXMNTLEN];	/* name mounted on */</span>
<span class="c">			__u8   fs_volname[UFS2_MAXVOLLEN]; /* volume name */</span>
<span class="c">			__fs64  fs_swuid;		/* system-wide uid */</span>
<span class="c">			__fs32  fs_pad;	/* due to alignment of fs_swuid */</span>
<span class="c">			__fs32   fs_cgrotor;     /* last cg searched */</span>
<span class="c">			__fs32   fs_ocsp[UFS2_NOCSPTRS]; /*list of fs_cs info buffers */</span>
<span class="c">			__fs32   fs_contigdirs;/*# of contiguously allocated dirs */</span>
<span class="c">			__fs32   fs_csp;	/* cg summary info buffer for fs_cs */</span>
<span class="c">			__fs32   fs_maxcluster;</span>
<span class="c">			__fs32   fs_active;/* used by snapshots to track fs */</span>
<span class="c">			__fs32   fs_old_cpc;	/* cyl per cycle in postbl */</span>
<span class="c">			__fs32   fs_maxbsize;/*maximum blocking factor permitted */</span>
<span class="c">			__fs64   fs_sparecon64[17];/*old rotation block list head */</span>
<span class="c">			__fs64   fs_sblockloc; /* byte offset of standard superblock */</span>
<span class="c">			struct  ufs2_csum_total fs_cstotal;/*cylinder summary information*/</span>
<span class="c">			struct  ufs_timeval    fs_time;		/* last time written */</span>
<span class="c">			__fs64    fs_size;		/* number of blocks in fs */</span>
<span class="c">			__fs64    fs_dsize;	/* number of data blocks in fs */</span>
<span class="c">			__fs64   fs_csaddr;	/* blk addr of cyl grp summary area */</span>
<span class="c">			__fs64    fs_pendingblocks;/* blocks in process of being freed */</span>
<span class="c">			__fs32    fs_pendinginodes;/*inodes in process of being freed */</span>
<span class="c">		} fs_u2;</span>
<span class="c">	}  fs_u11;</span>
<span class="c">	union {</span>
<span class="c">		struct {</span>
<span class="c">			__fs32	fs_sparecon[53];/* reserved for future constants */</span>
<span class="c">			__fs32	fs_reclaim;</span>
<span class="c">			__fs32	fs_sparecon2[1];</span>
<span class="c">			__fs32	fs_state;	/* file system state time stamp */</span>
<span class="c">			__fs32	fs_qbmask[2];	/* ~usb_bmask */</span>
<span class="c">			__fs32	fs_qfmask[2];	/* ~usb_fmask */</span>
<span class="c">		} fs_sun;</span>
<span class="c">		struct {</span>
<span class="c">			__fs32	fs_sparecon[53];/* reserved for future constants */</span>
<span class="c">			__fs32	fs_reclaim;</span>
<span class="c">			__fs32	fs_sparecon2[1];</span>
<span class="c">			__fs32	fs_npsect;	/* # sectors/track including spares */</span>
<span class="c">			__fs32	fs_qbmask[2];	/* ~usb_bmask */</span>
<span class="c">			__fs32	fs_qfmask[2];	/* ~usb_fmask */</span>
<span class="c">		} fs_sunx86;</span>
<span class="c">		struct {</span>
<span class="c">			__fs32	fs_sparecon[50];/* reserved for future constants */</span>
<span class="c">			__fs32	fs_contigsumsize;/* size of cluster summary array */</span>
<span class="c">			__fs32	fs_maxsymlinklen;/* max length of an internal symlink */</span>
<span class="c">			__fs32	fs_inodefmt;	/* format of on-disk inodes */</span>
<span class="c">			__fs32	fs_maxfilesize[2];	/* max representable file size */</span>
<span class="c">			__fs32	fs_qbmask[2];	/* ~usb_bmask */</span>
<span class="c">			__fs32	fs_qfmask[2];	/* ~usb_fmask */</span>
<span class="c">			__fs32	fs_state;	/* file system state time stamp */</span>
<span class="c">		} fs_44;</span>
<span class="c">	} fs_u2;</span>
<span class="c">	__fs32	fs_postblformat;	/* format of positional layout tables */</span>
<span class="c">	__fs32	fs_nrpos;		/* number of rotational positions */</span>
<span class="c">	__fs32	fs_postbloff;		/* (__s16) rotation block list head */</span>
<span class="c">	__fs32	fs_rotbloff;		/* (__u8) blocks for each rotation */</span>
<span class="c">	__fs32	fs_magic;		/* magic number */</span>
<span class="c">	__u8	fs_space[1];		/* list of blocks for each rotation */</span>
<span class="c">};</span>
<span class="cp">#endif/*struct ufs_super_block*/</span>

<span class="cm">/*</span>
<span class="cm"> * Preference for optimization.</span>
<span class="cm"> */</span>
<span class="cp">#define UFS_OPTTIME	0	</span><span class="cm">/* minimize allocation time */</span><span class="cp"></span>
<span class="cp">#define UFS_OPTSPACE	1	</span><span class="cm">/* minimize disk fragmentation */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Rotational layout table format types</span>
<span class="cm"> */</span>
<span class="cp">#define UFS_42POSTBLFMT		-1	</span><span class="cm">/* 4.2BSD rotational table format */</span><span class="cp"></span>
<span class="cp">#define UFS_DYNAMICPOSTBLFMT	1	</span><span class="cm">/* dynamic rotational table format */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Convert cylinder group to base address of its global summary info.</span>
<span class="cm"> */</span>
<span class="cp">#define fs_cs(indx) s_csp[(indx)]</span>

<span class="cm">/*</span>
<span class="cm"> * Cylinder group block for a file system.</span>
<span class="cm"> *</span>
<span class="cm"> * Writable fields in the cylinder group are protected by the associated</span>
<span class="cm"> * super block lock fs-&gt;fs_lock.</span>
<span class="cm"> */</span>
<span class="cp">#define	CG_MAGIC	0x090255</span>
<span class="cp">#define ufs_cg_chkmagic(sb, ucg) \</span>
<span class="cp">	(fs32_to_cpu((sb), (ucg)-&gt;cg_magic) == CG_MAGIC)</span>
<span class="cm">/*</span>
<span class="cm"> * Macros for access to old cylinder group array structures</span>
<span class="cm"> */</span>
<span class="cp">#define ufs_ocg_blktot(sb, ucg)      fs32_to_cpu((sb), ((struct ufs_old_cylinder_group *)(ucg))-&gt;cg_btot)</span>
<span class="cp">#define ufs_ocg_blks(sb, ucg, cylno) fs32_to_cpu((sb), ((struct ufs_old_cylinder_group *)(ucg))-&gt;cg_b[cylno])</span>
<span class="cp">#define ufs_ocg_inosused(sb, ucg)    fs32_to_cpu((sb), ((struct ufs_old_cylinder_group *)(ucg))-&gt;cg_iused)</span>
<span class="cp">#define ufs_ocg_blksfree(sb, ucg)    fs32_to_cpu((sb), ((struct ufs_old_cylinder_group *)(ucg))-&gt;cg_free)</span>
<span class="cp">#define ufs_ocg_chkmagic(sb, ucg) \</span>
<span class="cp">	(fs32_to_cpu((sb), ((struct ufs_old_cylinder_group *)(ucg))-&gt;cg_magic) == CG_MAGIC)</span>

<span class="cm">/*</span>
<span class="cm"> * size of this structure is 172 B</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">ufs_cylinder_group</span> <span class="p">{</span>
	<span class="n">__fs32</span>	<span class="n">cg_link</span><span class="p">;</span>		<span class="cm">/* linked list of cyl groups */</span>
	<span class="n">__fs32</span>	<span class="n">cg_magic</span><span class="p">;</span>		<span class="cm">/* magic number */</span>
	<span class="n">__fs32</span>	<span class="n">cg_time</span><span class="p">;</span>		<span class="cm">/* time last written */</span>
	<span class="n">__fs32</span>	<span class="n">cg_cgx</span><span class="p">;</span>			<span class="cm">/* we are the cgx&#39;th cylinder group */</span>
	<span class="n">__fs16</span>	<span class="n">cg_ncyl</span><span class="p">;</span>		<span class="cm">/* number of cyl&#39;s this cg */</span>
	<span class="n">__fs16</span>	<span class="n">cg_niblk</span><span class="p">;</span>		<span class="cm">/* number of inode blocks this cg */</span>
	<span class="n">__fs32</span>	<span class="n">cg_ndblk</span><span class="p">;</span>		<span class="cm">/* number of data blocks this cg */</span>
	<span class="k">struct</span>	<span class="n">ufs_csum</span> <span class="n">cg_cs</span><span class="p">;</span>		<span class="cm">/* cylinder summary information */</span>
	<span class="n">__fs32</span>	<span class="n">cg_rotor</span><span class="p">;</span>		<span class="cm">/* position of last used block */</span>
	<span class="n">__fs32</span>	<span class="n">cg_frotor</span><span class="p">;</span>		<span class="cm">/* position of last used frag */</span>
	<span class="n">__fs32</span>	<span class="n">cg_irotor</span><span class="p">;</span>		<span class="cm">/* position of last used inode */</span>
	<span class="n">__fs32</span>	<span class="n">cg_frsum</span><span class="p">[</span><span class="n">UFS_MAXFRAG</span><span class="p">];</span>	<span class="cm">/* counts of available frags */</span>
	<span class="n">__fs32</span>	<span class="n">cg_btotoff</span><span class="p">;</span>		<span class="cm">/* (__u32) block totals per cylinder */</span>
	<span class="n">__fs32</span>	<span class="n">cg_boff</span><span class="p">;</span>		<span class="cm">/* (short) free block positions */</span>
	<span class="n">__fs32</span>	<span class="n">cg_iusedoff</span><span class="p">;</span>		<span class="cm">/* (char) used inode map */</span>
	<span class="n">__fs32</span>	<span class="n">cg_freeoff</span><span class="p">;</span>		<span class="cm">/* (u_char) free block map */</span>
	<span class="n">__fs32</span>	<span class="n">cg_nextfreeoff</span><span class="p">;</span>		<span class="cm">/* (u_char) next available space */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">cg_clustersumoff</span><span class="p">;</span>	<span class="cm">/* (u_int32) counts of avail clusters */</span>
			<span class="n">__fs32</span>	<span class="n">cg_clusteroff</span><span class="p">;</span>		<span class="cm">/* (u_int8) free cluster map */</span>
			<span class="n">__fs32</span>	<span class="n">cg_nclusterblks</span><span class="p">;</span>	<span class="cm">/* number of clusters this cg */</span>
			<span class="n">__fs32</span>	<span class="n">cg_sparecon</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>	<span class="cm">/* reserved for future use */</span>
		<span class="p">}</span> <span class="n">cg_44</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">cg_clustersumoff</span><span class="p">;</span><span class="cm">/* (u_int32) counts of avail clusters */</span>
			<span class="n">__fs32</span>	<span class="n">cg_clusteroff</span><span class="p">;</span>	<span class="cm">/* (u_int8) free cluster map */</span>
			<span class="n">__fs32</span>	<span class="n">cg_nclusterblks</span><span class="p">;</span><span class="cm">/* number of clusters this cg */</span>
			<span class="n">__fs32</span>   <span class="n">cg_niblk</span><span class="p">;</span> <span class="cm">/* number of inode blocks this cg */</span>
			<span class="n">__fs32</span>   <span class="n">cg_initediblk</span><span class="p">;</span>	<span class="cm">/* last initialized inode */</span>
			<span class="n">__fs32</span>   <span class="n">cg_sparecon32</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="cm">/* reserved for future use */</span>
			<span class="n">__fs64</span>   <span class="n">cg_time</span><span class="p">;</span>	<span class="cm">/* time last written */</span>
			<span class="n">__fs64</span>	<span class="n">cg_sparecon</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* reserved for future use */</span>
		<span class="p">}</span> <span class="n">cg_u2</span><span class="p">;</span>
		<span class="n">__fs32</span>	<span class="n">cg_sparecon</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* reserved for future use */</span>
	<span class="p">}</span> <span class="n">cg_u</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">cg_space</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>		<span class="cm">/* space for cylinder group maps */</span>
<span class="cm">/* actually longer */</span>
<span class="p">};</span>

<span class="cm">/* Historic Cylinder group info */</span>
<span class="k">struct</span> <span class="n">ufs_old_cylinder_group</span> <span class="p">{</span>
	<span class="n">__fs32</span>	<span class="n">cg_link</span><span class="p">;</span>		<span class="cm">/* linked list of cyl groups */</span>
	<span class="n">__fs32</span>	<span class="n">cg_rlink</span><span class="p">;</span>		<span class="cm">/* for incore cyl groups     */</span>
	<span class="n">__fs32</span>	<span class="n">cg_time</span><span class="p">;</span>		<span class="cm">/* time last written */</span>
	<span class="n">__fs32</span>	<span class="n">cg_cgx</span><span class="p">;</span>			<span class="cm">/* we are the cgx&#39;th cylinder group */</span>
	<span class="n">__fs16</span>	<span class="n">cg_ncyl</span><span class="p">;</span>		<span class="cm">/* number of cyl&#39;s this cg */</span>
	<span class="n">__fs16</span>	<span class="n">cg_niblk</span><span class="p">;</span>		<span class="cm">/* number of inode blocks this cg */</span>
	<span class="n">__fs32</span>	<span class="n">cg_ndblk</span><span class="p">;</span>		<span class="cm">/* number of data blocks this cg */</span>
	<span class="k">struct</span>	<span class="n">ufs_csum</span> <span class="n">cg_cs</span><span class="p">;</span>		<span class="cm">/* cylinder summary information */</span>
	<span class="n">__fs32</span>	<span class="n">cg_rotor</span><span class="p">;</span>		<span class="cm">/* position of last used block */</span>
	<span class="n">__fs32</span>	<span class="n">cg_frotor</span><span class="p">;</span>		<span class="cm">/* position of last used frag */</span>
	<span class="n">__fs32</span>	<span class="n">cg_irotor</span><span class="p">;</span>		<span class="cm">/* position of last used inode */</span>
	<span class="n">__fs32</span>	<span class="n">cg_frsum</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* counts of available frags */</span>
	<span class="n">__fs32</span>	<span class="n">cg_btot</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/* block totals per cylinder */</span>
	<span class="n">__fs16</span>	<span class="n">cg_b</span><span class="p">[</span><span class="mi">32</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* positions of free blocks */</span>
	<span class="n">__u8</span>	<span class="n">cg_iused</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>		<span class="cm">/* used inode map */</span>
	<span class="n">__fs32</span>	<span class="n">cg_magic</span><span class="p">;</span>		<span class="cm">/* magic number */</span>
	<span class="n">__u8</span>	<span class="n">cg_free</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>		<span class="cm">/* free block map */</span>
<span class="cm">/* actually longer */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * structure of an on-disk inode</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ufs_inode</span> <span class="p">{</span>
	<span class="n">__fs16</span>	<span class="n">ui_mode</span><span class="p">;</span>		<span class="cm">/*  0x0 */</span>
	<span class="n">__fs16</span>	<span class="n">ui_nlink</span><span class="p">;</span>		<span class="cm">/*  0x2 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs16</span>	<span class="n">ui_suid</span><span class="p">;</span>	<span class="cm">/*  0x4 */</span>
			<span class="n">__fs16</span>	<span class="n">ui_sgid</span><span class="p">;</span>	<span class="cm">/*  0x6 */</span>
		<span class="p">}</span> <span class="n">oldids</span><span class="p">;</span>
		<span class="n">__fs32</span>	<span class="n">ui_inumber</span><span class="p">;</span>		<span class="cm">/*  0x4 lsf: inode number */</span>
		<span class="n">__fs32</span>	<span class="n">ui_author</span><span class="p">;</span>		<span class="cm">/*  0x4 GNU HURD: author */</span>
	<span class="p">}</span> <span class="n">ui_u1</span><span class="p">;</span>
	<span class="n">__fs64</span>	<span class="n">ui_size</span><span class="p">;</span>		<span class="cm">/*  0x8 */</span>
	<span class="k">struct</span> <span class="n">ufs_timeval</span> <span class="n">ui_atime</span><span class="p">;</span>	<span class="cm">/* 0x10 access */</span>
	<span class="k">struct</span> <span class="n">ufs_timeval</span> <span class="n">ui_mtime</span><span class="p">;</span>	<span class="cm">/* 0x18 modification */</span>
	<span class="k">struct</span> <span class="n">ufs_timeval</span> <span class="n">ui_ctime</span><span class="p">;</span>	<span class="cm">/* 0x20 creation */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">ui_db</span><span class="p">[</span><span class="n">UFS_NDADDR</span><span class="p">];</span><span class="cm">/* 0x28 data blocks */</span>
			<span class="n">__fs32</span>	<span class="n">ui_ib</span><span class="p">[</span><span class="n">UFS_NINDIR</span><span class="p">];</span><span class="cm">/* 0x58 indirect blocks */</span>
		<span class="p">}</span> <span class="n">ui_addr</span><span class="p">;</span>
		<span class="n">__u8</span>	<span class="n">ui_symlink</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">UFS_NDADDR</span><span class="o">+</span><span class="n">UFS_NINDIR</span><span class="p">)];</span><span class="cm">/* 0x28 fast symlink */</span>
	<span class="p">}</span> <span class="n">ui_u2</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">ui_flags</span><span class="p">;</span>		<span class="cm">/* 0x64 immutable, append-only... */</span>
	<span class="n">__fs32</span>	<span class="n">ui_blocks</span><span class="p">;</span>		<span class="cm">/* 0x68 blocks in use */</span>
	<span class="n">__fs32</span>	<span class="n">ui_gen</span><span class="p">;</span>			<span class="cm">/* 0x6c like ext2 i_version, for NFS support */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">ui_shadow</span><span class="p">;</span>	<span class="cm">/* 0x70 shadow inode with security data */</span>
			<span class="n">__fs32</span>	<span class="n">ui_uid</span><span class="p">;</span>		<span class="cm">/* 0x74 long EFT version of uid */</span>
			<span class="n">__fs32</span>	<span class="n">ui_gid</span><span class="p">;</span>		<span class="cm">/* 0x78 long EFT version of gid */</span>
			<span class="n">__fs32</span>	<span class="n">ui_oeftflag</span><span class="p">;</span>	<span class="cm">/* 0x7c reserved */</span>
		<span class="p">}</span> <span class="n">ui_sun</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">ui_uid</span><span class="p">;</span>		<span class="cm">/* 0x70 File owner */</span>
			<span class="n">__fs32</span>	<span class="n">ui_gid</span><span class="p">;</span>		<span class="cm">/* 0x74 File group */</span>
			<span class="n">__fs32</span>	<span class="n">ui_spare</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* 0x78 reserved */</span>
		<span class="p">}</span> <span class="n">ui_44</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">ui_uid</span><span class="p">;</span>		<span class="cm">/* 0x70 */</span>
			<span class="n">__fs32</span>	<span class="n">ui_gid</span><span class="p">;</span>		<span class="cm">/* 0x74 */</span>
			<span class="n">__fs16</span>	<span class="n">ui_modeh</span><span class="p">;</span>	<span class="cm">/* 0x78 mode high bits */</span>
			<span class="n">__fs16</span>	<span class="n">ui_spare</span><span class="p">;</span>	<span class="cm">/* 0x7A unused */</span>
			<span class="n">__fs32</span>	<span class="n">ui_trans</span><span class="p">;</span>	<span class="cm">/* 0x7c filesystem translator */</span>
		<span class="p">}</span> <span class="n">ui_hurd</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ui_u3</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define UFS_NXADDR  2            </span><span class="cm">/* External addresses in inode. */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">ufs2_inode</span> <span class="p">{</span>
	<span class="n">__fs16</span>     <span class="n">ui_mode</span><span class="p">;</span>        <span class="cm">/*   0: IFMT, permissions; see below. */</span>
	<span class="n">__fs16</span>     <span class="n">ui_nlink</span><span class="p">;</span>       <span class="cm">/*   2: File link count. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_uid</span><span class="p">;</span>         <span class="cm">/*   4: File owner. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_gid</span><span class="p">;</span>         <span class="cm">/*   8: File group. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_blksize</span><span class="p">;</span>     <span class="cm">/*  12: Inode blocksize. */</span>
	<span class="n">__fs64</span>     <span class="n">ui_size</span><span class="p">;</span>        <span class="cm">/*  16: File byte count. */</span>
	<span class="n">__fs64</span>     <span class="n">ui_blocks</span><span class="p">;</span>      <span class="cm">/*  24: Bytes actually held. */</span>
	<span class="n">__fs64</span>   <span class="n">ui_atime</span><span class="p">;</span>       <span class="cm">/*  32: Last access time. */</span>
	<span class="n">__fs64</span>   <span class="n">ui_mtime</span><span class="p">;</span>       <span class="cm">/*  40: Last modified time. */</span>
	<span class="n">__fs64</span>   <span class="n">ui_ctime</span><span class="p">;</span>       <span class="cm">/*  48: Last inode change time. */</span>
	<span class="n">__fs64</span>   <span class="n">ui_birthtime</span><span class="p">;</span>   <span class="cm">/*  56: Inode creation time. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_mtimensec</span><span class="p">;</span>   <span class="cm">/*  64: Last modified time. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_atimensec</span><span class="p">;</span>   <span class="cm">/*  68: Last access time. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_ctimensec</span><span class="p">;</span>   <span class="cm">/*  72: Last inode change time. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_birthnsec</span><span class="p">;</span>   <span class="cm">/*  76: Inode creation time. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_gen</span><span class="p">;</span>         <span class="cm">/*  80: Generation number. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_kernflags</span><span class="p">;</span>   <span class="cm">/*  84: Kernel flags. */</span>
	<span class="n">__fs32</span>     <span class="n">ui_flags</span><span class="p">;</span>       <span class="cm">/*  88: Status flags (chflags). */</span>
	<span class="n">__fs32</span>     <span class="n">ui_extsize</span><span class="p">;</span>     <span class="cm">/*  92: External attributes block. */</span>
	<span class="n">__fs64</span>     <span class="n">ui_extb</span><span class="p">[</span><span class="n">UFS_NXADDR</span><span class="p">];</span><span class="cm">/*  96: External attributes block. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs64</span>     <span class="n">ui_db</span><span class="p">[</span><span class="n">UFS_NDADDR</span><span class="p">];</span> <span class="cm">/* 112: Direct disk blocks. */</span>
			<span class="n">__fs64</span>     <span class="n">ui_ib</span><span class="p">[</span><span class="n">UFS_NINDIR</span><span class="p">];</span><span class="cm">/* 208: Indirect disk blocks.*/</span>
		<span class="p">}</span> <span class="n">ui_addr</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">ui_symlink</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">UFS_NDADDR</span><span class="o">+</span><span class="n">UFS_NINDIR</span><span class="p">)];</span><span class="cm">/* 0x28 fast symlink */</span>
	<span class="p">}</span> <span class="n">ui_u2</span><span class="p">;</span>
	<span class="n">__fs64</span>     <span class="n">ui_spare</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>    <span class="cm">/* 232: Reserved; currently unused */</span>
<span class="p">};</span>


<span class="cm">/* FreeBSD has these in sys/stat.h */</span>
<span class="cm">/* ui_flags that can be set by a file owner */</span>
<span class="cp">#define UFS_UF_SETTABLE   0x0000ffff</span>
<span class="cp">#define UFS_UF_NODUMP     0x00000001  </span><span class="cm">/* do not dump */</span><span class="cp"></span>
<span class="cp">#define UFS_UF_IMMUTABLE  0x00000002  </span><span class="cm">/* immutable (can&#39;t &quot;change&quot;) */</span><span class="cp"></span>
<span class="cp">#define UFS_UF_APPEND     0x00000004  </span><span class="cm">/* append-only */</span><span class="cp"></span>
<span class="cp">#define UFS_UF_OPAQUE     0x00000008  </span><span class="cm">/* directory is opaque (unionfs) */</span><span class="cp"></span>
<span class="cp">#define UFS_UF_NOUNLINK   0x00000010  </span><span class="cm">/* can&#39;t be removed or renamed */</span><span class="cp"></span>
<span class="cm">/* ui_flags that only root can set */</span>
<span class="cp">#define UFS_SF_SETTABLE   0xffff0000</span>
<span class="cp">#define UFS_SF_ARCHIVED   0x00010000  </span><span class="cm">/* archived */</span><span class="cp"></span>
<span class="cp">#define UFS_SF_IMMUTABLE  0x00020000  </span><span class="cm">/* immutable (can&#39;t &quot;change&quot;) */</span><span class="cp"></span>
<span class="cp">#define UFS_SF_APPEND     0x00040000  </span><span class="cm">/* append-only */</span><span class="cp"></span>
<span class="cp">#define UFS_SF_NOUNLINK   0x00100000  </span><span class="cm">/* can&#39;t be removed or renamed */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This structure is used for reading disk structures larger</span>
<span class="cm"> * than the size of fragment.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ufs_buffer_head</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">fragment</span><span class="p">;</span>			<span class="cm">/* first fragment */</span>
	<span class="n">__u64</span> <span class="n">count</span><span class="p">;</span>				<span class="cm">/* number of fragments */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">[</span><span class="n">UFS_MAXFRAG</span><span class="p">];</span>	<span class="cm">/* buffers */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ufs_cg_private_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_buffer_head</span> <span class="n">c_ubh</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">c_cgx</span><span class="p">;</span>		<span class="cm">/* number of cylidner group */</span>
	<span class="n">__u16</span>	<span class="n">c_ncyl</span><span class="p">;</span>		<span class="cm">/* number of cyl&#39;s this cg */</span>
	<span class="n">__u16</span>	<span class="n">c_niblk</span><span class="p">;</span>	<span class="cm">/* number of inode blocks this cg */</span>
	<span class="n">__u32</span>	<span class="n">c_ndblk</span><span class="p">;</span>	<span class="cm">/* number of data blocks this cg */</span>
	<span class="n">__u32</span>	<span class="n">c_rotor</span><span class="p">;</span>	<span class="cm">/* position of last used block */</span>
	<span class="n">__u32</span>	<span class="n">c_frotor</span><span class="p">;</span>	<span class="cm">/* position of last used frag */</span>
	<span class="n">__u32</span>	<span class="n">c_irotor</span><span class="p">;</span>	<span class="cm">/* position of last used inode */</span>
	<span class="n">__u32</span>	<span class="n">c_btotoff</span><span class="p">;</span>	<span class="cm">/* (__u32) block totals per cylinder */</span>
	<span class="n">__u32</span>	<span class="n">c_boff</span><span class="p">;</span>		<span class="cm">/* (short) free block positions */</span>
	<span class="n">__u32</span>	<span class="n">c_iusedoff</span><span class="p">;</span>	<span class="cm">/* (char) used inode map */</span>
	<span class="n">__u32</span>	<span class="n">c_freeoff</span><span class="p">;</span>	<span class="cm">/* (u_char) free block map */</span>
	<span class="n">__u32</span>	<span class="n">c_nextfreeoff</span><span class="p">;</span>	<span class="cm">/* (u_char) next available space */</span>
	<span class="n">__u32</span>	<span class="n">c_clustersumoff</span><span class="p">;</span><span class="cm">/* (u_int32) counts of avail clusters */</span>
	<span class="n">__u32</span>	<span class="n">c_clusteroff</span><span class="p">;</span>	<span class="cm">/* (u_int8) free cluster map */</span>
	<span class="n">__u32</span>	<span class="n">c_nclusterblks</span><span class="p">;</span>	<span class="cm">/* number of clusters this cg */</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">ufs_sb_private_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_buffer_head</span> <span class="n">s_ubh</span><span class="p">;</span> <span class="cm">/* buffer containing super block */</span>
	<span class="k">struct</span> <span class="n">ufs_csum_core</span> <span class="n">cs_total</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">s_sblkno</span><span class="p">;</span>	<span class="cm">/* offset of super-blocks in filesys */</span>
	<span class="n">__u32</span>	<span class="n">s_cblkno</span><span class="p">;</span>	<span class="cm">/* offset of cg-block in filesys */</span>
	<span class="n">__u32</span>	<span class="n">s_iblkno</span><span class="p">;</span>	<span class="cm">/* offset of inode-blocks in filesys */</span>
	<span class="n">__u32</span>	<span class="n">s_dblkno</span><span class="p">;</span>	<span class="cm">/* offset of first data after cg */</span>
	<span class="n">__u32</span>	<span class="n">s_cgoffset</span><span class="p">;</span>	<span class="cm">/* cylinder group offset in cylinder */</span>
	<span class="n">__u32</span>	<span class="n">s_cgmask</span><span class="p">;</span>	<span class="cm">/* used to calc mod fs_ntrak */</span>
	<span class="n">__u32</span>	<span class="n">s_size</span><span class="p">;</span>		<span class="cm">/* number of blocks (fragments) in fs */</span>
	<span class="n">__u32</span>	<span class="n">s_dsize</span><span class="p">;</span>	<span class="cm">/* number of data blocks in fs */</span>
	<span class="n">__u64</span>	<span class="n">s_u2_size</span><span class="p">;</span>	<span class="cm">/* ufs2: number of blocks (fragments) in fs */</span>
	<span class="n">__u64</span>	<span class="n">s_u2_dsize</span><span class="p">;</span>	<span class="cm">/*ufs2:  number of data blocks in fs */</span>
	<span class="n">__u32</span>	<span class="n">s_ncg</span><span class="p">;</span>		<span class="cm">/* number of cylinder groups */</span>
	<span class="n">__u32</span>	<span class="n">s_bsize</span><span class="p">;</span>	<span class="cm">/* size of basic blocks */</span>
	<span class="n">__u32</span>	<span class="n">s_fsize</span><span class="p">;</span>	<span class="cm">/* size of fragments */</span>
	<span class="n">__u32</span>	<span class="n">s_fpb</span><span class="p">;</span>		<span class="cm">/* fragments per block */</span>
	<span class="n">__u32</span>	<span class="n">s_minfree</span><span class="p">;</span>	<span class="cm">/* minimum percentage of free blocks */</span>
	<span class="n">__u32</span>	<span class="n">s_bmask</span><span class="p">;</span>	<span class="cm">/* `blkoff&#39;&#39; calc of blk offsets */</span>
	<span class="n">__u32</span>	<span class="n">s_fmask</span><span class="p">;</span>	<span class="cm">/* s_fsize mask */</span>
	<span class="n">__u32</span>	<span class="n">s_bshift</span><span class="p">;</span>	<span class="cm">/* `lblkno&#39;&#39; calc of logical blkno */</span>
	<span class="n">__u32</span>   <span class="n">s_fshift</span><span class="p">;</span>	<span class="cm">/* s_fsize shift */</span>
	<span class="n">__u32</span>	<span class="n">s_fpbshift</span><span class="p">;</span>	<span class="cm">/* fragments per block shift */</span>
	<span class="n">__u32</span>	<span class="n">s_fsbtodb</span><span class="p">;</span>	<span class="cm">/* fsbtodb and dbtofsb shift constant */</span>
	<span class="n">__u32</span>	<span class="n">s_sbsize</span><span class="p">;</span>	<span class="cm">/* actual size of super block */</span>
	<span class="n">__u32</span>   <span class="n">s_csmask</span><span class="p">;</span>	<span class="cm">/* csum block offset */</span>
	<span class="n">__u32</span>	<span class="n">s_csshift</span><span class="p">;</span>	<span class="cm">/* csum block number */</span>
	<span class="n">__u32</span>	<span class="n">s_nindir</span><span class="p">;</span>	<span class="cm">/* value of NINDIR */</span>
	<span class="n">__u32</span>	<span class="n">s_inopb</span><span class="p">;</span>	<span class="cm">/* value of INOPB */</span>
	<span class="n">__u32</span>	<span class="n">s_nspf</span><span class="p">;</span>		<span class="cm">/* value of NSPF */</span>
	<span class="n">__u32</span>	<span class="n">s_npsect</span><span class="p">;</span>	<span class="cm">/* # sectors/track including spares */</span>
	<span class="n">__u32</span>	<span class="n">s_interleave</span><span class="p">;</span>	<span class="cm">/* hardware sector interleave */</span>
	<span class="n">__u32</span>	<span class="n">s_trackskew</span><span class="p">;</span>	<span class="cm">/* sector 0 skew, per track */</span>
	<span class="n">__u64</span>	<span class="n">s_csaddr</span><span class="p">;</span>	<span class="cm">/* blk addr of cyl grp summary area */</span>
	<span class="n">__u32</span>	<span class="n">s_cssize</span><span class="p">;</span>	<span class="cm">/* size of cyl grp summary area */</span>
	<span class="n">__u32</span>	<span class="n">s_cgsize</span><span class="p">;</span>	<span class="cm">/* cylinder group size */</span>
	<span class="n">__u32</span>	<span class="n">s_ntrak</span><span class="p">;</span>	<span class="cm">/* tracks per cylinder */</span>
	<span class="n">__u32</span>	<span class="n">s_nsect</span><span class="p">;</span>	<span class="cm">/* sectors per track */</span>
	<span class="n">__u32</span>	<span class="n">s_spc</span><span class="p">;</span>		<span class="cm">/* sectors per cylinder */</span>
	<span class="n">__u32</span>	<span class="n">s_ipg</span><span class="p">;</span>		<span class="cm">/* inodes per cylinder group */</span>
	<span class="n">__u32</span>	<span class="n">s_fpg</span><span class="p">;</span>		<span class="cm">/* fragments per group */</span>
	<span class="n">__u32</span>	<span class="n">s_cpc</span><span class="p">;</span>		<span class="cm">/* cyl per cycle in postbl */</span>
	<span class="n">__s32</span>	<span class="n">s_contigsumsize</span><span class="p">;</span><span class="cm">/* size of cluster summary array, 44bsd */</span>
	<span class="n">__s64</span>	<span class="n">s_qbmask</span><span class="p">;</span>	<span class="cm">/* ~usb_bmask */</span>
	<span class="n">__s64</span>	<span class="n">s_qfmask</span><span class="p">;</span>	<span class="cm">/* ~usb_fmask */</span>
	<span class="n">__s32</span>	<span class="n">s_postblformat</span><span class="p">;</span>	<span class="cm">/* format of positional layout tables */</span>
	<span class="n">__s32</span>	<span class="n">s_nrpos</span><span class="p">;</span>	<span class="cm">/* number of rotational positions */</span>
        <span class="n">__s32</span>	<span class="n">s_postbloff</span><span class="p">;</span>	<span class="cm">/* (__s16) rotation block list head */</span>
	<span class="n">__s32</span>	<span class="n">s_rotbloff</span><span class="p">;</span>	<span class="cm">/* (__u8) blocks for each rotation */</span>

	<span class="n">__u32</span>	<span class="n">s_fpbmask</span><span class="p">;</span>	<span class="cm">/* fragments per block mask */</span>
	<span class="n">__u32</span>	<span class="n">s_apb</span><span class="p">;</span>		<span class="cm">/* address per block */</span>
	<span class="n">__u32</span>	<span class="n">s_2apb</span><span class="p">;</span>		<span class="cm">/* address per block^2 */</span>
	<span class="n">__u32</span>	<span class="n">s_3apb</span><span class="p">;</span>		<span class="cm">/* address per block^3 */</span>
	<span class="n">__u32</span>	<span class="n">s_apbmask</span><span class="p">;</span>	<span class="cm">/* address per block mask */</span>
	<span class="n">__u32</span>	<span class="n">s_apbshift</span><span class="p">;</span>	<span class="cm">/* address per block shift */</span>
	<span class="n">__u32</span>	<span class="n">s_2apbshift</span><span class="p">;</span>	<span class="cm">/* address per block shift * 2 */</span>
	<span class="n">__u32</span>	<span class="n">s_3apbshift</span><span class="p">;</span>	<span class="cm">/* address per block shift * 3 */</span>
	<span class="n">__u32</span>	<span class="n">s_nspfshift</span><span class="p">;</span>	<span class="cm">/* number of sector per fragment shift */</span>
	<span class="n">__u32</span>	<span class="n">s_nspb</span><span class="p">;</span>		<span class="cm">/* number of sector per block */</span>
	<span class="n">__u32</span>	<span class="n">s_inopf</span><span class="p">;</span>	<span class="cm">/* inodes per fragment */</span>
	<span class="n">__u32</span>	<span class="n">s_sbbase</span><span class="p">;</span>	<span class="cm">/* offset of NeXTstep superblock */</span>
	<span class="n">__u32</span>	<span class="n">s_bpf</span><span class="p">;</span>		<span class="cm">/* bits per fragment */</span>
	<span class="n">__u32</span>	<span class="n">s_bpfshift</span><span class="p">;</span>	<span class="cm">/* bits per fragment shift*/</span>
	<span class="n">__u32</span>	<span class="n">s_bpfmask</span><span class="p">;</span>	<span class="cm">/* bits per fragment mask */</span>

	<span class="n">__u32</span>	<span class="n">s_maxsymlinklen</span><span class="p">;</span><span class="cm">/* upper limit on fast symlinks&#39; size */</span>
	<span class="n">__s32</span>	<span class="n">fs_magic</span><span class="p">;</span>       <span class="cm">/* filesystem magic */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_dirblksize</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Sizes of this structures are:</span>
<span class="cm"> *	ufs_super_block_first	512</span>
<span class="cm"> *	ufs_super_block_second	512</span>
<span class="cm"> *	ufs_super_block_third	356</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ufs_super_block_first</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">fs_link</span><span class="p">;</span>	<span class="cm">/* UNUSED */</span>
		<span class="p">}</span> <span class="n">fs_42</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">fs_state</span><span class="p">;</span>	<span class="cm">/* file system state flag */</span>
		<span class="p">}</span> <span class="n">fs_sun</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fs_u0</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_rlink</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_sblkno</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_cblkno</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_iblkno</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_dblkno</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_cgoffset</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_cgmask</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_time</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_size</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_dsize</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_ncg</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_bsize</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_fsize</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_frag</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_minfree</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_rotdelay</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_rps</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_bmask</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_fmask</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_bshift</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_fshift</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_maxcontig</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_maxbpg</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_fragshift</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_fsbtodb</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_sbsize</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_csmask</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_csshift</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_nindir</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_inopb</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_nspf</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_optim</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">fs_npsect</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">fs_sun</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">fs_state</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">fs_sunx86</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fs_u1</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_interleave</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_trackskew</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_id</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__fs32</span>	<span class="n">fs_csaddr</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_cssize</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_cgsize</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_ntrak</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_nsect</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_spc</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_ncyl</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_cpg</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_ipg</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_fpg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_csum</span> <span class="n">fs_cstotal</span><span class="p">;</span>
	<span class="n">__s8</span>	<span class="n">fs_fmod</span><span class="p">;</span>
	<span class="n">__s8</span>	<span class="n">fs_clean</span><span class="p">;</span>
	<span class="n">__s8</span>	<span class="n">fs_ronly</span><span class="p">;</span>
	<span class="n">__s8</span>	<span class="n">fs_flags</span><span class="p">;</span>
	<span class="n">__s8</span>	<span class="n">fs_fsmnt</span><span class="p">[</span><span class="n">UFS_MAXMNTLEN</span> <span class="o">-</span> <span class="mi">212</span><span class="p">];</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="n">ufs_super_block_second</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__s8</span>	<span class="n">fs_fsmnt</span><span class="p">[</span><span class="mi">212</span><span class="p">];</span>
			<span class="n">__fs32</span>	<span class="n">fs_cgrotor</span><span class="p">;</span>
			<span class="n">__fs32</span>	<span class="n">fs_csp</span><span class="p">[</span><span class="n">UFS_MAXCSBUFS</span><span class="p">];</span>
			<span class="n">__fs32</span>	<span class="n">fs_maxcluster</span><span class="p">;</span>
			<span class="n">__fs32</span>	<span class="n">fs_cpc</span><span class="p">;</span>
			<span class="n">__fs16</span>	<span class="n">fs_opostbl</span><span class="p">[</span><span class="mi">82</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">fs_u1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__s8</span>  <span class="n">fs_fsmnt</span><span class="p">[</span><span class="n">UFS2_MAXMNTLEN</span> <span class="o">-</span> <span class="n">UFS_MAXMNTLEN</span> <span class="o">+</span> <span class="mi">212</span><span class="p">];</span>
			<span class="n">__u8</span>   <span class="n">fs_volname</span><span class="p">[</span><span class="n">UFS2_MAXVOLLEN</span><span class="p">];</span>
			<span class="n">__fs64</span>  <span class="n">fs_swuid</span><span class="p">;</span>
			<span class="n">__fs32</span>  <span class="n">fs_pad</span><span class="p">;</span>
			<span class="n">__fs32</span>   <span class="n">fs_cgrotor</span><span class="p">;</span>
			<span class="n">__fs32</span>   <span class="n">fs_ocsp</span><span class="p">[</span><span class="n">UFS2_NOCSPTRS</span><span class="p">];</span>
			<span class="n">__fs32</span>   <span class="n">fs_contigdirs</span><span class="p">;</span>
			<span class="n">__fs32</span>   <span class="n">fs_csp</span><span class="p">;</span>
			<span class="n">__fs32</span>   <span class="n">fs_maxcluster</span><span class="p">;</span>
			<span class="n">__fs32</span>   <span class="n">fs_active</span><span class="p">;</span>
			<span class="n">__fs32</span>   <span class="n">fs_old_cpc</span><span class="p">;</span>
			<span class="n">__fs32</span>   <span class="n">fs_maxbsize</span><span class="p">;</span>
			<span class="n">__fs64</span>   <span class="n">fs_sparecon64</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
			<span class="n">__fs64</span>   <span class="n">fs_sblockloc</span><span class="p">;</span>
			<span class="n">__fs64</span>	<span class="n">cs_ndir</span><span class="p">;</span>
			<span class="n">__fs64</span>	<span class="n">cs_nbfree</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">fs_u2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fs_un</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ufs_super_block_third</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs16</span>	<span class="n">fs_opostbl</span><span class="p">[</span><span class="mi">46</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">fs_u1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs64</span>	<span class="n">cs_nifree</span><span class="p">;</span>	<span class="cm">/* number of free inodes */</span>
			<span class="n">__fs64</span>	<span class="n">cs_nffree</span><span class="p">;</span>	<span class="cm">/* number of free frags */</span>
			<span class="n">__fs64</span>   <span class="n">cs_numclusters</span><span class="p">;</span>	<span class="cm">/* number of free clusters */</span>
			<span class="n">__fs64</span>   <span class="n">cs_spare</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* future expansion */</span>
			<span class="k">struct</span>  <span class="n">ufs_timeval</span>    <span class="n">fs_time</span><span class="p">;</span>		<span class="cm">/* last time written */</span>
			<span class="n">__fs64</span>    <span class="n">fs_size</span><span class="p">;</span>		<span class="cm">/* number of blocks in fs */</span>
			<span class="n">__fs64</span>    <span class="n">fs_dsize</span><span class="p">;</span>	<span class="cm">/* number of data blocks in fs */</span>
			<span class="n">__fs64</span>   <span class="n">fs_csaddr</span><span class="p">;</span>	<span class="cm">/* blk addr of cyl grp summary area */</span>
			<span class="n">__fs64</span>    <span class="n">fs_pendingblocks</span><span class="p">;</span><span class="cm">/* blocks in process of being freed */</span>
			<span class="n">__fs32</span>    <span class="n">fs_pendinginodes</span><span class="p">;</span><span class="cm">/*inodes in process of being freed */</span>
		<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">fs_u2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fs_un1</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">fs_sparecon</span><span class="p">[</span><span class="mi">53</span><span class="p">];</span><span class="cm">/* reserved for future constants */</span>
			<span class="n">__fs32</span>	<span class="n">fs_reclaim</span><span class="p">;</span>
			<span class="n">__fs32</span>	<span class="n">fs_sparecon2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">__fs32</span>	<span class="n">fs_state</span><span class="p">;</span>	<span class="cm">/* file system state time stamp */</span>
			<span class="n">__fs32</span>	<span class="n">fs_qbmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* ~usb_bmask */</span>
			<span class="n">__fs32</span>	<span class="n">fs_qfmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* ~usb_fmask */</span>
		<span class="p">}</span> <span class="n">fs_sun</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">fs_sparecon</span><span class="p">[</span><span class="mi">53</span><span class="p">];</span><span class="cm">/* reserved for future constants */</span>
			<span class="n">__fs32</span>	<span class="n">fs_reclaim</span><span class="p">;</span>
			<span class="n">__fs32</span>	<span class="n">fs_sparecon2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">__fs32</span>	<span class="n">fs_npsect</span><span class="p">;</span>	<span class="cm">/* # sectors/track including spares */</span>
			<span class="n">__fs32</span>	<span class="n">fs_qbmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* ~usb_bmask */</span>
			<span class="n">__fs32</span>	<span class="n">fs_qfmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* ~usb_fmask */</span>
		<span class="p">}</span> <span class="n">fs_sunx86</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__fs32</span>	<span class="n">fs_sparecon</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span><span class="cm">/* reserved for future constants */</span>
			<span class="n">__fs32</span>	<span class="n">fs_contigsumsize</span><span class="p">;</span><span class="cm">/* size of cluster summary array */</span>
			<span class="n">__fs32</span>	<span class="n">fs_maxsymlinklen</span><span class="p">;</span><span class="cm">/* max length of an internal symlink */</span>
			<span class="n">__fs32</span>	<span class="n">fs_inodefmt</span><span class="p">;</span>	<span class="cm">/* format of on-disk inodes */</span>
			<span class="n">__fs32</span>	<span class="n">fs_maxfilesize</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* max representable file size */</span>
			<span class="n">__fs32</span>	<span class="n">fs_qbmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* ~usb_bmask */</span>
			<span class="n">__fs32</span>	<span class="n">fs_qfmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* ~usb_fmask */</span>
			<span class="n">__fs32</span>	<span class="n">fs_state</span><span class="p">;</span>	<span class="cm">/* file system state time stamp */</span>
		<span class="p">}</span> <span class="n">fs_44</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fs_un2</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_postblformat</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_nrpos</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_postbloff</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_rotbloff</span><span class="p">;</span>
	<span class="n">__fs32</span>	<span class="n">fs_magic</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">fs_space</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_UFS_FS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
