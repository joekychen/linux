<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * (C) 1997 Linus Torvalds</span>
<span class="cm"> * (C) 1999 Andrea Arcangeli &lt;andrea@suse.de&gt; (dynamic inode allocation)</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/posix_acl.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt; </span><span class="cm">/* for inode_has_buffers */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Inode locking rules:</span>
<span class="cm"> *</span>
<span class="cm"> * inode-&gt;i_lock protects:</span>
<span class="cm"> *   inode-&gt;i_state, inode-&gt;i_hash, __iget()</span>
<span class="cm"> * inode-&gt;i_sb-&gt;s_inode_lru_lock protects:</span>
<span class="cm"> *   inode-&gt;i_sb-&gt;s_inode_lru, inode-&gt;i_lru</span>
<span class="cm"> * inode_sb_list_lock protects:</span>
<span class="cm"> *   sb-&gt;s_inodes, inode-&gt;i_sb_list</span>
<span class="cm"> * bdi-&gt;wb.list_lock protects:</span>
<span class="cm"> *   bdi-&gt;wb.b_{dirty,io,more_io}, inode-&gt;i_wb_list</span>
<span class="cm"> * inode_hash_lock protects:</span>
<span class="cm"> *   inode_hashtable, inode-&gt;i_hash</span>
<span class="cm"> *</span>
<span class="cm"> * Lock ordering:</span>
<span class="cm"> *</span>
<span class="cm"> * inode_sb_list_lock</span>
<span class="cm"> *   inode-&gt;i_lock</span>
<span class="cm"> *     inode-&gt;i_sb-&gt;s_inode_lru_lock</span>
<span class="cm"> *</span>
<span class="cm"> * bdi-&gt;wb.list_lock</span>
<span class="cm"> *   inode-&gt;i_lock</span>
<span class="cm"> *</span>
<span class="cm"> * inode_hash_lock</span>
<span class="cm"> *   inode_sb_list_lock</span>
<span class="cm"> *   inode-&gt;i_lock</span>
<span class="cm"> *</span>
<span class="cm"> * iunique_lock</span>
<span class="cm"> *   inode_hash_lock</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_hash_mask</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_hash_shift</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">inode_hashtable</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">__cacheline_aligned_in_smp</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">inode_hash_lock</span><span class="p">);</span>

<span class="n">__cacheline_aligned_in_smp</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Empty aops. Can be used for the cases where the user does not</span>
<span class="cm"> * define any of the address_space operations.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">empty_aops</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">empty_aops</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Statistics gathering..</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inodes_stat_t</span> <span class="n">inodes_stat</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nr_inodes</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nr_unused</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">inode_cachep</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_nr_inodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">nr_inodes</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_nr_inodes_unused</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">nr_unused</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_nr_dirty_inodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* not actually dirty inodes, but a wild approximation */</span>
	<span class="kt">int</span> <span class="n">nr_dirty</span> <span class="o">=</span> <span class="n">get_nr_inodes</span><span class="p">()</span> <span class="o">-</span> <span class="n">get_nr_inodes_unused</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">nr_dirty</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">nr_dirty</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle nr_inode sysctl</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="kt">int</span> <span class="nf">proc_nr_inodes</span><span class="p">(</span><span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		   <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inodes_stat</span><span class="p">.</span><span class="n">nr_inodes</span> <span class="o">=</span> <span class="n">get_nr_inodes</span><span class="p">();</span>
	<span class="n">inodes_stat</span><span class="p">.</span><span class="n">nr_unused</span> <span class="o">=</span> <span class="n">get_nr_inodes_unused</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">proc_dointvec</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * inode_init_always - perform inode structure intialisation</span>
<span class="cm"> * @sb: superblock inode belongs to</span>
<span class="cm"> * @inode: inode to initialise</span>
<span class="cm"> *</span>
<span class="cm"> * These are initializations that need to be done on every inode</span>
<span class="cm"> * allocation as the fields are not initialised by slab allocation.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">inode_init_always</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">empty_iops</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">empty_fops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="k">const</span> <span class="n">mapping</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">empty_iops</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">empty_fops</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">__i_nlink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_opflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i_uid_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">i_gid_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dquot</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dquot</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">dirtied_when</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">security_inode_alloc</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">i_lock_key</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">i_mutex_key</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dio_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">empty_aops</span><span class="p">;</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">);</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">assoc_mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_backing_dev_info</span><span class="p">;</span>
	<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the block_device provides a backing_dev_info for client</span>
<span class="cm">	 * inodes then use that.  Otherwise the inode share the bdev&#39;s</span>
<span class="cm">	 * backing_dev_info.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">;</span>

		<span class="n">bdi</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="n">bdi</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">);</span>	<span class="cm">/* buggered by rcu freeing */</span>
<span class="cp">#ifdef CONFIG_FS_POSIX_ACL</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_acl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_default_acl</span> <span class="o">=</span> <span class="n">ACL_NOT_CACHED</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FSNOTIFY</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fsnotify_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">nr_inodes</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_init_always</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">alloc_inode</span><span class="p">)</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">alloc_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">inode_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">inode_init_always</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">destroy_inode</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">inode_cachep</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_inode_nonrcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">inode_cachep</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">free_inode_nonrcu</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode_has_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">security_inode_free</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">fsnotify_inode_delete</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_remove_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_remove_count</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_FS_POSIX_ACL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_acl</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_acl</span> <span class="o">!=</span> <span class="n">ACL_NOT_CACHED</span><span class="p">)</span>
		<span class="n">posix_acl_release</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_acl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_default_acl</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_default_acl</span> <span class="o">!=</span> <span class="n">ACL_NOT_CACHED</span><span class="p">)</span>
		<span class="n">posix_acl_release</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_default_acl</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">this_cpu_dec</span><span class="p">(</span><span class="n">nr_inodes</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__destroy_inode</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">inode_cachep</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">));</span>
	<span class="n">__destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">destroy_inode</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drop_nlink - directly drop an inode&#39;s link count</span>
<span class="cm"> * @inode: inode</span>
<span class="cm"> *</span>
<span class="cm"> * This is a low-level filesystem helper to replace any</span>
<span class="cm"> * direct filesystem manipulation of i_nlink.  In cases</span>
<span class="cm"> * where we are attempting to track writes to the</span>
<span class="cm"> * filesystem, a decrement to zero means an imminent</span>
<span class="cm"> * write when the file is truncated and actually unlinked</span>
<span class="cm"> * on the filesystem.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drop_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">__i_nlink</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_remove_count</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drop_nlink</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clear_nlink - directly zero an inode&#39;s link count</span>
<span class="cm"> * @inode: inode</span>
<span class="cm"> *</span>
<span class="cm"> * This is a low-level filesystem helper to replace any</span>
<span class="cm"> * direct filesystem manipulation of i_nlink.  See</span>
<span class="cm"> * drop_nlink() for why we care about i_nlink hitting zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clear_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">__i_nlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_remove_count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clear_nlink</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * set_nlink - directly set an inode&#39;s link count</span>
<span class="cm"> * @inode: inode</span>
<span class="cm"> * @nlink: new nlink (should be non-zero)</span>
<span class="cm"> *</span>
<span class="cm"> * This is a low-level filesystem helper to replace any</span>
<span class="cm"> * direct filesystem manipulation of i_nlink.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nlink</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Yes, some filesystems do change nlink from zero to one */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_remove_count</span><span class="p">);</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">__i_nlink</span> <span class="o">=</span> <span class="n">nlink</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_nlink</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * inc_nlink - directly increment an inode&#39;s link count</span>
<span class="cm"> * @inode: inode</span>
<span class="cm"> *</span>
<span class="cm"> * This is a low-level filesystem helper to replace any</span>
<span class="cm"> * direct filesystem manipulation of i_nlink.  Currently,</span>
<span class="cm"> * it is only here for parity with dec_nlink().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">inc_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_remove_count</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">__i_nlink</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inc_nlink</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">address_space_init_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mapping</span><span class="p">));</span>
	<span class="n">INIT_RADIX_TREE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="n">INIT_RAW_PRIO_TREE_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">address_space_init_once</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * These are initializations that only need to be done</span>
<span class="cm"> * once, because the fields are idempotent across use</span>
<span class="cm"> * of the inode, so let the slab aware of that.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">inode_init_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_devices</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">);</span>
	<span class="n">address_space_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">);</span>
	<span class="n">i_size_ordered_init</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FSNOTIFY</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fsnotify_marks</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_init_once</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">)</span> <span class="n">foo</span><span class="p">;</span>

	<span class="n">inode_init_once</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * inode-&gt;i_lock must be held</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get additional reference to inode; caller must already hold one.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ihold</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ihold</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inode_lru_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_nr_inodes_unused</span><span class="o">++</span><span class="p">;</span>
		<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">nr_unused</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inode_lru_list_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_nr_inodes_unused</span><span class="o">--</span><span class="p">;</span>
		<span class="n">this_cpu_dec</span><span class="p">(</span><span class="n">nr_unused</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * inode_sb_list_add - add inode to the superblock list of inodes</span>
<span class="cm"> * @inode: inode to add</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">inode_sb_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_inodes</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">inode_sb_list_add</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inode_sb_list_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hashval</span> <span class="o">*</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sb</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">GOLDEN_RATIO_PRIME</span> <span class="o">+</span> <span class="n">hashval</span><span class="p">)</span> <span class="o">/</span>
			<span class="n">L1_CACHE_BYTES</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">^</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">^</span> <span class="n">GOLDEN_RATIO_PRIME</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">i_hash_shift</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">i_hash_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__insert_inode_hash - hash an inode</span>
<span class="cm"> *	@inode: unhashed inode</span>
<span class="cm"> *	@hashval: unsigned long value used to locate this object in the</span>
<span class="cm"> *		inode_hashtable.</span>
<span class="cm"> *</span>
<span class="cm"> *	Add an inode to the inode hash for this superblock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__insert_inode_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">inode_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">hashval</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__insert_inode_hash</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__remove_inode_hash - remove an inode from the hash</span>
<span class="cm"> *	@inode: inode to unhash</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove an inode from the superblock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__remove_inode_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__remove_inode_hash</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">clear_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have to cycle tree_lock here because reclaim can be still in the</span>
<span class="cm">	 * process of removing the last page (in __delete_from_page_cache())</span>
<span class="cm">	 * and we must not free mapping under it.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">private_list</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_FREEING</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_CLEAR</span><span class="p">);</span>
	<span class="cm">/* don&#39;t need i_lock here, no concurrent mods to i_state */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="n">I_FREEING</span> <span class="o">|</span> <span class="n">I_CLEAR</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clear_inode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Free the inode passed in, removing it from the lists it is still connected</span>
<span class="cm"> * to. We remove any pages still attached to the inode and wait for any IO that</span>
<span class="cm"> * is still in progress before finally destroying the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * An inode must already be marked I_FREEING so that we avoid the inode being</span>
<span class="cm"> * moved back onto lists if we race with other code that manipulates the lists</span>
<span class="cm"> * (e.g. writeback_single_inode). The caller is responsible for setting this.</span>
<span class="cm"> *</span>
<span class="cm"> * An inode must already be removed from the LRU list before being evicted from</span>
<span class="cm"> * the cache. This should occur atomically with setting the I_FREEING state</span>
<span class="cm"> * flag, so no inodes here should ever be on the LRU when being evicted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">evict</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_FREEING</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">))</span>
		<span class="n">inode_wb_list_del</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">inode_sb_list_del</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for flusher thread to be done with the inode so that filesystem</span>
<span class="cm">	 * does not start destroying it while writeback is still running. Since</span>
<span class="cm">	 * the inode has I_FREEING set, flusher thread won&#39;t start new work on</span>
<span class="cm">	 * the inode.  We just have to wait for running writeback to finish.</span>
<span class="cm">	 */</span>
	<span class="n">inode_wait_for_writeback</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">evict_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">evict_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span><span class="p">)</span>
			<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_bdev</span><span class="p">)</span>
		<span class="n">bd_forget</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span><span class="p">)</span>
		<span class="n">cd_forget</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">remove_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_NEW</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">!=</span> <span class="p">(</span><span class="n">I_FREEING</span> <span class="o">|</span> <span class="n">I_CLEAR</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="n">destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dispose_list - dispose of the contents of a local list</span>
<span class="cm"> * @head: the head of the list to free</span>
<span class="cm"> *</span>
<span class="cm"> * Dispose-list gets a local list with local inodes in it, so it doesn&#39;t</span>
<span class="cm"> * need to worry about list corruption and SMP locks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dispose_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

		<span class="n">inode</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_lru</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">);</span>

		<span class="n">evict</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * evict_inodes	- evict all evictable inodes for a superblock</span>
<span class="cm"> * @sb:		superblock to operate on</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure that no inodes with zero refcount are retained.  This is</span>
<span class="cm"> * called by superblock shutdown after having MS_ACTIVE flag removed,</span>
<span class="cm"> * so any inode reaching zero refcount during or after that call will</span>
<span class="cm"> * be immediately evicted.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">evict_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dispose</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inodes</span><span class="p">,</span> <span class="n">i_sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_NEW</span> <span class="o">|</span> <span class="n">I_FREEING</span> <span class="o">|</span> <span class="n">I_WILL_FREE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_FREEING</span><span class="p">;</span>
		<span class="n">inode_lru_list_del</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dispose</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>

	<span class="n">dispose_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispose</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * invalidate_inodes	- attempt to free all inodes on a superblock</span>
<span class="cm"> * @sb:		superblock to operate on</span>
<span class="cm"> * @kill_dirty: flag to guide handling of dirty inodes</span>
<span class="cm"> *</span>
<span class="cm"> * Attempts to free all inodes for a given superblock.  If there were any</span>
<span class="cm"> * busy inodes return a non-zero value, else zero.</span>
<span class="cm"> * If @kill_dirty is set, discard dirty inodes too, otherwise treat</span>
<span class="cm"> * them as busy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">invalidate_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">kill_dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dispose</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inodes</span><span class="p">,</span> <span class="n">i_sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_NEW</span> <span class="o">|</span> <span class="n">I_FREEING</span> <span class="o">|</span> <span class="n">I_WILL_FREE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kill_dirty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_FREEING</span><span class="p">;</span>
		<span class="n">inode_lru_list_del</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dispose</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>

	<span class="n">dispose_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispose</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">busy</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">can_unuse</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">I_REFERENCED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode_has_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk the superblock inode LRU for freeable inodes and attempt to free them.</span>
<span class="cm"> * This is called from the superblock shrinker function with a number of inodes</span>
<span class="cm"> * to trim from the LRU. Inodes to be freed are moved to a temporary list and</span>
<span class="cm"> * then are freed outside inode_lock by dispose_list().</span>
<span class="cm"> *</span>
<span class="cm"> * Any inodes which are pinned purely because of attached pagecache have their</span>
<span class="cm"> * pagecache removed.  If the inode has metadata buffers attached to</span>
<span class="cm"> * mapping-&gt;private_list then try to remove them.</span>
<span class="cm"> *</span>
<span class="cm"> * If the inode has the I_REFERENCED flag set, then it means that it has been</span>
<span class="cm"> * used recently - the flag is set in iput_final(). When we encounter such an</span>
<span class="cm"> * inode, clear the flag and move it to the back of the LRU so it gets another</span>
<span class="cm"> * pass through the LRU before it gets reclaimed. This is necessary because of</span>
<span class="cm"> * the fact we are doing lazy LRU updates to minimise lock contention so the</span>
<span class="cm"> * LRU does not have strict ordering. Hence we don&#39;t want to reclaim inodes</span>
<span class="cm"> * with this flag set because they are the inodes that are out of order.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">prune_icache_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_scan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">freeable</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nr_scanned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">nr_scanned</span> <span class="o">=</span> <span class="n">nr_to_scan</span><span class="p">;</span> <span class="n">nr_scanned</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nr_scanned</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">inode</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_lru</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * we are inverting the sb-&gt;s_inode_lru_lock/inode-&gt;i_lock here,</span>
<span class="cm">		 * so use a trylock. If we fail to get the lock, just move the</span>
<span class="cm">		 * inode to the back of the list so we don&#39;t spin on it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Referenced or dirty inodes are still in use. Give them</span>
<span class="cm">		 * another pass through the LRU as we canot reclaim them now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">I_REFERENCED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nr_inodes_unused</span><span class="o">--</span><span class="p">;</span>
			<span class="n">this_cpu_dec</span><span class="p">(</span><span class="n">nr_unused</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* recently referenced inodes get one more pass */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_REFERENCED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I_REFERENCED</span><span class="p">;</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode_has_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__iget</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">remove_inode_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
				<span class="n">reap</span> <span class="o">+=</span> <span class="n">invalidate_mapping_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span>
								<span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">!=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_lru</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* wrong inode or list_empty */</span>
			<span class="cm">/* avoid lock inversions with trylock */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_unuse</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_FREEING</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freeable</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nr_inodes_unused</span><span class="o">--</span><span class="p">;</span>
		<span class="n">this_cpu_dec</span><span class="p">(</span><span class="n">nr_unused</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_is_kswapd</span><span class="p">())</span>
		<span class="n">__count_vm_events</span><span class="p">(</span><span class="n">KSWAPD_INODESTEAL</span><span class="p">,</span> <span class="n">reap</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__count_vm_events</span><span class="p">(</span><span class="n">PGINODESTEAL</span><span class="p">,</span> <span class="n">reap</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span> <span class="o">+=</span> <span class="n">reap</span><span class="p">;</span>

	<span class="n">dispose_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freeable</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__wait_on_freeing_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Called with the inode lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">find_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">!=</span> <span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_FREEING</span><span class="o">|</span><span class="n">I_WILL_FREE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__wait_on_freeing_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__iget</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find_inode_fast is the fast path version of find_inode, see the comment at</span>
<span class="cm"> * iget_locked for details.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">find_inode_fast</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">!=</span> <span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">!=</span> <span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_FREEING</span><span class="o">|</span><span class="n">I_WILL_FREE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__wait_on_freeing_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__iget</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Each cpu owns a range of LAST_INO_BATCH numbers.</span>
<span class="cm"> * &#39;shared_last_ino&#39; is dirtied only once out of LAST_INO_BATCH allocations,</span>
<span class="cm"> * to renew the exhausted range.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not significantly increase overflow rate because every CPU can</span>
<span class="cm"> * consume at most LAST_INO_BATCH-1 unused inode numbers. So there is</span>
<span class="cm"> * NR_CPUS*(LAST_INO_BATCH-1) wastage. At 4096 and 1024, this is ~0.1% of the</span>
<span class="cm"> * 2^32 range, and is a worst-case. Even a 50% wastage would only increase</span>
<span class="cm"> * overflow rate by 2x, which does not seem too significant.</span>
<span class="cm"> *</span>
<span class="cm"> * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW</span>
<span class="cm"> * error if st_ino won&#39;t fit in target struct field. Use 32bit counter</span>
<span class="cm"> * here to attempt to avoid that.</span>
<span class="cm"> */</span>
<span class="cp">#define LAST_INO_BATCH 1024</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">last_ino</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_next_ino</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">last_ino</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">res</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LAST_INO_BATCH</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">shared_last_ino</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">atomic_add_return</span><span class="p">(</span><span class="n">LAST_INO_BATCH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shared_last_ino</span><span class="p">);</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">LAST_INO_BATCH</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">++</span><span class="n">res</span><span class="p">;</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">last_ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_next_ino</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	new_inode_pseudo 	- obtain an inode</span>
<span class="cm"> *	@sb: superblock</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocates a new inode for given superblock.</span>
<span class="cm"> *	Inode wont be chained in superblock s_inodes list</span>
<span class="cm"> *	This means :</span>
<span class="cm"> *	- fs can&#39;t be unmount</span>
<span class="cm"> *	- quotas, fsnotify, writeback can&#39;t work</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">new_inode_pseudo</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">alloc_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	new_inode 	- obtain an inode</span>
<span class="cm"> *	@sb: superblock</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocates a new inode for given superblock. The default gfp_mask</span>
<span class="cm"> *	for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE.</span>
<span class="cm"> *	If HIGHMEM pages are unsuitable or it is known that pages allocated</span>
<span class="cm"> *	for the page cache are not reclaimable or migratable,</span>
<span class="cm"> *	mapping_set_gfp_mask() must be called with suitable flags on the</span>
<span class="cm"> *	newly created inode&#39;s mapping</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">spin_lock_prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode_pseudo</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">inode_sb_list_add</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="kt">void</span> <span class="nf">lockdep_annotate_inode_mutex_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="p">;</span>

		<span class="cm">/* Set new key only if filesystem hasn&#39;t already changed it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lockdep_match_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">i_mutex_key</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * ensure nobody is actually holding i_mutex</span>
<span class="cm">			 */</span>
			<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">i_mutex_dir_key</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lockdep_annotate_inode_mutex_key</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * unlock_new_inode - clear the I_NEW state and wake up any waiters</span>
<span class="cm"> * @inode:	new inode to unlock</span>
<span class="cm"> *</span>
<span class="cm"> * Called when the inode is fully initialised to clear the new state of the</span>
<span class="cm"> * inode and wake up anyone waiting for the inode to finish initialisation.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unlock_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lockdep_annotate_inode_mutex_key</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">));</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I_NEW</span><span class="p">;</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_NEW</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unlock_new_inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iget5_locked - obtain an inode from a mounted file system</span>
<span class="cm"> * @sb:		super block of file system</span>
<span class="cm"> * @hashval:	hash value (usually inode number) to get</span>
<span class="cm"> * @test:	callback used for comparisons between inodes</span>
<span class="cm"> * @set:	callback used to initialize a new struct inode</span>
<span class="cm"> * @data:	opaque data pointer to pass to @test and @set</span>
<span class="cm"> *</span>
<span class="cm"> * Search for the inode specified by @hashval and @data in the inode cache,</span>
<span class="cm"> * and if present it is return it with an increased reference count. This is</span>
<span class="cm"> * a generalized version of iget_locked() for file systems where the inode</span>
<span class="cm"> * number is not sufficient for unique identification of an inode.</span>
<span class="cm"> *</span>
<span class="cm"> * If the inode is not in cache, allocate a new inode and return it locked,</span>
<span class="cm"> * hashed, and with the I_NEW flag set. The file system gets to fill it in</span>
<span class="cm"> * before unlocking it via unlock_new_inode().</span>
<span class="cm"> *</span>
<span class="cm"> * Note both @test and @set are called with the inode_hash_lock held, so can&#39;t</span>
<span class="cm"> * sleep.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">iget5_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">inode_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hashval</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">find_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_on_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">alloc_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
		<span class="cm">/* We released the lock, so.. */</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">find_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">set_failed</span><span class="p">;</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="n">I_NEW</span><span class="p">;</span>
			<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">inode_sb_list_add</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>

			<span class="cm">/* Return the locked inode with I_NEW set, the</span>
<span class="cm">			 * caller is responsible for filling in the contents</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Uhhuh, somebody else created the same inode under</span>
<span class="cm">		 * us. Use the old inode instead of the one we just</span>
<span class="cm">		 * allocated.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
		<span class="n">destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
		<span class="n">wait_on_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

<span class="nl">set_failed:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iget5_locked</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iget_locked - obtain an inode from a mounted file system</span>
<span class="cm"> * @sb:		super block of file system</span>
<span class="cm"> * @ino:	inode number to get</span>
<span class="cm"> *</span>
<span class="cm"> * Search for the inode specified by @ino in the inode cache and if present</span>
<span class="cm"> * return it with an increased reference count. This is for file systems</span>
<span class="cm"> * where the inode number is sufficient for unique identification of an inode.</span>
<span class="cm"> *</span>
<span class="cm"> * If the inode is not in cache, allocate a new inode and return it locked,</span>
<span class="cm"> * hashed, and with the I_NEW flag set.  The file system gets to fill it in</span>
<span class="cm"> * before unlocking it via unlock_new_inode().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">iget_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">inode_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">find_inode_fast</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_on_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">alloc_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
		<span class="cm">/* We released the lock, so.. */</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">find_inode_fast</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="n">I_NEW</span><span class="p">;</span>
			<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">inode_sb_list_add</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>

			<span class="cm">/* Return the locked inode with I_NEW set, the</span>
<span class="cm">			 * caller is responsible for filling in the contents</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Uhhuh, somebody else created the same inode under</span>
<span class="cm">		 * us. Use the old inode instead of the one we just</span>
<span class="cm">		 * allocated.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
		<span class="n">destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
		<span class="n">wait_on_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iget_locked</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * search the inode cache for a matching inode number.</span>
<span class="cm"> * If we find one, then the inode number we are trying to</span>
<span class="cm"> * allocate is not unique and so we should not use it.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if the inode number is unique, 0 if it is not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_inode_iunique</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">inode_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">i_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">==</span> <span class="n">ino</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">==</span> <span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	iunique - get a unique inode number</span>
<span class="cm"> *	@sb: superblock</span>
<span class="cm"> *	@max_reserved: highest reserved inode number</span>
<span class="cm"> *</span>
<span class="cm"> *	Obtain an inode number that is unique on the system for a given</span>
<span class="cm"> *	superblock. This is used by file systems that have no natural</span>
<span class="cm"> *	permanent inode numbering system. An inode number is returned that</span>
<span class="cm"> *	is higher than the reserved limit but unique.</span>
<span class="cm"> *</span>
<span class="cm"> *	BUGS:</span>
<span class="cm"> *	With a large number of inodes live on the file system this function</span>
<span class="cm"> *	currently becomes quite slow.</span>
<span class="cm"> */</span>
<span class="n">ino_t</span> <span class="nf">iunique</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">max_reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW</span>
<span class="cm">	 * error if st_ino won&#39;t fit in target struct field. Use 32bit counter</span>
<span class="cm">	 * here to attempt to avoid that.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">iunique_lock</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iunique_lock</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">max_reserved</span><span class="p">)</span>
			<span class="n">counter</span> <span class="o">=</span> <span class="n">max_reserved</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">test_inode_iunique</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">res</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iunique_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iunique</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">igrab</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_FREEING</span><span class="o">|</span><span class="n">I_WILL_FREE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">__iget</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Handle the case where s_op-&gt;clear_inode is not been</span>
<span class="cm">		 * called yet, and somebody is calling igrab</span>
<span class="cm">		 * while the inode is getting freed.</span>
<span class="cm">		 */</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">igrab</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ilookup5_nowait - search for an inode in the inode cache</span>
<span class="cm"> * @sb:		super block of file system to search</span>
<span class="cm"> * @hashval:	hash value (usually inode number) to search for</span>
<span class="cm"> * @test:	callback used for comparisons between inodes</span>
<span class="cm"> * @data:	opaque data pointer to pass to @test</span>
<span class="cm"> *</span>
<span class="cm"> * Search for the inode specified by @hashval and @data in the inode cache.</span>
<span class="cm"> * If the inode is in the cache, the inode is returned with an incremented</span>
<span class="cm"> * reference count.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: I_NEW is not waited upon so you have to be very careful what you do</span>
<span class="cm"> * with the returned inode.  You probably should be using ilookup5() instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Note2: @test is called with the inode_hash_lock held, so can&#39;t sleep.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ilookup5_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">inode_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hashval</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">find_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ilookup5_nowait</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ilookup5 - search for an inode in the inode cache</span>
<span class="cm"> * @sb:		super block of file system to search</span>
<span class="cm"> * @hashval:	hash value (usually inode number) to search for</span>
<span class="cm"> * @test:	callback used for comparisons between inodes</span>
<span class="cm"> * @data:	opaque data pointer to pass to @test</span>
<span class="cm"> *</span>
<span class="cm"> * Search for the inode specified by @hashval and @data in the inode cache,</span>
<span class="cm"> * and if the inode is in the cache, return the inode with an incremented</span>
<span class="cm"> * reference count.  Waits on I_NEW before returning the inode.</span>
<span class="cm"> * returned with an incremented reference count.</span>
<span class="cm"> *</span>
<span class="cm"> * This is a generalized version of ilookup() for file systems where the</span>
<span class="cm"> * inode number is not sufficient for unique identification of an inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: @test is called with the inode_hash_lock held, so can&#39;t sleep.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ilookup5</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ilookup5_nowait</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hashval</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">wait_on_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ilookup5</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ilookup - search for an inode in the inode cache</span>
<span class="cm"> * @sb:		super block of file system to search</span>
<span class="cm"> * @ino:	inode number to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Search for the inode @ino in the inode cache, and if the inode is in the</span>
<span class="cm"> * cache, the inode is returned with an incremented reference count.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ilookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">inode_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">find_inode_fast</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">wait_on_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ilookup</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">insert_inode_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">inode_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_hash</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">!=</span> <span class="n">ino</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">!=</span> <span class="n">sb</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_FREEING</span><span class="o">|</span><span class="n">I_WILL_FREE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_NEW</span><span class="p">;</span>
			<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__iget</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
		<span class="n">wait_on_inode</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">inode_unhashed</span><span class="p">(</span><span class="n">old</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">insert_inode_locked</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">insert_inode_locked4</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">inode_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hashval</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_hash</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">!=</span> <span class="n">sb</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_FREEING</span><span class="o">|</span><span class="n">I_WILL_FREE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_NEW</span><span class="p">;</span>
			<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__iget</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
		<span class="n">wait_on_inode</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">inode_unhashed</span><span class="p">(</span><span class="n">old</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">insert_inode_locked4</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">generic_delete_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_delete_inode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called when we&#39;re dropping the last reference</span>
<span class="cm"> * to an inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Call the FS &quot;drop_inode()&quot; function, defaulting to</span>
<span class="cm"> * the legacy UNIX filesystem behaviour.  If it tells</span>
<span class="cm"> * us to evict inode, do so.  Otherwise, retain inode</span>
<span class="cm"> * in cache if fs is alive, sync and evict if fs is</span>
<span class="cm"> * shutting down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iput_final</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">drop_inode</span><span class="p">)</span>
		<span class="n">drop</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">drop_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">drop</span> <span class="o">=</span> <span class="n">generic_drop_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drop</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_REFERENCED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_DIRTY</span><span class="o">|</span><span class="n">I_SYNC</span><span class="p">)))</span>
			<span class="n">inode_lru_list_add</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_WILL_FREE</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">write_inode_now</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I_WILL_FREE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_FREEING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lru</span><span class="p">))</span>
		<span class="n">inode_lru_list_del</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="n">evict</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	iput	- put an inode</span>
<span class="cm"> *	@inode: inode to put</span>
<span class="cm"> *</span>
<span class="cm"> *	Puts an inode, dropping its usage count. If the inode use count hits</span>
<span class="cm"> *	zero, the inode is then freed and may also be destroyed.</span>
<span class="cm"> *</span>
<span class="cm"> *	Consequently, iput() can sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_CLEAR</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span>
			<span class="n">iput_final</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iput</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	bmap	- find a block number in a file</span>
<span class="cm"> *	@inode: inode of file</span>
<span class="cm"> *	@block: block to find</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns the block number on the device holding the inode that</span>
<span class="cm"> *	is the disk block number for the block of the file requested.</span>
<span class="cm"> *	That is, asked for block 4 of inode 1 the function will return the</span>
<span class="cm"> *	disk block relative to the disk start that holds that block of the</span>
<span class="cm"> *	file.</span>
<span class="cm"> */</span>
<span class="n">sector_t</span> <span class="nf">bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bmap</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * With relative atime, only update atime if the previous atime is</span>
<span class="cm"> * earlier than either the ctime or mtime or if at least a day has</span>
<span class="cm"> * passed since the last atime update.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">relatime_need_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_RELATIME</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Is mtime younger than atime? If yes, update atime:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timespec_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Is ctime younger than atime? If yes, update atime:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timespec_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is the previous atime value older than a day? If yes,</span>
<span class="cm">	 * update atime:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Good, we can skip the atime update:</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This does the actual work of updating an inodes time or version.  Must have</span>
<span class="cm"> * had called mnt_want_write() before calling this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">update_time</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">update_time</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_ATIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="o">*</span><span class="n">time</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_VERSION</span><span class="p">)</span>
		<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_CTIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="o">*</span><span class="n">time</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_MTIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="o">*</span><span class="n">time</span><span class="p">;</span>
	<span class="n">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	touch_atime	-	update the access time</span>
<span class="cm"> *	@path: the &amp;struct path to update</span>
<span class="cm"> *</span>
<span class="cm"> *	Update the accessed time on an inode and mark it for writeback.</span>
<span class="cm"> *	This function automatically handles read only file systems and media,</span>
<span class="cm"> *	as well as the &quot;noatime&quot; flag and inode specific &quot;noatime&quot; markers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">touch_atime</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">S_NOATIME</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_NOATIME</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_NODIRATIME</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOATIME</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NODIRATIME</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">relatime_need_update</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">now</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mnt_want_write</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * File systems can error out when updating inodes if they need to</span>
<span class="cm">	 * allocate new space to modify an inode (such is the case for</span>
<span class="cm">	 * Btrfs), but since we touch atime while walking down the path we</span>
<span class="cm">	 * really don&#39;t care if we failed to update the atime of the file,</span>
<span class="cm">	 * so just ignore the return value.</span>
<span class="cm">	 */</span>
	<span class="n">update_time</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="n">S_ATIME</span><span class="p">);</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">touch_atime</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The logic we want is</span>
<span class="cm"> *</span>
<span class="cm"> *	if suid or (sgid and xgrp)</span>
<span class="cm"> *		remove privs</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">should_remove_suid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">kill</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* suid always must be killed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_ISUID</span><span class="p">))</span>
		<span class="n">kill</span> <span class="o">=</span> <span class="n">ATTR_KILL_SUID</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * sgid without any exec bits is just a mandatory locking mark; leave</span>
<span class="cm">	 * it alone.  If some exec bits are set, it&#39;s a real sgid; kill it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_ISGID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IXGRP</span><span class="p">)))</span>
		<span class="n">kill</span> <span class="o">|=</span> <span class="n">ATTR_KILL_SGID</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kill</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_FSETID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">kill</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">should_remove_suid</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__remove_suid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iattr</span> <span class="n">newattrs</span><span class="p">;</span>

	<span class="n">newattrs</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_FORCE</span> <span class="o">|</span> <span class="n">kill</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">notify_change</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newattrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">file_remove_suid</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">killsuid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">killpriv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Fast path for nothing security related */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_NOSEC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">killsuid</span> <span class="o">=</span> <span class="n">should_remove_suid</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">killpriv</span> <span class="o">=</span> <span class="n">security_inode_need_killpriv</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">killpriv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">killpriv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">killpriv</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">security_inode_killpriv</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">killsuid</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">__remove_suid</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">killsuid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_NOSEC</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOSEC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">file_remove_suid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	file_update_time	-	update mtime and ctime time</span>
<span class="cm"> *	@file: file accessed</span>
<span class="cm"> *</span>
<span class="cm"> *	Update the mtime and ctime members of an inode and mark the inode</span>
<span class="cm"> *	for writeback.  Note that this function is meant exclusively for</span>
<span class="cm"> *	usage in the file write path of filesystems, and filesystems may</span>
<span class="cm"> *	choose to explicitly ignore update via this function with the</span>
<span class="cm"> *	S_NOCMTIME inode flag, e.g. for network filesystem where these</span>
<span class="cm"> *	timestamps are handled by the server.  This can return an error for</span>
<span class="cm"> *	file systems who need to allocate space in order to update an inode.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">file_update_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sync_it</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* First try to exhaust all avenues to not sync */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_NOCMTIME</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">))</span>
		<span class="n">sync_it</span> <span class="o">=</span> <span class="n">S_MTIME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">))</span>
		<span class="n">sync_it</span> <span class="o">|=</span> <span class="n">S_CTIME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_I_VERSION</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">sync_it</span> <span class="o">|=</span> <span class="n">S_VERSION</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync_it</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Finally allowed to write? Takes lock. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt_want_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_time</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="n">sync_it</span><span class="p">);</span>
	<span class="n">mnt_drop_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">file_update_time</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">inode_needs_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_needs_sync</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">inode_wait</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_wait</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If we try to find an inode in the inode hash while it is being</span>
<span class="cm"> * deleted, we have to wait until the filesystem completes its</span>
<span class="cm"> * deletion before reporting that it isn&#39;t found.  This function waits</span>
<span class="cm"> * until the deletion _might_ have completed.  Callers are responsible</span>
<span class="cm"> * to recheck inode state.</span>
<span class="cm"> *</span>
<span class="cm"> * It doesn&#39;t matter if I_NEW is not set initially, a call to</span>
<span class="cm"> * wake_up_bit(&amp;inode-&gt;i_state, __I_NEW) after removing from the hash list</span>
<span class="cm"> * will DTRT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wait_on_freeing_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_NEW</span><span class="p">);</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">bit_waitqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_NEW</span><span class="p">);</span>
	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hash_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ihash_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_ihash_entries</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ihash_entries</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ihash_entries=&quot;</span><span class="p">,</span> <span class="n">set_ihash_entries</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the waitqueues and inode hash table.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">inode_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="cm">/* If hashes are distributed across NUMA nodes, defer</span>
<span class="cm">	 * hash allocation until vmalloc space is available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hashdist</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">inode_hashtable</span> <span class="o">=</span>
		<span class="n">alloc_large_system_hash</span><span class="p">(</span><span class="s">&quot;Inode-cache&quot;</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">),</span>
					<span class="n">ihash_entries</span><span class="p">,</span>
					<span class="mi">14</span><span class="p">,</span>
					<span class="n">HASH_EARLY</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">i_hash_shift</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">i_hash_mask</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">i_hash_shift</span><span class="p">);</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hashtable</span><span class="p">[</span><span class="n">loop</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">inode_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="cm">/* inode slab cache */</span>
	<span class="n">inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;inode_cache&quot;</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span><span class="p">),</span>
					 <span class="mi">0</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="o">|</span>
					 <span class="n">SLAB_MEM_SPREAD</span><span class="p">),</span>
					 <span class="n">init_once</span><span class="p">);</span>

	<span class="cm">/* Hash may have been set up in inode_init_early */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashdist</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">inode_hashtable</span> <span class="o">=</span>
		<span class="n">alloc_large_system_hash</span><span class="p">(</span><span class="s">&quot;Inode-cache&quot;</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">),</span>
					<span class="n">ihash_entries</span><span class="p">,</span>
					<span class="mi">14</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">i_hash_shift</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">i_hash_mask</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">i_hash_shift</span><span class="p">);</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_hashtable</span><span class="p">[</span><span class="n">loop</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_special_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">def_chr_fops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="n">rdev</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">def_blk_fops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="n">rdev</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISFIFO</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">def_fifo_fops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bad_sock_fops</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;init_special_inode: bogus i_mode (%o) for&quot;</span>
				  <span class="s">&quot; inode %s:%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
				  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">init_special_inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * inode_init_owner - Init uid,gid,mode for new inode according to posix standards</span>
<span class="cm"> * @inode: New inode</span>
<span class="cm"> * @dir: Directory inode</span>
<span class="cm"> * @mode: mode of the new inode</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">inode_init_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			<span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">&amp;&amp;</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_ISGID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
			<span class="n">mode</span> <span class="o">|=</span> <span class="n">S_ISGID</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_init_owner</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * inode_owner_or_capable - check current task permissions to inode</span>
<span class="cm"> * @inode: inode being checked</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if current either has CAP_FOWNER to the inode, or</span>
<span class="cm"> * owns the file.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">inode_owner_or_capable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">current_fsuid</span><span class="p">(),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">CAP_FOWNER</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_owner_or_capable</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Direct i/o helper functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__inode_dio_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="n">bit_waitqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_DIO_WAKEUP</span><span class="p">);</span>
	<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_DIO_WAKEUP</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dio_count</span><span class="p">))</span>
			<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dio_count</span><span class="p">));</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * inode_dio_wait - wait for outstanding DIO requests to finish</span>
<span class="cm"> * @inode: inode to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * Waits for all pending direct I/O requests to finish so that we can</span>
<span class="cm"> * proceed with a truncate or equivalent operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called under a lock that serializes taking new references</span>
<span class="cm"> * to i_dio_count, usually by inode-&gt;i_mutex.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">inode_dio_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dio_count</span><span class="p">))</span>
		<span class="n">__inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_dio_wait</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * inode_dio_done - signal finish of a direct I/O requests</span>
<span class="cm"> * @inode: inode the direct I/O happens on</span>
<span class="cm"> *</span>
<span class="cm"> * This is called once we&#39;ve finished processing a direct I/O request,</span>
<span class="cm"> * and is used to wake up callers waiting for direct I/O to be quiesced.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">inode_dio_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dio_count</span><span class="p">))</span>
		<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_DIO_WAKEUP</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">inode_dio_done</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
