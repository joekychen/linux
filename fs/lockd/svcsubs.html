<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › lockd › svcsubs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>svcsubs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/lockd/svcsubs.c</span>
<span class="cm"> *</span>
<span class="cm"> * Various support routines for the NLM server.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996, Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/svc.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/nfsd/nfsfh.h&gt;</span>
<span class="cp">#include &lt;linux/nfsd/export.h&gt;</span>
<span class="cp">#include &lt;linux/lockd/lockd.h&gt;</span>
<span class="cp">#include &lt;linux/lockd/share.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>

<span class="cp">#define NLMDBG_FACILITY		NLMDBG_SVCSUBS</span>


<span class="cm">/*</span>
<span class="cm"> * Global file hash table</span>
<span class="cm"> */</span>
<span class="cp">#define FILE_HASH_BITS		7</span>
<span class="cp">#define FILE_NRHASH		(1&lt;&lt;FILE_HASH_BITS)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">nlm_files</span><span class="p">[</span><span class="n">FILE_NRHASH</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">nlm_file_mutex</span><span class="p">);</span>

<span class="cp">#ifdef NFSD_DEBUG</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nlm_debug_print_fh</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">fhp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* print the first 32 bytes of the fh */</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;lockd: %s (%08x %08x %08x %08x %08x %08x %08x %08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">msg</span><span class="p">,</span> <span class="n">fhp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fhp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fhp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fhp</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		<span class="n">fhp</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">fhp</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">fhp</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">fhp</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nlm_debug_print_file</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;lockd: %s %s/%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">msg</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nlm_debug_print_fh</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nlm_debug_print_file</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">file_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NFS2_FHSIZE</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">+=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FILE_NRHASH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup file info. If it doesn&#39;t exist, create a file info struct</span>
<span class="cm"> * and open a (VFS) file for the given inode.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME:</span>
<span class="cm"> * Note that we open the file O_RDONLY even when creating write locks.</span>
<span class="cm"> * This is not quite right, but for now, we assume the client performs</span>
<span class="cm"> * the proper R/W checking.</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nlm_lookup_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">**</span><span class="n">result</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlm_file</span>	<span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">hash</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">nfserr</span><span class="p">;</span>

	<span class="n">nlm_debug_print_fh</span><span class="p">(</span><span class="s">&quot;nlm_lookup_file&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">file_hash</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

	<span class="cm">/* Lock file table */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlm_file_mutex</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nlm_files</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span> <span class="n">f_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_compare_fh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_handle</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">nlm_debug_print_fh</span><span class="p">(</span><span class="s">&quot;creating file for&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

	<span class="n">nfserr</span> <span class="o">=</span> <span class="n">nlm_lck_denied_nolocks</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">file</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_handle</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_fh</span><span class="p">));</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mutex</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_blocks</span><span class="p">);</span>

	<span class="cm">/* Open the file. Note that this must not sleep for too long, else</span>
<span class="cm">	 * we would lock up lockd:-) So no NFS re-exports, folks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We have to make sure we have the right credential to open</span>
<span class="cm">	 * the file.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nfserr</span> <span class="o">=</span> <span class="n">nlmsvc_ops</span><span class="o">-&gt;</span><span class="n">fopen</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_file</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;lockd: open failed (error %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nfserr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nlm_files</span><span class="p">[</span><span class="n">hash</span><span class="p">]);</span>

<span class="nl">found:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;lockd: found file %p (count %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">);</span>
	<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">nfserr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlm_file_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nfserr</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Delete a file after having released all locks, blocks and shares</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">nlm_delete_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nlm_debug_print_file</span><span class="p">(</span><span class="s">&quot;closing file&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_list</span><span class="p">);</span>
		<span class="n">nlmsvc_ops</span><span class="o">-&gt;</span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_file</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;lockd: attempt to release unknown file!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Loop over all locks on the given file and perform the specified</span>
<span class="cm"> * action.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nlm_traverse_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="n">nlm_host_match_fn_t</span> <span class="n">match</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	 <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">nlmsvc_file_inode</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlm_host</span>	 <span class="o">*</span><span class="n">lockhost</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lock_flocks</span><span class="p">();</span> <span class="cm">/* protects i_flock list */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">fl</span><span class="p">;</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">nlmsvc_lock_operations</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* update current lock count */</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_locks</span><span class="o">++</span><span class="p">;</span>

		<span class="n">lockhost</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">)</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_owner</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">lockhost</span><span class="p">,</span> <span class="n">host</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">file_lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>

			<span class="n">unlock_flocks</span><span class="p">();</span>
			<span class="n">lock</span><span class="p">.</span><span class="n">fl_type</span>  <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
			<span class="n">lock</span><span class="p">.</span><span class="n">fl_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">lock</span><span class="p">.</span><span class="n">fl_end</span>   <span class="o">=</span> <span class="n">OFFSET_MAX</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vfs_lock_file</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_file</span><span class="p">,</span> <span class="n">F_SETLK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;lockd: unlock failure in %s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nlmsvc_always_match</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">dummy2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inspect a single file</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">nlm_inspect_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">nlm_host_match_fn_t</span> <span class="n">match</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nlmsvc_traverse_blocks</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">match</span><span class="p">);</span>
	<span class="n">nlmsvc_traverse_shares</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">match</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nlm_traverse_locks</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">match</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Quick check whether there are still any locks, blocks or</span>
<span class="cm"> * shares on a given file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">nlm_file_inuse</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	 <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">nlmsvc_file_inode</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_blocks</span><span class="p">)</span> <span class="o">||</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_shares</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">fl</span><span class="p">;</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">nlmsvc_lock_operations</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlock_flocks</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Loop over all files in the file table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nlm_traverse_files</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">nlm_host_match_fn_t</span> <span class="n">match</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">is_failover_file</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlm_file</span>	<span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlm_file_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FILE_NRHASH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nlm_files</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_failover_file</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_failover_file</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlm_file_mutex</span><span class="p">);</span>

			<span class="cm">/* Traverse locks, blocks and shares of this file</span>
<span class="cm">			 * and update file-&gt;f_locks count */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nlm_inspect_file</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlm_file_mutex</span><span class="p">);</span>
			<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="o">--</span><span class="p">;</span>
			<span class="cm">/* No more references to this file. Let go of it. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_blocks</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_locks</span>
			 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_shares</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_list</span><span class="p">);</span>
				<span class="n">nlmsvc_ops</span><span class="o">-&gt;</span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_file</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlm_file_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release file. If there are no more remote locks on this file,</span>
<span class="cm"> * close it and free the handle.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we can&#39;t do proper reference counting without major</span>
<span class="cm"> * contortions because the code in fs/locks.c creates, deletes and</span>
<span class="cm"> * splits locks without notification. Our only way is to walk the</span>
<span class="cm"> * entire lock list each time we remove a lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">nlm_release_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;lockd: nlm_release_file(%p, ct = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">file</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">);</span>

	<span class="cm">/* Lock file table */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlm_file_mutex</span><span class="p">);</span>

	<span class="cm">/* If there are no more locks etc, delete the file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nlm_file_inuse</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="n">nlm_delete_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlm_file_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helpers function for resource traversal</span>
<span class="cm"> *</span>
<span class="cm"> * nlmsvc_mark_host:</span>
<span class="cm"> *	used by the garbage collector; simply sets h_inuse.</span>
<span class="cm"> *	Always returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * nlmsvc_same_host:</span>
<span class="cm"> *	returns 1 iff the two hosts match. Used to release</span>
<span class="cm"> *	all resources bound to a specific host.</span>
<span class="cm"> *</span>
<span class="cm"> * nlmsvc_is_client:</span>
<span class="cm"> *	returns 1 iff the host is a client.</span>
<span class="cm"> *	Used by nlmsvc_invalidate_all</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nlmsvc_mark_host</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">h_inuse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nlmsvc_same_host</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">host</span> <span class="o">==</span> <span class="n">other</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nlmsvc_is_client</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">h_server</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we are destroying locks even though the client</span>
<span class="cm">		 * hasn&#39;t asked us too, so don&#39;t unmonitor the</span>
<span class="cm">		 * client</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">h_nsmhandle</span><span class="p">)</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">h_nsmhandle</span><span class="o">-&gt;</span><span class="n">sm_sticky</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark all hosts that still hold resources</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">nlmsvc_mark_resources</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;lockd: nlmsvc_mark_resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">nlm_traverse_files</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">nlmsvc_mark_host</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release all resources held by the given client</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">nlmsvc_free_host_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;lockd: nlmsvc_free_host_resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nlm_traverse_files</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">nlmsvc_same_host</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;lockd: couldn&#39;t remove all locks held by %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">h_name</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsvc_invalidate_all - remove all locks held for clients</span>
<span class="cm"> *</span>
<span class="cm"> * Release all locks held by NFS clients.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">nlmsvc_invalidate_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Previously, the code would call</span>
<span class="cm">	 * nlmsvc_free_host_resources for each client in</span>
<span class="cm">	 * turn, which is about as inefficient as it gets.</span>
<span class="cm">	 * Now we just do it once in nlm_traverse_files.</span>
<span class="cm">	 */</span>
	<span class="n">nlm_traverse_files</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">nlmsvc_is_client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nlmsvc_match_sb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">datap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">datap</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sb</span> <span class="o">==</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsvc_unlock_all_by_sb - release locks held on this file system</span>
<span class="cm"> * @sb: super block</span>
<span class="cm"> *</span>
<span class="cm"> * Release all locks held by clients accessing this file system.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">nlmsvc_unlock_all_by_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nlm_traverse_files</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">nlmsvc_always_match</span><span class="p">,</span> <span class="n">nlmsvc_match_sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nlmsvc_unlock_all_by_sb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nlmsvc_match_ip</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">datap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rpc_cmp_addr</span><span class="p">(</span><span class="n">nlm_srcaddr</span><span class="p">(</span><span class="n">host</span><span class="p">),</span> <span class="n">datap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nlmsvc_unlock_all_by_ip - release local locks by IP address</span>
<span class="cm"> * @server_addr: server&#39;s IP address as seen by clients</span>
<span class="cm"> *</span>
<span class="cm"> * Release all locks held by clients accessing this host</span>
<span class="cm"> * via the passed in IP address.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">nlmsvc_unlock_all_by_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">server_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nlm_traverse_files</span><span class="p">(</span><span class="n">server_addr</span><span class="p">,</span> <span class="n">nlmsvc_match_ip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nlmsvc_unlock_all_by_ip</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
