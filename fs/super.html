<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › super.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>super.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/super.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  super.c contains code to handle: - mount structures</span>
<span class="cm"> *                                   - super-block tables</span>
<span class="cm"> *                                   - filesystem drivers list</span>
<span class="cm"> *                                   - mount system call</span>
<span class="cm"> *                                   - umount system call</span>
<span class="cm"> *                                   - ustat system call</span>
<span class="cm"> *</span>
<span class="cm"> * GK 2/5/95  -  Changed to support mounting the root fs via NFS</span>
<span class="cm"> *</span>
<span class="cm"> *  Added kerneld support: Jacques Gelinas and Bjorn Ekwall</span>
<span class="cm"> *  Added change_root: Werner Almesberger &amp; Hans Lermen, Feb &#39;96</span>
<span class="cm"> *  Added options to /proc/mounts:</span>
<span class="cm"> *    Torbjörn Lindh (torbjorn.lindh@gopta.se), April 14, 1996.</span>
<span class="cm"> *  Added devfs support: Richard Gooch &lt;rgooch@atnf.csiro.au&gt;, 13-JAN-1998</span>
<span class="cm"> *  Heavily rewritten for &#39;one fs - one tree&#39; dcache architecture. AV, Mar 2000</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/acct.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;		</span><span class="cm">/* for the emergency remount stuff */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/rculist_bl.h&gt;</span>
<span class="cp">#include &lt;linux/cleancache.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>


<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">super_blocks</span><span class="p">);</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">sb_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * One thing we have to be careful of with a per-sb shrinker is that we don&#39;t</span>
<span class="cm"> * drop the last active reference to the superblock from within the shrinker.</span>
<span class="cm"> * If that happens we could trigger unregistering the shrinker from within the</span>
<span class="cm"> * shrinker path and that leads to deadlock on the shrinker_rwsem. Hence we</span>
<span class="cm"> * take a passive reference to the superblock to avoid this from occurring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">prune_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrink</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">fs_objects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">total_objects</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">shrink</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span><span class="p">,</span> <span class="n">s_shrink</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Deadlock avoidance.  We may hold various FS locks, and we don&#39;t want</span>
<span class="cm">	 * to recurse into the FS that called us in clear_inode() and friends..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_FS</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grab_super_passive</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">nr_cached_objects</span><span class="p">)</span>
		<span class="n">fs_objects</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">nr_cached_objects</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">total_objects</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nr_dentry_unused</span> <span class="o">+</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nr_inodes_unused</span> <span class="o">+</span> <span class="n">fs_objects</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">dentries</span><span class="p">;</span>
		<span class="kt">int</span>	<span class="n">inodes</span><span class="p">;</span>

		<span class="cm">/* proportion the scan between the caches */</span>
		<span class="n">dentries</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span> <span class="o">*</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nr_dentry_unused</span><span class="p">)</span> <span class="o">/</span>
							<span class="n">total_objects</span><span class="p">;</span>
		<span class="n">inodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span> <span class="o">*</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nr_inodes_unused</span><span class="p">)</span> <span class="o">/</span>
							<span class="n">total_objects</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fs_objects</span><span class="p">)</span>
			<span class="n">fs_objects</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span> <span class="o">*</span> <span class="n">fs_objects</span><span class="p">)</span> <span class="o">/</span>
							<span class="n">total_objects</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * prune the dcache first as the icache is pinned by it, then</span>
<span class="cm">		 * prune the icache, followed by the filesystem specific caches</span>
<span class="cm">		 */</span>
		<span class="n">prune_dcache_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">dentries</span><span class="p">);</span>
		<span class="n">prune_icache_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inodes</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fs_objects</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">free_cached_objects</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">free_cached_objects</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fs_objects</span><span class="p">);</span>
			<span class="n">fs_objects</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">nr_cached_objects</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">total_objects</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nr_dentry_unused</span> <span class="o">+</span>
				<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nr_inodes_unused</span> <span class="o">+</span> <span class="n">fs_objects</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">total_objects</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_objects</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="n">sysctl_vfs_cache_pressure</span><span class="p">;</span>
	<span class="n">drop_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">total_objects</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	alloc_super	-	create new superblock</span>
<span class="cm"> *	@type:	filesystem type superblock should belong to</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocates and initializes a new &amp;struct super_block.  alloc_super()</span>
<span class="cm"> *	returns a pointer new superblock or %NULL if allocation had failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">alloc_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span><span class="p">),</span>  <span class="n">GFP_USER</span><span class="p">);</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">default_op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">security_sb_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_files</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_files</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">security_sb_free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
				<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_files</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_files</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_backing_dev_info</span><span class="p">;</span>
		<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">);</span>
		<span class="n">INIT_HLIST_BL_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_anon</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_inodes</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_dentry_lru</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_inode_lru</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_inode_lru_lock</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_mounts</span><span class="p">);</span>
		<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_lock</span><span class="p">);</span>
		<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">s_umount_key</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The locking rules for s_lock are up to the</span>
<span class="cm">		 * filesystem. For example ext3fs has different</span>
<span class="cm">		 * lock ordering than usbfs:</span>
<span class="cm">		 */</span>
		<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">s_lock_key</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * sget() can have s_umount recursion.</span>
<span class="cm">		 *</span>
<span class="cm">		 * When it cannot find a suitable sb, it allocates a new</span>
<span class="cm">		 * one (this one), and tries again to find a suitable old</span>
<span class="cm">		 * one.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In case that succeeds, it will acquire the s_umount</span>
<span class="cm">		 * lock of the old one. Since these are clearly distrinct</span>
<span class="cm">		 * locks, and this object isn&#39;t exposed yet, there&#39;s no</span>
<span class="cm">		 * risk of deadlocks.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Annotate this by putting this lock in a different</span>
<span class="cm">		 * subclass.</span>
<span class="cm">		 */</span>
		<span class="n">down_write_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_vfs_rename_mutex</span><span class="p">);</span>
		<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_vfs_rename_mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">s_vfs_rename_key</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_dquot</span><span class="p">.</span><span class="n">dqio_mutex</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_dquot</span><span class="p">.</span><span class="n">dqonoff_mutex</span><span class="p">);</span>
		<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_dquot</span><span class="p">.</span><span class="n">dqptr_sem</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_wait_unfrozen</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">=</span> <span class="n">MAX_NON_LFS</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_op</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">=</span> <span class="mi">1000000000</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cleancache_poolid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_shrink</span><span class="p">.</span><span class="n">seeks</span> <span class="o">=</span> <span class="n">DEFAULT_SEEKS</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_shrink</span><span class="p">.</span><span class="n">shrink</span> <span class="o">=</span> <span class="n">prune_super</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_shrink</span><span class="p">.</span><span class="n">batch</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	destroy_super	-	frees a superblock</span>
<span class="cm"> *	@s: superblock to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Frees a superblock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">destroy_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_files</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">security_sb_free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_mounts</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_subtype</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_options</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Superblock refcounting  */</span>

<span class="cm">/*</span>
<span class="cm"> * Drop a superblock&#39;s refcount.  The caller must hold sb_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_list</span><span class="p">);</span>
		<span class="n">destroy_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	put_super	-	drop a temporary reference to superblock</span>
<span class="cm"> *	@sb: superblock in question</span>
<span class="cm"> *</span>
<span class="cm"> *	Drops a temporary reference, frees superblock if there&#39;s no</span>
<span class="cm"> *	references left.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">__put_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	deactivate_locked_super	-	drop an active reference to superblock</span>
<span class="cm"> *	@s: superblock to deactivate</span>
<span class="cm"> *</span>
<span class="cm"> *	Drops an active reference to superblock, converting it into a temprory</span>
<span class="cm"> *	one if there is no other active references left.  In that case we</span>
<span class="cm"> *	tell fs driver to shut it down and drop the temporary reference we</span>
<span class="cm"> *	had just acquired.</span>
<span class="cm"> *</span>
<span class="cm"> *	Caller holds exclusive lock on superblock; that lock is released.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">deactivate_locked_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cleancache_invalidate_fs</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">fs</span><span class="o">-&gt;</span><span class="n">kill_sb</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

		<span class="cm">/* caches are now gone, we can safely kill the shrinker now */</span>
		<span class="n">unregister_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_shrink</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to call rcu_barrier so all the delayed rcu free</span>
<span class="cm">		 * inodes are flushed before we release the fs module.</span>
<span class="cm">		 */</span>
		<span class="n">rcu_barrier</span><span class="p">();</span>
		<span class="n">put_filesystem</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
		<span class="n">put_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">deactivate_locked_super</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	deactivate_super	-	drop an active reference to superblock</span>
<span class="cm"> *	@s: superblock to deactivate</span>
<span class="cm"> *</span>
<span class="cm"> *	Variant of deactivate_locked_super(), except that superblock is *not*</span>
<span class="cm"> *	locked by caller.  If we are going to drop the final active reference,</span>
<span class="cm"> *	lock will be acquired prior to that.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">deactivate_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">deactivate_super</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	grab_super - acquire an active reference</span>
<span class="cm"> *	@s: reference we are trying to make active</span>
<span class="cm"> *</span>
<span class="cm"> *	Tries to acquire an active reference.  grab_super() is used when we</span>
<span class="cm"> * 	had just found a superblock in super_blocks or fs_type-&gt;fs_supers</span>
<span class="cm"> *	and want to turn it into a full-blown active reference.  grab_super()</span>
<span class="cm"> *	is called with sb_lock held and drops it.  Returns 1 in case of</span>
<span class="cm"> *	success, 0 if we had failed (superblock contents was already dead or</span>
<span class="cm"> *	dying when grab_super() had been called).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">grab_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">sb_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* it&#39;s going away */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="cm">/* wait for it to die */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="n">put_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	grab_super_passive - acquire a passive reference</span>
<span class="cm"> *	@s: reference we are trying to grab</span>
<span class="cm"> *</span>
<span class="cm"> *	Tries to acquire a passive reference. This is used in places where we</span>
<span class="cm"> *	cannot take an active reference but we need to ensure that the</span>
<span class="cm"> *	superblock does not go away while we are working on it. It returns</span>
<span class="cm"> *	false if a reference was not gained, and returns true with the s_umount</span>
<span class="cm"> *	lock held in read mode if a reference is gained. On successful return,</span>
<span class="cm"> *	the caller must drop the s_umount lock and the passive reference when</span>
<span class="cm"> *	done.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">grab_super_passive</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Superblock locking.  We really ought to get rid of these two.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lock_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lock_super</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unlock_super</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	generic_shutdown_super	-	common helper for -&gt;kill_sb()</span>
<span class="cm"> *	@sb: superblock to kill</span>
<span class="cm"> *</span>
<span class="cm"> *	generic_shutdown_super() does all fs-independent work on superblock</span>
<span class="cm"> *	shutdown.  Typical -&gt;kill_sb() should pick all fs-specific objects</span>
<span class="cm"> *	that need destruction out of superblock, call generic_shutdown_super()</span>
<span class="cm"> *	and release aforementioned objects.  Note: dentries and inodes _are_</span>
<span class="cm"> *	taken care of and do not need specific handling.</span>
<span class="cm"> *</span>
<span class="cm"> *	Upon calling this function, the filesystem may no longer alter or</span>
<span class="cm"> *	rearrange the set of dentries belonging to this super_block, nor may it</span>
<span class="cm"> *	change the attachments of dentries to inodes.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">generic_shutdown_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="o">*</span><span class="n">sop</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shrink_dcache_for_umount</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">sync_filesystem</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MS_ACTIVE</span><span class="p">;</span>

		<span class="n">fsnotify_unmount_inodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inodes</span><span class="p">);</span>

		<span class="n">evict_inodes</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sop</span><span class="o">-&gt;</span><span class="n">put_super</span><span class="p">)</span>
			<span class="n">sop</span><span class="o">-&gt;</span><span class="n">put_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inodes</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;VFS: Busy inodes after unmount of %s. &quot;</span>
			   <span class="s">&quot;Self-destruct in 5 seconds.  Have a nice day...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="cm">/* should be initialized for __put_super_and_need_restart() */</span>
	<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_shutdown_super</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	sget	-	find or create a superblock</span>
<span class="cm"> *	@type:	filesystem type superblock should belong to</span>
<span class="cm"> *	@test:	comparison callback</span>
<span class="cm"> *	@set:	setup callback</span>
<span class="cm"> *	@data:	argument to each of them</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">sget</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fs_supers</span><span class="p">,</span> <span class="n">s_instances</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grab_super</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
				<span class="n">destroy_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">alloc_super</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
		
	<span class="n">err</span> <span class="o">=</span> <span class="n">set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="n">destroy_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">));</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super_blocks</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fs_supers</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">get_filesystem</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="n">register_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_shrink</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sget</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">drop_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="n">put_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">drop_super</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sync_supers - helper for periodic superblock writeback</span>
<span class="cm"> *</span>
<span class="cm"> * Call the write_super method if present on all dirty superblocks in</span>
<span class="cm"> * the system.  This is for the periodic writeback used by most older</span>
<span class="cm"> * filesystems.  For data integrity superblock writeback use</span>
<span class="cm"> * sync_filesystems() instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: check the dirty flag before waiting, so we don&#39;t</span>
<span class="cm"> * hold up the sync while mounting a device. (The newly</span>
<span class="cm"> * mounted device won&#39;t need syncing.)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sync_supers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super_blocks</span><span class="p">,</span> <span class="n">s_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_super</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dirt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>

			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dirt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">))</span>
				<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
				<span class="n">__put_super</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">__put_super</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	iterate_supers - call function for all active superblocks</span>
<span class="cm"> *	@f: function to call</span>
<span class="cm"> *	@arg: argument to pass to it</span>
<span class="cm"> *</span>
<span class="cm"> *	Scans the superblock list and calls given function, passing it</span>
<span class="cm"> *	locked superblock and given argument.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iterate_supers</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super_blocks</span><span class="p">,</span> <span class="n">s_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>

		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">))</span>
			<span class="n">f</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">__put_super</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">__put_super</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	iterate_supers_type - call function for superblocks of given type</span>
<span class="cm"> *	@type: fs type</span>
<span class="cm"> *	@f: function to call</span>
<span class="cm"> *	@arg: argument to pass to it</span>
<span class="cm"> *</span>
<span class="cm"> *	Scans the superblock list and calls given function, passing it</span>
<span class="cm"> *	locked superblock and given argument.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iterate_supers_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fs_supers</span><span class="p">,</span> <span class="n">s_instances</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>

		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">))</span>
			<span class="n">f</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">__put_super</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">__put_super</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iterate_supers_type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	get_super - get the superblock of a device</span>
<span class="cm"> *	@bdev: device to get the superblock for</span>
<span class="cm"> *	</span>
<span class="cm"> *	Scans the superblock list and finds the superblock of the file system</span>
<span class="cm"> *	mounted on the device given. %NULL is returned if no match is found.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">get_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
<span class="nl">rescan:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super_blocks</span><span class="p">,</span> <span class="n">s_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span> <span class="o">==</span> <span class="n">bdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
			<span class="cm">/* still alive? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">sb</span><span class="p">;</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
			<span class="cm">/* nope, got unmounted */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
			<span class="n">__put_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_super</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	get_super_thawed - get thawed superblock of a device</span>
<span class="cm"> *	@bdev: device to get the superblock for</span>
<span class="cm"> *</span>
<span class="cm"> *	Scans the superblock list and finds the superblock of the file system</span>
<span class="cm"> *	mounted on the device. The superblock is returned once it is thawed</span>
<span class="cm"> *	(or immediately if it was not frozen). %NULL is returned if no match</span>
<span class="cm"> *	is found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">get_super_thawed</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">get_super</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">==</span> <span class="n">SB_UNFROZEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="n">vfs_check_frozen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">);</span>
		<span class="n">put_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_super_thawed</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * get_active_super - get an active reference to the superblock of a device</span>
<span class="cm"> * @bdev: device to get the superblock for</span>
<span class="cm"> *</span>
<span class="cm"> * Scans the superblock list and finds the superblock of the file system</span>
<span class="cm"> * mounted on the device given.  Returns the superblock with an active</span>
<span class="cm"> * reference or %NULL if none was found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">get_active_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super_blocks</span><span class="p">,</span> <span class="n">s_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span> <span class="o">==</span> <span class="n">bdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">grab_super</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="cm">/* drops sb_lock */</span>
				<span class="k">return</span> <span class="n">sb</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">user_get_super</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
<span class="nl">rescan:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super_blocks</span><span class="p">,</span> <span class="n">s_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dev</span> <span class="o">==</span>  <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
			<span class="cm">/* still alive? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">sb</span><span class="p">;</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
			<span class="cm">/* nope, got unmounted */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
			<span class="n">__put_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	do_remount_sb - asks filesystem to change mount options.</span>
<span class="cm"> *	@sb:	superblock in question</span>
<span class="cm"> *	@flags:	numeric part of options</span>
<span class="cm"> *	@data:	the rest of options</span>
<span class="cm"> *      @force: whether or not to force the change</span>
<span class="cm"> *</span>
<span class="cm"> *	Alters the mount options of a mounted file system.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">do_remount_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remount_ro</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">!=</span> <span class="n">SB_UNFROZEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bdev_read_only</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="n">acct_auto_close</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">shrink_dcache_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">sync_filesystem</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">remount_ro</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">);</span>

	<span class="cm">/* If we are remounting RDONLY and current sb is read/write,</span>
<span class="cm">	   make sure there are no rw files opened */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remount_ro</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mark_files_ro</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">sb_prepare_remount_readonly</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">remount_fs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">remount_fs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cancel_readonly</span><span class="p">;</span>
			<span class="cm">/* If forced remount, go ahead despite any errors */</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;forced remount of a %s fs returned %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MS_RMT_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RMT_MASK</span><span class="p">);</span>
	<span class="cm">/* Needs to be ordered wrt mnt_is_readonly() */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_readonly_remount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some filesystems modify their metadata via some other path than the</span>
<span class="cm">	 * bdev buffer cache (eg. use a private mapping, or directories in</span>
<span class="cm">	 * pagecache, etc). Also file data modifications go via their own</span>
<span class="cm">	 * mappings. So If we try to mount readonly then copy the filesystem</span>
<span class="cm">	 * from bdev, we could get stale data, so invalidate it to give a best</span>
<span class="cm">	 * effort at coherency.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remount_ro</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">)</span>
		<span class="n">invalidate_bdev</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cancel_readonly:</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_readonly_remount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_emergency_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super_blocks</span><span class="p">,</span> <span class="n">s_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_instances</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * What lock protects sb-&gt;s_flags??</span>
<span class="cm">			 */</span>
			<span class="n">do_remount_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">MS_RDONLY</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">__put_super</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">__put_super</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Emergency Remount complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">emergency_remount</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="n">work</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">do_emergency_remount</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unnamed block devices are dummy devices used by virtual</span>
<span class="cm"> * filesystems which don&#39;t use real block-devices.  -- jrs</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_IDA</span><span class="p">(</span><span class="n">unnamed_dev_ida</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">unnamed_dev_lock</span><span class="p">);</span><span class="cm">/* protects the above */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unnamed_dev_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* don&#39;t bother trying below it */</span>

<span class="kt">int</span> <span class="nf">get_anon_bdev</span><span class="p">(</span><span class="n">dev_t</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

 <span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ida_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_ida</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ida_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_ida</span><span class="p">,</span> <span class="n">unnamed_dev_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">unnamed_dev_start</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="cm">/* We raced and lost with another CPU. */</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span> <span class="o">&amp;</span> <span class="n">MAX_ID_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MINORBITS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_lock</span><span class="p">);</span>
		<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_ida</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unnamed_dev_start</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="p">)</span>
			<span class="n">unnamed_dev_start</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMFILE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span> <span class="o">&amp;</span> <span class="n">MINORMASK</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_anon_bdev</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">free_anon_bdev</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_ida</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">unnamed_dev_start</span><span class="p">)</span>
		<span class="n">unnamed_dev_start</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unnamed_dev_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">free_anon_bdev</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">set_anon_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">get_anon_bdev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">noop_backing_dev_info</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_anon_super</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kill_anon_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_t</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">;</span>
	<span class="n">generic_shutdown_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">free_anon_bdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kill_anon_super</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kill_litter_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span>
		<span class="n">d_genocide</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
	<span class="n">kill_anon_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kill_litter_super</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ns_test_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">==</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ns_set_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">set_anon_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">mount_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">ns_test_super</span><span class="p">,</span> <span class="n">ns_set_super</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fill_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_SILENT</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dget</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mount_ns</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_bdev_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_dev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We set the bdi here to the queue backing, file systems can</span>
<span class="cm">	 * overwrite this in -&gt;fill_super()</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_bdev_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdev</span> <span class="o">==</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">mount_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="n">fmode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FMODE_WRITE</span><span class="p">;</span>

	<span class="n">bdev</span> <span class="o">=</span> <span class="n">blkdev_get_by_path</span><span class="p">(</span><span class="n">dev_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * once the super is inserted into the list by sget, s_umount</span>
<span class="cm">	 * will protect the lockfs code from trying to start a snapshot</span>
<span class="cm">	 * while we are mounting</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_fsfreeze_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_fsfreeze_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_fsfreeze_mutex</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_bdev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">test_bdev_super</span><span class="p">,</span> <span class="n">set_bdev_super</span><span class="p">,</span> <span class="n">bdev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_fsfreeze_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">^</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_bdev</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * s_umount nests inside bd_mutex during</span>
<span class="cm">		 * __invalidate_device().  blkdev_put() acquires</span>
<span class="cm">		 * bd_mutex and can&#39;t be called under s_umount.  Drop</span>
<span class="cm">		 * s_umount temporarily.  This is safe as we&#39;re</span>
<span class="cm">		 * holding an active reference.</span>
<span class="cm">		 */</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="n">blkdev_put</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">MS_NOSEC</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">));</span>
		<span class="n">sb_set_blocksize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">fill_super</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_SILENT</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_ACTIVE</span><span class="p">;</span>
		<span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_super</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dget</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>

<span class="nl">error_s:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="nl">error_bdev:</span>
	<span class="n">blkdev_put</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mount_bdev</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kill_block_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">;</span>
	<span class="n">fmode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_mode</span><span class="p">;</span>

	<span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_super</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">generic_shutdown_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">sync_blockdev</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_EXCL</span><span class="p">));</span>
	<span class="n">blkdev_put</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kill_block_super</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">mount_nodev</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">set_anon_super</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">fill_super</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_SILENT</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_ACTIVE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dget</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mount_nodev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compare_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">mount_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">compare_single</span><span class="p">,</span> <span class="n">set_anon_super</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">fill_super</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_SILENT</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">do_remount_sb</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dget</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mount_single</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">mount_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fs_flags</span> <span class="o">&amp;</span> <span class="n">FS_BINARY_MOUNTDATA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">secdata</span> <span class="o">=</span> <span class="n">alloc_secdata</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">secdata</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">security_sb_copy_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">secdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_secdata</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">mount</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_secdata</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">default_backing_dev_info</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_BORN</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_sb_kern_mount</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">secdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_sb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE</span>
<span class="cm">	 * but s_maxbytes was an unsigned long long for many releases. Throw</span>
<span class="cm">	 * this warning for a little while to try and catch filesystems that</span>
<span class="cm">	 * violate this rule.</span>
<span class="cm">	 */</span>
	<span class="n">WARN</span><span class="p">((</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="s">&quot;%s set sb-&gt;s_maxbytes to &quot;</span>
		<span class="s">&quot;negative value (%lld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="n">free_secdata</span><span class="p">(</span><span class="n">secdata</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="nl">out_sb:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="nl">out_free_secdata:</span>
	<span class="n">free_secdata</span><span class="p">(</span><span class="n">secdata</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * freeze_super - lock the filesystem and force it into a consistent state</span>
<span class="cm"> * @sb: the super to lock</span>
<span class="cm"> *</span>
<span class="cm"> * Syncs the super to make sure the filesystem is consistent and calls the fs&#39;s</span>
<span class="cm"> * freeze_fs.  Subsequent calls to this without first thawing the fs will return</span>
<span class="cm"> * -EBUSY.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">freeze_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_BORN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* sic - it&#39;s &quot;nothing to do&quot; */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">=</span> <span class="n">SB_FREEZE_TRANS</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">=</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">sync_filesystem</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">=</span> <span class="n">SB_FREEZE_TRANS</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">sync_blockdev</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">freeze_fs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">freeze_fs</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;VFS:Filesystem freeze failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">=</span> <span class="n">SB_UNFROZEN</span><span class="p">;</span>
			<span class="n">smp_wmb</span><span class="p">();</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_wait_unfrozen</span><span class="p">);</span>
			<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">freeze_super</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * thaw_super -- unlock filesystem</span>
<span class="cm"> * @sb: the super to thaw</span>
<span class="cm"> *</span>
<span class="cm"> * Unlocks the filesystem and marks it writeable again after freeze_super().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">thaw_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">==</span> <span class="n">SB_UNFROZEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">unfreeze_fs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">unfreeze_fs</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;VFS:Filesystem thaw failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">=</span> <span class="n">SB_FREEZE_TRANS</span><span class="p">;</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">=</span> <span class="n">SB_UNFROZEN</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_wait_unfrozen</span><span class="p">);</span>
	<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">thaw_super</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
