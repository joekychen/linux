<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › configfs › dir.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dir.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * dir.c - Operations for configfs directories.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on sysfs:</span>
<span class="cm"> * 	sysfs is Copyright (C) 2001, 2002, 2003 Patrick Mochel</span>
<span class="cm"> *</span>
<span class="cm"> * configfs Copyright (C) 2005 Oracle.  All rights reserved.</span>
<span class="cm"> */</span>

<span class="cp">#undef DEBUG</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>

<span class="cp">#include &lt;linux/configfs.h&gt;</span>
<span class="cp">#include &quot;configfs_internal.h&quot;</span>

<span class="n">DECLARE_RWSEM</span><span class="p">(</span><span class="n">configfs_rename_sem</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Protects mutations of configfs_dirent linkage together with proper i_mutex</span>
<span class="cm"> * Also protects mutations of symlinks linkage to target configfs_dirent</span>
<span class="cm"> * Mutators of configfs_dirent linkage must *both* have the proper inode locked</span>
<span class="cm"> * and configfs_dirent_lock locked, in that order.</span>
<span class="cm"> * This allows one to safely traverse configfs_dirent trees and symlinks without</span>
<span class="cm"> * having to lock inodes.</span>
<span class="cm"> *</span>
<span class="cm"> * Protects setting of CONFIGFS_USET_DROPPING: checking the flag</span>
<span class="cm"> * unlocked is not reliable unless in detach_groups() called from</span>
<span class="cm"> * rmdir()/unregister() and from configfs_attach_group()</span>
<span class="cm"> */</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_d_iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span> <span class="o">!=</span> <span class="n">dentry</span><span class="p">);</span>
		<span class="cm">/* Coordinate with configfs_readdir */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="n">configfs_put</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We _must_ delete our dentries on last dput, as the chain-to-parent</span>
<span class="cm"> * behavior is required to clear the parents of default_groups.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_d_delete</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">configfs_dentry_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_iput</span>		<span class="o">=</span> <span class="n">configfs_d_iput</span><span class="p">,</span>
	<span class="cm">/* simple_delete_dentry() isn&#39;t exported */</span>
	<span class="p">.</span><span class="n">d_delete</span>	<span class="o">=</span> <span class="n">configfs_d_delete</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>

<span class="cm">/*</span>
<span class="cm"> * Helpers to make lockdep happy with our recursive locking of default groups&#39;</span>
<span class="cm"> * inodes (see configfs_attach_group() and configfs_detach_group()).</span>
<span class="cm"> * We put default groups i_mutexes in separate classes according to their depth</span>
<span class="cm"> * from the youngest non-default group ancestor.</span>
<span class="cm"> *</span>
<span class="cm"> * For a non-default group A having default groups A/B, A/C, and A/C/D, default</span>
<span class="cm"> * groups A/B and A/C will have their inode&#39;s mutex in class</span>
<span class="cm"> * default_group_class[0], and default group A/C/D will be in</span>
<span class="cm"> * default_group_class[1].</span>
<span class="cm"> *</span>
<span class="cm"> * The lock classes are declared and assigned in inode.c, according to the</span>
<span class="cm"> * s_depth value.</span>
<span class="cm"> * The s_depth value is initialized to -1, adjusted to &gt;= 0 when attaching</span>
<span class="cm"> * default groups, and reset to -1 when all default groups are attached. During</span>
<span class="cm"> * attachment, if configfs_create() sees s_depth &gt; 0, the lock class of the new</span>
<span class="cm"> * inode&#39;s mutex is set to default_group_class[s_depth - 1].</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_init_dirent_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_depth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_set_dir_dirent_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">parent_sd</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">parent_depth</span> <span class="o">=</span> <span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_depth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent_depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_depth</span> <span class="o">=</span> <span class="n">parent_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">configfs_adjust_dir_dirent_depth_before_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * item&#39;s i_mutex class is already setup, so s_depth is now only</span>
<span class="cm">	 * used to set new sub-directories s_depth, which is always done</span>
<span class="cm">	 * with item&#39;s i_mutex locked.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 *  sd-&gt;s_depth == -1 iff we are a non default group.</span>
<span class="cm">	 *  else (we are a default group) sd-&gt;s_depth &gt; 0 (see</span>
<span class="cm">	 *  create_dir()).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_depth</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are a non default group and we are going to create</span>
<span class="cm">		 * default groups.</span>
<span class="cm">		 */</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">configfs_adjust_dir_dirent_depth_after_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We will not create default groups anymore. */</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_depth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_LOCKDEP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_init_dirent_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_set_dir_dirent_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">parent_sd</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">configfs_adjust_dir_dirent_depth_before_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">configfs_adjust_dir_dirent_depth_after_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_LOCKDEP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Allocates a new configfs_dirent and links it to the parent configfs_dirent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="nf">configfs_new_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">parent_sd</span><span class="p">,</span>
						   <span class="kt">void</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">sd</span><span class="p">;</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">configfs_dir_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_links</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">);</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">configfs_init_dirent_depth</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_DROPPING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">configfs_dir_cachep</span><span class="p">,</span> <span class="n">sd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Return -EEXIST if there is already a configfs element with the same</span>
<span class="cm"> * name for the same parent.</span>
<span class="cm"> *</span>
<span class="cm"> * called with parent inode&#39;s i_mutex held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_dirent_exists</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">parent_sd</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">sd</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">existing</span> <span class="o">=</span> <span class="n">configfs_get_name</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">existing</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">configfs_make_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">parent_sd</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">element</span><span class="p">,</span>
			 <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">sd</span><span class="p">;</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">configfs_new_dirent</span><span class="p">(</span><span class="n">parent_sd</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>

	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="n">configfs_get</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">configfs_dir_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">configfs_dir_operations</span><span class="p">;</span>

	<span class="cm">/* directory inodes start off with i_nlink == 2 (for &quot;.&quot; entry) */</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_init_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">configfs_file_operations</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">configfs_symlink_inode_operations</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">S_IFDIR</span><span class="o">|</span> <span class="n">S_IRWXU</span> <span class="o">|</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IXUGO</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">k</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">configfs_dirent_exists</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">configfs_make_dirent</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
					     <span class="n">CONFIGFS_DIR</span> <span class="o">|</span> <span class="n">CONFIGFS_USET_CREATING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">configfs_set_dir_dirent_depth</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">configfs_create</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">init_dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inc_nlink</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="n">configfs_put</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	configfs_create_dir - create a directory for an config_item.</span>
<span class="cm"> *	@item:		config_itemwe&#39;re creating directory for.</span>
<span class="cm"> *	@dentry:	config_item&#39;s dentry.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: user-created entries won&#39;t be allowed under this new directory</span>
<span class="cm"> *	until it is validated by configfs_dir_set_ready()</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_create_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span> <span class="n">item</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">create_dir</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allow userspace to create new entries under a new directory created with</span>
<span class="cm"> * configfs_create_dir(), and under all of its chidlren directories recursively.</span>
<span class="cm"> * @sd		configfs_dirent of the new directory to validate</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold configfs_dirent_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_dir_set_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">child_sd</span><span class="p">;</span>

	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CONFIGFS_USET_CREATING</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child_sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">child_sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_CREATING</span><span class="p">)</span>
			<span class="n">configfs_dir_set_ready</span><span class="p">(</span><span class="n">child_sd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check that a directory does not belong to a directory hierarchy being</span>
<span class="cm"> * attached and not validated yet.</span>
<span class="cm"> * @sd		configfs_dirent of the directory to check</span>
<span class="cm"> *</span>
<span class="cm"> * @return	non-zero iff the directory was validated</span>
<span class="cm"> *</span>
<span class="cm"> * Note: takes configfs_dirent_lock, so the result may change from false to true</span>
<span class="cm"> * in two consecutive calls, but never from true to false.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">configfs_dirent_is_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_CREATING</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">configfs_create_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_symlink</span> <span class="o">*</span><span class="n">sl</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">S_IFLNK</span> <span class="o">|</span> <span class="n">S_IRWXUGO</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">configfs_make_dirent</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">sl</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
				   <span class="n">CONFIGFS_ITEM_LINK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">configfs_create</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">init_symlink</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="n">configfs_put</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">sd</span><span class="p">;</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="n">configfs_put</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="n">simple_rmdir</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; o %s removing done (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">);</span>

	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * configfs_remove_dir - remove an config_item&#39;s directory.</span>
<span class="cm"> * @item:	config_item we&#39;re removing.</span>
<span class="cm"> *</span>
<span class="cm"> * The only thing special about this is that we remove any files in</span>
<span class="cm"> * the directory before we remove the directory, and we&#39;ve inlined</span>
<span class="cm"> * what used to be configfs_rmdir() below, instead of calling separately.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller holds the mutex of the item&#39;s inode</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_remove_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">remove_dir</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="cm">/**</span>
<span class="cm">	 * Drop reference from dget() on entrance.</span>
<span class="cm">	 */</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* attaches attribute&#39;s configfs_dirent to the dentry corresponding to the</span>
<span class="cm"> * attribute file</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_attach_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_attribute</span> <span class="o">*</span> <span class="n">attr</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="n">configfs_get</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">configfs_create</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ca_mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">)</span> <span class="o">|</span> <span class="n">S_IFREG</span><span class="p">,</span>
				<span class="n">configfs_init_file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">configfs_put</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d_rehash</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="nf">configfs_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">parent_sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fake invisibility if dir belongs to a group/default groups hierarchy</span>
<span class="cm">	 * being attached</span>
<span class="cm">	 *</span>
<span class="cm">	 * This forbids userspace to read/write attributes of items which may</span>
<span class="cm">	 * not complete their initialization, since the dentries of the</span>
<span class="cm">	 * attributes won&#39;t be instantiated.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">configfs_dirent_is_ready</span><span class="p">(</span><span class="n">parent_sd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_NOT_PINNED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="n">configfs_get_name</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">configfs_attach_attr</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it doesn&#39;t exist and it isn&#39;t a NOT_PINNED item,</span>
<span class="cm">		 * it must be negative.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">NAME_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Only subdirectories count here.  Files (CONFIGFS_NOT_PINNED) are</span>
<span class="cm"> * attributes and are removed by rmdir().  We recurse, setting</span>
<span class="cm"> * CONFIGFS_USET_DROPPING on all children that are candidates for</span>
<span class="cm"> * default detach.</span>
<span class="cm"> * If there is an error, the caller will reset the flags via</span>
<span class="cm"> * configfs_detach_rollback().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_detach_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="o">**</span><span class="n">wait_mutex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">parent_sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Mark that we&#39;re trying to drop the group */</span>
	<span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">|=</span> <span class="n">CONFIGFS_USET_DROPPING</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_links</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_NOT_PINNED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_DEFAULT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Abort if racing with mkdir() */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_IN_MKDIR</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">wait_mutex</span><span class="p">)</span>
					<span class="o">*</span><span class="n">wait_mutex</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Yup, recursive.  If there&#39;s a problem, blame</span>
<span class="cm">			 * deep nesting of default_groups</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_detach_prep</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span><span class="p">,</span> <span class="n">wait_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk the tree, resetting CONFIGFS_USET_DROPPING wherever it was</span>
<span class="cm"> * set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_detach_rollback</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">parent_sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CONFIGFS_USET_DROPPING</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_DEFAULT</span><span class="p">)</span>
			<span class="n">configfs_detach_rollback</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span> <span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_dentry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">parent_sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">sd</span><span class="p">,</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;configfs %s: dropping attrs for  dir</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">parent_sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_NOT_PINNED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="n">configfs_drop_dentry</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
		<span class="n">configfs_put</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/**</span>
<span class="cm">	 * Drop reference from dget() on entrance.</span>
<span class="cm">	 */</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">populate_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">config_item_type</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ct_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">ct_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">configfs_create_file</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">detach_attrs</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">configfs_attach_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">parent_item</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">configfs_detach_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_dentry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">parent_sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">parent_sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_DEFAULT</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">child</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

		<span class="n">configfs_detach_group</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span><span class="p">);</span>
		<span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DEAD</span><span class="p">;</span>
		<span class="n">dont_mount</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

		<span class="n">d_delete</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/**</span>
<span class="cm">	 * Drop reference from dget() on entrance.</span>
<span class="cm">	 */</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This fakes mkdir(2) on a default_groups[] entry.  It</span>
<span class="cm"> * creates a dentry, attachs it, and then does fixup</span>
<span class="cm"> * on the sd-&gt;s_type.</span>
<span class="cm"> *</span>
<span class="cm"> * We could, perhaps, tweak our parent&#39;s -&gt;mkdir for a minute and</span>
<span class="cm"> * try using vfs_mkdir.  Just a thought.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_default_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">parent_group</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="cm">/* We trust the caller holds a reference to parent */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent_group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_dentry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_name</span><span class="p">)</span>
		<span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_name</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_namebuf</span><span class="p">;</span>
	<span class="n">name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_name</span><span class="p">;</span>
	<span class="n">name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">name</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">child</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_attach_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">|=</span> <span class="n">CONFIGFS_USET_DEFAULT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
			<span class="n">d_drop</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">populate_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">new_group</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_group</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">create_default_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">new_group</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">detach_groups</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All of link_obj/unlink_obj/link_group/unlink_group require that</span>
<span class="cm"> * subsys-&gt;su_mutex is held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>

	<span class="n">group</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_group</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_entry</span><span class="p">);</span>

		<span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_group</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Drop the reference for ci_entry */</span>
		<span class="n">config_item_put</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

		<span class="cm">/* Drop the reference for ci_parent */</span>
		<span class="n">config_group_put</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">link_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">parent_item</span><span class="p">,</span> <span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Parent seems redundant with group, but it makes certain</span>
<span class="cm">	 * traversals much nicer.</span>
<span class="cm">	 */</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_parent</span> <span class="o">=</span> <span class="n">parent_item</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We hold a reference on the parent for the child&#39;s ci_parent</span>
<span class="cm">	 * link.</span>
<span class="cm">	 */</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_group</span> <span class="o">=</span> <span class="n">config_group_get</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">));</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_group</span><span class="o">-&gt;</span><span class="n">cg_children</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We hold a reference on the child for ci_entry on the parent&#39;s</span>
<span class="cm">	 * cg_children</span>
<span class="cm">	 */</span>
	<span class="n">config_item_get</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">new_group</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_group</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">unlink_group</span><span class="p">(</span><span class="n">new_group</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_subsys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">unlink_obj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">link_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">parent_group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">new_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_subsystem</span> <span class="o">*</span><span class="n">subsys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* gcc is a turd */</span>

	<span class="n">link_obj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent_group</span><span class="o">-&gt;</span><span class="n">cg_subsys</span><span class="p">)</span>
		<span class="n">subsys</span> <span class="o">=</span> <span class="n">parent_group</span><span class="o">-&gt;</span><span class="n">cg_subsys</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">configfs_is_root</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">))</span>
		<span class="n">subsys</span> <span class="o">=</span> <span class="n">to_configfs_subsystem</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_subsys</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_group</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">default_groups</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">link_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">new_group</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The goal is that configfs_attach_item() (and</span>
<span class="cm"> * configfs_attach_group()) can be called from either the VFS or this</span>
<span class="cm"> * module.  That is, they assume that the items have been created,</span>
<span class="cm"> * the dentry allocated, and the dcache is all ready to go.</span>
<span class="cm"> *</span>
<span class="cm"> * If they fail, they must clean up after themselves as if they</span>
<span class="cm"> * had never been called.  The caller (VFS or local function) will</span>
<span class="cm"> * handle cleaning up the dcache bits.</span>
<span class="cm"> *</span>
<span class="cm"> * configfs_detach_group() and configfs_detach_item() behave similarly on</span>
<span class="cm"> * the way out.  They assume that the proper semaphores are held, they</span>
<span class="cm"> * clean up the configfs items, and they expect their callers will</span>
<span class="cm"> * handle the dcache bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_attach_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">parent_item</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_create_dir</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">populate_attrs</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We are going to remove an inode and its dentry but</span>
<span class="cm">			 * the VFS may already have hit and used them. Thus,</span>
<span class="cm">			 * we must lock them as rmdir() would.</span>
<span class="cm">			 */</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="n">configfs_remove_dir</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DEAD</span><span class="p">;</span>
			<span class="n">dont_mount</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="n">d_delete</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller holds the mutex of the item&#39;s inode */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_detach_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">detach_attrs</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
	<span class="n">configfs_remove_dir</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_attach_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">parent_item</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_attach_item</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">|=</span> <span class="n">CONFIGFS_USET_DIR</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * FYI, we&#39;re faking mkdir in populate_groups()</span>
<span class="cm">		 * We must lock the group&#39;s inode to avoid races with the VFS</span>
<span class="cm">		 * which can already hit the inode and try to add/remove entries</span>
<span class="cm">		 * under it.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We must also lock the inode to remove it safely in case of</span>
<span class="cm">		 * error, as rmdir() would.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_CHILD</span><span class="p">);</span>
		<span class="n">configfs_adjust_dir_dirent_depth_before_populate</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">populate_groups</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">configfs_detach_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DEAD</span><span class="p">;</span>
			<span class="n">dont_mount</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">configfs_adjust_dir_dirent_depth_after_populate</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">d_delete</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller holds the mutex of the group&#39;s inode */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_detach_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">detach_groups</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
	<span class="n">configfs_detach_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After the item has been detached from the filesystem view, we are</span>
<span class="cm"> * ready to tear it out of the hierarchy.  Notify the client before</span>
<span class="cm"> * we do that so they can perform any cleanup that requires</span>
<span class="cm"> * navigating the hierarchy.  A client does not need to provide this</span>
<span class="cm"> * callback.  The subsystem semaphore MUST be held by the caller, and</span>
<span class="cm"> * references must be valid for both items.  It also assumes the</span>
<span class="cm"> * caller has validated ci_type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">client_disconnect_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">parent_item</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">config_item_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">parent_item</span><span class="o">-&gt;</span><span class="n">ci_type</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span> <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">disconnect_notify</span><span class="p">)</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">disconnect_notify</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">),</span>
						      <span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Drop the initial reference from make_item()/make_group()</span>
<span class="cm"> * This function assumes that reference is held on item</span>
<span class="cm"> * and that item holds a valid reference to the parent.  Also, it</span>
<span class="cm"> * assumes the caller has validated ci_type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">client_drop_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">parent_item</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">config_item_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">parent_item</span><span class="o">-&gt;</span><span class="n">ci_type</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If -&gt;drop_item() exists, it is responsible for the</span>
<span class="cm">	 * config_item_put().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span> <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">drop_item</span><span class="p">)</span>
		<span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">drop_item</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">),</span>
					      <span class="n">item</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">config_item_put</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">configfs_dump_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%*s</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">configfs_get_name</span><span class="p">(</span><span class="n">sd</span><span class="p">));</span>

<span class="cp">#define type_print(_type) if (sd-&gt;s_type &amp; _type) printk(KERN_INFO &quot;%*s %s\n&quot;, level, &quot; &quot;, #_type);</span>
	<span class="n">type_print</span><span class="p">(</span><span class="n">CONFIGFS_ROOT</span><span class="p">);</span>
	<span class="n">type_print</span><span class="p">(</span><span class="n">CONFIGFS_DIR</span><span class="p">);</span>
	<span class="n">type_print</span><span class="p">(</span><span class="n">CONFIGFS_ITEM_ATTR</span><span class="p">);</span>
	<span class="n">type_print</span><span class="p">(</span><span class="n">CONFIGFS_ITEM_LINK</span><span class="p">);</span>
	<span class="n">type_print</span><span class="p">(</span><span class="n">CONFIGFS_USET_DIR</span><span class="p">);</span>
	<span class="n">type_print</span><span class="p">(</span><span class="n">CONFIGFS_USET_DEFAULT</span><span class="p">);</span>
	<span class="n">type_print</span><span class="p">(</span><span class="n">CONFIGFS_USET_DROPPING</span><span class="p">);</span>
<span class="cp">#undef type_print</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">child_sd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">configfs_dump_one</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CONFIGFS_DIR</span><span class="o">|</span><span class="n">CONFIGFS_ROOT</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child_sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_dump</span><span class="p">(</span><span class="n">child_sd</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * configfs_depend_item() and configfs_undepend_item()</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: Do not call these from a configfs callback!</span>
<span class="cm"> *</span>
<span class="cm"> * This describes these functions and their helpers.</span>
<span class="cm"> *</span>
<span class="cm"> * Allow another kernel system to depend on a config_item.  If this</span>
<span class="cm"> * happens, the item cannot go away until the dependent can live without</span>
<span class="cm"> * it.  The idea is to give client modules as simple an interface as</span>
<span class="cm"> * possible.  When a system asks them to depend on an item, they just</span>
<span class="cm"> * call configfs_depend_item().  If the item is live and the client</span>
<span class="cm"> * driver is in good shape, we&#39;ll happily do the work for them.</span>
<span class="cm"> *</span>
<span class="cm"> * Why is the locking complex?  Because configfs uses the VFS to handle</span>
<span class="cm"> * all locking, but this function is called outside the normal</span>
<span class="cm"> * VFS-&gt;configfs path.  So it must take VFS locks to prevent the</span>
<span class="cm"> * VFS-&gt;configfs stuff (configfs_mkdir(), configfs_rmdir(), etc).  This is</span>
<span class="cm"> * why you can&#39;t call these functions underneath configfs callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, btw, that this can be called at *any* time, even when a configfs</span>
<span class="cm"> * subsystem isn&#39;t registered, or when configfs is loading or unloading.</span>
<span class="cm"> * Just like configfs_register_subsystem().  So we take the same</span>
<span class="cm"> * precautions.  We pin the filesystem.  We lock configfs_dirent_lock.</span>
<span class="cm"> * If we can find the target item in the</span>
<span class="cm"> * configfs tree, it must be part of the subsystem tree as well, so we</span>
<span class="cm"> * do not need the subsystem semaphore.  Holding configfs_dirent_lock helps</span>
<span class="cm"> * locking out mkdir() and rmdir(), who might be racing us.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * configfs_depend_prep()</span>
<span class="cm"> *</span>
<span class="cm"> * Only subdirectories count here.  Files (CONFIGFS_NOT_PINNED) are</span>
<span class="cm"> * attributes.  This is similar but not the same to configfs_detach_prep().</span>
<span class="cm"> * Note that configfs_detach_prep() expects the parent to be locked when it</span>
<span class="cm"> * is called, but we lock the parent *inside* configfs_depend_prep().  We</span>
<span class="cm"> * do that so we can unlock it if we find nothing.</span>
<span class="cm"> *</span>
<span class="cm"> * Here we do a depth-first search of the dentry hierarchy looking for</span>
<span class="cm"> * our object.</span>
<span class="cm"> * We deliberately ignore items tagged as dropping since they are virtually</span>
<span class="cm"> * dead, as well as items in the middle of attachment since they virtually</span>
<span class="cm"> * do not exist yet. This completes the locking out of racing mkdir() and</span>
<span class="cm"> * rmdir().</span>
<span class="cm"> * Note: subdirectories in the middle of attachment start with s_type =</span>
<span class="cm"> * CONFIGFS_DIR|CONFIGFS_USET_CREATING set by create_dir().  When</span>
<span class="cm"> * CONFIGFS_USET_CREATING is set, we ignore the item.  The actual set of</span>
<span class="cm"> * s_type is in configfs_new_dirent(), which has configfs_dirent_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * If the target is not found, -ENOENT is bubbled up.</span>
<span class="cm"> *</span>
<span class="cm"> * This adds a requirement that all config_items be unique!</span>
<span class="cm"> *</span>
<span class="cm"> * This is recursive.  There isn&#39;t</span>
<span class="cm"> * much on the stack, though, so folks that need this function - be careful</span>
<span class="cm"> * about your stack!  Patches will be accepted to make it iterative.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_depend_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">origin</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">child_sd</span><span class="p">,</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">origin</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">origin</span> <span class="o">||</span> <span class="o">!</span><span class="n">sd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>  <span class="cm">/* Boo-yah */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child_sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">child_sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_DIR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">child_sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_DROPPING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">child_sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_CREATING</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_depend_prep</span><span class="p">(</span><span class="n">child_sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span><span class="p">,</span>
						   <span class="n">target</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>  <span class="cm">/* Child path boo-yah */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We looped all our children and didn&#39;t find target */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">configfs_depend_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_subsystem</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">root_sd</span><span class="p">,</span> <span class="o">*</span><span class="n">subsys_sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">s_item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_group</span><span class="p">.</span><span class="n">cg_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pin the configfs filesystem.  This means we can safely access</span>
<span class="cm">	 * the root of the configfs filesystem.</span>
<span class="cm">	 */</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">configfs_pin_fs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Next, lock the root directory.  We&#39;re going to check that the</span>
<span class="cm">	 * subsystem is really registered, and so we need to lock out</span>
<span class="cm">	 * configfs_[un]register_subsystem().</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">root_sd</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">,</span> <span class="n">s_sibling</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_DIR</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">s_element</span> <span class="o">==</span> <span class="n">s_item</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">subsys_sd</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subsys_sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock_fs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Ok, now we can trust subsys/s_item */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="cm">/* Scan the tree, return 0 if found */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_depend_prep</span><span class="p">(</span><span class="n">subsys_sd</span><span class="o">-&gt;</span><span class="n">s_dentry</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock_dirent_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are sure that the item is not about to be removed by rmdir(), and</span>
<span class="cm">	 * not in the middle of attachment by mkdir().</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">ci_dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">s_dependent_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out_unlock_dirent_lock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
<span class="nl">out_unlock_fs:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we succeeded, the fs is pinned via other methods.  If not,</span>
<span class="cm">	 * we&#39;re done with it anyway.  So release_fs() is always right.</span>
<span class="cm">	 */</span>
	<span class="n">configfs_release_fs</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">configfs_depend_item</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Release the dependent linkage.  This is much simpler than</span>
<span class="cm"> * configfs_depend_item() because we know that that the client driver is</span>
<span class="cm"> * pinned, thus the subsystem is pinned, and therefore configfs is pinned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">configfs_undepend_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_subsystem</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we can trust everything is pinned, we just need</span>
<span class="cm">	 * configfs_dirent_lock.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">ci_dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dependent_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dependent_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * After this unlock, we cannot trust the item to stay alive!</span>
<span class="cm">	 * DO NOT REFERENCE item after this unlock.</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">configfs_undepend_item</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">module_got</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">parent_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_subsystem</span> <span class="o">*</span><span class="n">subsys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_item_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">subsys_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">new_item_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fake invisibility if dir belongs to a group/default groups hierarchy</span>
<span class="cm">	 * being attached</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">configfs_dirent_is_ready</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_DIR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get a working ref for the duration of this function */</span>
	<span class="n">parent_item</span> <span class="o">=</span> <span class="n">configfs_get_config_item</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">parent_item</span><span class="o">-&gt;</span><span class="n">ci_type</span><span class="p">;</span>
	<span class="n">subsys</span> <span class="o">=</span> <span class="n">to_config_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cg_subsys</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">subsys</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span> <span class="o">||</span> <span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">make_group</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">make_item</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>  <span class="cm">/* Lack-of-mkdir returns -EPERM */</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The subsystem may belong to a different module than the item</span>
<span class="cm">	 * being created.  We don&#39;t want to safely pin the new item but</span>
<span class="cm">	 * fail to pin the subsystem it sits under.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_group</span><span class="p">.</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">subsys_owner</span> <span class="o">=</span> <span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_group</span><span class="p">.</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_type</span><span class="o">-&gt;</span><span class="n">ct_owner</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">subsys_owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_subsys_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">make_group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">group</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">make_group</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">),</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span>
			<span class="n">group</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">link_group</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">),</span> <span class="n">group</span><span class="p">);</span>
			<span class="n">item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_group_ops</span><span class="o">-&gt;</span><span class="n">make_item</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">),</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span>
			<span class="n">item</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
			<span class="n">link_obj</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_mutex</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If ret != 0, then link_obj() was never called.</span>
<span class="cm">		 * There are no extra references to clean up.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out_subsys_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * link_obj() has been called (via link_group() for groups).</span>
<span class="cm">	 * From here on out, errors must clean that up.</span>
<span class="cm">	 */</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlink</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new_item_owner</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">ct_owner</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">new_item_owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlink</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * I hate doing it this way, but if there is</span>
<span class="cm">	 * an error,  module_put() probably should</span>
<span class="cm">	 * happen after any cleanup.</span>
<span class="cm">	 */</span>
	<span class="n">module_got</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make racing rmdir() fail if it did not tag parent with</span>
<span class="cm">	 * CONFIGFS_USET_DROPPING</span>
<span class="cm">	 * Note: if CONFIGFS_USET_DROPPING is already set, attach_group() will</span>
<span class="cm">	 * fail and let rmdir() terminate correctly</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="cm">/* This will make configfs_detach_prep() fail */</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">|=</span> <span class="n">CONFIGFS_USET_IN_MKDIR</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_attach_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_attach_item</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CONFIGFS_USET_IN_MKDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">configfs_dir_set_ready</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>

<span class="nl">out_unlink:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Tear down everything we built up */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_mutex</span><span class="p">);</span>

		<span class="n">client_disconnect_notify</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="p">)</span>
			<span class="n">unlink_group</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">unlink_obj</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
		<span class="n">client_drop_item</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">module_got</span><span class="p">)</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">new_item_owner</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_subsys_put:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">subsys_owner</span><span class="p">);</span>

<span class="nl">out_put:</span>
	<span class="cm">/*</span>
<span class="cm">	 * link_obj()/link_group() took a reference from child-&gt;parent,</span>
<span class="cm">	 * so the parent is safely pinned.  We can drop our working</span>
<span class="cm">	 * reference.</span>
<span class="cm">	 */</span>
	<span class="n">config_item_put</span><span class="p">(</span><span class="n">parent_item</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">parent_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_subsystem</span> <span class="o">*</span><span class="n">subsys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">subsys_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">dead_item_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* Get a working ref until we have the child */</span>
	<span class="n">parent_item</span> <span class="o">=</span> <span class="n">configfs_get_config_item</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
	<span class="n">subsys</span> <span class="o">=</span> <span class="n">to_config_group</span><span class="p">(</span><span class="n">parent_item</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cg_subsys</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">subsys</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent_item</span><span class="o">-&gt;</span><span class="n">ci_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">config_item_put</span><span class="p">(</span><span class="n">parent_item</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* configfs_mkdir() shouldn&#39;t have allowed this */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_group</span><span class="p">.</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_type</span><span class="p">);</span>
	<span class="n">subsys_owner</span> <span class="o">=</span> <span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_group</span><span class="p">.</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_type</span><span class="o">-&gt;</span><span class="n">ct_owner</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that no racing symlink() will make detach_prep() fail while</span>
<span class="cm">	 * the new link is temporarily attached</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">wait_mutex</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_symlink_mutex</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Here&#39;s where we check for dependents.  We&#39;re protected by</span>
<span class="cm">		 * configfs_dirent_lock.</span>
<span class="cm">		 * If no dependent, atomically tag the item as dropping.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_dependent_count</span> <span class="o">?</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">configfs_detach_prep</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">configfs_detach_rollback</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_symlink_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">config_item_put</span><span class="p">(</span><span class="n">parent_item</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Wait until the racing operation terminates */</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">wait_mutex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="cm">/* Get a working ref for the duration of this function */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">configfs_get_config_item</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="cm">/* Drop reference from above, item already holds one. */</span>
	<span class="n">config_item_put</span><span class="p">(</span><span class="n">parent_item</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_type</span><span class="p">)</span>
		<span class="n">dead_item_owner</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ci_type</span><span class="o">-&gt;</span><span class="n">ct_owner</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_type</span> <span class="o">&amp;</span> <span class="n">CONFIGFS_USET_DIR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">configfs_detach_group</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_mutex</span><span class="p">);</span>
		<span class="n">client_disconnect_notify</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="n">unlink_group</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">configfs_detach_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_mutex</span><span class="p">);</span>
		<span class="n">client_disconnect_notify</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="n">unlink_obj</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">client_drop_item</span><span class="p">(</span><span class="n">parent_item</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_mutex</span><span class="p">);</span>

	<span class="cm">/* Drop our reference from above */</span>
	<span class="n">config_item_put</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

	<span class="n">module_put</span><span class="p">(</span><span class="n">dead_item_owner</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">subsys_owner</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">configfs_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mkdir</span>		<span class="o">=</span> <span class="n">configfs_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span>		<span class="o">=</span> <span class="n">configfs_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>	<span class="o">=</span> <span class="n">configfs_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>		<span class="o">=</span> <span class="n">configfs_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">configfs_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">configfs_setattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">configfs_root_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">configfs_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">configfs_setattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int configfs_rename_dir(struct config_item * item, const char *new_name)</span>
<span class="c">{</span>
<span class="c">	int error = 0;</span>
<span class="c">	struct dentry * new_dentry, * parent;</span>

<span class="c">	if (!strcmp(config_item_name(item), new_name))</span>
<span class="c">		return -EINVAL;</span>

<span class="c">	if (!item-&gt;parent)</span>
<span class="c">		return -EINVAL;</span>

<span class="c">	down_write(&amp;configfs_rename_sem);</span>
<span class="c">	parent = item-&gt;parent-&gt;dentry;</span>

<span class="c">	mutex_lock(&amp;parent-&gt;d_inode-&gt;i_mutex);</span>

<span class="c">	new_dentry = lookup_one_len(new_name, parent, strlen(new_name));</span>
<span class="c">	if (!IS_ERR(new_dentry)) {</span>
<span class="c">		if (!new_dentry-&gt;d_inode) {</span>
<span class="c">			error = config_item_set_name(item, &quot;%s&quot;, new_name);</span>
<span class="c">			if (!error) {</span>
<span class="c">				d_add(new_dentry, NULL);</span>
<span class="c">				d_move(item-&gt;dentry, new_dentry);</span>
<span class="c">			}</span>
<span class="c">			else</span>
<span class="c">				d_delete(new_dentry);</span>
<span class="c">		} else</span>
<span class="c">			error = -EEXIST;</span>
<span class="c">		dput(new_dentry);</span>
<span class="c">	}</span>
<span class="c">	mutex_unlock(&amp;parent-&gt;d_inode-&gt;i_mutex);</span>
<span class="c">	up_write(&amp;configfs_rename_sem);</span>

<span class="c">	return error;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_dir_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">parent_sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fake invisibility if dir belongs to a group/default groups hierarchy</span>
<span class="cm">	 * being attached</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">configfs_dirent_is_ready</span><span class="p">(</span><span class="n">parent_sd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">configfs_new_dirent</span><span class="p">(</span><span class="n">parent_sd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_dir_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">release_configfs_dirent</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Relationship between s_mode and the DT_xxx types */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">dt_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_mode</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">configfs_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span> <span class="n">parent_sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">ino</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* fallthrough */</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">ino</span> <span class="o">=</span> <span class="n">parent_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* fallthrough */</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="n">list_move</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">p</span><span class="o">!=</span> <span class="o">&amp;</span><span class="n">parent_sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">;</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

				<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">configfs_dirent</span><span class="p">,</span>
						   <span class="n">s_sibling</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">s_element</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">name</span> <span class="o">=</span> <span class="n">configfs_get_name</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * We&#39;ll have a dentry and an inode for</span>
<span class="cm">				 * PINNED items and for open attribute</span>
<span class="cm">				 * files.  We lock here to prevent a race</span>
<span class="cm">				 * with configfs_d_iput() clearing</span>
<span class="cm">				 * s_dentry before calling iput().</span>
<span class="cm">				 *</span>
<span class="cm">				 * Why do we go to the trouble?  If</span>
<span class="cm">				 * someone has an attribute file open,</span>
<span class="cm">				 * the inode number should match until</span>
<span class="cm">				 * they close it.  Beyond that, we don&#39;t</span>
<span class="cm">				 * care.</span>
<span class="cm">				 */</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="n">dentry</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">s_dentry</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
					<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
					<span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
					<span class="n">ino</span> <span class="o">=</span> <span class="n">iunique</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span>
						 <span class="n">dt_type</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="n">list_move</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
				<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">configfs_dir_lseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
			<span class="n">loff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_children</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">configfs_dirent</span><span class="p">,</span>
						   <span class="n">s_sibling</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">s_element</span><span class="p">)</span>
					<span class="n">n</span><span class="o">--</span><span class="p">;</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">s_sibling</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">configfs_dir_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">configfs_dir_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">configfs_dir_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">configfs_dir_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">configfs_readdir</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">configfs_register_subsystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_subsystem</span> <span class="o">*</span><span class="n">subsys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">configfs_dirent</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">configfs_pin_fs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_name</span><span class="p">)</span>
		<span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_name</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_namebuf</span><span class="p">;</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="n">link_group</span><span class="p">(</span><span class="n">to_config_group</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span><span class="p">),</span> <span class="n">group</span><span class="p">);</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>

	<span class="n">name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_name</span><span class="p">;</span>
	<span class="n">name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">name</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">configfs_attach_group</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">s_element</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">,</span>
					    <span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
			<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
			<span class="n">configfs_dir_set_ready</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlink_group</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
		<span class="n">configfs_release_fs</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">configfs_unregister_subsystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">configfs_subsystem</span> <span class="o">*</span><span class="n">subsys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">config_group</span> <span class="o">*</span><span class="n">group</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">su_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">.</span><span class="n">ci_dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;configfs: Tried to unregister non-subsystem!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span>
			  <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_CHILD</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_symlink_mutex</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">configfs_detach_prep</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;configfs: Tried to unregister non-empty subsystem!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_dirent_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configfs_symlink_mutex</span><span class="p">);</span>
	<span class="n">configfs_detach_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">cg_item</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DEAD</span><span class="p">;</span>
	<span class="n">dont_mount</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">d_delete</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">unlink_group</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
	<span class="n">configfs_release_fs</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">configfs_register_subsystem</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">configfs_unregister_subsystem</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
