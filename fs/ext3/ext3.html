<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext3 › ext3.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ext3.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1999</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1998--1999 Red Hat corp --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/include/linux/minix_fs.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/blockgroup_lock.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The second extended filesystem constants/structures</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Define EXT3FS_DEBUG to produce debug messages</span>
<span class="cm"> */</span>
<span class="cp">#undef EXT3FS_DEBUG</span>

<span class="cm">/*</span>
<span class="cm"> * Define EXT3_RESERVATION to reserve data blocks for expanding files</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_DEFAULT_RESERVE_BLOCKS     8</span>
<span class="cm">/*max window size: 1024(direct blocks) + 3([t,d]indirect blocks) */</span>
<span class="cp">#define EXT3_MAX_RESERVE_BLOCKS         1027</span>
<span class="cp">#define EXT3_RESERVE_WINDOW_NOT_ALLOCATED 0</span>

<span class="cm">/*</span>
<span class="cm"> * Debug code</span>
<span class="cm"> */</span>
<span class="cp">#ifdef EXT3FS_DEBUG</span>
<span class="cp">#define ext3_debug(f, a...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		printk (KERN_DEBUG &quot;EXT3-fs DEBUG (%s, %d): %s:&quot;,	\</span>
<span class="cp">			__FILE__, __LINE__, __func__);		\</span>
<span class="cp">		printk (KERN_DEBUG f, ## a);				\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define ext3_debug(f, a...)	do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Special inodes numbers</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT3_BAD_INO		 1	</span><span class="cm">/* Bad blocks inode */</span><span class="cp"></span>
<span class="cp">#define EXT3_ROOT_INO		 2	</span><span class="cm">/* Root inode */</span><span class="cp"></span>
<span class="cp">#define EXT3_BOOT_LOADER_INO	 5	</span><span class="cm">/* Boot loader inode */</span><span class="cp"></span>
<span class="cp">#define EXT3_UNDEL_DIR_INO	 6	</span><span class="cm">/* Undelete directory inode */</span><span class="cp"></span>
<span class="cp">#define EXT3_RESIZE_INO		 7	</span><span class="cm">/* Reserved group descriptors inode */</span><span class="cp"></span>
<span class="cp">#define EXT3_JOURNAL_INO	 8	</span><span class="cm">/* Journal inode */</span><span class="cp"></span>

<span class="cm">/* First non-reserved inode for old ext3 filesystems */</span>
<span class="cp">#define EXT3_GOOD_OLD_FIRST_INO	11</span>

<span class="cm">/*</span>
<span class="cm"> * Maximal count of links to a file</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_LINK_MAX		32000</span>

<span class="cm">/*</span>
<span class="cm"> * Macro-instructions used to manage several block sizes</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_MIN_BLOCK_SIZE		1024</span>
<span class="cp">#define	EXT3_MAX_BLOCK_SIZE		65536</span>
<span class="cp">#define EXT3_MIN_BLOCK_LOG_SIZE		10</span>
<span class="cp">#define EXT3_BLOCK_SIZE(s)		((s)-&gt;s_blocksize)</span>
<span class="cp">#define	EXT3_ADDR_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (__u32))</span>
<span class="cp">#define EXT3_BLOCK_SIZE_BITS(s)	((s)-&gt;s_blocksize_bits)</span>
<span class="cp">#define	EXT3_ADDR_PER_BLOCK_BITS(s)	(EXT3_SB(s)-&gt;s_addr_per_block_bits)</span>
<span class="cp">#define EXT3_INODE_SIZE(s)		(EXT3_SB(s)-&gt;s_inode_size)</span>
<span class="cp">#define EXT3_FIRST_INO(s)		(EXT3_SB(s)-&gt;s_first_ino)</span>

<span class="cm">/*</span>
<span class="cm"> * Macro-instructions used to manage fragments</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_MIN_FRAG_SIZE		1024</span>
<span class="cp">#define	EXT3_MAX_FRAG_SIZE		4096</span>
<span class="cp">#define EXT3_MIN_FRAG_LOG_SIZE		  10</span>
<span class="cp">#define EXT3_FRAG_SIZE(s)		(EXT3_SB(s)-&gt;s_frag_size)</span>
<span class="cp">#define EXT3_FRAGS_PER_BLOCK(s)		(EXT3_SB(s)-&gt;s_frags_per_block)</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of a blocks group descriptor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_group_desc</span>
<span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">bg_block_bitmap</span><span class="p">;</span>		<span class="cm">/* Blocks bitmap block */</span>
	<span class="n">__le32</span>	<span class="n">bg_inode_bitmap</span><span class="p">;</span>		<span class="cm">/* Inodes bitmap block */</span>
	<span class="n">__le32</span>	<span class="n">bg_inode_table</span><span class="p">;</span>		<span class="cm">/* Inodes table block */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_blocks_count</span><span class="p">;</span>	<span class="cm">/* Free blocks count */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_inodes_count</span><span class="p">;</span>	<span class="cm">/* Free inodes count */</span>
	<span class="n">__le16</span>	<span class="n">bg_used_dirs_count</span><span class="p">;</span>	<span class="cm">/* Directories count */</span>
	<span class="n">__u16</span>	<span class="n">bg_pad</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">bg_reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Macro-instructions used to manage group descriptors</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_BLOCKS_PER_GROUP(s)	(EXT3_SB(s)-&gt;s_blocks_per_group)</span>
<span class="cp">#define EXT3_DESC_PER_BLOCK(s)		(EXT3_SB(s)-&gt;s_desc_per_block)</span>
<span class="cp">#define EXT3_INODES_PER_GROUP(s)	(EXT3_SB(s)-&gt;s_inodes_per_group)</span>
<span class="cp">#define EXT3_DESC_PER_BLOCK_BITS(s)	(EXT3_SB(s)-&gt;s_desc_per_block_bits)</span>

<span class="cm">/*</span>
<span class="cm"> * Constants relative to the data blocks</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT3_NDIR_BLOCKS		12</span>
<span class="cp">#define	EXT3_IND_BLOCK			EXT3_NDIR_BLOCKS</span>
<span class="cp">#define	EXT3_DIND_BLOCK			(EXT3_IND_BLOCK + 1)</span>
<span class="cp">#define	EXT3_TIND_BLOCK			(EXT3_DIND_BLOCK + 1)</span>
<span class="cp">#define	EXT3_N_BLOCKS			(EXT3_TIND_BLOCK + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Inode flags</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT3_SECRM_FL			0x00000001 </span><span class="cm">/* Secure deletion */</span><span class="cp"></span>
<span class="cp">#define	EXT3_UNRM_FL			0x00000002 </span><span class="cm">/* Undelete */</span><span class="cp"></span>
<span class="cp">#define	EXT3_COMPR_FL			0x00000004 </span><span class="cm">/* Compress file */</span><span class="cp"></span>
<span class="cp">#define EXT3_SYNC_FL			0x00000008 </span><span class="cm">/* Synchronous updates */</span><span class="cp"></span>
<span class="cp">#define EXT3_IMMUTABLE_FL		0x00000010 </span><span class="cm">/* Immutable file */</span><span class="cp"></span>
<span class="cp">#define EXT3_APPEND_FL			0x00000020 </span><span class="cm">/* writes to file may only append */</span><span class="cp"></span>
<span class="cp">#define EXT3_NODUMP_FL			0x00000040 </span><span class="cm">/* do not dump file */</span><span class="cp"></span>
<span class="cp">#define EXT3_NOATIME_FL			0x00000080 </span><span class="cm">/* do not update atime */</span><span class="cp"></span>
<span class="cm">/* Reserved for compression usage... */</span>
<span class="cp">#define EXT3_DIRTY_FL			0x00000100</span>
<span class="cp">#define EXT3_COMPRBLK_FL		0x00000200 </span><span class="cm">/* One or more compressed clusters */</span><span class="cp"></span>
<span class="cp">#define EXT3_NOCOMPR_FL			0x00000400 </span><span class="cm">/* Don&#39;t compress */</span><span class="cp"></span>
<span class="cp">#define EXT3_ECOMPR_FL			0x00000800 </span><span class="cm">/* Compression error */</span><span class="cp"></span>
<span class="cm">/* End compression flags --- maybe not all used */</span>
<span class="cp">#define EXT3_INDEX_FL			0x00001000 </span><span class="cm">/* hash-indexed directory */</span><span class="cp"></span>
<span class="cp">#define EXT3_IMAGIC_FL			0x00002000 </span><span class="cm">/* AFS directory */</span><span class="cp"></span>
<span class="cp">#define EXT3_JOURNAL_DATA_FL		0x00004000 </span><span class="cm">/* file data should be journaled */</span><span class="cp"></span>
<span class="cp">#define EXT3_NOTAIL_FL			0x00008000 </span><span class="cm">/* file tail should not be merged */</span><span class="cp"></span>
<span class="cp">#define EXT3_DIRSYNC_FL			0x00010000 </span><span class="cm">/* dirsync behaviour (directories only) */</span><span class="cp"></span>
<span class="cp">#define EXT3_TOPDIR_FL			0x00020000 </span><span class="cm">/* Top of directory hierarchies*/</span><span class="cp"></span>
<span class="cp">#define EXT3_RESERVED_FL		0x80000000 </span><span class="cm">/* reserved for ext3 lib */</span><span class="cp"></span>

<span class="cp">#define EXT3_FL_USER_VISIBLE		0x0003DFFF </span><span class="cm">/* User visible flags */</span><span class="cp"></span>
<span class="cp">#define EXT3_FL_USER_MODIFIABLE		0x000380FF </span><span class="cm">/* User modifiable flags */</span><span class="cp"></span>

<span class="cm">/* Flags that should be inherited by new inodes from their parent. */</span>
<span class="cp">#define EXT3_FL_INHERITED (EXT3_SECRM_FL | EXT3_UNRM_FL | EXT3_COMPR_FL |\</span>
<span class="cp">			   EXT3_SYNC_FL | EXT3_NODUMP_FL |\</span>
<span class="cp">			   EXT3_NOATIME_FL | EXT3_COMPRBLK_FL |\</span>
<span class="cp">			   EXT3_NOCOMPR_FL | EXT3_JOURNAL_DATA_FL |\</span>
<span class="cp">			   EXT3_NOTAIL_FL | EXT3_DIRSYNC_FL)</span>

<span class="cm">/* Flags that are appropriate for regular files (all but dir-specific ones). */</span>
<span class="cp">#define EXT3_REG_FLMASK (~(EXT3_DIRSYNC_FL | EXT3_TOPDIR_FL))</span>

<span class="cm">/* Flags that are appropriate for non-directories/regular files. */</span>
<span class="cp">#define EXT3_OTHER_FLMASK (EXT3_NODUMP_FL | EXT3_NOATIME_FL)</span>

<span class="cm">/* Mask out flags that are inappropriate for the given type of inode. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ext3_mask_flags</span><span class="p">(</span><span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT3_REG_FLMASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT3_OTHER_FLMASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Used to pass group descriptor data when online resize is done */</span>
<span class="k">struct</span> <span class="n">ext3_new_group_input</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">group</span><span class="p">;</span>            <span class="cm">/* Group number for this data */</span>
	<span class="n">__u32</span> <span class="n">block_bitmap</span><span class="p">;</span>     <span class="cm">/* Absolute block number of block bitmap */</span>
	<span class="n">__u32</span> <span class="n">inode_bitmap</span><span class="p">;</span>     <span class="cm">/* Absolute block number of inode bitmap */</span>
	<span class="n">__u32</span> <span class="n">inode_table</span><span class="p">;</span>      <span class="cm">/* Absolute block number of inode table start */</span>
	<span class="n">__u32</span> <span class="n">blocks_count</span><span class="p">;</span>     <span class="cm">/* Total number of blocks in this group */</span>
	<span class="n">__u16</span> <span class="n">reserved_blocks</span><span class="p">;</span>  <span class="cm">/* Number of reserved blocks in this group */</span>
	<span class="n">__u16</span> <span class="n">unused</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The struct ext3_new_group_input in kernel space, with free_blocks_count */</span>
<span class="k">struct</span> <span class="n">ext3_new_group_data</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">group</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">block_bitmap</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">inode_bitmap</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">inode_table</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">blocks_count</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">reserved_blocks</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">unused</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">free_blocks_count</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * ioctl commands</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT3_IOC_GETFLAGS		FS_IOC_GETFLAGS</span>
<span class="cp">#define	EXT3_IOC_SETFLAGS		FS_IOC_SETFLAGS</span>
<span class="cp">#define	EXT3_IOC_GETVERSION		_IOR(&#39;f&#39;, 3, long)</span>
<span class="cp">#define	EXT3_IOC_SETVERSION		_IOW(&#39;f&#39;, 4, long)</span>
<span class="cp">#define EXT3_IOC_GROUP_EXTEND		_IOW(&#39;f&#39;, 7, unsigned long)</span>
<span class="cp">#define EXT3_IOC_GROUP_ADD		_IOW(&#39;f&#39;, 8,struct ext3_new_group_input)</span>
<span class="cp">#define	EXT3_IOC_GETVERSION_OLD		FS_IOC_GETVERSION</span>
<span class="cp">#define	EXT3_IOC_SETVERSION_OLD		FS_IOC_SETVERSION</span>
<span class="cp">#ifdef CONFIG_JBD_DEBUG</span>
<span class="cp">#define EXT3_IOC_WAIT_FOR_READONLY	_IOR(&#39;f&#39;, 99, long)</span>
<span class="cp">#endif</span>
<span class="cp">#define EXT3_IOC_GETRSVSZ		_IOR(&#39;f&#39;, 5, long)</span>
<span class="cp">#define EXT3_IOC_SETRSVSZ		_IOW(&#39;f&#39;, 6, long)</span>

<span class="cm">/*</span>
<span class="cm"> * ioctl commands in 32 bit emulation</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_IOC32_GETFLAGS		FS_IOC32_GETFLAGS</span>
<span class="cp">#define EXT3_IOC32_SETFLAGS		FS_IOC32_SETFLAGS</span>
<span class="cp">#define EXT3_IOC32_GETVERSION		_IOR(&#39;f&#39;, 3, int)</span>
<span class="cp">#define EXT3_IOC32_SETVERSION		_IOW(&#39;f&#39;, 4, int)</span>
<span class="cp">#define EXT3_IOC32_GETRSVSZ		_IOR(&#39;f&#39;, 5, int)</span>
<span class="cp">#define EXT3_IOC32_SETRSVSZ		_IOW(&#39;f&#39;, 6, int)</span>
<span class="cp">#define EXT3_IOC32_GROUP_EXTEND		_IOW(&#39;f&#39;, 7, unsigned int)</span>
<span class="cp">#ifdef CONFIG_JBD_DEBUG</span>
<span class="cp">#define EXT3_IOC32_WAIT_FOR_READONLY	_IOR(&#39;f&#39;, 99, int)</span>
<span class="cp">#endif</span>
<span class="cp">#define EXT3_IOC32_GETVERSION_OLD	FS_IOC32_GETVERSION</span>
<span class="cp">#define EXT3_IOC32_SETVERSION_OLD	FS_IOC32_SETVERSION</span>


<span class="cm">/*</span>
<span class="cm"> *  Mount options</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_mount_options</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_mount_opt</span><span class="p">;</span>
	<span class="n">kuid_t</span> <span class="n">s_resuid</span><span class="p">;</span>
	<span class="n">kgid_t</span> <span class="n">s_resgid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_commit_interval</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="kt">int</span> <span class="n">s_jquota_fmt</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s_qf_names</span><span class="p">[</span><span class="n">MAXQUOTAS</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of an inode on the disk</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_inode</span> <span class="p">{</span>
	<span class="n">__le16</span>	<span class="n">i_mode</span><span class="p">;</span>		<span class="cm">/* File mode */</span>
	<span class="n">__le16</span>	<span class="n">i_uid</span><span class="p">;</span>		<span class="cm">/* Low 16 bits of Owner Uid */</span>
	<span class="n">__le32</span>	<span class="n">i_size</span><span class="p">;</span>		<span class="cm">/* Size in bytes */</span>
	<span class="n">__le32</span>	<span class="n">i_atime</span><span class="p">;</span>	<span class="cm">/* Access time */</span>
	<span class="n">__le32</span>	<span class="n">i_ctime</span><span class="p">;</span>	<span class="cm">/* Creation time */</span>
	<span class="n">__le32</span>	<span class="n">i_mtime</span><span class="p">;</span>	<span class="cm">/* Modification time */</span>
	<span class="n">__le32</span>	<span class="n">i_dtime</span><span class="p">;</span>	<span class="cm">/* Deletion Time */</span>
	<span class="n">__le16</span>	<span class="n">i_gid</span><span class="p">;</span>		<span class="cm">/* Low 16 bits of Group Id */</span>
	<span class="n">__le16</span>	<span class="n">i_links_count</span><span class="p">;</span>	<span class="cm">/* Links count */</span>
	<span class="n">__le32</span>	<span class="n">i_blocks</span><span class="p">;</span>	<span class="cm">/* Blocks count */</span>
	<span class="n">__le32</span>	<span class="n">i_flags</span><span class="p">;</span>	<span class="cm">/* File flags */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u32</span>  <span class="n">l_i_reserved1</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">linux1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u32</span>  <span class="n">h_i_translator</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">hurd1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u32</span>  <span class="n">m_i_reserved1</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">masix1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">osd1</span><span class="p">;</span>				<span class="cm">/* OS dependent 1 */</span>
	<span class="n">__le32</span>	<span class="n">i_block</span><span class="p">[</span><span class="n">EXT3_N_BLOCKS</span><span class="p">];</span><span class="cm">/* Pointers to blocks */</span>
	<span class="n">__le32</span>	<span class="n">i_generation</span><span class="p">;</span>	<span class="cm">/* File version (for NFS) */</span>
	<span class="n">__le32</span>	<span class="n">i_file_acl</span><span class="p">;</span>	<span class="cm">/* File ACL */</span>
	<span class="n">__le32</span>	<span class="n">i_dir_acl</span><span class="p">;</span>	<span class="cm">/* Directory ACL */</span>
	<span class="n">__le32</span>	<span class="n">i_faddr</span><span class="p">;</span>	<span class="cm">/* Fragment address */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span>	<span class="n">l_i_frag</span><span class="p">;</span>	<span class="cm">/* Fragment number */</span>
			<span class="n">__u8</span>	<span class="n">l_i_fsize</span><span class="p">;</span>	<span class="cm">/* Fragment size */</span>
			<span class="n">__u16</span>	<span class="n">i_pad1</span><span class="p">;</span>
			<span class="n">__le16</span>	<span class="n">l_i_uid_high</span><span class="p">;</span>	<span class="cm">/* these 2 fields    */</span>
			<span class="n">__le16</span>	<span class="n">l_i_gid_high</span><span class="p">;</span>	<span class="cm">/* were reserved2[0] */</span>
			<span class="n">__u32</span>	<span class="n">l_i_reserved2</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">linux2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span>	<span class="n">h_i_frag</span><span class="p">;</span>	<span class="cm">/* Fragment number */</span>
			<span class="n">__u8</span>	<span class="n">h_i_fsize</span><span class="p">;</span>	<span class="cm">/* Fragment size */</span>
			<span class="n">__u16</span>	<span class="n">h_i_mode_high</span><span class="p">;</span>
			<span class="n">__u16</span>	<span class="n">h_i_uid_high</span><span class="p">;</span>
			<span class="n">__u16</span>	<span class="n">h_i_gid_high</span><span class="p">;</span>
			<span class="n">__u32</span>	<span class="n">h_i_author</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">hurd2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span>	<span class="n">m_i_frag</span><span class="p">;</span>	<span class="cm">/* Fragment number */</span>
			<span class="n">__u8</span>	<span class="n">m_i_fsize</span><span class="p">;</span>	<span class="cm">/* Fragment size */</span>
			<span class="n">__u16</span>	<span class="n">m_pad1</span><span class="p">;</span>
			<span class="n">__u32</span>	<span class="n">m_i_reserved2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">masix2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">osd2</span><span class="p">;</span>				<span class="cm">/* OS dependent 2 */</span>
	<span class="n">__le16</span>	<span class="n">i_extra_isize</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">i_pad1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define i_size_high	i_dir_acl</span>

<span class="cp">#define i_reserved1	osd1.linux1.l_i_reserved1</span>
<span class="cp">#define i_frag		osd2.linux2.l_i_frag</span>
<span class="cp">#define i_fsize		osd2.linux2.l_i_fsize</span>
<span class="cp">#define i_uid_low	i_uid</span>
<span class="cp">#define i_gid_low	i_gid</span>
<span class="cp">#define i_uid_high	osd2.linux2.l_i_uid_high</span>
<span class="cp">#define i_gid_high	osd2.linux2.l_i_gid_high</span>
<span class="cp">#define i_reserved2	osd2.linux2.l_i_reserved2</span>

<span class="cm">/*</span>
<span class="cm"> * File system states</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT3_VALID_FS			0x0001	</span><span class="cm">/* Unmounted cleanly */</span><span class="cp"></span>
<span class="cp">#define	EXT3_ERROR_FS			0x0002	</span><span class="cm">/* Errors detected */</span><span class="cp"></span>
<span class="cp">#define	EXT3_ORPHAN_FS			0x0004	</span><span class="cm">/* Orphans being recovered */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Misc. filesystem flags</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_FLAGS_SIGNED_HASH		0x0001  </span><span class="cm">/* Signed dirhash in use */</span><span class="cp"></span>
<span class="cp">#define EXT2_FLAGS_UNSIGNED_HASH	0x0002  </span><span class="cm">/* Unsigned dirhash in use */</span><span class="cp"></span>
<span class="cp">#define EXT2_FLAGS_TEST_FILESYS		0x0004	</span><span class="cm">/* to test development code */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Mount flags</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_MOUNT_CHECK		0x00001	</span><span class="cm">/* Do mount-time checks */</span><span class="cp"></span>
<span class="cm">/* EXT3_MOUNT_OLDALLOC was there */</span>
<span class="cp">#define EXT3_MOUNT_GRPID		0x00004	</span><span class="cm">/* Create files with directory&#39;s group */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_DEBUG		0x00008	</span><span class="cm">/* Some debugging messages */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_ERRORS_CONT		0x00010	</span><span class="cm">/* Continue on errors */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_ERRORS_RO		0x00020	</span><span class="cm">/* Remount fs ro on errors */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_ERRORS_PANIC		0x00040	</span><span class="cm">/* Panic on errors */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_MINIX_DF		0x00080	</span><span class="cm">/* Mimics the Minix statfs */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_NOLOAD		0x00100	</span><span class="cm">/* Don&#39;t use existing journal*/</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_ABORT		0x00200	</span><span class="cm">/* Fatal error detected */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_DATA_FLAGS		0x00C00	</span><span class="cm">/* Mode for data writes: */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_JOURNAL_DATA		0x00400	</span><span class="cm">/* Write data to journal */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_ORDERED_DATA		0x00800	</span><span class="cm">/* Flush data before commit */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_WRITEBACK_DATA	0x00C00	</span><span class="cm">/* No data ordering */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_UPDATE_JOURNAL	0x01000	</span><span class="cm">/* Update the journal format */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_NO_UID32		0x02000  </span><span class="cm">/* Disable 32-bit UIDs */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_XATTR_USER		0x04000	</span><span class="cm">/* Extended user attributes */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_POSIX_ACL		0x08000	</span><span class="cm">/* POSIX Access Control Lists */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_RESERVATION		0x10000	</span><span class="cm">/* Preallocation */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_BARRIER		0x20000 </span><span class="cm">/* Use block barriers */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_QUOTA		0x80000 </span><span class="cm">/* Some quota option set */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_USRQUOTA		0x100000 </span><span class="cm">/* &quot;old&quot; user quota */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_GRPQUOTA		0x200000 </span><span class="cm">/* &quot;old&quot; group quota */</span><span class="cp"></span>
<span class="cp">#define EXT3_MOUNT_DATA_ERR_ABORT	0x400000 </span><span class="cm">/* Abort on file data write</span>
<span class="cm">						  * error in ordered mode */</span><span class="cp"></span>

<span class="cm">/* Compatibility, for having both ext2_fs.h and ext3_fs.h included at once */</span>
<span class="cp">#ifndef _LINUX_EXT2_FS_H</span>
<span class="cp">#define clear_opt(o, opt)		o &amp;= ~EXT3_MOUNT_##opt</span>
<span class="cp">#define set_opt(o, opt)			o |= EXT3_MOUNT_##opt</span>
<span class="cp">#define test_opt(sb, opt)		(EXT3_SB(sb)-&gt;s_mount_opt &amp; \</span>
<span class="cp">					 EXT3_MOUNT_##opt)</span>
<span class="cp">#else</span>
<span class="cp">#define EXT2_MOUNT_NOLOAD		EXT3_MOUNT_NOLOAD</span>
<span class="cp">#define EXT2_MOUNT_ABORT		EXT3_MOUNT_ABORT</span>
<span class="cp">#define EXT2_MOUNT_DATA_FLAGS		EXT3_MOUNT_DATA_FLAGS</span>
<span class="cp">#endif</span>

<span class="cp">#define ext3_set_bit			__set_bit_le</span>
<span class="cp">#define ext3_set_bit_atomic		ext2_set_bit_atomic</span>
<span class="cp">#define ext3_clear_bit			__clear_bit_le</span>
<span class="cp">#define ext3_clear_bit_atomic		ext2_clear_bit_atomic</span>
<span class="cp">#define ext3_test_bit			test_bit_le</span>
<span class="cp">#define ext3_find_next_zero_bit		find_next_zero_bit_le</span>

<span class="cm">/*</span>
<span class="cm"> * Maximal mount counts between two filesystem checks</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_DFL_MAX_MNT_COUNT		20	</span><span class="cm">/* Allow 20 mounts */</span><span class="cp"></span>
<span class="cp">#define EXT3_DFL_CHECKINTERVAL		0	</span><span class="cm">/* Don&#39;t use interval check */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Behaviour when detecting errors</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_ERRORS_CONTINUE		1	</span><span class="cm">/* Continue execution */</span><span class="cp"></span>
<span class="cp">#define EXT3_ERRORS_RO			2	</span><span class="cm">/* Remount fs read-only */</span><span class="cp"></span>
<span class="cp">#define EXT3_ERRORS_PANIC		3	</span><span class="cm">/* Panic */</span><span class="cp"></span>
<span class="cp">#define EXT3_ERRORS_DEFAULT		EXT3_ERRORS_CONTINUE</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of the super block</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_super_block</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span>	<span class="n">s_inodes_count</span><span class="p">;</span>		<span class="cm">/* Inodes count */</span>
	<span class="n">__le32</span>	<span class="n">s_blocks_count</span><span class="p">;</span>		<span class="cm">/* Blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_r_blocks_count</span><span class="p">;</span>	<span class="cm">/* Reserved blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_free_blocks_count</span><span class="p">;</span>	<span class="cm">/* Free blocks count */</span>
<span class="cm">/*10*/</span>	<span class="n">__le32</span>	<span class="n">s_free_inodes_count</span><span class="p">;</span>	<span class="cm">/* Free inodes count */</span>
	<span class="n">__le32</span>	<span class="n">s_first_data_block</span><span class="p">;</span>	<span class="cm">/* First Data Block */</span>
	<span class="n">__le32</span>	<span class="n">s_log_block_size</span><span class="p">;</span>	<span class="cm">/* Block size */</span>
	<span class="n">__le32</span>	<span class="n">s_log_frag_size</span><span class="p">;</span>	<span class="cm">/* Fragment size */</span>
<span class="cm">/*20*/</span>	<span class="n">__le32</span>	<span class="n">s_blocks_per_group</span><span class="p">;</span>	<span class="cm">/* # Blocks per group */</span>
	<span class="n">__le32</span>	<span class="n">s_frags_per_group</span><span class="p">;</span>	<span class="cm">/* # Fragments per group */</span>
	<span class="n">__le32</span>	<span class="n">s_inodes_per_group</span><span class="p">;</span>	<span class="cm">/* # Inodes per group */</span>
	<span class="n">__le32</span>	<span class="n">s_mtime</span><span class="p">;</span>		<span class="cm">/* Mount time */</span>
<span class="cm">/*30*/</span>	<span class="n">__le32</span>	<span class="n">s_wtime</span><span class="p">;</span>		<span class="cm">/* Write time */</span>
	<span class="n">__le16</span>	<span class="n">s_mnt_count</span><span class="p">;</span>		<span class="cm">/* Mount count */</span>
	<span class="n">__le16</span>	<span class="n">s_max_mnt_count</span><span class="p">;</span>	<span class="cm">/* Maximal mount count */</span>
	<span class="n">__le16</span>	<span class="n">s_magic</span><span class="p">;</span>		<span class="cm">/* Magic signature */</span>
	<span class="n">__le16</span>	<span class="n">s_state</span><span class="p">;</span>		<span class="cm">/* File system state */</span>
	<span class="n">__le16</span>	<span class="n">s_errors</span><span class="p">;</span>		<span class="cm">/* Behaviour when detecting errors */</span>
	<span class="n">__le16</span>	<span class="n">s_minor_rev_level</span><span class="p">;</span>	<span class="cm">/* minor revision level */</span>
<span class="cm">/*40*/</span>	<span class="n">__le32</span>	<span class="n">s_lastcheck</span><span class="p">;</span>		<span class="cm">/* time of last check */</span>
	<span class="n">__le32</span>	<span class="n">s_checkinterval</span><span class="p">;</span>	<span class="cm">/* max. time between checks */</span>
	<span class="n">__le32</span>	<span class="n">s_creator_os</span><span class="p">;</span>		<span class="cm">/* OS */</span>
	<span class="n">__le32</span>	<span class="n">s_rev_level</span><span class="p">;</span>		<span class="cm">/* Revision level */</span>
<span class="cm">/*50*/</span>	<span class="n">__le16</span>	<span class="n">s_def_resuid</span><span class="p">;</span>		<span class="cm">/* Default uid for reserved blocks */</span>
	<span class="n">__le16</span>	<span class="n">s_def_resgid</span><span class="p">;</span>		<span class="cm">/* Default gid for reserved blocks */</span>
	<span class="cm">/*</span>
<span class="cm">	 * These fields are for EXT3_DYNAMIC_REV superblocks only.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: the difference between the compatible feature set and</span>
<span class="cm">	 * the incompatible feature set is that if there is a bit set</span>
<span class="cm">	 * in the incompatible feature set that the kernel doesn&#39;t</span>
<span class="cm">	 * know about, it should refuse to mount the filesystem.</span>
<span class="cm">	 *</span>
<span class="cm">	 * e2fsck&#39;s requirements are more strict; if it doesn&#39;t know</span>
<span class="cm">	 * about a feature in either the compatible or incompatible</span>
<span class="cm">	 * feature set, it must abort and not try to meddle with</span>
<span class="cm">	 * things it doesn&#39;t understand...</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span>	<span class="n">s_first_ino</span><span class="p">;</span>		<span class="cm">/* First non-reserved inode */</span>
	<span class="n">__le16</span>   <span class="n">s_inode_size</span><span class="p">;</span>		<span class="cm">/* size of inode structure */</span>
	<span class="n">__le16</span>	<span class="n">s_block_group_nr</span><span class="p">;</span>	<span class="cm">/* block group # of this superblock */</span>
	<span class="n">__le32</span>	<span class="n">s_feature_compat</span><span class="p">;</span>	<span class="cm">/* compatible feature set */</span>
<span class="cm">/*60*/</span>	<span class="n">__le32</span>	<span class="n">s_feature_incompat</span><span class="p">;</span>	<span class="cm">/* incompatible feature set */</span>
	<span class="n">__le32</span>	<span class="n">s_feature_ro_compat</span><span class="p">;</span>	<span class="cm">/* readonly-compatible feature set */</span>
<span class="cm">/*68*/</span>	<span class="n">__u8</span>	<span class="n">s_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 128-bit uuid for volume */</span>
<span class="cm">/*78*/</span>	<span class="kt">char</span>	<span class="n">s_volume_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* volume name */</span>
<span class="cm">/*88*/</span>	<span class="kt">char</span>	<span class="n">s_last_mounted</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* directory where last mounted */</span>
<span class="cm">/*C8*/</span>	<span class="n">__le32</span>	<span class="n">s_algorithm_usage_bitmap</span><span class="p">;</span> <span class="cm">/* For compression */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Performance hints.  Directory preallocation should only</span>
<span class="cm">	 * happen if the EXT3_FEATURE_COMPAT_DIR_PREALLOC flag is on.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span>	<span class="n">s_prealloc_blocks</span><span class="p">;</span>	<span class="cm">/* Nr of blocks to try to preallocate*/</span>
	<span class="n">__u8</span>	<span class="n">s_prealloc_dir_blocks</span><span class="p">;</span>	<span class="cm">/* Nr to preallocate for dirs */</span>
	<span class="n">__le16</span>	<span class="n">s_reserved_gdt_blocks</span><span class="p">;</span>	<span class="cm">/* Per group desc for online growth */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.</span>
<span class="cm">	 */</span>
<span class="cm">/*D0*/</span>	<span class="n">__u8</span>	<span class="n">s_journal_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* uuid of journal superblock */</span>
<span class="cm">/*E0*/</span>	<span class="n">__le32</span>	<span class="n">s_journal_inum</span><span class="p">;</span>		<span class="cm">/* inode number of journal file */</span>
	<span class="n">__le32</span>	<span class="n">s_journal_dev</span><span class="p">;</span>		<span class="cm">/* device number of journal file */</span>
	<span class="n">__le32</span>	<span class="n">s_last_orphan</span><span class="p">;</span>		<span class="cm">/* start of list of inodes to delete */</span>
	<span class="n">__le32</span>	<span class="n">s_hash_seed</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* HTREE hash seed */</span>
	<span class="n">__u8</span>	<span class="n">s_def_hash_version</span><span class="p">;</span>	<span class="cm">/* Default hash version to use */</span>
	<span class="n">__u8</span>	<span class="n">s_reserved_char_pad</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">s_reserved_word_pad</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">s_default_mount_opts</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">s_first_meta_bg</span><span class="p">;</span>	<span class="cm">/* First metablock block group */</span>
	<span class="n">__le32</span>	<span class="n">s_mkfs_time</span><span class="p">;</span>		<span class="cm">/* When the filesystem was created */</span>
	<span class="n">__le32</span>	<span class="n">s_jnl_blocks</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>	<span class="cm">/* Backup of the journal inode */</span>
	<span class="cm">/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */</span>
<span class="cm">/*150*/</span>	<span class="n">__le32</span>	<span class="n">s_blocks_count_hi</span><span class="p">;</span>	<span class="cm">/* Blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_r_blocks_count_hi</span><span class="p">;</span>	<span class="cm">/* Reserved blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_free_blocks_count_hi</span><span class="p">;</span>	<span class="cm">/* Free blocks count */</span>
	<span class="n">__le16</span>	<span class="n">s_min_extra_isize</span><span class="p">;</span>	<span class="cm">/* All inodes have at least # bytes */</span>
	<span class="n">__le16</span>	<span class="n">s_want_extra_isize</span><span class="p">;</span> 	<span class="cm">/* New inodes should reserve # bytes */</span>
	<span class="n">__le32</span>	<span class="n">s_flags</span><span class="p">;</span>		<span class="cm">/* Miscellaneous flags */</span>
	<span class="n">__le16</span>  <span class="n">s_raid_stride</span><span class="p">;</span>		<span class="cm">/* RAID stride */</span>
	<span class="n">__le16</span>  <span class="n">s_mmp_interval</span><span class="p">;</span>         <span class="cm">/* # seconds to wait in MMP checking */</span>
	<span class="n">__le64</span>  <span class="n">s_mmp_block</span><span class="p">;</span>            <span class="cm">/* Block for multi-mount protection */</span>
	<span class="n">__le32</span>  <span class="n">s_raid_stripe_width</span><span class="p">;</span>    <span class="cm">/* blocks on all data disks (N*stride)*/</span>
	<span class="n">__u8</span>	<span class="n">s_log_groups_per_flex</span><span class="p">;</span>  <span class="cm">/* FLEX_BG group size */</span>
	<span class="n">__u8</span>	<span class="n">s_reserved_char_pad2</span><span class="p">;</span>
	<span class="n">__le16</span>  <span class="n">s_reserved_pad</span><span class="p">;</span>
	<span class="n">__u32</span>   <span class="n">s_reserved</span><span class="p">[</span><span class="mi">162</span><span class="p">];</span>        <span class="cm">/* Padding to the end of the block */</span>
<span class="p">};</span>

<span class="cm">/* data type for block offset of block group */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ext3_grpblk_t</span><span class="p">;</span>

<span class="cm">/* data type for filesystem-wide blocks number */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext3_fsblk_t</span><span class="p">;</span>

<span class="cp">#define E3FSBLK &quot;%lu&quot;</span>

<span class="k">struct</span> <span class="n">ext3_reserve_window</span> <span class="p">{</span>
	<span class="n">ext3_fsblk_t</span>	<span class="n">_rsv_start</span><span class="p">;</span>	<span class="cm">/* First byte reserved */</span>
	<span class="n">ext3_fsblk_t</span>	<span class="n">_rsv_end</span><span class="p">;</span>	<span class="cm">/* Last byte reserved or 0 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">rsv_node</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">rsv_goal_size</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">rsv_alloc_hit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window</span>	<span class="n">rsv_window</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ext3_block_alloc_info</span> <span class="p">{</span>
	<span class="cm">/* information about reservation window */</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span>	<span class="n">rsv_window_node</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * was i_next_alloc_block in ext3_inode_info</span>
<span class="cm">	 * is the logical (file-relative) number of the</span>
<span class="cm">	 * most-recently-allocated block in this file.</span>
<span class="cm">	 * We use this for detecting linearly ascending allocation requests.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span>                   <span class="n">last_alloc_logical_block</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Was i_next_alloc_goal in ext3_inode_info</span>
<span class="cm">	 * is the *physical* companion to i_next_alloc_block.</span>
<span class="cm">	 * it the physical block number of the block which was most-recentl</span>
<span class="cm">	 * allocated to this file.  This give us the goal (target) for the next</span>
<span class="cm">	 * allocation when we detect linearly ascending requests.</span>
<span class="cm">	 */</span>
	<span class="n">ext3_fsblk_t</span>		<span class="n">last_alloc_physical_block</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define rsv_start rsv_window._rsv_start</span>
<span class="cp">#define rsv_end rsv_window._rsv_end</span>

<span class="cm">/*</span>
<span class="cm"> * third extended file system inode data in memory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">i_data</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>	<span class="cm">/* unconverted */</span>
	<span class="n">__u32</span>	<span class="n">i_flags</span><span class="p">;</span>
<span class="cp">#ifdef EXT3_FRAGMENTS</span>
	<span class="n">__u32</span>	<span class="n">i_faddr</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">i_frag_no</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">i_frag_size</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ext3_fsblk_t</span>	<span class="n">i_file_acl</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">i_dir_acl</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">i_dtime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * i_block_group is the number of the block group which contains</span>
<span class="cm">	 * this file&#39;s inode.  Constant across the lifetime of the inode,</span>
<span class="cm">	 * it is ued for making block allocation decisions - we try to</span>
<span class="cm">	 * place a file&#39;s data blocks near its inode block, and new inodes</span>
<span class="cm">	 * near to their parent directory&#39;s inode.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span>	<span class="n">i_block_group</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">i_state_flags</span><span class="p">;</span>	<span class="cm">/* Dynamic state flags for ext3 */</span>

	<span class="cm">/* block reservation info */</span>
	<span class="k">struct</span> <span class="n">ext3_block_alloc_info</span> <span class="o">*</span><span class="n">i_block_alloc_info</span><span class="p">;</span>

	<span class="n">__u32</span>	<span class="n">i_dir_start_lookup</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_EXT3_FS_XATTR</span>
	<span class="cm">/*</span>
<span class="cm">	 * Extended attributes can be read independently of the main file</span>
<span class="cm">	 * data. Taking i_mutex even when reading would cause contention</span>
<span class="cm">	 * between readers of EAs and writers of regular file data, so</span>
<span class="cm">	 * instead we synchronize on xattr_sem when reading or changing</span>
<span class="cm">	 * EAs.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">xattr_sem</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_orphan</span><span class="p">;</span>	<span class="cm">/* unlinked but open inodes */</span>

	<span class="cm">/*</span>
<span class="cm">	 * i_disksize keeps track of what the inode size is ON DISK, not</span>
<span class="cm">	 * in memory.  During truncate, i_size is set to the new size by</span>
<span class="cm">	 * the VFS prior to calling ext3_truncate(), but the filesystem won&#39;t</span>
<span class="cm">	 * set i_disksize to 0 until the truncate is actually under way.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The intent is that i_disksize always represents the blocks which</span>
<span class="cm">	 * are used by this file.  This allows recovery to restart truncate</span>
<span class="cm">	 * on orphans if we crash during truncate.  We actually write i_disksize</span>
<span class="cm">	 * into the on-disk inode when writing inodes out, instead of i_size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The only time when i_disksize and i_size may be different is when</span>
<span class="cm">	 * a truncate is in progress.  The only things which change i_disksize</span>
<span class="cm">	 * are ext3_get_block (growth) and ext3_truncate (shrinkth).</span>
<span class="cm">	 */</span>
	<span class="n">loff_t</span>	<span class="n">i_disksize</span><span class="p">;</span>

	<span class="cm">/* on-disk additional length */</span>
	<span class="n">__u16</span> <span class="n">i_extra_isize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * truncate_mutex is for serialising ext3_truncate() against</span>
<span class="cm">	 * ext3_getblock().  In the 2.4 ext2 design, great chunks of inode&#39;s</span>
<span class="cm">	 * data tree are chopped off during truncate. We can&#39;t do that in</span>
<span class="cm">	 * ext3 because whenever we perform intermediate commits during</span>
<span class="cm">	 * truncate, the inode and all the metadata blocks *must* be in a</span>
<span class="cm">	 * consistent state which allows truncation of the orphans to restart</span>
<span class="cm">	 * during recovery.  Hence we must fix the get_block-vs-truncate race</span>
<span class="cm">	 * by other means, so we have truncate_mutex.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">truncate_mutex</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transactions that contain inode&#39;s metadata needed to complete</span>
<span class="cm">	 * fsync and fdatasync, respectively.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">i_sync_tid</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">i_datasync_tid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * third extended-fs super-block data in memory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_frag_size</span><span class="p">;</span>	<span class="cm">/* Size of a fragment in bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_frags_per_block</span><span class="p">;</span><span class="cm">/* Number of fragments per block */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_inodes_per_block</span><span class="p">;</span><span class="cm">/* Number of inodes per block */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_frags_per_group</span><span class="p">;</span><span class="cm">/* Number of fragments in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_blocks_per_group</span><span class="p">;</span><span class="cm">/* Number of blocks in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_inodes_per_group</span><span class="p">;</span><span class="cm">/* Number of inodes in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_itb_per_group</span><span class="p">;</span>	<span class="cm">/* Number of inode table blocks per group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_gdb_count</span><span class="p">;</span>	<span class="cm">/* Number of group descriptor blocks */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_desc_per_block</span><span class="p">;</span>	<span class="cm">/* Number of group descriptors per block */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_groups_count</span><span class="p">;</span>	<span class="cm">/* Number of groups in the fs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_overhead_last</span><span class="p">;</span>  <span class="cm">/* Last calculated overhead */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_blocks_last</span><span class="p">;</span>    <span class="cm">/* Last seen block count */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">s_sbh</span><span class="p">;</span>	<span class="cm">/* Buffer containing the super block */</span>
	<span class="k">struct</span> <span class="n">ext3_super_block</span> <span class="o">*</span> <span class="n">s_es</span><span class="p">;</span>	<span class="cm">/* Pointer to the super block in the buffer */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span> <span class="n">s_group_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">s_mount_opt</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">s_sb_block</span><span class="p">;</span>
	<span class="n">kuid_t</span> <span class="n">s_resuid</span><span class="p">;</span>
	<span class="n">kgid_t</span> <span class="n">s_resgid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">s_mount_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">s_pad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_addr_per_block_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_desc_per_block_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_inode_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_first_ino</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">s_next_gen_lock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_next_generation</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_hash_seed</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">s_def_hash_version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_hash_unsigned</span><span class="p">;</span>	<span class="cm">/* 3 if hash should be signed, 0 if not */</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_freeblocks_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_freeinodes_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_dirs_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blockgroup_lock</span> <span class="o">*</span><span class="n">s_blockgroup_lock</span><span class="p">;</span>

	<span class="cm">/* root of the per fs reservation window tree */</span>
	<span class="n">spinlock_t</span> <span class="n">s_rsv_window_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">s_rsv_window_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="n">s_rsv_window_head</span><span class="p">;</span>

	<span class="cm">/* Journaling */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">s_journal_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_s</span> <span class="o">*</span> <span class="n">s_journal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_orphan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">s_orphan_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">s_resize_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_commit_interval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">journal_bdev</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s_qf_names</span><span class="p">[</span><span class="n">MAXQUOTAS</span><span class="p">];</span>		<span class="cm">/* Names of quota files with journalled quota */</span>
	<span class="kt">int</span> <span class="n">s_jquota_fmt</span><span class="p">;</span>			<span class="cm">/* Format of quota to use */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">spinlock_t</span> <span class="o">*</span>
<span class="nf">sb_bgl_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bgl_lock_ptr</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_blockgroup_lock</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="o">*</span> <span class="nf">EXT3_SB</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="nf">EXT3_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_valid_inum</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ino</span> <span class="o">==</span> <span class="n">EXT3_ROOT_INO</span> <span class="o">||</span>
		<span class="n">ino</span> <span class="o">==</span> <span class="n">EXT3_JOURNAL_INO</span> <span class="o">||</span>
		<span class="n">ino</span> <span class="o">==</span> <span class="n">EXT3_RESIZE_INO</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ino</span> <span class="o">&gt;=</span> <span class="n">EXT3_FIRST_INO</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">ino</span> <span class="o">&lt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_inodes_count</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inode dynamic state flags</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">EXT3_STATE_JDATA</span><span class="p">,</span>		<span class="cm">/* journaled data exists */</span>
	<span class="n">EXT3_STATE_NEW</span><span class="p">,</span>			<span class="cm">/* inode is newly created */</span>
	<span class="n">EXT3_STATE_XATTR</span><span class="p">,</span>		<span class="cm">/* has in-inode xattrs */</span>
	<span class="n">EXT3_STATE_FLUSH_ON_CLOSE</span><span class="p">,</span>	<span class="cm">/* flush dirty pages on close */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_test_inode_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_state_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext3_set_inode_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_state_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext3_clear_inode_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_state_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define NEXT_ORPHAN(inode) EXT3_I(inode)-&gt;i_dtime</span>

<span class="cm">/*</span>
<span class="cm"> * Codes for operating systems</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_OS_LINUX		0</span>
<span class="cp">#define EXT3_OS_HURD		1</span>
<span class="cp">#define EXT3_OS_MASIX		2</span>
<span class="cp">#define EXT3_OS_FREEBSD		3</span>
<span class="cp">#define EXT3_OS_LITES		4</span>

<span class="cm">/*</span>
<span class="cm"> * Revision levels</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_GOOD_OLD_REV	0	</span><span class="cm">/* The good old (original) format */</span><span class="cp"></span>
<span class="cp">#define EXT3_DYNAMIC_REV	1	</span><span class="cm">/* V2 format w/ dynamic inode sizes */</span><span class="cp"></span>

<span class="cp">#define EXT3_CURRENT_REV	EXT3_GOOD_OLD_REV</span>
<span class="cp">#define EXT3_MAX_SUPP_REV	EXT3_DYNAMIC_REV</span>

<span class="cp">#define EXT3_GOOD_OLD_INODE_SIZE 128</span>

<span class="cm">/*</span>
<span class="cm"> * Feature set definitions</span>
<span class="cm"> */</span>

<span class="cp">#define EXT3_HAS_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( EXT3_SB(sb)-&gt;s_es-&gt;s_feature_compat &amp; cpu_to_le32(mask) )</span>
<span class="cp">#define EXT3_HAS_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( EXT3_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat &amp; cpu_to_le32(mask) )</span>
<span class="cp">#define EXT3_HAS_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( EXT3_SB(sb)-&gt;s_es-&gt;s_feature_incompat &amp; cpu_to_le32(mask) )</span>
<span class="cp">#define EXT3_SET_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT3_SB(sb)-&gt;s_es-&gt;s_feature_compat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT3_SET_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT3_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT3_SET_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT3_SB(sb)-&gt;s_es-&gt;s_feature_incompat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT3_CLEAR_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT3_SB(sb)-&gt;s_es-&gt;s_feature_compat &amp;= ~cpu_to_le32(mask)</span>
<span class="cp">#define EXT3_CLEAR_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT3_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat &amp;= ~cpu_to_le32(mask)</span>
<span class="cp">#define EXT3_CLEAR_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT3_SB(sb)-&gt;s_es-&gt;s_feature_incompat &amp;= ~cpu_to_le32(mask)</span>

<span class="cp">#define EXT3_FEATURE_COMPAT_DIR_PREALLOC	0x0001</span>
<span class="cp">#define EXT3_FEATURE_COMPAT_IMAGIC_INODES	0x0002</span>
<span class="cp">#define EXT3_FEATURE_COMPAT_HAS_JOURNAL		0x0004</span>
<span class="cp">#define EXT3_FEATURE_COMPAT_EXT_ATTR		0x0008</span>
<span class="cp">#define EXT3_FEATURE_COMPAT_RESIZE_INODE	0x0010</span>
<span class="cp">#define EXT3_FEATURE_COMPAT_DIR_INDEX		0x0020</span>

<span class="cp">#define EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER	0x0001</span>
<span class="cp">#define EXT3_FEATURE_RO_COMPAT_LARGE_FILE	0x0002</span>
<span class="cp">#define EXT3_FEATURE_RO_COMPAT_BTREE_DIR	0x0004</span>

<span class="cp">#define EXT3_FEATURE_INCOMPAT_COMPRESSION	0x0001</span>
<span class="cp">#define EXT3_FEATURE_INCOMPAT_FILETYPE		0x0002</span>
<span class="cp">#define EXT3_FEATURE_INCOMPAT_RECOVER		0x0004 </span><span class="cm">/* Needs recovery */</span><span class="cp"></span>
<span class="cp">#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008 </span><span class="cm">/* Journal device */</span><span class="cp"></span>
<span class="cp">#define EXT3_FEATURE_INCOMPAT_META_BG		0x0010</span>

<span class="cp">#define EXT3_FEATURE_COMPAT_SUPP	EXT2_FEATURE_COMPAT_EXT_ATTR</span>
<span class="cp">#define EXT3_FEATURE_INCOMPAT_SUPP	(EXT3_FEATURE_INCOMPAT_FILETYPE| \</span>
<span class="cp">					 EXT3_FEATURE_INCOMPAT_RECOVER| \</span>
<span class="cp">					 EXT3_FEATURE_INCOMPAT_META_BG)</span>
<span class="cp">#define EXT3_FEATURE_RO_COMPAT_SUPP	(EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER| \</span>
<span class="cp">					 EXT3_FEATURE_RO_COMPAT_LARGE_FILE| \</span>
<span class="cp">					 EXT3_FEATURE_RO_COMPAT_BTREE_DIR)</span>

<span class="cm">/*</span>
<span class="cm"> * Default values for user and/or group using reserved blocks</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT3_DEF_RESUID		0</span>
<span class="cp">#define	EXT3_DEF_RESGID		0</span>

<span class="cm">/*</span>
<span class="cm"> * Default mount options</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_DEFM_DEBUG		0x0001</span>
<span class="cp">#define EXT3_DEFM_BSDGROUPS	0x0002</span>
<span class="cp">#define EXT3_DEFM_XATTR_USER	0x0004</span>
<span class="cp">#define EXT3_DEFM_ACL		0x0008</span>
<span class="cp">#define EXT3_DEFM_UID16		0x0010</span>
<span class="cp">#define EXT3_DEFM_JMODE		0x0060</span>
<span class="cp">#define EXT3_DEFM_JMODE_DATA	0x0020</span>
<span class="cp">#define EXT3_DEFM_JMODE_ORDERED	0x0040</span>
<span class="cp">#define EXT3_DEFM_JMODE_WBACK	0x0060</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of a directory entry</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_NAME_LEN 255</span>

<span class="k">struct</span> <span class="n">ext3_dir_entry</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* Inode number */</span>
	<span class="n">__le16</span>	<span class="n">rec_len</span><span class="p">;</span>		<span class="cm">/* Directory entry length */</span>
	<span class="n">__le16</span>	<span class="n">name_len</span><span class="p">;</span>		<span class="cm">/* Name length */</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="n">EXT3_NAME_LEN</span><span class="p">];</span>	<span class="cm">/* File name */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The new version of the directory entry.  Since EXT3 structures are</span>
<span class="cm"> * stored in intel byte order, and the name_len field could never be</span>
<span class="cm"> * bigger than 255 chars, it&#39;s safe to reclaim the extra byte for the</span>
<span class="cm"> * file_type field.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* Inode number */</span>
	<span class="n">__le16</span>	<span class="n">rec_len</span><span class="p">;</span>		<span class="cm">/* Directory entry length */</span>
	<span class="n">__u8</span>	<span class="n">name_len</span><span class="p">;</span>		<span class="cm">/* Name length */</span>
	<span class="n">__u8</span>	<span class="n">file_type</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="n">EXT3_NAME_LEN</span><span class="p">];</span>	<span class="cm">/* File name */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Ext3 directory file types.  Only the low 3 bits are used.  The</span>
<span class="cm"> * other bits are reserved for now.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_FT_UNKNOWN		0</span>
<span class="cp">#define EXT3_FT_REG_FILE	1</span>
<span class="cp">#define EXT3_FT_DIR		2</span>
<span class="cp">#define EXT3_FT_CHRDEV		3</span>
<span class="cp">#define EXT3_FT_BLKDEV		4</span>
<span class="cp">#define EXT3_FT_FIFO		5</span>
<span class="cp">#define EXT3_FT_SOCK		6</span>
<span class="cp">#define EXT3_FT_SYMLINK		7</span>

<span class="cp">#define EXT3_FT_MAX		8</span>

<span class="cm">/*</span>
<span class="cm"> * EXT3_DIR_PAD defines the directory entries boundaries</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: It must be a multiple of 4</span>
<span class="cm"> */</span>
<span class="cp">#define EXT3_DIR_PAD			4</span>
<span class="cp">#define EXT3_DIR_ROUND			(EXT3_DIR_PAD - 1)</span>
<span class="cp">#define EXT3_DIR_REC_LEN(name_len)	(((name_len) + 8 + EXT3_DIR_ROUND) &amp; \</span>
<span class="cp">					 ~EXT3_DIR_ROUND)</span>
<span class="cp">#define EXT3_MAX_REC_LEN		((1&lt;&lt;16)-1)</span>

<span class="cm">/*</span>
<span class="cm"> * Tests against MAX_REC_LEN etc were put in place for 64k block</span>
<span class="cm"> * sizes; if that is not possible on this arch, we can skip</span>
<span class="cm"> * those tests and speed things up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">__le16</span> <span class="n">dlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dlen</span><span class="p">);</span>

<span class="cp">#if (PAGE_CACHE_SIZE &gt;= 65536)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">EXT3_MAX_REC_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__le16</span> <span class="nf">ext3_rec_len_to_disk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if (PAGE_CACHE_SIZE &gt;= 65536)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">EXT3_MAX_REC_LEN</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hash Tree Directory indexing</span>
<span class="cm"> * (c) Daniel Phillips, 2001</span>
<span class="cm"> */</span>

<span class="cp">#define is_dx(dir) (EXT3_HAS_COMPAT_FEATURE(dir-&gt;i_sb, \</span>
<span class="cp">				      EXT3_FEATURE_COMPAT_DIR_INDEX) &amp;&amp; \</span>
<span class="cp">		      (EXT3_I(dir)-&gt;i_flags &amp; EXT3_INDEX_FL))</span>
<span class="cp">#define EXT3_DIR_LINK_MAX(dir) (!is_dx(dir) &amp;&amp; (dir)-&gt;i_nlink &gt;= EXT3_LINK_MAX)</span>
<span class="cp">#define EXT3_DIR_LINK_EMPTY(dir) ((dir)-&gt;i_nlink == 2 || (dir)-&gt;i_nlink == 1)</span>

<span class="cm">/* Legal values for the dx_root hash_version field: */</span>

<span class="cp">#define DX_HASH_LEGACY		0</span>
<span class="cp">#define DX_HASH_HALF_MD4	1</span>
<span class="cp">#define DX_HASH_TEA		2</span>
<span class="cp">#define DX_HASH_LEGACY_UNSIGNED	3</span>
<span class="cp">#define DX_HASH_HALF_MD4_UNSIGNED	4</span>
<span class="cp">#define DX_HASH_TEA_UNSIGNED		5</span>

<span class="cm">/* hash info structure used by the directory hash */</span>
<span class="k">struct</span> <span class="n">dx_hash_info</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">hash</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">minor_hash</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">hash_version</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="o">*</span><span class="n">seed</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* 32 and 64 bit signed EOF for dx directories */</span>
<span class="cp">#define EXT3_HTREE_EOF_32BIT   ((1UL  &lt;&lt; (32 - 1)) - 1)</span>
<span class="cp">#define EXT3_HTREE_EOF_64BIT   ((1ULL &lt;&lt; (64 - 1)) - 1)</span>


<span class="cm">/*</span>
<span class="cm"> * Control parameters used by ext3_htree_next_block</span>
<span class="cm"> */</span>
<span class="cp">#define HASH_NB_ALWAYS		1</span>


<span class="cm">/*</span>
<span class="cm"> * Describe an inode&#39;s exact location on disk and in memory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_iloc</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_group</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext3_inode</span> <span class="o">*</span><span class="nf">ext3_raw_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_inode</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">iloc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is stuffed into the struct file&#39;s private_data field</span>
<span class="cm"> * for directories.  It is where we put information so that we can do</span>
<span class="cm"> * readdir operations in hash tree order.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dir_private_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span>	<span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span>	<span class="o">*</span><span class="n">curr_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fname</span>	<span class="o">*</span><span class="n">extra_fname</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">last_pos</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">curr_hash</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">curr_minor_hash</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">next_hash</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* calculate the first block number of the group */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext3_fsblk_t</span>
<span class="nf">ext3_group_first_block_no</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">group_no</span> <span class="o">*</span> <span class="p">(</span><span class="n">ext3_fsblk_t</span><span class="p">)</span><span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Special error return code only used by dx_probe() and its callers.</span>
<span class="cm"> */</span>
<span class="cp">#define ERR_BAD_DX_DIR	-75000</span>

<span class="cm">/*</span>
<span class="cm"> * Function prototypes</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Ok, these declarations are also in &lt;linux/kernel.h&gt; but none of the</span>
<span class="cm"> * ext3 source programs needs to include it so they are duplicated here.</span>
<span class="cm"> */</span>
<span class="cp"># define NORET_TYPE    </span><span class="cm">/**/</span><span class="cp"></span>
<span class="cp"># define ATTRIB_NORET  __attribute__((noreturn))</span>
<span class="cp"># define NORET_AND     noreturn,</span>

<span class="cm">/* balloc.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_bg_has_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext3_bg_num_gdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext3_fsblk_t</span> <span class="n">ext3_new_block</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext3_fsblk_t</span> <span class="n">ext3_new_blocks</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_free_blocks</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_free_blocks_sb</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="n">ext3_fsblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdquot_freed_blocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext3_fsblk_t</span> <span class="n">ext3_count_free_blocks</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_check_blocks_bitmap</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span> <span class="n">bh</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_should_retry_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">retries</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_init_block_alloc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_rsv_window_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_trim_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fstrim_range</span> <span class="o">*</span><span class="n">range</span><span class="p">);</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_check_dir_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_htree_store_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dir_file</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">hash</span><span class="p">,</span>
				    <span class="n">__u32</span> <span class="n">minor_hash</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">dirent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_htree_free_dir_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">dir_private_info</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/* fsync.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_sync_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* hash.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3fs_dirhash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span>
			  <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">);</span>

<span class="cm">/* ialloc.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">ext3_new_inode</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_free_inode</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">ext3_orphan_get</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext3_count_free_inodes</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext3_count_dirs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_check_inodes_bitmap</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext3_count_free</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>


<span class="cm">/* inode.c */</span>
<span class="kt">int</span> <span class="n">ext3_forget</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">ext3_fsblk_t</span> <span class="n">blocknr</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">ext3_getblk</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ext3_get_blocks_handle</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxblocks</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">create</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ext3_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">ext3_write_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">ext3_setattr</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_evict_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">ext3_sync_inode</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_discard_reservation</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_change_inode_journal_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_get_inode_loc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_can_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_get_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_set_aops</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
		       <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* ioctl.c */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext3_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext3_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cm">/* namei.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_orphan_del</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_htree_fill_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dir_file</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">start_hash</span><span class="p">,</span>
				<span class="n">__u32</span> <span class="n">start_minor_hash</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">next_hash</span><span class="p">);</span>

<span class="cm">/* resize.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_group_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext3_new_group_data</span> <span class="o">*</span><span class="n">input</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext3_group_extend</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext3_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">,</span>
				<span class="n">ext3_fsblk_t</span> <span class="n">n_blocks_count</span><span class="p">);</span>

<span class="cm">/* super.c */</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext3_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ext3_std_error</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext3_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext3_warning</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext3_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext3_update_dynamic_rev</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="cp">#define ext3_std_error(sb, errno)				\</span>
<span class="cp">do {								\</span>
<span class="cp">	if ((errno))						\</span>
<span class="cp">		__ext3_std_error((sb), __func__, (errno));	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Inodes and files operations</span>
<span class="cm"> */</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext3_dir_operations</span><span class="p">;</span>

<span class="cm">/* file.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext3_file_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext3_file_operations</span><span class="p">;</span>

<span class="cm">/* namei.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext3_dir_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext3_special_inode_operations</span><span class="p">;</span>

<span class="cm">/* symlink.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext3_symlink_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext3_fast_symlink_inode_operations</span><span class="p">;</span>

<span class="cp">#define EXT3_JOURNAL(inode)	(EXT3_SB((inode)-&gt;i_sb)-&gt;s_journal)</span>

<span class="cm">/* Define the number of blocks we need to account to a transaction to</span>
<span class="cm"> * modify one block of data.</span>
<span class="cm"> *</span>
<span class="cm"> * We may have to touch one inode, one bitmap buffer, up to three</span>
<span class="cm"> * indirection blocks, the group and superblock summaries, and the data</span>
<span class="cm"> * block to complete the transaction.  */</span>

<span class="cp">#define EXT3_SINGLEDATA_TRANS_BLOCKS	8U</span>

<span class="cm">/* Extended attribute operations touch at most two data buffers,</span>
<span class="cm"> * two bitmap buffers, and two group summaries, in addition to the inode</span>
<span class="cm"> * and the superblock, which are already accounted for. */</span>

<span class="cp">#define EXT3_XATTR_TRANS_BLOCKS		6U</span>

<span class="cm">/* Define the minimum size for a transaction which modifies data.  This</span>
<span class="cm"> * needs to take into account the fact that we may end up modifying two</span>
<span class="cm"> * quota files too (one for the group, one for the user quota).  The</span>
<span class="cm"> * superblock only gets updated once, of course, so don&#39;t bother</span>
<span class="cm"> * counting that again for the quota updates. */</span>

<span class="cp">#define EXT3_DATA_TRANS_BLOCKS(sb)	(EXT3_SINGLEDATA_TRANS_BLOCKS + \</span>
<span class="cp">					 EXT3_XATTR_TRANS_BLOCKS - 2 + \</span>
<span class="cp">					 EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))</span>

<span class="cm">/* Delete operations potentially hit one directory&#39;s namespace plus an</span>
<span class="cm"> * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be</span>
<span class="cm"> * generous.  We can grow the delete transaction later if necessary. */</span>

<span class="cp">#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)</span>

<span class="cm">/* Define an arbitrary limit for the amount of data we will anticipate</span>
<span class="cm"> * writing to any given transaction.  For unbounded transactions such as</span>
<span class="cm"> * write(2) and truncate(2) we can write more than this, but we always</span>
<span class="cm"> * start off at the maximum transaction size and grow the transaction</span>
<span class="cm"> * optimistically as we go. */</span>

<span class="cp">#define EXT3_MAX_TRANS_DATA		64U</span>

<span class="cm">/* We break up a large truncate or write transaction once the handle&#39;s</span>
<span class="cm"> * buffer credits gets this low, we need either to extend the</span>
<span class="cm"> * transaction or to start a new one.  Reserve enough space here for</span>
<span class="cm"> * inode, bitmap, superblock, group and indirection updates for at least</span>
<span class="cm"> * one block, plus two quota updates.  Quota allocations are not</span>
<span class="cm"> * needed. */</span>

<span class="cp">#define EXT3_RESERVE_TRANS_BLOCKS	12U</span>

<span class="cp">#define EXT3_INDEX_EXTRA_TRANS_BLOCKS	8</span>

<span class="cp">#ifdef CONFIG_QUOTA</span>
<span class="cm">/* Amount of blocks needed for quota update - we know that the structure was</span>
<span class="cm"> * allocated so we need to update only inode+data */</span>
<span class="cp">#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)</span>
<span class="cm">/* Amount of blocks needed for quota insert/delete - we do some block writes</span>
<span class="cm"> * but inode, sb and group updates are done only once */</span>
<span class="cp">#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\</span>
<span class="cp">		(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)</span>
<span class="cp">#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\</span>
<span class="cp">		(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)</span>
<span class="cp">#else</span>
<span class="cp">#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0</span>
<span class="cp">#define EXT3_QUOTA_INIT_BLOCKS(sb) 0</span>
<span class="cp">#define EXT3_QUOTA_DEL_BLOCKS(sb) 0</span>
<span class="cp">#endif</span>
<span class="cp">#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))</span>
<span class="cp">#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))</span>
<span class="cp">#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))</span>

<span class="kt">int</span>
<span class="n">ext3_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * On success, We end up with an outstanding reference count against</span>
<span class="cm"> * iloc-&gt;bh.  This _must_ be cleaned up later.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">ext3_reserve_inode_write</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper functions with which ext3 calls into JBD.  The intent here is</span>
<span class="cm"> * to allow these to be turned into appropriate stubs so ext3 can control</span>
<span class="cm"> * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn&#39;t</span>
<span class="cm"> * been done yet.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext3_journal_release_buffer</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_release_buffer</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ext3_journal_abort_handle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caller</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">err_fn</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext3_journal_get_undo_access</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext3_journal_get_write_access</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext3_journal_forget</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext3_journal_revoke</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext3_journal_get_create_access</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span>
				<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ext3_journal_dirty_metadata</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span>
				<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="cp">#define ext3_journal_get_undo_access(handle, bh) \</span>
<span class="cp">	__ext3_journal_get_undo_access(__func__, (handle), (bh))</span>
<span class="cp">#define ext3_journal_get_write_access(handle, bh) \</span>
<span class="cp">	__ext3_journal_get_write_access(__func__, (handle), (bh))</span>
<span class="cp">#define ext3_journal_revoke(handle, blocknr, bh) \</span>
<span class="cp">	__ext3_journal_revoke(__func__, (handle), (blocknr), (bh))</span>
<span class="cp">#define ext3_journal_get_create_access(handle, bh) \</span>
<span class="cp">	__ext3_journal_get_create_access(__func__, (handle), (bh))</span>
<span class="cp">#define ext3_journal_dirty_metadata(handle, bh) \</span>
<span class="cp">	__ext3_journal_dirty_metadata(__func__, (handle), (bh))</span>
<span class="cp">#define ext3_journal_forget(handle, bh) \</span>
<span class="cp">	__ext3_journal_forget(__func__, (handle), (bh))</span>

<span class="kt">int</span> <span class="n">ext3_journal_dirty_data</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="n">handle_t</span> <span class="o">*</span><span class="n">ext3_journal_start_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__ext3_journal_stop</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">ext3_journal_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext3_journal_start_sb</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ext3_journal_stop(handle) \</span>
<span class="cp">	__ext3_journal_stop(__func__, (handle))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">ext3_journal_current_handle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">journal_current_handle</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_journal_extend</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">journal_extend</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_journal_restart</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">journal_restart</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_journal_blocks_per_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">journal_blocks_per_page</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_journal_force_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">journal_force_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* super.c */</span>
<span class="kt">int</span> <span class="n">ext3_force_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_should_journal_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DATA_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="n">EXT3_MOUNT_JOURNAL_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">EXT3_JOURNAL_DATA_FL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_should_order_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">EXT3_JOURNAL_DATA_FL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DATA_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="n">EXT3_MOUNT_ORDERED_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_should_writeback_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">EXT3_JOURNAL_DATA_FL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DATA_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="n">EXT3_MOUNT_WRITEBACK_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &lt;trace/events/ext3.h&gt;</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
