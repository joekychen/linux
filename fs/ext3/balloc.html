<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext3 › balloc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>balloc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ext3/balloc.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  Enhanced block allocation by Stephen Tweedie (sct@redhat.com), 1993</span>
<span class="cm"> *  Big-endian to little-endian byte-swapping/bitmaps by</span>
<span class="cm"> *        David S. Miller (davem@caip.rutgers.edu), 1995</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &quot;ext3.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * balloc.c contains the blocks allocation and deallocation routines</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The free blocks are managed by bitmaps.  A file system contains several</span>
<span class="cm"> * blocks groups.  Each group contains 1 bitmap block for blocks, 1 bitmap</span>
<span class="cm"> * block for inodes, N blocks for the inode table and data blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * The file system contains group descriptors which are located after the</span>
<span class="cm"> * super block.  Each descriptor contains the number of the bitmap block and</span>
<span class="cm"> * the free blocks count in the block.  The descriptors are loaded in memory</span>
<span class="cm"> * when a file system is mounted (see ext3_fill_super).</span>
<span class="cm"> */</span>


<span class="cp">#define in_range(b, first, len)	((b) &gt;= (first) &amp;&amp; (b) &lt;= (first) + (len) - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the block group number and offset, given a block number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext3_get_group_no_and_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">blocknr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">blockgrpp</span><span class="p">,</span> <span class="n">ext3_grpblk_t</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_super_block</span> <span class="o">*</span><span class="n">es</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>

	<span class="n">blocknr</span> <span class="o">=</span> <span class="n">blocknr</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offsetp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">offsetp</span> <span class="o">=</span> <span class="n">blocknr</span> <span class="o">%</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blockgrpp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">blockgrpp</span> <span class="o">=</span> <span class="n">blocknr</span> <span class="o">/</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_get_group_desc() -- load group descriptor from disk</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @block_group:	given block group</span>
<span class="cm"> * @bh:			pointer to the buffer head to store the block</span>
<span class="cm"> *			group descriptor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span> <span class="nf">ext3_get_group_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span> <span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span> <span class="o">&gt;=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext3_get_group_desc&quot;</span><span class="p">,</span>
			    <span class="s">&quot;block_group &gt;= groups_count - &quot;</span>
			    <span class="s">&quot;block_group = %d, groups_count = %lu&quot;</span><span class="p">,</span>
			    <span class="n">block_group</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">);</span>

		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="n">group_desc</span> <span class="o">=</span> <span class="n">block_group</span> <span class="o">&gt;&gt;</span> <span class="n">EXT3_DESC_PER_BLOCK_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">block_group</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EXT3_DESC_PER_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_group_desc</span><span class="p">[</span><span class="n">group_desc</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">ext3_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext3_get_group_desc&quot;</span><span class="p">,</span>
			    <span class="s">&quot;Group descriptor not loaded - &quot;</span>
			    <span class="s">&quot;block_group = %d, group_desc = %lu, desc = %lu&quot;</span><span class="p">,</span>
			     <span class="n">block_group</span><span class="p">,</span> <span class="n">group_desc</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span><span class="p">)</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_group_desc</span><span class="p">[</span><span class="n">group_desc</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_group_desc</span><span class="p">[</span><span class="n">group_desc</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">desc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_valid_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">next_zero_bit</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">bitmap_blk</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">group_first_block</span><span class="p">;</span>

	<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext3_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>

	<span class="cm">/* check whether block bitmap block number is set */</span>
	<span class="n">bitmap_blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">bitmap_blk</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_test_bit</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
		<span class="cm">/* bad block bitmap */</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/* check whether the inode bitmap block number is set */</span>
	<span class="n">bitmap_blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_bitmap</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">bitmap_blk</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_test_bit</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
		<span class="cm">/* bad block bitmap */</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/* check whether the inode table block number is set */</span>
	<span class="n">bitmap_blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">bitmap_blk</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="n">next_zero_bit</span> <span class="o">=</span> <span class="n">ext3_find_next_zero_bit</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
				<span class="n">offset</span> <span class="o">+</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">,</span>
				<span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_zero_bit</span> <span class="o">&gt;=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">)</span>
		<span class="cm">/* good bitmap for inode tables */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="s">&quot;Invalid block bitmap - &quot;</span>
			<span class="s">&quot;block_group = %d, block = %lu&quot;</span><span class="p">,</span>
			<span class="n">block_group</span><span class="p">,</span> <span class="n">bitmap_blk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_block_bitmap()</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @block_group:	given block group</span>
<span class="cm"> *</span>
<span class="cm"> * Read the bitmap for a given block_group,and validate the</span>
<span class="cm"> * bits for block/inode/inode tables are set in the bitmaps</span>
<span class="cm"> *</span>
<span class="cm"> * Return buffer_head on success or NULL in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">read_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">bitmap_blk</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">trace_ext3_read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>
	<span class="n">bitmap_blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bitmap_blk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			    <span class="s">&quot;Cannot read block bitmap - &quot;</span>
			    <span class="s">&quot;block_group = %d, block_bitmap = %u&quot;</span><span class="p">,</span>
			    <span class="n">block_group</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bh_uptodate_or_lock</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bh_submit_read</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			    <span class="s">&quot;Cannot read block bitmap - &quot;</span>
			    <span class="s">&quot;block_group = %d, block_bitmap = %u&quot;</span><span class="p">,</span>
			    <span class="n">block_group</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ext3_valid_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * file system mounted not to panic on error, continue with corrupt</span>
<span class="cm">	 * bitmap</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * The reservation window structure operations</span>
<span class="cm"> * --------------------------------------------</span>
<span class="cm"> * Operations include:</span>
<span class="cm"> * dump, find, add, remove, is_empty, find_next_reservable_window, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * We use a red-black tree to represent per-filesystem reservation</span>
<span class="cm"> * windows.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * __rsv_window_dump() -- Dump the filesystem block allocation reservation map</span>
<span class="cm"> * @rb_root:		root of per-filesystem reservation rb tree</span>
<span class="cm"> * @verbose:		verbose mode</span>
<span class="cm"> * @fn:			function which wishes to dump the reservation map</span>
<span class="cm"> *</span>
<span class="cm"> * If verbose is turned on, it will print the whole block reservation</span>
<span class="cm"> * windows(start, end).	Otherwise, it will only print out the &quot;bad&quot; windows,</span>
<span class="cm"> * those windows that overlap with their immediate neighbors.</span>
<span class="cm"> */</span>
<span class="cp">#if 1</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__rsv_window_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bad</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">bad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block Allocation Reservation Windows Map (%s):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;reservation window 0x%p &quot;</span>
			       <span class="s">&quot;start:  %lu, end:  %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rsv</span><span class="p">,</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">,</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&amp;&amp;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&gt;=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Bad reservation %p (start &gt;= end)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rsv</span><span class="p">);</span>
			<span class="n">bad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">&gt;=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Bad reservation %p (prev-&gt;end &gt;= start)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rsv</span><span class="p">);</span>
			<span class="n">bad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Restarting reservation walk in verbose mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">verbose</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">rsv</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Window map complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bad</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define rsv_window_dump(root, verbose) \</span>
<span class="cp">	__rsv_window_dump((root), (verbose), __func__)</span>
<span class="cp">#else</span>
<span class="cp">#define rsv_window_dump(root, verbose) do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * goal_in_my_reservation()</span>
<span class="cm"> * @rsv:		inode&#39;s reservation window</span>
<span class="cm"> * @grp_goal:		given goal block relative to the allocation block group</span>
<span class="cm"> * @group:		the current allocation block group</span>
<span class="cm"> * @sb:			filesystem super block</span>
<span class="cm"> *</span>
<span class="cm"> * Test if the given goal block (group relative) is within the file&#39;s</span>
<span class="cm"> * own block reservation window range.</span>
<span class="cm"> *</span>
<span class="cm"> * If the reservation window is outside the goal allocation group, return 0;</span>
<span class="cm"> * grp_goal (given goal block) could be -1, which means no specific</span>
<span class="cm"> * goal block. In this case, always return 1.</span>
<span class="cm"> * If the goal block is within the reservation window, return 1;</span>
<span class="cm"> * otherwise, return 0;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">goal_in_my_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_reserve_window</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span> <span class="n">ext3_grpblk_t</span> <span class="n">grp_goal</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">group_first_block</span><span class="p">,</span> <span class="n">group_last_block</span><span class="p">;</span>

	<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext3_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="n">group_last_block</span> <span class="o">=</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_start</span> <span class="o">&gt;</span> <span class="n">group_last_block</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_end</span> <span class="o">&lt;</span> <span class="n">group_first_block</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">grp_goal</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">grp_goal</span> <span class="o">+</span> <span class="n">group_first_block</span> <span class="o">&lt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_start</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">+</span> <span class="n">group_first_block</span> <span class="o">&gt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_end</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * search_reserve_window()</span>
<span class="cm"> * @rb_root:		root of reservation tree</span>
<span class="cm"> * @goal:		target allocation block</span>
<span class="cm"> *</span>
<span class="cm"> * Find the reserved window which includes the goal, or the previous one</span>
<span class="cm"> * if the goal is not in any window.</span>
<span class="cm"> * Returns NULL if there are no windows or if all windows start after the goal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span>
<span class="nf">search_reserve_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">ext3_fsblk_t</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">&lt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">&gt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">rsv</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve fallen off the end of the tree: the goal wasn&#39;t inside</span>
<span class="cm">	 * any particular node.  OK, the previous node must be to one</span>
<span class="cm">	 * side of the interval containing the goal.  If it&#39;s the RHS,</span>
<span class="cm">	 * we need to back up one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&gt;</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">);</span>
		<span class="n">rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rsv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_rsv_window_add() -- Insert a window to the block reservation rb tree.</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @rsv:		reservation window to add</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with rsv_lock hold.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext3_rsv_window_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

	<span class="n">trace_ext3_rsv_window_add</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">rsv</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">rsv_window_dump</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_rsv_window_remove() -- unlink a window from the reservation rb tree</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @rsv:		reservation window to remove</span>
<span class="cm"> *</span>
<span class="cm"> * Mark the block reservation window as not allocated, and unlink it</span>
<span class="cm"> * from the filesystem reservation window rb tree. Must be called with</span>
<span class="cm"> * rsv_lock hold.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rsv_window_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">=</span> <span class="n">EXT3_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>
	<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">=</span> <span class="n">EXT3_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>
	<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rsv_is_empty() -- Check if the reservation window is allocated.</span>
<span class="cm"> * @rsv:		given reservation window to check</span>
<span class="cm"> *</span>
<span class="cm"> * returns 1 if the end block is EXT3_RESERVE_WINDOW_NOT_ALLOCATED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rsv_is_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_reserve_window</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* a valid reservation end block could not be 0 */</span>
	<span class="k">return</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_end</span> <span class="o">==</span> <span class="n">EXT3_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_init_block_alloc_info()</span>
<span class="cm"> * @inode:		file inode structure</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate and initialize the	reservation window structure, and</span>
<span class="cm"> * link the window to the ext3 inode structure at last</span>
<span class="cm"> *</span>
<span class="cm"> * The reservation window structure is only dynamically allocated</span>
<span class="cm"> * and linked to ext3 inode the first time the open file</span>
<span class="cm"> * needs a new block. So, before every ext3_new_block(s) call, for</span>
<span class="cm"> * regular files, we should check whether the reservation window</span>
<span class="cm"> * structure exists or not. In the latter case, this function is called.</span>
<span class="cm"> * Fail to do so will result in block reservation being turned off for that</span>
<span class="cm"> * open file.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from ext3_get_blocks_handle(), also called</span>
<span class="cm"> * when setting the reservation window size through ioctl before the file</span>
<span class="cm"> * is open for write (needs block allocation).</span>
<span class="cm"> *</span>
<span class="cm"> * Needs truncate_mutex protection prior to call this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext3_init_block_alloc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext3_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="n">block_i</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">block_i</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block_i</span><span class="o">-&gt;</span><span class="n">rsv_window_node</span><span class="p">;</span>

		<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">=</span> <span class="n">EXT3_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>
		<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">=</span> <span class="n">EXT3_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if filesystem is mounted with NORESERVATION, the goal</span>
<span class="cm">		 * reservation window size is set to zero to indicate</span>
<span class="cm">		 * block reservation is off</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_opt</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">RESERVATION</span><span class="p">))</span>
			<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span> <span class="o">=</span> <span class="n">EXT3_DEFAULT_RESERVE_BLOCKS</span><span class="p">;</span>
		<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_logical_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_physical_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span> <span class="o">=</span> <span class="n">block_i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_discard_reservation()</span>
<span class="cm"> * @inode:		inode</span>
<span class="cm"> *</span>
<span class="cm"> * Discard(free) block reservation window on last file close, or truncate</span>
<span class="cm"> * or at last iput().</span>
<span class="cm"> *</span>
<span class="cm"> * It is being called in three cases:</span>
<span class="cm"> *	ext3_release_file(): last writer close the file</span>
<span class="cm"> *	ext3_clear_inode(): last iput(), when nobody link to this file.</span>
<span class="cm"> *	ext3_truncate(): when the block indirect map is about to change.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext3_discard_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext3_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">rsv_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_i</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block_i</span><span class="o">-&gt;</span><span class="n">rsv_window_node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">trace_ext3_discard_reservation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">rsv</span><span class="p">);</span>
			<span class="n">rsv_window_remove</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">rsv</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_free_blocks_sb() -- Free given blocks and update quota</span>
<span class="cm"> * @handle:			handle to this transaction</span>
<span class="cm"> * @sb:				super block</span>
<span class="cm"> * @block:			start physcial block to free</span>
<span class="cm"> * @count:			number of blocks to free</span>
<span class="cm"> * @pdquot_freed_blocks:	pointer to quota</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext3_free_blocks_sb</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			 <span class="n">ext3_fsblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdquot_freed_blocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">gd_bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_group</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">bit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overflow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_super_block</span> <span class="o">*</span> <span class="n">es</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">group_freed</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pdquot_freed_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">es</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">block</span> <span class="o">||</span>
	    <span class="n">block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext3_free_blocks&quot;</span><span class="p">,</span>
			    <span class="s">&quot;Freeing blocks not in datazone - &quot;</span>
			    <span class="s">&quot;block = &quot;</span><span class="n">E3FSBLK</span><span class="s">&quot;, count = %lu&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ext3_debug</span> <span class="p">(</span><span class="s">&quot;freeing block(s) %lu-%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">do_more:</span>
	<span class="n">overflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">block_group</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">))</span> <span class="o">/</span>
		      <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">))</span> <span class="o">%</span>
		      <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check to see if we are freeing blocks across a group</span>
<span class="cm">	 * boundary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">overflow</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">overflow</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gd_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_range</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">),</span> <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_bitmap</span><span class="p">),</span> <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">),</span>
		      <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span> <span class="p">(</span><span class="n">block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">),</span>
		      <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext3_free_blocks&quot;</span><span class="p">,</span>
			    <span class="s">&quot;Freeing blocks in system zones - &quot;</span>
			    <span class="s">&quot;Block = &quot;</span><span class="n">E3FSBLK</span><span class="s">&quot;, count = %lu&quot;</span><span class="p">,</span>
			    <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are about to start releasing blocks in the bitmap,</span>
<span class="cm">	 * so we need undo access.</span>
<span class="cm">	 */</span>
	<span class="cm">/* @@@ check errors */</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;getting undo access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_undo_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are about to modify some metadata.  Call the journal APIs</span>
<span class="cm">	 * to unshare -&gt;b_data if a currently-committing transaction is</span>
<span class="cm">	 * using it</span>
<span class="cm">	 */</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">gd_bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">gd_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">group_freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * An HJ special.  This is expensive...</span>
<span class="cm">		 */</span>
<span class="cp">#ifdef CONFIG_JBD_DEBUG</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">debug_bh</span><span class="p">;</span>
			<span class="n">debug_bh</span> <span class="o">=</span> <span class="n">sb_find_get_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debug_bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">debug_bh</span><span class="p">,</span> <span class="s">&quot;Deleted!&quot;</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh2jh</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span>
					<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">debug_bh</span><span class="p">,</span>
						<span class="s">&quot;No committed data in bitmap&quot;</span><span class="p">);</span>
				<span class="n">BUFFER_TRACE2</span><span class="p">(</span><span class="n">debug_bh</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;bitmap&quot;</span><span class="p">);</span>
				<span class="n">__brelse</span><span class="p">(</span><span class="n">debug_bh</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* @@@ This prevents newly-allocated data from being</span>
<span class="cm">		 * freed and then reallocated within the same</span>
<span class="cm">		 * transaction.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Ideally we would want to allow that to happen, but to</span>
<span class="cm">		 * do so requires making journal_forget() capable of</span>
<span class="cm">		 * revoking the queued write of a data block, which</span>
<span class="cm">		 * implies blocking on the journal lock.  *forget()</span>
<span class="cm">		 * cannot block due to truncate races.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Eventually we can fix this by making journal_forget()</span>
<span class="cm">		 * return a status indicating whether or not it was able</span>
<span class="cm">		 * to revoke the buffer.  On successful revoke, it is</span>
<span class="cm">		 * safe not to set the allocation bit in the committed</span>
<span class="cm">		 * bitmap, because we know that there is no outstanding</span>
<span class="cm">		 * activity on the buffer any more and so it is safe to</span>
<span class="cm">		 * reallocate it.</span>
<span class="cm">		 */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;set in b_committed_data&quot;</span><span class="p">);</span>
		<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span>
				<span class="n">bh2jh</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_committed_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ext3_set_bit_atomic</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">block_group</span><span class="p">),</span> <span class="n">bit</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">bh2jh</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We clear the bit in the bitmap after setting the committed</span>
<span class="cm">		 * data bit, because this is the reverse order to that which</span>
<span class="cm">		 * the allocator uses.</span>
<span class="cm">		 */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;clear bit&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_clear_bit_atomic</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">block_group</span><span class="p">),</span>
						<span class="n">bit</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
			<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="s">&quot;bit already cleared for block &quot;</span><span class="n">E3FSBLK</span><span class="p">,</span>
				 <span class="n">block</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;bit already cleared&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">group_freed</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">block_group</span><span class="p">));</span>
	<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">,</span> <span class="n">group_freed</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">block_group</span><span class="p">));</span>
	<span class="n">percpu_counter_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeblocks_counter</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="cm">/* We dirtied the bitmap block */</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;dirtied bitmap block&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>

	<span class="cm">/* And the group descriptor block */</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">gd_bh</span><span class="p">,</span> <span class="s">&quot;dirtied group descriptor block&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">gd_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pdquot_freed_blocks</span> <span class="o">+=</span> <span class="n">group_freed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">overflow</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">overflow</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_more</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">error_return:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_free_blocks() -- Free given blocks and update quota</span>
<span class="cm"> * @handle:		handle for this transaction</span>
<span class="cm"> * @inode:		inode</span>
<span class="cm"> * @block:		start physical block to free</span>
<span class="cm"> * @count:		number of blocks to count</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext3_free_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dquot_freed_blocks</span><span class="p">;</span>

	<span class="n">trace_ext3_free_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">ext3_free_blocks_sb</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dquot_freed_blocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dquot_freed_blocks</span><span class="p">)</span>
		<span class="n">dquot_free_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dquot_freed_blocks</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_test_allocatable()</span>
<span class="cm"> * @nr:			given allocation block group</span>
<span class="cm"> * @bh:			bufferhead contains the bitmap of the given block group</span>
<span class="cm"> *</span>
<span class="cm"> * For ext3 allocations, we must not reuse any blocks which are</span>
<span class="cm"> * allocated in the bitmap buffer&#39;s &quot;last committed data&quot; copy.  This</span>
<span class="cm"> * prevents deletes from freeing up the page for reuse until we have</span>
<span class="cm"> * committed the delete transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * If we didn&#39;t do this, then deleting something and reallocating it as</span>
<span class="cm"> * data would allow the old block to be overwritten before the</span>
<span class="cm"> * transaction committed (because we force data to disk before commit).</span>
<span class="cm"> * This would lead to corruption if we crashed between overwriting the</span>
<span class="cm"> * data and committing the delete.</span>
<span class="cm"> *</span>
<span class="cm"> * @@@ We may want to make this allocation behaviour conditional on</span>
<span class="cm"> * data-writes at some point, and disable it for metadata allocations or</span>
<span class="cm"> * sync-data inodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_test_allocatable</span><span class="p">(</span><span class="n">ext3_grpblk_t</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_test_bit</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">!</span><span class="n">ext3_test_bit</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_search_next_usable_block()</span>
<span class="cm"> * @start:		the starting block (group relative) of the search</span>
<span class="cm"> * @bh:			bufferhead contains the block group bitmap</span>
<span class="cm"> * @maxblocks:		the ending block (group relative) of the reservation</span>
<span class="cm"> *</span>
<span class="cm"> * The bitmap search --- search forward alternately through the actual</span>
<span class="cm"> * bitmap on disk and the last-committed copy in journal, until we find a</span>
<span class="cm"> * bit free in both bitmaps.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext3_grpblk_t</span>
<span class="nf">bitmap_search_next_usable_block</span><span class="p">(</span><span class="n">ext3_grpblk_t</span> <span class="n">start</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
					<span class="n">ext3_grpblk_t</span> <span class="n">maxblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">maxblocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ext3_find_next_zero_bit</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">maxblocks</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&gt;=</span> <span class="n">maxblocks</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext3_test_allocatable</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">ext3_find_next_zero_bit</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">,</span>
							<span class="n">maxblocks</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_next_usable_block()</span>
<span class="cm"> * @start:		the starting block (group relative) to find next</span>
<span class="cm"> *			allocatable block in bitmap.</span>
<span class="cm"> * @bh:			bufferhead contains the block group bitmap</span>
<span class="cm"> * @maxblocks:		the ending block (group relative) for the search</span>
<span class="cm"> *</span>
<span class="cm"> * Find an allocatable block in a bitmap.  We honor both the bitmap and</span>
<span class="cm"> * its last-committed copy (if that exists), and perform the &quot;most</span>
<span class="cm"> * appropriate allocation&quot; algorithm of looking for a free block near</span>
<span class="cm"> * the initial goal; then for a free byte somewhere in the bitmap; then</span>
<span class="cm"> * for any free bit in the bitmap.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext3_grpblk_t</span>
<span class="nf">find_next_usable_block</span><span class="p">(</span><span class="n">ext3_grpblk_t</span> <span class="n">start</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			<span class="n">ext3_grpblk_t</span> <span class="n">maxblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">here</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The goal was occupied; search forward for a free</span>
<span class="cm">		 * block within the next XX blocks.</span>
<span class="cm">		 *</span>
<span class="cm">		 * end_goal is more or less random, but it has to be</span>
<span class="cm">		 * less than EXT3_BLOCKS_PER_GROUP. Aligning up to the</span>
<span class="cm">		 * next 64-bit boundary is simple..</span>
<span class="cm">		 */</span>
		<span class="n">ext3_grpblk_t</span> <span class="n">end_goal</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">63</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">63</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_goal</span> <span class="o">&gt;</span> <span class="n">maxblocks</span><span class="p">)</span>
			<span class="n">end_goal</span> <span class="o">=</span> <span class="n">maxblocks</span><span class="p">;</span>
		<span class="n">here</span> <span class="o">=</span> <span class="n">ext3_find_next_zero_bit</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">end_goal</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">here</span> <span class="o">&lt;</span> <span class="n">end_goal</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_test_allocatable</span><span class="p">(</span><span class="n">here</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">here</span><span class="p">;</span>
		<span class="n">ext3_debug</span><span class="p">(</span><span class="s">&quot;Bit not found near goal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">here</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">here</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">here</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="p">(</span><span class="n">here</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">memscan</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="n">maxblocks</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">here</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;</span> <span class="n">maxblocks</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_test_allocatable</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The bitmap search --- search forward alternately through the actual</span>
<span class="cm">	 * bitmap and the last-committed copy until we find a bit free in</span>
<span class="cm">	 * both</span>
<span class="cm">	 */</span>
	<span class="n">here</span> <span class="o">=</span> <span class="n">bitmap_search_next_usable_block</span><span class="p">(</span><span class="n">here</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">maxblocks</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">here</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * claim_block()</span>
<span class="cm"> * @lock:		the spin lock for this block group</span>
<span class="cm"> * @block:		the free block (group relative) to allocate</span>
<span class="cm"> * @bh:			the buffer_head contains the block group bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * We think we can allocate this block in this bitmap.  Try to set the bit.</span>
<span class="cm"> * If that succeeds then check that nobody has allocated and then freed the</span>
<span class="cm"> * block since we saw that is was not marked in b_committed_data.  If it _was_</span>
<span class="cm"> * allocated and freed then clear the bit in the bitmap again and return</span>
<span class="cm"> * zero (failure).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">claim_block</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="n">ext3_grpblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_set_bit_atomic</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_test_bit</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_clear_bit_atomic</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_try_to_allocate()</span>
<span class="cm"> * @sb:			superblock</span>
<span class="cm"> * @handle:		handle to this transaction</span>
<span class="cm"> * @group:		given allocation block group</span>
<span class="cm"> * @bitmap_bh:		bufferhead holds the block bitmap</span>
<span class="cm"> * @grp_goal:		given target block within the group</span>
<span class="cm"> * @count:		target number of blocks to allocate</span>
<span class="cm"> * @my_rsv:		reservation window</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to allocate blocks within a give range. Set the range of allocation</span>
<span class="cm"> * first, then find the first free bit(s) from the bitmap (within the range),</span>
<span class="cm"> * and at last, allocate the blocks by claiming the found free bit as allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * To set the range of this allocation:</span>
<span class="cm"> *	if there is a reservation window, only try to allocate block(s) from the</span>
<span class="cm"> *	file&#39;s own reservation window;</span>
<span class="cm"> *	Otherwise, the allocation range starts from the give goal block, ends at</span>
<span class="cm"> *	the block group&#39;s last block.</span>
<span class="cm"> *</span>
<span class="cm"> * If we failed to allocate the desired block then we may end up crossing to a</span>
<span class="cm"> * new bitmap.  In that case we must release write access to the old one via</span>
<span class="cm"> * ext3_journal_release_buffer(), else we&#39;ll run out of credits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext3_grpblk_t</span>
<span class="nf">ext3_try_to_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">ext3_grpblk_t</span> <span class="n">grp_goal</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_reserve_window</span> <span class="o">*</span><span class="n">my_rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* we do allocation within the reservation window if we have a window */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext3_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">_rsv_start</span> <span class="o">&gt;=</span> <span class="n">group_first_block</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">_rsv_start</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* reservation window cross group boundary */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">_rsv_end</span> <span class="o">-</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
			<span class="cm">/* reservation window crosses group boundary */</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">grp_goal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">))</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">grp_goal</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">grp_goal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">grp_goal</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>

<span class="nl">repeat:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">ext3_test_allocatable</span><span class="p">(</span><span class="n">grp_goal</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">grp_goal</span> <span class="o">=</span> <span class="n">find_next_usable_block</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_access</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_rsv</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="n">grp_goal</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span>
					<span class="n">ext3_test_allocatable</span><span class="p">(</span><span class="n">grp_goal</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
								<span class="n">bitmap_bh</span><span class="p">);</span>
					<span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">grp_goal</span><span class="o">--</span><span class="p">)</span>
				<span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">grp_goal</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">claim_block</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">group</span><span class="p">),</span>
		<span class="n">grp_goal</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The block was allocated by another thread, or it was</span>
<span class="cm">		 * allocated and then freed by another thread</span>
<span class="cm">		 */</span>
		<span class="n">start</span><span class="o">++</span><span class="p">;</span>
		<span class="n">grp_goal</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_access</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">num</span><span class="o">++</span><span class="p">;</span>
	<span class="n">grp_goal</span><span class="o">++</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="n">end</span>
		<span class="o">&amp;&amp;</span> <span class="n">ext3_test_allocatable</span><span class="p">(</span><span class="n">grp_goal</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">claim_block</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">group</span><span class="p">),</span>
				<span class="n">grp_goal</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
		<span class="n">grp_goal</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">grp_goal</span> <span class="o">-</span> <span class="n">num</span><span class="p">;</span>
<span class="nl">fail_access:</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	find_next_reservable_window():</span>
<span class="cm"> *		find a reservable space within the given range.</span>
<span class="cm"> *		It does not allocate the reservation window for now:</span>
<span class="cm"> *		alloc_new_reservation() will do the work later.</span>
<span class="cm"> *</span>
<span class="cm"> *	@search_head: the head of the searching list;</span>
<span class="cm"> *		This is not necessarily the list head of the whole filesystem</span>
<span class="cm"> *</span>
<span class="cm"> *		We have both head and start_block to assist the search</span>
<span class="cm"> *		for the reservable space. The list starts from head,</span>
<span class="cm"> *		but we will shift to the place where start_block is,</span>
<span class="cm"> *		then start from there, when looking for a reservable space.</span>
<span class="cm"> *</span>
<span class="cm"> *	@my_rsv: the reservation window</span>
<span class="cm"> *</span>
<span class="cm"> *	@sb: the super block</span>
<span class="cm"> *</span>
<span class="cm"> *	@start_block: the first block we consider to start</span>
<span class="cm"> *			the real search from</span>
<span class="cm"> *</span>
<span class="cm"> *	@last_block:</span>
<span class="cm"> *		the maximum block number that our goal reservable space</span>
<span class="cm"> *		could start from. This is normally the last block in this</span>
<span class="cm"> *		group. The search will end when we found the start of next</span>
<span class="cm"> *		possible reservable space is out of this boundary.</span>
<span class="cm"> *		This could handle the cross boundary reservation window</span>
<span class="cm"> *		request.</span>
<span class="cm"> *</span>
<span class="cm"> *	basically we search from the given range, rather than the whole</span>
<span class="cm"> *	reservation double linked list, (start_block, last_block)</span>
<span class="cm"> *	to find a free region that is of my size and has not</span>
<span class="cm"> *	been reserved.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_next_reservable_window</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">search_head</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">my_rsv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span>
				<span class="n">ext3_fsblk_t</span> <span class="n">start_block</span><span class="p">,</span>
				<span class="n">ext3_fsblk_t</span> <span class="n">last_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">cur</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span><span class="p">;</span>

	<span class="cm">/* TODO: make the start of the reservation window byte-aligned */</span>
	<span class="cm">/* cur = *start_block &amp; ~7;*/</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">start_block</span><span class="p">;</span>
	<span class="n">rsv</span> <span class="o">=</span> <span class="n">search_head</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&lt;=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* TODO?</span>
<span class="cm">		 * in the case we could not find a reservable space</span>
<span class="cm">		 * that is what is expected, during the re-search, we could</span>
<span class="cm">		 * remember what&#39;s the largest reservable space we could have</span>
<span class="cm">		 * and return that one.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For now it will fail if we could not find the reservable</span>
<span class="cm">		 * space with expected-size (or more)...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&gt;</span> <span class="n">last_block</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* fail */</span>

		<span class="n">prev</span> <span class="o">=</span> <span class="n">rsv</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">);</span>
		<span class="n">rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="k">struct</span> <span class="n">ext3_reserve_window_node</span><span class="p">,</span><span class="n">rsv_node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Reached the last reservation, we can just append to the</span>
<span class="cm">		 * previous one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Found a reserveable space big enough.  We could</span>
<span class="cm">			 * have a reservation across the group boundary here</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * we come here either :</span>
<span class="cm">	 * when we reach the end of the whole list,</span>
<span class="cm">	 * and there is empty reservable space after last entry in the list.</span>
<span class="cm">	 * append it to the end of the list.</span>
<span class="cm">	 *</span>
<span class="cm">	 * or we found one reservable space in the middle of the list,</span>
<span class="cm">	 * return the reservation window that we could append to.</span>
<span class="cm">	 * succeed.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">my_rsv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">)))</span>
		<span class="n">rsv_window_remove</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let&#39;s book the whole available window for now.  We will check the</span>
<span class="cm">	 * disk bitmap later and then, if there are free blocks then we adjust</span>
<span class="cm">	 * the window size if it&#39;s larger than requested.</span>
<span class="cm">	 * Otherwise, we will remove this node from the tree next time</span>
<span class="cm">	 * call find_next_reservable_window.</span>
<span class="cm">	 */</span>
	<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
	<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">my_rsv</span><span class="p">)</span>
		<span class="n">ext3_rsv_window_add</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	alloc_new_reservation()--allocate a new reservation window</span>
<span class="cm"> *</span>
<span class="cm"> *		To make a new reservation, we search part of the filesystem</span>
<span class="cm"> *		reservation list (the list that inside the group). We try to</span>
<span class="cm"> *		allocate a new reservation window near the allocation goal,</span>
<span class="cm"> *		or the beginning of the group, if there is no goal.</span>
<span class="cm"> *</span>
<span class="cm"> *		We first find a reservable space after the goal, then from</span>
<span class="cm"> *		there, we check the bitmap for the first free block after</span>
<span class="cm"> *		it. If there is no free block until the end of group, then the</span>
<span class="cm"> *		whole group is full, we failed. Otherwise, check if the free</span>
<span class="cm"> *		block is inside the expected reservable space, if so, we</span>
<span class="cm"> *		succeed.</span>
<span class="cm"> *		If the first free block is outside the reservable space, then</span>
<span class="cm"> *		start from the first free block, we search for next available</span>
<span class="cm"> *		space, and go on.</span>
<span class="cm"> *</span>
<span class="cm"> *	on succeed, a new reservation will be found and inserted into the list</span>
<span class="cm"> *	It contains at least one free block, and it does not overlap with other</span>
<span class="cm"> *	reservation windows.</span>
<span class="cm"> *</span>
<span class="cm"> *	failed: we failed to find a reservation window in this group</span>
<span class="cm"> *</span>
<span class="cm"> *	@my_rsv: the reservation window</span>
<span class="cm"> *</span>
<span class="cm"> *	@grp_goal: The goal (group-relative).  It is where the search for a</span>
<span class="cm"> *		free reservable space should start from.</span>
<span class="cm"> *		if we have a grp_goal(grp_goal &gt;0 ), then start from there,</span>
<span class="cm"> *		no grp_goal(grp_goal = -1), we start from the first block</span>
<span class="cm"> *		of the group.</span>
<span class="cm"> *</span>
<span class="cm"> *	@sb: the super block</span>
<span class="cm"> *	@group: the group we are trying to allocate in</span>
<span class="cm"> *	@bitmap_bh: the block group block bitmap</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_new_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">my_rsv</span><span class="p">,</span>
		<span class="n">ext3_grpblk_t</span> <span class="n">grp_goal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">search_head</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">group_first_block</span><span class="p">,</span> <span class="n">group_end_block</span><span class="p">,</span> <span class="n">start_block</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">first_free_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">fs_rsv_root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_root</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">rsv_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_lock</span><span class="p">;</span>

	<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext3_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="n">group_end_block</span> <span class="o">=</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">start_block</span> <span class="o">=</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">start_block</span> <span class="o">=</span> <span class="n">grp_goal</span> <span class="o">+</span> <span class="n">group_first_block</span><span class="p">;</span>

	<span class="n">trace_ext3_alloc_new_reservation</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">start_block</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if the old reservation is cross group boundary</span>
<span class="cm">		 * and if the goal is inside the old reservation window,</span>
<span class="cm">		 * we will come here when we just failed to allocate from</span>
<span class="cm">		 * the first part of the window. We still have another part</span>
<span class="cm">		 * that belongs to the next group. In this case, there is no</span>
<span class="cm">		 * point to discard our window and try to allocate a new one</span>
<span class="cm">		 * in this group(which will fail). we should</span>
<span class="cm">		 * keep the reservation window, just simply move on.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Maybe we could shift the start block of the reservation</span>
<span class="cm">		 * window to the first block of next group.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&lt;=</span> <span class="n">group_end_block</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">&gt;</span> <span class="n">group_end_block</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">start_block</span> <span class="o">&gt;=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">&gt;</span>
		     <span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">-</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if the previously allocation hit ratio is</span>
<span class="cm">			 * greater than 1/2, then we double the size of</span>
<span class="cm">			 * the reservation window the next time,</span>
<span class="cm">			 * otherwise we keep the same size window</span>
<span class="cm">			 */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">EXT3_MAX_RESERVE_BLOCKS</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">EXT3_MAX_RESERVE_BLOCKS</span><span class="p">;</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span><span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * shift the search start to the window near the goal block</span>
<span class="cm">	 */</span>
	<span class="n">search_head</span> <span class="o">=</span> <span class="n">search_reserve_window</span><span class="p">(</span><span class="n">fs_rsv_root</span><span class="p">,</span> <span class="n">start_block</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * find_next_reservable_window() simply finds a reservable window</span>
<span class="cm">	 * inside the given range(start_block, group_end_block).</span>
<span class="cm">	 *</span>
<span class="cm">	 * To make sure the reservation window has a free bit inside it, we</span>
<span class="cm">	 * need to check the bitmap after we found a reservable window.</span>
<span class="cm">	 */</span>
<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">find_next_reservable_window</span><span class="p">(</span><span class="n">search_head</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
						<span class="n">start_block</span><span class="p">,</span> <span class="n">group_end_block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span>
			<span class="n">rsv_window_remove</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * On success, find_next_reservable_window() returns the</span>
<span class="cm">	 * reservation window where there is a reservable space after it.</span>
<span class="cm">	 * Before we reserve this reservable space, we need</span>
<span class="cm">	 * to make sure there is at least a free block inside this region.</span>
<span class="cm">	 *</span>
<span class="cm">	 * searching the first free bit on the block bitmap and copy of</span>
<span class="cm">	 * last committed bitmap alternatively, until we found a allocatable</span>
<span class="cm">	 * block. Search start from the start block of the reservable space</span>
<span class="cm">	 * we just found.</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
	<span class="n">first_free_block</span> <span class="o">=</span> <span class="n">bitmap_search_next_usable_block</span><span class="p">(</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">,</span>
			<span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">group_end_block</span> <span class="o">-</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first_free_block</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * no free block left on the bitmap, no point</span>
<span class="cm">		 * to reserve the space. return failed.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span>
			<span class="n">rsv_window_remove</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* failed */</span>
	<span class="p">}</span>

	<span class="n">start_block</span> <span class="o">=</span> <span class="n">first_free_block</span> <span class="o">+</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * check if the first free block is within the</span>
<span class="cm">	 * free space we just reserved</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_block</span> <span class="o">&gt;=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&amp;&amp;</span>
	    <span class="n">start_block</span> <span class="o">&lt;=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_ext3_reserved</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* success */</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the first free bit we found is out of the reservable space</span>
<span class="cm">	 * continue search for next reservable space,</span>
<span class="cm">	 * start from where the free block is,</span>
<span class="cm">	 * we also shift the list head to where we stopped last time</span>
<span class="cm">	 */</span>
	<span class="n">search_head</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_extend_reservation()</span>
<span class="cm"> * @my_rsv:		given reservation window</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @size:		the delta to extend</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to expand the reservation window large enough to have</span>
<span class="cm"> * required number of free blocks</span>
<span class="cm"> *</span>
<span class="cm"> * Since ext3_try_to_allocate() will always allocate blocks within</span>
<span class="cm"> * the reservation window range, if the window size is too small,</span>
<span class="cm"> * multiple blocks allocation has to stop at the end of the reservation</span>
<span class="cm"> * window. To make this more efficient, given the total number of</span>
<span class="cm"> * blocks needed and the current size of the window, we try to</span>
<span class="cm"> * expand the reservation window size if necessary on a best-effort</span>
<span class="cm"> * basis before ext3_new_blocks() tries to allocate blocks,</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">try_to_extend_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">my_rsv</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">next_rsv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">rsv_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
		<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">next_rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">next_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">-</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">=</span> <span class="n">next_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_try_to_allocate_with_rsv()</span>
<span class="cm"> * @sb:			superblock</span>
<span class="cm"> * @handle:		handle to this transaction</span>
<span class="cm"> * @group:		given allocation block group</span>
<span class="cm"> * @bitmap_bh:		bufferhead holds the block bitmap</span>
<span class="cm"> * @grp_goal:		given target block within the group</span>
<span class="cm"> * @my_rsv:		reservation window</span>
<span class="cm"> * @count:		target number of blocks to allocate</span>
<span class="cm"> * @errp:		pointer to store the error code</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main function used to allocate a new block and its reservation</span>
<span class="cm"> * window.</span>
<span class="cm"> *</span>
<span class="cm"> * Each time when a new block allocation is need, first try to allocate from</span>
<span class="cm"> * its own reservation.  If it does not have a reservation window, instead of</span>
<span class="cm"> * looking for a free bit on bitmap first, then look up the reservation list to</span>
<span class="cm"> * see if it is inside somebody else&#39;s reservation window, we try to allocate a</span>
<span class="cm"> * reservation window for it starting from the goal first. Then do the block</span>
<span class="cm"> * allocation within the reservation window.</span>
<span class="cm"> *</span>
<span class="cm"> * This will avoid keeping on searching the reservation list again and</span>
<span class="cm"> * again when somebody is looking for a free block (without</span>
<span class="cm"> * reservation), and there are lots of free blocks, but they are all</span>
<span class="cm"> * being reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * We use a red-black tree for the per-filesystem reservation list.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext3_grpblk_t</span>
<span class="nf">ext3_try_to_allocate_with_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">,</span>
			<span class="n">ext3_grpblk_t</span> <span class="n">grp_goal</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span> <span class="n">my_rsv</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">group_first_block</span><span class="p">,</span> <span class="n">group_last_block</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fatal</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>

	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we use undo access for the bitmap, because it is critical</span>
<span class="cm">	 * that we do the frozen_data COW on bitmap buffers in all cases even</span>
<span class="cm">	 * if the buffer is in BJ_Forget state in the committing transaction.</span>
<span class="cm">	 */</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;get undo access for new block&quot;</span><span class="p">);</span>
	<span class="n">fatal</span> <span class="o">=</span> <span class="n">ext3_journal_get_undo_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">fatal</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t deal with reservation when</span>
<span class="cm">	 * filesystem is mounted without reservation</span>
<span class="cm">	 * or the file is not a regular file</span>
<span class="cm">	 * or last attempt to allocate a block with reservation turned on failed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_try_to_allocate</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span>
						<span class="n">grp_goal</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * grp_goal is a group relative block number (if there is a goal)</span>
<span class="cm">	 * 0 &lt;= grp_goal &lt; EXT3_BLOCKS_PER_GROUP(sb)</span>
<span class="cm">	 * first block is a filesystem wide block number</span>
<span class="cm">	 * first block is the block number of the first block in this group</span>
<span class="cm">	 */</span>
	<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext3_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="n">group_last_block</span> <span class="o">=</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Basically we will allocate a new block from inode&#39;s reservation</span>
<span class="cm">	 * window.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to allocate a new reservation window, if:</span>
<span class="cm">	 * a) inode does not have a reservation window; or</span>
<span class="cm">	 * b) last attempt to allocate a block from existing reservation</span>
<span class="cm">	 *    failed; or</span>
<span class="cm">	 * c) we come here with a goal and with a reservation window</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do not need to allocate a new reservation window if we come here</span>
<span class="cm">	 * at the beginning with a goal and the goal is inside the window, or</span>
<span class="cm">	 * we don&#39;t have a goal but already have a reservation window.</span>
<span class="cm">	 * then we could go to allocate from the reservation window directly.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">goal_in_my_reservation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">,</span>
						<span class="n">grp_goal</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
				<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_new_reservation</span><span class="p">(</span><span class="n">my_rsv</span><span class="p">,</span> <span class="n">grp_goal</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
							<span class="n">group</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>			<span class="cm">/* failed */</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">goal_in_my_reservation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">,</span>
							<span class="n">grp_goal</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span>
				<span class="n">grp_goal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">-</span>
					<span class="p">(</span><span class="n">grp_goal</span> <span class="o">+</span> <span class="n">group_first_block</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
				<span class="n">try_to_extend_reservation</span><span class="p">(</span><span class="n">my_rsv</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
							<span class="o">*</span><span class="n">count</span> <span class="o">-</span> <span class="n">curr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&gt;</span> <span class="n">group_last_block</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">&lt;</span> <span class="n">group_first_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rsv_window_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_try_to_allocate</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span>
					   <span class="n">grp_goal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
			<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>				<span class="cm">/* succeed */</span>
		<span class="p">}</span>
		<span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;journal_dirty_metadata for &quot;</span>
					<span class="s">&quot;bitmap block&quot;</span><span class="p">);</span>
		<span class="n">fatal</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">fatal</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;journal_release_buffer&quot;</span><span class="p">);</span>
	<span class="n">ext3_journal_release_buffer</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_has_free_blocks()</span>
<span class="cm"> * @sbi:		in-core super block structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Check if filesystem has at least 1 free block available for allocation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_has_free_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">use_reservation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">free_blocks</span><span class="p">,</span> <span class="n">root_blocks</span><span class="p">;</span>

	<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeblocks_counter</span><span class="p">);</span>
	<span class="n">root_blocks</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_r_blocks_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;</span> <span class="n">root_blocks</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">use_reservation</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_resuid</span><span class="p">,</span> <span class="n">current_fsuid</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_resgid</span><span class="p">,</span> <span class="n">GLOBAL_ROOT_GID</span><span class="p">)</span> <span class="o">||</span>
		 <span class="o">!</span><span class="n">in_group_p</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_resgid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_should_retry_alloc()</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @retries		number of attemps has been made</span>
<span class="cm"> *</span>
<span class="cm"> * ext3_should_retry_alloc() is called when ENOSPC is returned, and if</span>
<span class="cm"> * it is profitable to retry the operation, this function will wait</span>
<span class="cm"> * for the current or committing transaction to complete, and then</span>
<span class="cm"> * return TRUE.</span>
<span class="cm"> *</span>
<span class="cm"> * if the total number of retries exceed three times, return FALSE.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_should_retry_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">retries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_has_free_blocks</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">retries</span><span class="p">)</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: retrying operation after ENOSPC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">journal_force_commit_nested</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_journal</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_new_blocks() -- core block(s) allocation function</span>
<span class="cm"> * @handle:		handle to this transaction</span>
<span class="cm"> * @inode:		file inode</span>
<span class="cm"> * @goal:		given target block(filesystem wide)</span>
<span class="cm"> * @count:		target number of blocks to allocate</span>
<span class="cm"> * @errp:		error code</span>
<span class="cm"> *</span>
<span class="cm"> * ext3_new_blocks uses a goal block to assist allocation.  It tries to</span>
<span class="cm"> * allocate block(s) from the block group contains the goal block first. If that</span>
<span class="cm"> * fails, it will try to allocate block(s) from other block groups without</span>
<span class="cm"> * any specific goal block.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">ext3_fsblk_t</span> <span class="nf">ext3_new_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">gdp_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group_no</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">goal_group</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">grp_target_blk</span><span class="p">;</span>	<span class="cm">/* blockgroup relative goal block */</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">grp_alloc_blk</span><span class="p">;</span>	<span class="cm">/* blockgroup-relative allocated block*/</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">ret_block</span><span class="p">;</span>		<span class="cm">/* filesyetem-wide allocated block */</span>
	<span class="kt">int</span> <span class="n">bgi</span><span class="p">;</span>			<span class="cm">/* blockgroup iteration index */</span>
	<span class="kt">int</span> <span class="n">fatal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">performed_allocation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">free_blocks</span><span class="p">;</span>	<span class="cm">/* number of free blocks in a group */</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_reserve_window_node</span> <span class="o">*</span><span class="n">my_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">windowsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef EXT3FS_DEBUG</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">goal_hits</span><span class="p">,</span> <span class="n">goal_attempts</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ngroups</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>

	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check quota for allocation of this block.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dquot_alloc_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_ext3_request_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

	<span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">es</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>
	<span class="n">ext3_debug</span><span class="p">(</span><span class="s">&quot;goal=%lu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate a block from reservation only when</span>
<span class="cm">	 * filesystem is mounted with reservation(default,-o reservation), and</span>
<span class="cm">	 * it&#39;s a regular file, and</span>
<span class="cm">	 * the desired window size is greater than 0 (One could use ioctl</span>
<span class="cm">	 * command EXT3_IOC_SETRSVSZ to set the window size to 0 to turn off</span>
<span class="cm">	 * reservation on that particular file)</span>
<span class="cm">	 */</span>
	<span class="n">block_i</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_i</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">windowsz</span> <span class="o">=</span> <span class="n">block_i</span><span class="o">-&gt;</span><span class="n">rsv_window_node</span><span class="p">.</span><span class="n">rsv_goal_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">my_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block_i</span><span class="o">-&gt;</span><span class="n">rsv_window_node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_has_free_blocks</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">IS_NOQUOTA</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * First, test whether the goal block is free.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">goal</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">))</span>
		<span class="n">goal</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">);</span>
	<span class="n">group_no</span> <span class="o">=</span> <span class="p">(</span><span class="n">goal</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">))</span> <span class="o">/</span>
			<span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">goal_group</span> <span class="o">=</span> <span class="n">group_no</span><span class="p">;</span>
<span class="nl">retry_alloc:</span>
	<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdp_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>

	<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * if there is not enough free blocks to make a new resevation</span>
<span class="cm">	 * turn off reservation for this allocation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;</span> <span class="n">windowsz</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">)))</span>
		<span class="n">my_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">grp_target_blk</span> <span class="o">=</span> <span class="p">((</span><span class="n">goal</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">))</span> <span class="o">%</span>
				<span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
		<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>
		<span class="n">grp_alloc_blk</span> <span class="o">=</span> <span class="n">ext3_try_to_allocate_with_rsv</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span>
					<span class="n">group_no</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">grp_target_blk</span><span class="p">,</span>
					<span class="n">my_rsv</span><span class="p">,</span>	<span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fatal</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp_alloc_blk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ngroups</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now search the rest of the groups.  We assume that</span>
<span class="cm">	 * group_no and gdp correctly point to the last group visited.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bgi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bgi</span> <span class="o">&lt;</span> <span class="n">ngroups</span><span class="p">;</span> <span class="n">bgi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">group_no</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">group_no</span> <span class="o">&gt;=</span> <span class="n">ngroups</span><span class="p">)</span>
			<span class="n">group_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdp_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>
		<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * skip this group (and avoid loading bitmap) if there</span>
<span class="cm">		 * are no free blocks</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_blocks</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * skip this group if the number of</span>
<span class="cm">		 * free blocks is less than half of the reservation</span>
<span class="cm">		 * window size.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">windowsz</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
		<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * try to allocate block(s) from this group, without a goal(-1).</span>
<span class="cm">		 */</span>
		<span class="n">grp_alloc_blk</span> <span class="o">=</span> <span class="n">ext3_try_to_allocate_with_rsv</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span>
					<span class="n">group_no</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fatal</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp_alloc_blk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We may end up a bogus earlier ENOSPC error due to</span>
<span class="cm">	 * filesystem is &quot;full&quot; of reservations, but</span>
<span class="cm">	 * there maybe indeed free blocks available on disk</span>
<span class="cm">	 * In this case, we just forget about the reservations</span>
<span class="cm">	 * just do block allocation as without reservations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">my_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">windowsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">group_no</span> <span class="o">=</span> <span class="n">goal_group</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* No space left on the device */</span>
	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">allocated:</span>

	<span class="n">ext3_debug</span><span class="p">(</span><span class="s">&quot;using block group %d(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">group_no</span><span class="p">,</span> <span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">gdp_bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">fatal</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">gdp_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret_block</span> <span class="o">=</span> <span class="n">grp_alloc_blk</span> <span class="o">+</span> <span class="n">ext3_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_range</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">),</span> <span class="n">ret_block</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_inode_bitmap</span><span class="p">),</span> <span class="n">ret_block</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span><span class="p">(</span><span class="n">ret_block</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">),</span>
		      <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span><span class="p">(</span><span class="n">ret_block</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">),</span>
		      <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext3_new_block&quot;</span><span class="p">,</span>
			    <span class="s">&quot;Allocating block in system zone - &quot;</span>
			    <span class="s">&quot;blocks from &quot;</span><span class="n">E3FSBLK</span><span class="s">&quot;, length %lu&quot;</span><span class="p">,</span>
			     <span class="n">ret_block</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * claim_block() marked the blocks we allocated as in use. So we</span>
<span class="cm">		 * may want to selectively mark some of the blocks as free.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">retry_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">performed_allocation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_JBD_DEBUG</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">debug_bh</span><span class="p">;</span>

		<span class="cm">/* Record bitmap buffer state in the newly allocated block */</span>
		<span class="n">debug_bh</span> <span class="o">=</span> <span class="n">sb_find_get_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ret_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug_bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">debug_bh</span><span class="p">,</span> <span class="s">&quot;state when allocated&quot;</span><span class="p">);</span>
			<span class="n">BUFFER_TRACE2</span><span class="p">(</span><span class="n">debug_bh</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;bitmap state&quot;</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">debug_bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group_no</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext3_test_bit</span><span class="p">(</span><span class="n">grp_alloc_blk</span><span class="o">+</span><span class="n">i</span><span class="p">,</span>
					<span class="n">bh2jh</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: block was unexpectedly set in &quot;</span>
					<span class="s">&quot;b_committed_data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ext3_debug</span><span class="p">(</span><span class="s">&quot;found bit %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">grp_alloc_blk</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group_no</span><span class="p">));</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_block</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext3_new_block&quot;</span><span class="p">,</span>
			    <span class="s">&quot;block(&quot;</span><span class="n">E3FSBLK</span><span class="s">&quot;) &gt;= blocks count(%d) - &quot;</span>
			    <span class="s">&quot;block_group = %d, es == %p &quot;</span><span class="p">,</span> <span class="n">ret_block</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">),</span> <span class="n">group_no</span><span class="p">,</span> <span class="n">es</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is up to the caller to add the new buffer to a journal</span>
<span class="cm">	 * list of some description.  We don&#39;t know in advance whether</span>
<span class="cm">	 * the caller wants to use it as metadata or data.</span>
<span class="cm">	 */</span>
	<span class="n">ext3_debug</span><span class="p">(</span><span class="s">&quot;allocating block %lu. Goal hits %d of %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret_block</span><span class="p">,</span> <span class="n">goal_hits</span><span class="p">,</span> <span class="n">goal_attempts</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group_no</span><span class="p">));</span>
	<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group_no</span><span class="p">));</span>
	<span class="n">percpu_counter_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeblocks_counter</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">gdp_bh</span><span class="p">,</span> <span class="s">&quot;journal_dirty_metadata for group descriptor&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">gdp_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fatal</span><span class="p">)</span>
		<span class="n">fatal</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dquot_free_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">count</span><span class="o">-</span><span class="n">num</span><span class="p">);</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_ext3_allocate_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ret_block</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_block</span><span class="p">;</span>

<span class="nl">io_error:</span>
	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">fatal</span><span class="p">;</span>
		<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fatal</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Undo the block allocation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">performed_allocation</span><span class="p">)</span>
		<span class="n">dquot_free_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">count</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ext3_fsblk_t</span> <span class="nf">ext3_new_block</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ext3_new_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">errp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_count_free_blocks() -- count filesystem free blocks</span>
<span class="cm"> * @sb:		superblock</span>
<span class="cm"> *</span>
<span class="cm"> * Adds up the number of free blocks from each block group.</span>
<span class="cm"> */</span>
<span class="n">ext3_fsblk_t</span> <span class="nf">ext3_count_free_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">desc_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ngroups</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">;</span>
<span class="cp">#ifdef EXT3FS_DEBUG</span>
	<span class="k">struct</span> <span class="n">ext3_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">bitmap_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">es</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>
	<span class="n">desc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bitmap_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gdp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ngroups</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">desc_count</span> <span class="o">+=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
		<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap_bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">x</span> <span class="o">=</span> <span class="n">ext3_count_free</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;group %d: stored = %d, counted = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">),</span> <span class="n">x</span><span class="p">);</span>
		<span class="n">bitmap_count</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ext3_count_free_blocks: stored = &quot;</span><span class="n">E3FSBLK</span>
		<span class="s">&quot;, computed = &quot;</span><span class="n">E3FSBLK</span><span class="s">&quot;, &quot;</span><span class="n">E3FSBLK</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_free_blocks_count</span><span class="p">),</span>
		<span class="n">desc_count</span><span class="p">,</span> <span class="n">bitmap_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bitmap_count</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">desc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ngroups</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">desc_count</span> <span class="o">+=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">desc_count</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_root</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">num</span><span class="p">)</span>
		<span class="n">num</span> <span class="o">*=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">num</span> <span class="o">==</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_group_sparse</span><span class="p">(</span><span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">group</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">test_root</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">||</span> <span class="n">test_root</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">test_root</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_bg_has_super - number of blocks used by the superblock in group</span>
<span class="cm"> *	@sb: superblock for filesystem</span>
<span class="cm"> *	@group: group number to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the number of blocks used by the superblock (primary or backup)</span>
<span class="cm"> *	in this group.  Currently this will be only 0 or 1.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_bg_has_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT3_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				<span class="n">EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">ext3_group_sparse</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ext3_bg_num_gdb_meta</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">metagroup</span> <span class="o">=</span> <span class="n">group</span> <span class="o">/</span> <span class="n">EXT3_DESC_PER_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first</span> <span class="o">=</span> <span class="n">metagroup</span> <span class="o">*</span> <span class="n">EXT3_DESC_PER_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">EXT3_DESC_PER_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group</span> <span class="o">==</span> <span class="n">first</span> <span class="o">||</span> <span class="n">group</span> <span class="o">==</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">group</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ext3_bg_num_gdb_nometa</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext3_bg_has_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="o">?</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_gdb_count</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_bg_num_gdb - number of blocks used by the group table in group</span>
<span class="cm"> *	@sb: superblock for filesystem</span>
<span class="cm"> *	@group: group number to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the number of blocks used by the group descriptor table</span>
<span class="cm"> *	(primary or backup) in this group.  In the future there may be a</span>
<span class="cm"> *	different number of descriptor blocks in each group.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ext3_bg_num_gdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_meta_bg</span> <span class="o">=</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_first_meta_bg</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">metagroup</span> <span class="o">=</span> <span class="n">group</span> <span class="o">/</span> <span class="n">EXT3_DESC_PER_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT3_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span><span class="n">EXT3_FEATURE_INCOMPAT_META_BG</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">metagroup</span> <span class="o">&lt;</span> <span class="n">first_meta_bg</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ext3_bg_num_gdb_nometa</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span><span class="n">group</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ext3_bg_num_gdb_meta</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span><span class="n">group</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_trim_all_free -- function to trim all free space in alloc. group</span>
<span class="cm"> * @sb:			super block for file system</span>
<span class="cm"> * @group:		allocation group to trim</span>
<span class="cm"> * @start:		first group block to examine</span>
<span class="cm"> * @max:		last group block to examine</span>
<span class="cm"> * @gdp:		allocation group description structure</span>
<span class="cm"> * @minblocks:		minimum extent block count</span>
<span class="cm"> *</span>
<span class="cm"> * ext3_trim_all_free walks through group&#39;s block bitmap searching for free</span>
<span class="cm"> * blocks. When the free block is found, it tries to allocate this block and</span>
<span class="cm"> * consequent free block to get the biggest free extent possible, until it</span>
<span class="cm"> * reaches any used block. Then issue a TRIM command on this extent and free</span>
<span class="cm"> * the extent in the block bitmap. This is done until whole group is scanned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext3_grpblk_t</span> <span class="nf">ext3_trim_all_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span>
					<span class="n">ext3_grpblk_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">ext3_grpblk_t</span> <span class="n">max</span><span class="p">,</span>
					<span class="n">ext3_grpblk_t</span> <span class="n">minblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">next</span><span class="p">,</span> <span class="n">free_blocks</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">freed</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">discard_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">gdp_bh</span><span class="p">,</span> <span class="o">*</span><span class="n">bitmap_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We will update one block bitmap, and one group descriptor</span>
<span class="cm">	 */</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;getting undo access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_undo_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdp_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">gdp_bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">gdp_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
	<span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	 <span class="cm">/* Walk through the whole group */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">bitmap_search_next_usable_block</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Allocate contiguous free extents by setting bits in the</span>
<span class="cm">		 * block bitmap</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;=</span> <span class="n">max</span>
			<span class="o">&amp;&amp;</span> <span class="n">claim_block</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group</span><span class="p">),</span>
					<span class="n">next</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">next</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		 <span class="cm">/* We did not claim any blocks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">discard_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">ext3_fsblk_t</span><span class="p">)</span><span class="n">start</span> <span class="o">+</span>
				<span class="n">ext3_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>

		<span class="cm">/* Update counters */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group</span><span class="p">));</span>
		<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="n">next</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group</span><span class="p">));</span>
		<span class="n">percpu_counter_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeblocks_counter</span><span class="p">,</span> <span class="n">next</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>

		<span class="n">free_blocks</span> <span class="o">-=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="cm">/* Do not issue a TRIM on extents smaller than minblocks */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">next</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minblocks</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_extent</span><span class="p">;</span>

		<span class="n">trace_ext3_discard_blocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">discard_block</span><span class="p">,</span> <span class="n">next</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
		 <span class="cm">/* Send the TRIM command down to the device */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sb_issue_discard</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">discard_block</span><span class="p">,</span> <span class="n">next</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
				       <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">next</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
<span class="nl">free_extent:</span>
		<span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear bits in the bitmap</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bit</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="n">next</span><span class="p">;</span> <span class="n">bit</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;clear bit&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_clear_bit_atomic</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group</span><span class="p">),</span>
						<span class="n">bit</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					<span class="s">&quot;bit already cleared for block &quot;</span><span class="n">E3FSBLK</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bit</span><span class="p">);</span>
				<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;bit already cleared&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">freed</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Update couters */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group</span><span class="p">));</span>
		<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group</span><span class="p">));</span>
		<span class="n">percpu_counter_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeblocks_counter</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
				<span class="n">ext3_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;Discard command &quot;</span>
					     <span class="s">&quot;returned error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/* No more suitable extents */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;</span> <span class="n">minblocks</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We dirtied the bitmap block */</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="s">&quot;dirtied bitmap block&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* And the group descriptor block */</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">gdp_bh</span><span class="p">,</span> <span class="s">&quot;dirtied group descriptor block&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">gdp_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ext3_debug</span><span class="p">(</span><span class="s">&quot;trimmed %d blocks in the group %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">count</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_trim_fs() -- trim ioctl handle function</span>
<span class="cm"> * @sb:			superblock for filesystem</span>
<span class="cm"> * @start:		First Byte to trim</span>
<span class="cm"> * @len:		number of Bytes to trim from start</span>
<span class="cm"> * @minlen:		minimum extent length in Bytes</span>
<span class="cm"> *</span>
<span class="cm"> * ext3_trim_fs goes through all allocation groups containing Bytes from</span>
<span class="cm"> * start to start+len. For each such a group ext3_trim_all_free function</span>
<span class="cm"> * is invoked to trim all free space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_trim_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fstrim_range</span> <span class="o">*</span><span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">last_block</span><span class="p">,</span> <span class="n">first_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group</span><span class="p">,</span> <span class="n">first_group</span><span class="p">,</span> <span class="n">last_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_super_block</span> <span class="o">*</span><span class="n">es</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">minlen</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">trimmed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">first_data_blk</span> <span class="o">=</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">);</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">max_blks</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">minlen</span> <span class="o">=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">minlen</span> <span class="o">&gt;</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">max_blks</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">max_blks</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">max_blks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">first_data_blk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">first_data_blk</span><span class="p">)</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">first_data_blk</span><span class="p">;</span>

	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="cm">/* Determine first and last group to examine based on start and len */</span>
	<span class="n">ext3_get_group_no_and_offset</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="p">(</span><span class="n">ext3_fsblk_t</span><span class="p">)</span> <span class="n">start</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">first_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>
	<span class="n">ext3_get_group_no_and_offset</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="p">(</span><span class="n">ext3_fsblk_t</span><span class="p">)</span> <span class="n">end</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">last_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_block</span><span class="p">);</span>

	<span class="cm">/* end now represents the last block to discard in this group */</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="n">first_group</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;=</span> <span class="n">last_group</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For all the groups except the last one, last block will</span>
<span class="cm">		 * always be EXT3_BLOCKS_PER_GROUP(sb)-1, so we only need to</span>
<span class="cm">		 * change it for the last group, note that last_block is</span>
<span class="cm">		 * already computed earlier by ext3_get_group_no_and_offset()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">group</span> <span class="o">==</span> <span class="n">last_group</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">last_block</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_trim_all_free</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">first_block</span><span class="p">,</span>
						 <span class="n">end</span><span class="p">,</span> <span class="n">minlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">trimmed</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * For every group except the first one, we are sure</span>
<span class="cm">		 * that the first block to discard will be block #0.</span>
<span class="cm">		 */</span>
		<span class="n">first_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">trimmed</span> <span class="o">*</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
