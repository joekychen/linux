<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext3 › namei.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>namei.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ext3/namei.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/minix/namei.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  Big-endian to little-endian byte-swapping/bitmaps by</span>
<span class="cm"> *        David S. Miller (davem@caip.rutgers.edu), 1995</span>
<span class="cm"> *  Directory entry file type support and forward compatibility hooks</span>
<span class="cm"> *	for B-tree directories by Theodore Ts&#39;o (tytso@mit.edu), 1998</span>
<span class="cm"> *  Hash Tree Directory indexing (c)</span>
<span class="cm"> *	Daniel Phillips, 2001</span>
<span class="cm"> *  Hash Tree Directory indexing porting</span>
<span class="cm"> *	Christopher Li, 2002</span>
<span class="cm"> *  Hash Tree Directory indexing cleanup</span>
<span class="cm"> *	Theodore Ts&#39;o, 2002</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &quot;ext3.h&quot;</span>
<span class="cp">#include &quot;namei.h&quot;</span>
<span class="cp">#include &quot;xattr.h&quot;</span>
<span class="cp">#include &quot;acl.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * define how far ahead to read directories while searching them.</span>
<span class="cm"> */</span>
<span class="cp">#define NAMEI_RA_CHUNKS  2</span>
<span class="cp">#define NAMEI_RA_BLOCKS  4</span>
<span class="cp">#define NAMEI_RA_SIZE        (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)</span>
<span class="cp">#define NAMEI_RA_INDEX(c,b)  (((c) * NAMEI_RA_BLOCKS) + (b))</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">ext3_append</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					<span class="n">u32</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
		<span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef assert</span>
<span class="cp">#define assert(test) J_ASSERT(test)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DX_DEBUG</span>
<span class="cp">#define dxtrace(command) command</span>
<span class="cp">#else</span>
<span class="cp">#define dxtrace(command)</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">fake_dirent</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">rec_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">file_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dx_countlimit</span>
<span class="p">{</span>
	<span class="n">__le16</span> <span class="n">limit</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dx_entry</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="n">hash</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">block</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * dx_root_info is laid out so that if it should somehow get overlaid by a</span>
<span class="cm"> * dirent the two low bits of the hash version will be zero.  Therefore, the</span>
<span class="cm"> * hash version mod 4 should never be 0.  Sincerely, the paranoia department.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">dx_root</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fake_dirent</span> <span class="n">dot</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dot_name</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">fake_dirent</span> <span class="n">dotdot</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dotdot_name</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">dx_root_info</span>
	<span class="p">{</span>
		<span class="n">__le32</span> <span class="n">reserved_zero</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">hash_version</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">info_length</span><span class="p">;</span> <span class="cm">/* 8 */</span>
		<span class="n">u8</span> <span class="n">indirect_levels</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">unused_flags</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_entry</span>	<span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dx_node</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fake_dirent</span> <span class="n">fake</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_entry</span>	<span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">dx_frame</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">at</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dx_map_entry</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="n">dx_get_block</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dx_set_block</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="n">dx_get_hash</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dx_set_hash</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">dx_get_count</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">dx_get_limit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dx_set_count</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dx_set_limit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">dx_root_limit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">infosize</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">dx_node_limit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">dx_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dx_release</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frames</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dx_make_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="n">map</span><span class="p">[]);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dx_sort_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">dx_move_dirents</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">dx_pack_dirents</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dx_insert_block</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash</span><span class="p">,</span> <span class="n">u32</span> <span class="n">block</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext3_htree_next_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">hash</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frames</span><span class="p">,</span>
				 <span class="n">__u32</span> <span class="o">*</span><span class="n">start_hash</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">ext3_dx_find_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">**</span><span class="n">res_dir</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext3_dx_add_entry</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * p is at least 6 bytes before the end of page</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span>
<span class="nf">ext3_next_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">+</span>
		<span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Future: use high four bits of block for coalesce-on-delete flags</span>
<span class="cm"> * Mask them off for now.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">dx_get_block</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dx_set_block</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">dx_get_hash</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dx_set_hash</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">dx_get_count</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le16_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">dx_countlimit</span> <span class="o">*</span><span class="p">)</span> <span class="n">entries</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">dx_get_limit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le16_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">dx_countlimit</span> <span class="o">*</span><span class="p">)</span> <span class="n">entries</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dx_set_count</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">dx_countlimit</span> <span class="o">*</span><span class="p">)</span> <span class="n">entries</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dx_set_limit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">dx_countlimit</span> <span class="o">*</span><span class="p">)</span> <span class="n">entries</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">dx_root_limit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">infosize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">entry_space</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
		<span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">infosize</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">entry_space</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">dx_node_limit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">entry_space</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">entry_space</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Debug</span>
<span class="cm"> */</span>
<span class="cp">#ifdef DX_DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dx_show_index</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">label</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">dx_get_count</span> <span class="p">(</span><span class="n">entries</span><span class="p">);</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s index &quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%x-&gt;%u &quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">?</span> <span class="n">dx_get_hash</span><span class="p">(</span><span class="n">entries</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dx_get_block</span><span class="p">(</span><span class="n">entries</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">stats</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">names</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">space</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bcount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">stats</span> <span class="nf">dx_show_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">show_names</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">names</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="n">h</span> <span class="o">=</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;names: &quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">show_names</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">;</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="o">++</span><span class="p">);</span>
				<span class="n">ext3fs_dirhash</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;:%x.%u &quot;</span><span class="p">,</span> <span class="n">h</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">-</span> <span class="n">base</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">space</span> <span class="o">+=</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
			<span class="n">names</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">names</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">stats</span><span class="p">)</span> <span class="p">{</span> <span class="n">names</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">stats</span> <span class="nf">dx_show_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="kt">int</span> <span class="n">levels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dx_get_count</span> <span class="p">(</span><span class="n">entries</span><span class="p">),</span> <span class="n">names</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%i indexed blocks...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">entries</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">u32</span> <span class="n">block</span> <span class="o">=</span> <span class="n">dx_get_block</span><span class="p">(</span><span class="n">entries</span><span class="p">),</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">i</span><span class="o">?</span> <span class="n">dx_get_hash</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">range</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">?</span> <span class="p">(</span><span class="n">dx_get_hash</span><span class="p">(</span><span class="n">entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">hash</span><span class="p">)</span><span class="o">:</span> <span class="o">~</span><span class="n">hash</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">stats</span> <span class="n">stats</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s%3u:%03u hash %8x/%8x &quot;</span><span class="p">,</span><span class="n">levels</span><span class="o">?</span><span class="s">&quot;&quot;</span><span class="o">:</span><span class="s">&quot;   &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">range</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">err</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">stats</span> <span class="o">=</span> <span class="n">levels</span><span class="o">?</span>
		   <span class="n">dx_show_entries</span><span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">dx_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">:</span>
		   <span class="n">dx_show_leaf</span><span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">names</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">names</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">space</span><span class="p">;</span>
		<span class="n">bcount</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">bcount</span><span class="p">;</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcount</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%snames %u, fullness %u (%u%%)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">levels</span><span class="o">?</span><span class="s">&quot;&quot;</span><span class="o">:</span><span class="s">&quot;   &quot;</span><span class="p">,</span>
			<span class="n">names</span><span class="p">,</span> <span class="n">space</span><span class="o">/</span><span class="n">bcount</span><span class="p">,(</span><span class="n">space</span><span class="o">/</span><span class="n">bcount</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">blocksize</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">stats</span><span class="p">)</span> <span class="p">{</span> <span class="n">names</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">bcount</span><span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DX_DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Probe for a directory leaf block to search.</span>
<span class="cm"> *</span>
<span class="cm"> * dx_probe can return ERR_BAD_DX_DIR, which means there was a format</span>
<span class="cm"> * error in the directory index, and the caller should fall back to</span>
<span class="cm"> * searching the directory normally.  The callers of dx_probe **MUST**</span>
<span class="cm"> * check for this error code, and make sure it never gets reflected</span>
<span class="cm"> * back to userspace.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span>
<span class="nf">dx_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	 <span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frame_in</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">,</span> <span class="n">indirect</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">at</span><span class="p">,</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame_in</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>

	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_root</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">!=</span> <span class="n">DX_HASH_TEA</span> <span class="o">&amp;&amp;</span>
	    <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">!=</span> <span class="n">DX_HASH_HALF_MD4</span> <span class="o">&amp;&amp;</span>
	    <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">!=</span> <span class="n">DX_HASH_LEGACY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_warning</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			     <span class="s">&quot;Unrecognised inode hash code %d&quot;</span><span class="p">,</span>
			     <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">hash_version</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">hash_version</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">hash_version</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">hash_version</span> <span class="o">&lt;=</span> <span class="n">DX_HASH_TEA</span><span class="p">)</span>
		<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">hash_version</span> <span class="o">+=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_hash_unsigned</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">seed</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_hash_seed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">ext3fs_dirhash</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">hinfo</span><span class="p">);</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">unused_flags</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_warning</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			     <span class="s">&quot;Unimplemented inode hash flags: %#06x&quot;</span><span class="p">,</span>
			     <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">unused_flags</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">indirect</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">indirect_levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_warning</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			     <span class="s">&quot;Unimplemented inode hash depth: %#06x&quot;</span><span class="p">,</span>
			     <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">indirect_levels</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span> <span class="o">+</span>
				       <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">info_length</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dx_get_limit</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dx_root_limit</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span>
						   <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">info_length</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_warning</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			     <span class="s">&quot;dx entry: limit != root limit&quot;</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dxtrace</span> <span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;Look up %x&quot;</span><span class="p">,</span> <span class="n">hash</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">dx_get_count</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">dx_get_limit</span><span class="p">(</span><span class="n">entries</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext3_warning</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				     <span class="s">&quot;dx entry: no count or count &gt; limit&quot;</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">entries</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
			<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dx_get_hash</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hash</span><span class="p">)</span>
				<span class="n">q</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// linear search cross check</span>
		<span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">at</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dx_get_hash</span><span class="p">(</span><span class="o">++</span><span class="n">at</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hash</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">at</span><span class="o">--</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">assert</span> <span class="p">(</span><span class="n">at</span> <span class="o">==</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">at</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot; %x-&gt;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">at</span> <span class="o">==</span> <span class="n">entries</span><span class="o">?</span> <span class="mi">0</span><span class="o">:</span> <span class="n">dx_get_hash</span><span class="p">(</span><span class="n">at</span><span class="p">),</span> <span class="n">dx_get_block</span><span class="p">(</span><span class="n">at</span><span class="p">)));</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span> <span class="o">=</span> <span class="n">at</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">indirect</span><span class="o">--</span><span class="p">)</span> <span class="k">return</span> <span class="n">frame</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span> <span class="n">dx_get_block</span><span class="p">(</span><span class="n">at</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
		<span class="n">at</span> <span class="o">=</span> <span class="n">entries</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">dx_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dx_get_limit</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dx_node_limit</span> <span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext3_warning</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				     <span class="s">&quot;dx entry: limit != node limit&quot;</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">frame</span><span class="o">++</span><span class="p">;</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">fail2:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">frame</span> <span class="o">&gt;=</span> <span class="n">frame_in</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">frame</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span> <span class="o">==</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">)</span>
		<span class="n">ext3_warning</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			     <span class="s">&quot;Corrupt dir inode %ld, running e2fsck is &quot;</span>
			     <span class="s">&quot;recommended.&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dx_release</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frames</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">dx_root</span> <span class="o">*</span><span class="p">)</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">indirect_levels</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function increments the frame pointer to search the next leaf</span>
<span class="cm"> * block, and reads in the necessary intervening nodes if the search</span>
<span class="cm"> * should be necessary.  Whether or not the search is necessary is</span>
<span class="cm"> * controlled by the hash parameter.  If the hash value is even, then</span>
<span class="cm"> * the search is only continued if the next block starts with that</span>
<span class="cm"> * hash value.  This is used if we are searching for a specific file.</span>
<span class="cm"> *</span>
<span class="cm"> * If the hash value is HASH_NB_ALWAYS, then always go to the next block.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 1 if the caller should continue to search,</span>
<span class="cm"> * or 0 if it should not.  If there is an error reading one of the</span>
<span class="cm"> * index blocks, it will a negative error code.</span>
<span class="cm"> *</span>
<span class="cm"> * If start_hash is non-null, it will be filled in with the starting</span>
<span class="cm"> * hash of the next page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_htree_next_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">hash</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frames</span><span class="p">,</span>
				 <span class="n">__u32</span> <span class="o">*</span><span class="n">start_hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">num_frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">bhash</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the next leaf page by incrementing the frame pointer.</span>
<span class="cm">	 * If we run out of entries in the interior node, loop around and</span>
<span class="cm">	 * increment pointer in the parent node.  When we break out of</span>
<span class="cm">	 * this loop, num_frames indicates the number of interior</span>
<span class="cm">	 * nodes need to be read.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">+</span> <span class="n">dx_get_count</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">frames</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">num_frames</span><span class="o">++</span><span class="p">;</span>
		<span class="n">p</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the hash is 1, then continue only if the next page has a</span>
<span class="cm">	 * continuation hash of any value.  This is used for readdir</span>
<span class="cm">	 * handling.  Otherwise, check to see if the hash matches the</span>
<span class="cm">	 * desired contiuation hash.  If it doesn&#39;t, return since</span>
<span class="cm">	 * there&#39;s no point to read in the successive index pages.</span>
<span class="cm">	 */</span>
	<span class="n">bhash</span> <span class="o">=</span> <span class="n">dx_get_hash</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_hash</span><span class="p">)</span>
		<span class="o">*</span><span class="n">start_hash</span> <span class="o">=</span> <span class="n">bhash</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bhash</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the hash is HASH_NB_ALWAYS, we always go to the next</span>
<span class="cm">	 * block so no check is necessary</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num_frames</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dx_get_block</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">),</span>
				      <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span> <span class="cm">/* Failure */</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">at</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">dx_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This function fills a red-black tree with information from a</span>
<span class="cm"> * directory block.  It returns the number directory entries loaded</span>
<span class="cm"> * into the tree.  If there is an error it is returned in err.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">htree_dirblock_to_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dir_file</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span>
				  <span class="n">__u32</span> <span class="n">start_hash</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">start_minor_hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;In htree dirblock_to_tree: block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">top</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">+</span>
					   <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
					   <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">de</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">;</span> <span class="n">de</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_check_dir_entry</span><span class="p">(</span><span class="s">&quot;htree_dirblock_to_tree&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span>
					<span class="p">(</span><span class="n">block</span><span class="o">&lt;&lt;</span><span class="n">EXT3_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span>
						<span class="o">+</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">de</span> <span class="o">-</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* On error, skip the f_pos to the next block. */</span>
			<span class="n">dir_file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">dir_file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ext3fs_dirhash</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span> <span class="n">hinfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">&lt;</span> <span class="n">start_hash</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">==</span> <span class="n">start_hash</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">minor_hash</span> <span class="o">&lt;</span> <span class="n">start_minor_hash</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">ext3_htree_store_dirent</span><span class="p">(</span><span class="n">dir_file</span><span class="p">,</span>
				   <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">minor_hash</span><span class="p">,</span> <span class="n">de</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This function fills a red-black tree with information from a</span>
<span class="cm"> * directory.  We start scanning the directory in hash order, starting</span>
<span class="cm"> * at start_hash and start_minor_hash.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of entries inserted into the tree,</span>
<span class="cm"> * or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_htree_fill_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dir_file</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">start_hash</span><span class="p">,</span>
			 <span class="n">__u32</span> <span class="n">start_minor_hash</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">next_hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="n">hinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_frame</span> <span class="n">frames</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">hashval</span><span class="p">;</span>

	<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;In htree_fill_tree, start hash: %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start_hash</span><span class="p">,</span>
		       <span class="n">start_minor_hash</span><span class="p">));</span>
	<span class="n">dir</span> <span class="o">=</span> <span class="n">dir_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">EXT3_INDEX_FL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hinfo</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_def_hash_version</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hinfo</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">&lt;=</span> <span class="n">DX_HASH_TEA</span><span class="p">)</span>
			<span class="n">hinfo</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">+=</span>
				<span class="n">EXT3_SB</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_hash_unsigned</span><span class="p">;</span>
		<span class="n">hinfo</span><span class="p">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_hash_seed</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">htree_dirblock_to_tree</span><span class="p">(</span><span class="n">dir_file</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hinfo</span><span class="p">,</span>
					       <span class="n">start_hash</span><span class="p">,</span> <span class="n">start_minor_hash</span><span class="p">);</span>
		<span class="o">*</span><span class="n">next_hash</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hinfo</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">start_hash</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="p">.</span><span class="n">minor_hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">dx_probe</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dir_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Add &#39;.&#39; and &#39;..&#39; from the htree header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_hash</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">start_minor_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">ext3_htree_store_dirent</span><span class="p">(</span><span class="n">dir_file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">de</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_hash</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="p">(</span><span class="n">start_hash</span> <span class="o">==</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">start_minor_hash</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">ext3_htree_store_dirent</span><span class="p">(</span><span class="n">dir_file</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">de</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">dx_get_block</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">htree_dirblock_to_tree</span><span class="p">(</span><span class="n">dir_file</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hinfo</span><span class="p">,</span>
					     <span class="n">start_hash</span><span class="p">,</span> <span class="n">start_minor_hash</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">hashval</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_htree_next_block</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">HASH_NB_ALWAYS</span><span class="p">,</span>
					    <span class="n">frame</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hashval</span><span class="p">);</span>
		<span class="o">*</span><span class="n">next_hash</span> <span class="o">=</span> <span class="n">hashval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Stop if:  (a) there are no more entries, or</span>
<span class="cm">		 * (b) we have inserted at least one entry and the</span>
<span class="cm">		 * next hash value is not a continuation</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">hashval</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dx_release</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>
	<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;Fill tree: returned %d entries, next hash: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">count</span><span class="p">,</span> <span class="o">*</span><span class="n">next_hash</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">errout:</span>
	<span class="n">dx_release</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Directory block splitting, compacting</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Create map of hash values, offsets, and sizes, stored at end of block.</span>
<span class="cm"> * Returns number of entries mapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dx_make_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="o">*</span><span class="n">map_tail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="n">h</span> <span class="o">=</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">&amp;&amp;</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3fs_dirhash</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
			<span class="n">map_tail</span><span class="o">--</span><span class="p">;</span>
			<span class="n">map_tail</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">hash</span><span class="p">;</span>
			<span class="n">map_tail</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
			<span class="n">map_tail</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="cm">/* XXX: do we need to check rec_len == 0 case? -Chris */</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Sort map by hash value */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dx_sort_map</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="n">map</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">more</span><span class="p">;</span>
        <span class="cm">/* Combsort until bubble sort doesn&#39;t suck */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">{</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">*</span><span class="mi">10</span><span class="o">/</span><span class="mi">13</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="cm">/* 9, 10 -&gt; 11 */</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">top</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">count</span><span class="p">;</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">map</span><span class="p">;</span> <span class="n">p</span><span class="o">--</span><span class="p">,</span> <span class="n">q</span><span class="o">--</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span>
                                <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* Garden variety bubble sort */</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="n">more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">--</span> <span class="o">&gt;</span> <span class="n">map</span><span class="p">)</span>
		<span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hash</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hash</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
                        <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
                        <span class="n">more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">more</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dx_insert_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash</span><span class="p">,</span> <span class="n">u32</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dx_get_count</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span>

	<span class="n">assert</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">dx_get_limit</span><span class="p">(</span><span class="n">entries</span><span class="p">));</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">old</span> <span class="o">&lt;</span> <span class="n">entries</span> <span class="o">+</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">new</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">entries</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">new</span><span class="p">));</span>
	<span class="n">dx_set_hash</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="n">dx_set_block</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">dx_set_count</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext3_update_dx_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT3_HAS_COMPAT_FEATURE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				     <span class="n">EXT3_FEATURE_COMPAT_DIR_INDEX</span><span class="p">))</span>
		<span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXT3_INDEX_FL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE! unlike strncmp, ext3_match returns 1 for success, 0 for failure.</span>
<span class="cm"> *</span>
<span class="cm"> * `len &lt;= EXT3_NAME_LEN&#39; is guaranteed by caller.</span>
<span class="cm"> * `de != NULL&#39; is guaranteed by caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext3_match</span> <span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">name</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns 0 if not found, -1 on failure, and 1 on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">search_dirblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">**</span> <span class="n">res_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span> <span class="n">dlimit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">de_len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">dlimit</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">&lt;</span> <span class="n">dlimit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this code is executed quadratically often */</span>
		<span class="cm">/* do minimal checking `by hand&#39; */</span>

		<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">+</span> <span class="n">namelen</span> <span class="o">&lt;=</span> <span class="n">dlimit</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ext3_match</span> <span class="p">(</span><span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">de</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* found a match - just to be sure, do a full check */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_check_dir_entry</span><span class="p">(</span><span class="s">&quot;ext3_find_entry&quot;</span><span class="p">,</span>
						  <span class="n">dir</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">res_dir</span> <span class="o">=</span> <span class="n">de</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* prevent looping on a bad block */</span>
		<span class="n">de_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">de_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">de_len</span><span class="p">;</span>
		<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">+</span> <span class="n">de_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	ext3_find_entry()</span>
<span class="cm"> *</span>
<span class="cm"> * finds an entry in the specified directory with the wanted name. It</span>
<span class="cm"> * returns the cache buffer in which the entry was found, and the entry</span>
<span class="cm"> * itself (as a parameter - res_dir). It does NOT read the inode of the</span>
<span class="cm"> * entry - you&#39;ll have to do that yourself if you want to.</span>
<span class="cm"> *</span>
<span class="cm"> * The returned buffer_head has -&gt;b_count elevated.  The caller is expected</span>
<span class="cm"> * to brelse() it when appropriate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">ext3_find_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">**</span><span class="n">res_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh_use</span><span class="p">[</span><span class="n">NAMEI_RA_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ra_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Number of bh&#39;s in the readahead</span>
<span class="cm">				   buffer, bh_use[] */</span>
	<span class="kt">int</span> <span class="n">ra_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Current index into readahead</span>
<span class="cm">				   buffer */</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="o">*</span><span class="n">res_dir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">EXT3_NAME_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">namelen</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * &quot;.&quot; or &quot;..&quot; will only be in the first block</span>
<span class="cm">		 * NFS may look up &quot;..&quot;; &quot;.&quot; should be handled by the VFS</span>
<span class="cm">		 */</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nblocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_dx</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_dx_find_entry</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">res_dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * On success, or if the error was file not found,</span>
<span class="cm">		 * return.  Otherwise, fall back to doing a search the</span>
<span class="cm">		 * old fashioned way.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">||</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;ext3_find_entry: dx failed, falling back</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">EXT3_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_dir_start_lookup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">nblocks</span><span class="p">)</span>
		<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We deal with the read-ahead logic here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ra_ptr</span> <span class="o">&gt;=</span> <span class="n">ra_max</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Refill the readahead buffer */</span>
			<span class="n">ra_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">ra_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ra_max</span> <span class="o">&lt;</span> <span class="n">NAMEI_RA_SIZE</span><span class="p">;</span> <span class="n">ra_max</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Terminate if we reach the end of the</span>
<span class="cm">				 * directory and must wrap, or if our</span>
<span class="cm">				 * search has finished at this block.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="n">nblocks</span> <span class="o">||</span> <span class="p">(</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">==</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">bh_use</span><span class="p">[</span><span class="n">ra_max</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">num</span><span class="o">++</span><span class="p">;</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_getblk</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">b</span><span class="o">++</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
				<span class="n">bh_use</span><span class="p">[</span><span class="n">ra_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bh_uptodate_or_lock</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
					<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span> <span class="o">|</span> <span class="n">REQ_META</span> <span class="o">|</span> <span class="n">REQ_PRIO</span><span class="p">,</span>
						  <span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh_use</span><span class="p">[</span><span class="n">ra_ptr</span><span class="o">++</span><span class="p">])</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* read error, skip block &amp; hope for the best */</span>
			<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;reading directory #%lu &quot;</span>
				   <span class="s">&quot;offset %lu&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">search_dirblock</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
			    <span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="n">EXT3_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">res_dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">EXT3_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_dir_start_lookup</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup_and_exit</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup_and_exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="nl">next:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">nblocks</span><span class="p">)</span>
			<span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">block</span> <span class="o">!=</span> <span class="n">start</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the directory has grown while we were searching, then</span>
<span class="cm">	 * search the last part of the directory before giving up.</span>
<span class="cm">	 */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">EXT3_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">nblocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">cleanup_and_exit:</span>
	<span class="cm">/* Clean up the read-ahead blocks */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">ra_ptr</span> <span class="o">&lt;</span> <span class="n">ra_max</span><span class="p">;</span> <span class="n">ra_ptr</span><span class="o">++</span><span class="p">)</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">bh_use</span><span class="p">[</span><span class="n">ra_ptr</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="nf">ext3_dx_find_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">**</span><span class="n">res_dir</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_hash_info</span>	<span class="n">hinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_frame</span> <span class="n">frames</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">frame</span> <span class="o">=</span> <span class="n">dx_probe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">err</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">dx_get_block</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">search_dirblock</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
					 <span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="n">EXT3_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span>
					 <span class="n">res_dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dx_release</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check to see if we should continue to search */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_htree_next_block</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">hinfo</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span>
					       <span class="n">frames</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			     <span class="s">&quot;error reading index page in directory #%lu&quot;</span><span class="p">,</span>
			     <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
			<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="nl">errout:</span>
	<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">dx_release</span> <span class="p">(</span><span class="n">frames</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ext3_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">EXT3_NAME_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_find_entry</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">de</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_valid_inum</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext3_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_lookup&quot;</span><span class="p">,</span>
				   <span class="s">&quot;bad inode number: %lu&quot;</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">ext3_iget</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESTALE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext3_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					<span class="s">&quot;deleted inode referenced: %lu&quot;</span><span class="p">,</span>
					<span class="n">ino</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">d_splice_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ext3_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">dotdot</span> <span class="o">=</span> <span class="n">QSTR_INIT</span><span class="p">(</span><span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_find_entry</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dotdot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">de</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_valid_inum</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_error</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_get_parent&quot;</span><span class="p">,</span>
			   <span class="s">&quot;bad inode number: %lu&quot;</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">d_obtain_alias</span><span class="p">(</span><span class="n">ext3_iget</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define S_SHIFT 12</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ext3_type_by_mode</span><span class="p">[</span><span class="n">S_IFMT</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">S_IFREG</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">EXT3_FT_REG_FILE</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFDIR</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">EXT3_FT_DIR</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFCHR</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">EXT3_FT_CHRDEV</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFBLK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">EXT3_FT_BLKDEV</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFIFO</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">EXT3_FT_FIFO</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFSOCK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">EXT3_FT_SOCK</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFLNK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">EXT3_FT_SYMLINK</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext3_set_de_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span>
				<span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT3_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">EXT3_FEATURE_INCOMPAT_FILETYPE</span><span class="p">))</span>
		<span class="n">de</span><span class="o">-&gt;</span><span class="n">file_type</span> <span class="o">=</span> <span class="n">ext3_type_by_mode</span><span class="p">[(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="n">S_SHIFT</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move count entries from end of map between two memory locations.</span>
<span class="cm"> * Returns pointer to last entry moved.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span>
<span class="nf">dx_move_dirents</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">rec_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">from</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="n">rec_len</span> <span class="o">=</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
		<span class="n">memcpy</span> <span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">rec_len</span><span class="p">);</span>
		<span class="p">((</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span>
				<span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">rec_len</span><span class="p">);</span>
		<span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">map</span><span class="o">++</span><span class="p">;</span>
		<span class="n">to</span> <span class="o">+=</span> <span class="n">rec_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">to</span> <span class="o">-</span> <span class="n">rec_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compact each dir entry in the range to the minimal rec_len.</span>
<span class="cm"> * Returns pointer to last entry in range.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="nf">dx_pack_dirents</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rec_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">to</span> <span class="o">=</span> <span class="n">de</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">de</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rec_len</span> <span class="o">=</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">de</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">)</span>
				<span class="n">memmove</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">rec_len</span><span class="p">);</span>
			<span class="n">to</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">rec_len</span><span class="p">);</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
			<span class="n">to</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">to</span><span class="p">)</span> <span class="o">+</span> <span class="n">rec_len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split a full leaf block to make room for a new dir entry.</span>
<span class="cm"> * Allocate a new block, and move entries so that they are approx. equally full.</span>
<span class="cm"> * Returns pointer to de in block into which the new entry will be inserted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="nf">do_split</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bh</span><span class="p">,</span><span class="k">struct</span> <span class="n">dx_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">,</span> <span class="n">continued</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">newblock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data1</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="o">*</span><span class="n">data2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">split</span><span class="p">,</span> <span class="n">move</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">de2</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bh2</span> <span class="o">=</span> <span class="n">ext3_append</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="o">*</span><span class="n">bh</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>

	<span class="n">data2</span> <span class="o">=</span> <span class="n">bh2</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="cm">/* create map in the end of data2 block */</span>
	<span class="n">map</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_map_entry</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">data2</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">dx_make_map</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">data1</span><span class="p">,</span>
			     <span class="n">blocksize</span><span class="p">,</span> <span class="n">hinfo</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
	<span class="n">map</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">dx_sort_map</span> <span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="cm">/* Split the existing block in the middle, size-wise */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">move</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* is more than half of this entry in 2nd half of the block? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">blocksize</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
		<span class="n">move</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* map index at which we will split */</span>
	<span class="n">split</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="n">move</span><span class="p">;</span>
	<span class="n">hash2</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">split</span><span class="p">].</span><span class="n">hash</span><span class="p">;</span>
	<span class="n">continued</span> <span class="o">=</span> <span class="n">hash2</span> <span class="o">==</span> <span class="n">map</span><span class="p">[</span><span class="n">split</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hash</span><span class="p">;</span>
	<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;Split block %i at %x, %i/%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dx_get_block</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">),</span> <span class="n">hash2</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">count</span><span class="o">-</span><span class="n">split</span><span class="p">));</span>

	<span class="cm">/* Fancy dance to stay within two buffers */</span>
	<span class="n">de2</span> <span class="o">=</span> <span class="n">dx_move_dirents</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">map</span> <span class="o">+</span> <span class="n">split</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">split</span><span class="p">);</span>
	<span class="n">de</span> <span class="o">=</span> <span class="n">dx_pack_dirents</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span><span class="n">blocksize</span><span class="p">);</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">data1</span> <span class="o">+</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span><span class="p">);</span>
	<span class="n">de2</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">data2</span> <span class="o">+</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de2</span><span class="p">);</span>
	<span class="n">dxtrace</span><span class="p">(</span><span class="n">dx_show_leaf</span> <span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">data1</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">dxtrace</span><span class="p">(</span><span class="n">dx_show_leaf</span> <span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">data2</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* Which block gets the new entry? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">&gt;=</span> <span class="n">hash2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">bh2</span><span class="p">);</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">de2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dx_insert_block</span> <span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">hash2</span> <span class="o">+</span> <span class="n">continued</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
	<span class="n">dxtrace</span><span class="p">(</span><span class="n">dx_show_index</span> <span class="p">(</span><span class="s">&quot;frame&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">de</span><span class="p">;</span>

<span class="nl">journal_error:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="o">*</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="nl">errout:</span>
	<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Add a new entry into a directory (leaf) block.  If de is non-NULL,</span>
<span class="cm"> * it points to a directory entry which is guaranteed to be large</span>
<span class="cm"> * enough for new directory entry.  If de is NULL, then</span>
<span class="cm"> * add_dirent_to_buf will attempt search the directory block for</span>
<span class="cm"> * space.  It will return -ENOSPC if no space is available, and -EIO</span>
<span class="cm"> * and -EEXIST if directory entry already exists.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE!  bh is NOT released in the case where ENOSPC is returned.  In</span>
<span class="cm"> * all other cases bh is released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_dirent_to_buf</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">namelen</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">reclen</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nlen</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">top</span><span class="p">;</span>

	<span class="n">reclen</span> <span class="o">=</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="n">namelen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="n">top</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="n">reclen</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">&lt;=</span> <span class="n">top</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_check_dir_entry</span><span class="p">(</span><span class="s">&quot;ext3_add_entry&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span>
						  <span class="n">bh</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext3_match</span> <span class="p">(</span><span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">de</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">nlen</span> <span class="o">=</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
			<span class="n">rlen</span> <span class="o">=</span> <span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">?</span> <span class="n">rlen</span> <span class="o">-</span> <span class="n">nlen</span><span class="o">:</span> <span class="n">rlen</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">reclen</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">de</span> <span class="o">+</span> <span class="n">rlen</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">rlen</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">&gt;</span> <span class="n">top</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* By now the buffer is marked for journaling */</span>
	<span class="n">nlen</span> <span class="o">=</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">de</span> <span class="o">+</span> <span class="n">nlen</span><span class="p">);</span>
		<span class="n">de1</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">rlen</span> <span class="o">-</span> <span class="n">nlen</span><span class="p">);</span>
		<span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">nlen</span><span class="p">);</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">de1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">file_type</span> <span class="o">=</span> <span class="n">EXT3_FT_UNKNOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">ext3_set_de_type</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">memcpy</span> <span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXX shouldn&#39;t update any times until successful</span>
<span class="cm">	 * completion of syscall, but too many callers depend</span>
<span class="cm">	 * on this.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX similarly, too many callers depend on</span>
<span class="cm">	 * ext3_new_inode() setting the times, but error</span>
<span class="cm">	 * recovery deletes the inode, so the worst that can</span>
<span class="cm">	 * happen is that the times are slightly out of date</span>
<span class="cm">	 * and/or different from the directory change time.</span>
<span class="cm">	 */</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">ext3_update_dx_flag</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This converts a one block unindexed directory to a 3 block indexed</span>
<span class="cm"> * directory, and adds the dentry to the indexed directory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_indexed_dir</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">namelen</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_root</span>	<span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_frame</span>	<span class="n">frames</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span>	<span class="o">*</span><span class="n">de</span><span class="p">,</span> <span class="o">*</span><span class="n">de2</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">blocksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="n">hinfo</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fake_dirent</span> <span class="o">*</span><span class="n">fde</span><span class="p">;</span>

	<span class="n">blocksize</span> <span class="o">=</span>  <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Creating index: inode %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">));</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_root</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="cm">/* The 0th block becomes the root, move the dirents out */</span>
	<span class="n">fde</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dotdot</span><span class="p">;</span>
	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">fde</span> <span class="o">+</span>
			<span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">fde</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">&gt;=</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">root</span><span class="p">)</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="s">&quot;invalid rec_len for &#39;..&#39; in inode %lu&quot;</span><span class="p">,</span>
			   <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">root</span><span class="p">)</span> <span class="o">+</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span><span class="p">;</span>

	<span class="n">bh2</span> <span class="o">=</span> <span class="n">ext3_append</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">EXT3_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT3_INDEX_FL</span><span class="p">;</span>
	<span class="n">data1</span> <span class="o">=</span> <span class="n">bh2</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="n">memcpy</span> <span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">data1</span><span class="p">;</span>
	<span class="n">top</span> <span class="o">=</span> <span class="n">data1</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">de2</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">)</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">de2</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">data1</span> <span class="o">+</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span><span class="p">);</span>
	<span class="cm">/* Initialize the root; the dot dirents already exist */</span>
	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dotdot</span><span class="p">);</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
	<span class="n">memset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">));</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">info_length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_def_hash_version</span><span class="p">;</span>
	<span class="n">entries</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
	<span class="n">dx_set_block</span> <span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dx_set_count</span> <span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dx_set_limit</span> <span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">dx_root_limit</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)));</span>

	<span class="cm">/* Initialize as for dx_probe */</span>
	<span class="n">hinfo</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">hash_version</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hinfo</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">&lt;=</span> <span class="n">DX_HASH_TEA</span><span class="p">)</span>
		<span class="n">hinfo</span><span class="p">.</span><span class="n">hash_version</span> <span class="o">+=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_hash_unsigned</span><span class="p">;</span>
	<span class="n">hinfo</span><span class="p">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_hash_seed</span><span class="p">;</span>
	<span class="n">ext3fs_dirhash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hinfo</span><span class="p">);</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">frames</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span> <span class="o">=</span> <span class="n">entries</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">bh2</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark buffers dirty here so that if do_split() fails we write a</span>
<span class="cm">	 * consistent set of buffers to disk.</span>
<span class="cm">	 */</span>
	<span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">de</span> <span class="o">=</span> <span class="n">do_split</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">dx_release</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dx_release</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">add_dirent_to_buf</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	ext3_add_entry()</span>
<span class="cm"> *</span>
<span class="cm"> * adds a file entry to the specified directory, using the same</span>
<span class="cm"> * semantics as ext3_find_entry(). It returns NULL if it failed.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE!! The inode part of &#39;de&#39; is left at 0 - which means you</span>
<span class="cm"> * may not sleep between calling this and putting something into</span>
<span class="cm"> * the entry, as someone else might have used it while you slept.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_add_entry</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dx_fallback</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">block</span><span class="p">,</span> <span class="n">blocks</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_dx</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_dx_add_entry</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">||</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">ERR_BAD_DX_DIR</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">EXT3_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXT3_INDEX_FL</span><span class="p">;</span>
		<span class="n">dx_fallback</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">blocks</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">blocks</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">add_dirent_to_buf</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dx_fallback</span> <span class="o">&amp;&amp;</span>
		    <span class="n">EXT3_HAS_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">EXT3_FEATURE_COMPAT_DIR_INDEX</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">make_indexed_dir</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_append</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">blocksize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">add_dirent_to_buf</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns 0 for success, or a negative error value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_dx_add_entry</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dx_frame</span> <span class="n">frames</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="o">*</span><span class="n">at</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dx_hash_info</span> <span class="n">hinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">dx_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">entries</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
	<span class="n">at</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">dir</span><span class="p">,</span> <span class="n">dx_get_block</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">add_dirent_to_buf</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Block full, should compress but for now just split */</span>
	<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;using %u of %u node entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dx_get_count</span><span class="p">(</span><span class="n">entries</span><span class="p">),</span> <span class="n">dx_get_limit</span><span class="p">(</span><span class="n">entries</span><span class="p">)));</span>
	<span class="cm">/* Need to split index? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dx_get_count</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">==</span> <span class="n">dx_get_limit</span><span class="p">(</span><span class="n">entries</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">newblock</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">icount</span> <span class="o">=</span> <span class="n">dx_get_count</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">levels</span> <span class="o">=</span> <span class="n">frame</span> <span class="o">-</span> <span class="n">frames</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dx_entry</span> <span class="o">*</span><span class="n">entries2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dx_node</span> <span class="o">*</span><span class="n">node2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">levels</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dx_get_count</span><span class="p">(</span><span class="n">frames</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span> <span class="o">==</span>
			       <span class="n">dx_get_limit</span><span class="p">(</span><span class="n">frames</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ext3_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				     <span class="s">&quot;Directory index full!&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bh2</span> <span class="o">=</span> <span class="n">ext3_append</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh2</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">node2</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dx_node</span> <span class="o">*</span><span class="p">)(</span><span class="n">bh2</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
		<span class="n">entries2</span> <span class="o">=</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">fake</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fake_dirent</span><span class="p">));</span>
		<span class="n">node2</span><span class="o">-&gt;</span><span class="n">fake</span><span class="p">.</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">icount1</span> <span class="o">=</span> <span class="n">icount</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">icount2</span> <span class="o">=</span> <span class="n">icount</span> <span class="o">-</span> <span class="n">icount1</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">hash2</span> <span class="o">=</span> <span class="n">dx_get_hash</span><span class="p">(</span><span class="n">entries</span> <span class="o">+</span> <span class="n">icount1</span><span class="p">);</span>
			<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;Split index %i/%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">icount1</span><span class="p">,</span> <span class="n">icount2</span><span class="p">));</span>

			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span> <span class="cm">/* index root */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
							     <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>

			<span class="n">memcpy</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">entries2</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">entries</span> <span class="o">+</span> <span class="n">icount1</span><span class="p">),</span>
				<span class="n">icount2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span><span class="p">));</span>
			<span class="n">dx_set_count</span> <span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">icount1</span><span class="p">);</span>
			<span class="n">dx_set_count</span> <span class="p">(</span><span class="n">entries2</span><span class="p">,</span> <span class="n">icount2</span><span class="p">);</span>
			<span class="n">dx_set_limit</span> <span class="p">(</span><span class="n">entries2</span><span class="p">,</span> <span class="n">dx_node_limit</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>

			<span class="cm">/* Which index block gets the new entry? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">at</span> <span class="o">-</span> <span class="n">entries</span> <span class="o">&gt;=</span> <span class="n">icount1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span> <span class="o">=</span> <span class="n">at</span> <span class="o">=</span> <span class="n">at</span> <span class="o">-</span> <span class="n">entries</span> <span class="o">-</span> <span class="n">icount1</span> <span class="o">+</span> <span class="n">entries2</span><span class="p">;</span>
				<span class="n">frame</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">entries2</span><span class="p">;</span>
				<span class="n">swap</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="n">bh2</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">dx_insert_block</span> <span class="p">(</span><span class="n">frames</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hash2</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
			<span class="n">dxtrace</span><span class="p">(</span><span class="n">dx_show_index</span> <span class="p">(</span><span class="s">&quot;node&quot;</span><span class="p">,</span> <span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">entries</span><span class="p">));</span>
			<span class="n">dxtrace</span><span class="p">(</span><span class="n">dx_show_index</span> <span class="p">(</span><span class="s">&quot;node&quot;</span><span class="p">,</span>
			       <span class="p">((</span><span class="k">struct</span> <span class="n">dx_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh2</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">));</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dxtrace</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;Creating second level index...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">entries2</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">entries</span><span class="p">,</span>
			       <span class="n">icount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dx_entry</span><span class="p">));</span>
			<span class="n">dx_set_limit</span><span class="p">(</span><span class="n">entries2</span><span class="p">,</span> <span class="n">dx_node_limit</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>

			<span class="cm">/* Set up root */</span>
			<span class="n">dx_set_count</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">dx_set_block</span><span class="p">(</span><span class="n">entries</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">dx_root</span> <span class="o">*</span><span class="p">)</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">indirect_levels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* Add new access path frame */</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="n">frames</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">at</span> <span class="o">=</span> <span class="n">at</span> <span class="o">=</span> <span class="n">at</span> <span class="o">-</span> <span class="n">entries</span> <span class="o">+</span> <span class="n">entries2</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">=</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">entries2</span><span class="p">;</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh2</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
							     <span class="n">frame</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">de</span> <span class="o">=</span> <span class="n">do_split</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">de</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">add_dirent_to_buf</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

<span class="nl">journal_error:</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="nl">cleanup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">dx_release</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext3_delete_entry deletes a directory entry by merging it with the</span>
<span class="cm"> * previous entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_delete_entry</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de_del</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">,</span> <span class="o">*</span> <span class="n">pde</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pde</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_check_dir_entry</span><span class="p">(</span><span class="s">&quot;ext3_delete_entry&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">de</span> <span class="o">==</span> <span class="n">de_del</span><span class="p">)</span>  <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pde</span><span class="p">)</span>
				<span class="n">pde</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span>
					<span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">pde</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="o">++</span><span class="p">;</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">journal_error:</span>
				<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">);</span>
		<span class="n">pde</span> <span class="o">=</span> <span class="n">de</span><span class="p">;</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_add_nondir</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ext3_add_entry</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * By the time this is called, we already have created</span>
<span class="cm"> * the directory cache entry for the new file, but it</span>
<span class="cm"> * is so far negative - it has no inode.</span>
<span class="cm"> *</span>
<span class="cm"> * If the create succeeds, we fill in the inode information</span>
<span class="cm"> * with d_instantiate().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_create</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">EXT3_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">EXT3_INDEX_EXTRA_TRANS_BLOCKS</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span>
					<span class="n">EXT3_MAXQUOTAS_INIT_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ext3_new_inode</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_file_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_file_operations</span><span class="p">;</span>
		<span class="n">ext3_set_aops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_add_nondir</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_retry_alloc</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_mknod</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			<span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_valid_dev</span><span class="p">(</span><span class="n">rdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">EXT3_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">EXT3_INDEX_EXTRA_TRANS_BLOCKS</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span>
					<span class="n">EXT3_MAXQUOTAS_INIT_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ext3_new_inode</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_EXT3_FS_XATTR</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_special_inode_operations</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_add_nondir</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_retry_alloc</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">dir_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;=</span> <span class="n">EXT3_LINK_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMLINK</span><span class="p">;</span>

	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">EXT3_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">EXT3_INDEX_EXTRA_TRANS_BLOCKS</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span>
					<span class="n">EXT3_MAXQUOTAS_INIT_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ext3_new_inode</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_dir_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_dir_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">dir_block</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir_block</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_clear_inode</span><span class="p">;</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">dir_block</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_clear_inode</span><span class="p">;</span>

	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">dir_block</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">));</span>
	<span class="n">strcpy</span> <span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">);</span>
	<span class="n">ext3_set_de_type</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">);</span>
	<span class="n">de</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span> <span class="o">=</span> <span class="n">ext3_rec_len_to_disk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
					<span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">strcpy</span> <span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">);</span>
	<span class="n">ext3_set_de_type</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">dir_block</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_clear_inode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_add_entry</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">out_clear_inode:</span>
		<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span> <span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">ext3_update_dx_flag</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_clear_inode</span><span class="p">;</span>

	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">out_stop:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">dir_block</span><span class="p">);</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_retry_alloc</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * routine to check that the specified directory is empty (for rmdir)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">empty_dir</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">,</span> <span class="o">*</span> <span class="n">de1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&lt;</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">EXT3_DIR_REC_LEN</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">ext3_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				   <span class="s">&quot;error %d reading directory #%lu offset 0&quot;</span><span class="p">,</span>
				   <span class="n">err</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ext3_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				     <span class="s">&quot;bad directory (dir #%lu) - no data block&quot;</span><span class="p">,</span>
				     <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">de1</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">de1</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">strcmp</span> <span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">strcmp</span> <span class="p">(</span><span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="n">de1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext3_warning</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;empty_dir&quot;</span><span class="p">,</span>
			      <span class="s">&quot;bad directory (dir #%lu) - no `.&#39; or `..&#39;&quot;</span><span class="p">,</span>
			      <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">de1</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">);</span>
	<span class="n">de</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de1</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span> <span class="o">||</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">de</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="o">+</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
				<span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">EXT3_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="n">ext3_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
						   <span class="s">&quot;error %d reading directory&quot;</span>
						   <span class="s">&quot; #%lu offset %lu&quot;</span><span class="p">,</span>
						   <span class="n">err</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
				<span class="n">offset</span> <span class="o">+=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_check_dir_entry</span><span class="p">(</span><span class="s">&quot;empty_dir&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="p">)(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span>
							 <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">|</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">ext3_rec_len_from_disk</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">rec_len</span><span class="p">);</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">ext3_next_entry</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ext3_orphan_add() links an unlinked or truncated inode into a list of</span>
<span class="cm"> * such inodes, starting at the superblock, in case we crash before the</span>
<span class="cm"> * file is closed/deleted, or in case the inode truncate spans multiple</span>
<span class="cm"> * transactions and the last transaction is not recovered after a crash.</span>
<span class="cm"> *</span>
<span class="cm"> * At filesystem recovery time, we walk this list deleting unlinked</span>
<span class="cm"> * inodes and truncating linked inodes in ext3_orphan_cleanup().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_orphan_add</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="n">iloc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_orphan_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_orphan</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Orphan handling is only valid for files with data blocks</span>
<span class="cm">	 * being truncated, or files being unlinked. */</span>

	<span class="cm">/* @@@ FIXME: Observation from aviro:</span>
<span class="cm">	 * I think I can trigger J_ASSERT in ext3_orphan_add().  We block</span>
<span class="cm">	 * here (on s_orphan_lock), so race with ext3_link() which might bump</span>
<span class="cm">	 * -&gt;i_nlink. For, say it, character device. Not a regular file,</span>
<span class="cm">	 * not a directory, not a symlink and -&gt;i_nlink &gt; 0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * tytso, 4/25/2009: I&#39;m not sure how that could happen;</span>
<span class="cm">	 * shouldn&#39;t the fs core protect us from these sort of</span>
<span class="cm">	 * unlink()/link() races?</span>
<span class="cm">	 */</span>
	<span class="n">J_ASSERT</span> <span class="p">((</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="o">||</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_reserve_inode_write</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Insert this inode at the head of the on-disk orphan list... */</span>
	<span class="n">NEXT_ORPHAN</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_last_orphan</span><span class="p">);</span>
	<span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_last_orphan</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ext3_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Only add to the head of the in-memory list if all the</span>
<span class="cm">	 * previous operations succeeded.  If the orphan_add is going to</span>
<span class="cm">	 * fail (possibly taking the journal offline), we can&#39;t risk</span>
<span class="cm">	 * leaving the inode on the orphan list: stray orphan-list</span>
<span class="cm">	 * entries can cause panics at unmount time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is safe: on error we&#39;re going to ignore the orphan list</span>
<span class="cm">	 * anyway on the next recovery. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_orphan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_orphan</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;superblock will point to %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;orphan inode %lu will point to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">NEXT_ORPHAN</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_orphan_lock</span><span class="p">);</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext3_orphan_del() removes an unlinked or truncated inode from the list</span>
<span class="cm"> * of such inodes stored on disk, because it is finally being cleaned up.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_orphan_del</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext3_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino_next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="n">iloc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_orphan_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_orphan</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ino_next</span> <span class="o">=</span> <span class="n">NEXT_ORPHAN</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_orphan</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;remove inode %lu from orphan list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_orphan</span><span class="p">);</span>

	<span class="cm">/* If we&#39;re on an error path, we may not have a valid</span>
<span class="cm">	 * transaction handle with which to update the orphan list on</span>
<span class="cm">	 * disk, but we still need to remove the inode from the linked</span>
<span class="cm">	 * list in memory. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_reserve_inode_write</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_orphan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;superblock will point to %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ino_next</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_brelse</span><span class="p">;</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_last_orphan</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ino_next</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="n">iloc2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i_prev</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">list_entry</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_inode_info</span><span class="p">,</span> <span class="n">i_orphan</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>

		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;orphan inode %lu will point to %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">i_prev</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ino_next</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_reserve_inode_write</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">i_prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_brelse</span><span class="p">;</span>
		<span class="n">NEXT_ORPHAN</span><span class="p">(</span><span class="n">i_prev</span><span class="p">)</span> <span class="o">=</span> <span class="n">ino_next</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">i_prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_brelse</span><span class="p">;</span>
	<span class="n">NEXT_ORPHAN</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>

<span class="nl">out_err:</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_orphan_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_brelse:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_rmdir</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

	<span class="cm">/* Initialize quotas before so that eventual writes go in</span>
<span class="cm">	 * separate transaction */</span>
	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">EXT3_DELETE_TRANS_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_find_entry</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">de</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_rmdir</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_rmdir</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty_dir</span> <span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_rmdir</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_delete_entry</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_rmdir</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ext3_warning</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_rmdir&quot;</span><span class="p">,</span>
			      <span class="s">&quot;empty directory has nlink!=2 (%d)&quot;</span><span class="p">,</span>
			      <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="o">++</span><span class="p">;</span>
	<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* There&#39;s no need to set i_disksize: the fact that i_nlink is</span>
<span class="cm">	 * zero will ensure that the right thing happens during any</span>
<span class="cm">	 * recovery. */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">ext3_update_dx_flag</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

<span class="nl">end_rmdir:</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">de</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

	<span class="n">trace_ext3_unlink_enter</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="cm">/* Initialize quotas before so that eventual writes go</span>
<span class="cm">	 * in separate transaction */</span>
	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">EXT3_DELETE_TRANS_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_find_entry</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">de</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_unlink</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_unlink</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_warning</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_unlink&quot;</span><span class="p">,</span>
			      <span class="s">&quot;Deleting nonexistent file (%lu), %d&quot;</span><span class="p">,</span>
			      <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_delete_entry</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_unlink</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">ext3_update_dx_flag</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">end_unlink:</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">trace_ext3_unlink_exit</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_symlink</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">credits</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">symname</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>

	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">EXT3_N_BLOCKS</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For non-fast symlinks, we just allocate inode and put it on</span>
<span class="cm">		 * orphan list in the first transaction =&gt; we need bitmap,</span>
<span class="cm">		 * group descriptor, sb, inode block, quota blocks, and</span>
<span class="cm">		 * possibly selinux xattr blocks.</span>
<span class="cm">		 */</span>
		<span class="n">credits</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">EXT3_MAXQUOTAS_INIT_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
			  <span class="n">EXT3_XATTR_TRANS_BLOCKS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fast symlink. We have to add entry to directory</span>
<span class="cm">		 * (EXT3_DATA_TRANS_BLOCKS + EXT3_INDEX_EXTRA_TRANS_BLOCKS),</span>
<span class="cm">		 * allocate new inode (bitmap, group descriptor, inode block,</span>
<span class="cm">		 * quota blocks, sb is already counted in previous macros).</span>
<span class="cm">		 */</span>
		<span class="n">credits</span> <span class="o">=</span> <span class="n">EXT3_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
			  <span class="n">EXT3_INDEX_EXTRA_TRANS_BLOCKS</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span>
			  <span class="n">EXT3_MAXQUOTAS_INIT_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">retry:</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ext3_new_inode</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">S_IFLNK</span><span class="o">|</span><span class="n">S_IRWXUGO</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">EXT3_N_BLOCKS</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_symlink_inode_operations</span><span class="p">;</span>
		<span class="n">ext3_set_aops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We cannot call page_symlink() with transaction started</span>
<span class="cm">		 * because it calls into ext3_write_begin() which acquires page</span>
<span class="cm">		 * lock which ranks below transaction start (and it can also</span>
<span class="cm">		 * wait for journal commit if we are running out of space). So</span>
<span class="cm">		 * we have to stop transaction now and restart it when symlink</span>
<span class="cm">		 * contents is written. </span>
<span class="cm">		 *</span>
<span class="cm">		 * To keep fs consistent in case of crash, we have to put inode</span>
<span class="cm">		 * to orphan list in the mean time.</span>
<span class="cm">		 */</span>
		<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_drop_inode</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__page_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_drop_inode</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now inode is being linked into dir (EXT3_DATA_TRANS_BLOCKS</span>
<span class="cm">		 * + EXT3_INDEX_EXTRA_TRANS_BLOCKS), inode is also modified</span>
<span class="cm">		 */</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span>
				<span class="n">EXT3_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">EXT3_INDEX_EXTRA_TRANS_BLOCKS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_drop_inode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_drop_inode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_fast_symlink_inode_operations</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span><span class="n">symname</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_add_nondir</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="nl">out_stop:</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_retry_alloc</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">err_drop_inode:</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_link</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">old_dentry</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;=</span> <span class="n">EXT3_LINK_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMLINK</span><span class="p">;</span>

	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">EXT3_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">EXT3_INDEX_EXTRA_TRANS_BLOCKS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_add_entry</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_retry_alloc</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PARENT_INO(buffer) \</span>
<span class="cp">	(ext3_next_entry((struct ext3_dir_entry_2 *)(buffer))-&gt;inode)</span>

<span class="cm">/*</span>
<span class="cm"> * Anybody can rename anything with this: the permission checks are left to the</span>
<span class="cm"> * higher-level routines.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_rename</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">new_dir</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">old_inode</span><span class="p">,</span> <span class="o">*</span> <span class="n">new_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">old_bh</span><span class="p">,</span> <span class="o">*</span> <span class="n">new_bh</span><span class="p">,</span> <span class="o">*</span> <span class="n">dir_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span> <span class="n">old_de</span><span class="p">,</span> <span class="o">*</span> <span class="n">new_de</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">flush_file</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
	<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">new_dir</span><span class="p">);</span>

	<span class="n">old_bh</span> <span class="o">=</span> <span class="n">new_bh</span> <span class="o">=</span> <span class="n">dir_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Initialize quotas before so that eventual writes go</span>
<span class="cm">	 * in separate transaction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span>
					<span class="n">EXT3_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">EXT3_INDEX_EXTRA_TRANS_BLOCKS</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">old_dir</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">new_dir</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">old_bh</span> <span class="o">=</span> <span class="n">ext3_find_entry</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_de</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check for inode number is _not_ due to possible IO errors.</span>
<span class="cm">	 *  We might rmdir the source, keep it as pwd of some process</span>
<span class="cm">	 *  and merrily kill the link to whatever was created under the</span>
<span class="cm">	 *  same name. Goodbye sticky bit ;-&lt;</span>
<span class="cm">	 */</span>
	<span class="n">old_inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_bh</span> <span class="o">||</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">old_de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_rename</span><span class="p">;</span>

	<span class="n">new_inode</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">new_bh</span> <span class="o">=</span> <span class="n">ext3_find_entry</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_de</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">new_bh</span><span class="p">);</span>
			<span class="n">new_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty_dir</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">end_rename</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">dir_bh</span> <span class="o">=</span> <span class="n">ext3_bread</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir_bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_rename</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">PARENT_INO</span><span class="p">(</span><span class="n">dir_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="o">!=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_rename</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMLINK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_inode</span> <span class="o">&amp;&amp;</span> <span class="n">new_dir</span><span class="o">!=</span><span class="n">old_dir</span> <span class="o">&amp;&amp;</span>
				<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;=</span> <span class="n">EXT3_LINK_MAX</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_rename</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_add_entry</span> <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_rename</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">new_bh</span><span class="p">,</span> <span class="s">&quot;get write access&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">new_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
		<span class="n">new_de</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EXT3_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					      <span class="n">EXT3_FEATURE_INCOMPAT_FILETYPE</span><span class="p">))</span>
			<span class="n">new_de</span><span class="o">-&gt;</span><span class="n">file_type</span> <span class="o">=</span> <span class="n">old_de</span><span class="o">-&gt;</span><span class="n">file_type</span><span class="p">;</span>
		<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="o">++</span><span class="p">;</span>
		<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">new_bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">new_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">new_bh</span><span class="p">);</span>
		<span class="n">new_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Like most other Unix systems, set the ctime for inodes on a</span>
<span class="cm">	 * rename.</span>
<span class="cm">	 */</span>
	<span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ok, that&#39;s it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">old_de</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">||</span>
	    <span class="n">old_de</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">!=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">||</span>
	    <span class="n">strncmp</span><span class="p">(</span><span class="n">old_de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">old_de</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_delete_entry</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span>
					<span class="n">old_de</span><span class="p">,</span> <span class="n">old_bh</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* old_de could have moved from under us during htree split, so</span>
<span class="cm">		 * make sure that we are deleting the right entry.  We might</span>
<span class="cm">		 * also be pointing to a stale entry in the unused part of</span>
<span class="cm">		 * old_bh so just checking inum and the name isn&#39;t enough. */</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">old_bh2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ext3_dir_entry_2</span> <span class="o">*</span><span class="n">old_de2</span><span class="p">;</span>

		<span class="n">old_bh2</span> <span class="o">=</span> <span class="n">ext3_find_entry</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">old_de2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_bh2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_delete_entry</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span>
						   <span class="n">old_de2</span><span class="p">,</span> <span class="n">old_bh2</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">old_bh2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_warning</span><span class="p">(</span><span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_rename&quot;</span><span class="p">,</span>
				<span class="s">&quot;Deleting old file (%lu), %d, error=%d&quot;</span><span class="p">,</span>
				<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_nlink</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>
		<span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">ext3_update_dx_flag</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">dir_bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">journal_error</span><span class="p">;</span>
		<span class="n">PARENT_INO</span><span class="p">(</span><span class="n">dir_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">dir_bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">dir_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">journal_error:</span>
			<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">end_rename</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">drop_nlink</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drop_nlink</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inc_nlink</span><span class="p">(</span><span class="n">new_dir</span><span class="p">);</span>
			<span class="n">ext3_update_dx_flag</span><span class="p">(</span><span class="n">new_dir</span><span class="p">);</span>
			<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">new_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
			<span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">new_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext3_should_writeback_data</span><span class="p">(</span><span class="n">new_inode</span><span class="p">))</span>
			<span class="n">flush_file</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">end_rename:</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">dir_bh</span><span class="p">);</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">old_bh</span><span class="p">);</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">new_bh</span><span class="p">);</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flush_file</span><span class="p">)</span>
		<span class="n">filemap_flush</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * directories can handle most operations...</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext3_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">ext3_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">ext3_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>		<span class="o">=</span> <span class="n">ext3_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>		<span class="o">=</span> <span class="n">ext3_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>	<span class="o">=</span> <span class="n">ext3_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>		<span class="o">=</span> <span class="n">ext3_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span>		<span class="o">=</span> <span class="n">ext3_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>		<span class="o">=</span> <span class="n">ext3_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>		<span class="o">=</span> <span class="n">ext3_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">ext3_setattr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_EXT3_FS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">generic_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">generic_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">ext3_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">generic_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">get_acl</span>	<span class="o">=</span> <span class="n">ext3_get_acl</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext3_special_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">ext3_setattr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_EXT3_FS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">generic_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">generic_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">ext3_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">generic_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">get_acl</span>	<span class="o">=</span> <span class="n">ext3_get_acl</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
