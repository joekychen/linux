<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext3 › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ext3/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/minix/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  Goal-directed block allocation by Stephen Tweedie</span>
<span class="cm"> *	(sct@redhat.com), 1993, 1998</span>
<span class="cm"> *  Big-endian to little-endian byte-swapping/bitmaps by</span>
<span class="cm"> *        David S. Miller (davem@caip.rutgers.edu), 1995</span>
<span class="cm"> *  64-bit file support on 64-bit platforms by Jakub Jelinek</span>
<span class="cm"> *	(jj@sunsite.ms.mff.cuni.cz)</span>
<span class="cm"> *</span>
<span class="cm"> *  Assorted race fixes, rewrite of ext3_get_block() by Al Viro, 2000</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/highuid.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &quot;ext3.h&quot;</span>
<span class="cp">#include &quot;xattr.h&quot;</span>
<span class="cp">#include &quot;acl.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext3_writepage_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext3_block_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Test whether an inode is a fast symlink.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_inode_is_fast_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ea_blocks</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">-</span> <span class="n">ea_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The ext3 forget function must perform a revoke if we are freeing data</span>
<span class="cm"> * which has been journaled.  Metadata (eg. indirect blocks) must be</span>
<span class="cm"> * revoked in all cases.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;bh&quot; may be NULL: a metadata block may have been freed from memory</span>
<span class="cm"> * but there may still be a record of it in the journal, and that record</span>
<span class="cm"> * still needs to be revoked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_forget</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">ext3_fsblk_t</span> <span class="n">blocknr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">trace_ext3_forget</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">is_metadata</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;enter&quot;</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;forgetting bh %p: is_metadata = %d, mode %o, &quot;</span>
		  <span class="s">&quot;data mode %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">bh</span><span class="p">,</span> <span class="n">is_metadata</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
		  <span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DATA_FLAGS</span><span class="p">));</span>

	<span class="cm">/* Never use the revoke function if we are doing full data</span>
<span class="cm">	 * journaling: there is no need to, and a V1 superblock won&#39;t</span>
<span class="cm">	 * support it.  Otherwise, only skip the revoke on un-journaled</span>
<span class="cm">	 * data blocks. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DATA_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="n">EXT3_MOUNT_JOURNAL_DATA</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">is_metadata</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ext3_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call journal_forget&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ext3_journal_forget</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * data!=journal &amp;&amp; (is_metadata || should_journal_data(inode))</span>
<span class="cm">	 */</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_revoke&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_revoke</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ext3_abort</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="s">&quot;error %d when attempting revoke&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;exit&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Work out how many blocks we need to proceed with the next chunk of a</span>
<span class="cm"> * truncate transaction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">blocks_for_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">needed</span><span class="p">;</span>

	<span class="n">needed</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>

	<span class="cm">/* Give ourselves just enough room to cope with inodes in which</span>
<span class="cm">	 * i_blocks is corrupt: we&#39;ve seen disk corruptions in the past</span>
<span class="cm">	 * which resulted in random data in an inode which looked enough</span>
<span class="cm">	 * like a regular file for ext3 to try to delete it.  Things</span>
<span class="cm">	 * will go a bit crazy if that happens, but at least we should</span>
<span class="cm">	 * try not to panic the whole kernel. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">needed</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* But we need to bound the transaction so we don&#39;t overflow the</span>
<span class="cm">	 * journal. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&gt;</span> <span class="n">EXT3_MAX_TRANS_DATA</span><span class="p">)</span>
		<span class="n">needed</span> <span class="o">=</span> <span class="n">EXT3_MAX_TRANS_DATA</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">EXT3_DATA_TRANS_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span> <span class="n">needed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Truncate transactions can be complex and absolutely huge.  So we need to</span>
<span class="cm"> * be able to restart the transaction at a conventient checkpoint to make</span>
<span class="cm"> * sure we don&#39;t overflow the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * start_transaction gets us a new handle for a truncate transaction,</span>
<span class="cm"> * and extend_transaction tries to extend the existing one a bit.  If</span>
<span class="cm"> * extend fails, we need to propagate the failure up and restart the</span>
<span class="cm"> * transaction in the top-level truncate loop. --sct</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">start_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">blocks_for_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to extend this transaction for the purposes of truncation.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if we managed to create more room.  If we can&#39;t create more</span>
<span class="cm"> * room, and the transaction must be restarted we return 1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_extend_transaction</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span> <span class="o">&gt;</span> <span class="n">EXT3_RESERVE_TRANS_BLOCKS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_journal_extend</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">blocks_for_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Restart the transaction associated with *handle.  This does a commit,</span>
<span class="cm"> * so before we call here everything must be consistently dirtied against</span>
<span class="cm"> * this transaction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">truncate_restart_transaction</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;restarting handle %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Drop truncate_mutex to avoid deadlock with ext3_get_blocks_handle</span>
<span class="cm">	 * At this moment, get_block can be called only for blocks inside</span>
<span class="cm">	 * i_size since page cache has been already dropped and writes are</span>
<span class="cm">	 * blocked by i_mutex. So we can safely drop the truncate_mutex.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_journal_restart</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">blocks_for_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called at inode eviction from icache</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext3_evict_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext3_block_alloc_info</span> <span class="o">*</span><span class="n">rsv</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want_delete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_ext3_evict_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">want_delete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When journalling data dirty buffers are tracked only in the journal.</span>
<span class="cm">	 * So although mm thinks everything is clean and ready for reaping the</span>
<span class="cm">	 * inode might still have some pages to write in the running</span>
<span class="cm">	 * transaction or waiting to be checkpointed. Thus calling</span>
<span class="cm">	 * journal_invalidatepage() (via truncate_inode_pages()) to discard</span>
<span class="cm">	 * these buffers can cause data loss. Also even if we did not discard</span>
<span class="cm">	 * these buffers, we would have no way to find them after the inode</span>
<span class="cm">	 * is reaped and thus user could see stale data if he tries to read</span>
<span class="cm">	 * them before the transaction is checkpointed. So be careful and</span>
<span class="cm">	 * force everything to disk here... We use ei-&gt;i_datasync_tid to</span>
<span class="cm">	 * store the newest transaction containing inode&#39;s data.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that directories do not have this problem because they don&#39;t</span>
<span class="cm">	 * use page cache.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The s_journal check handles the case when ext3_get_journal() fails</span>
<span class="cm">	 * and puts the journal inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_journal</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">tid_t</span> <span class="n">commit_tid</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span><span class="p">);</span>
		<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_journal</span><span class="p">;</span>

		<span class="n">log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_tid</span><span class="p">);</span>
		<span class="n">log_wait_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_tid</span><span class="p">);</span>
		<span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ext3_discard_reservation</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">rsv</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rsv</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rsv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">want_delete</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">start_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;re going to skip the normal cleanup, we still need to</span>
<span class="cm">		 * make sure that the in-core orphan linked list is properly</span>
<span class="cm">		 * cleaned up.</span>
<span class="cm">		 */</span>
		<span class="n">ext3_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">)</span>
		<span class="n">ext3_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Kill off the orphan record created when the inode lost the last</span>
<span class="cm">	 * link.  Note that ext3_orphan_del() has to be able to cope with the</span>
<span class="cm">	 * deletion of a non-existent orphan - ext3_truncate() could</span>
<span class="cm">	 * have removed the record.</span>
<span class="cm">	 */</span>
	<span class="n">ext3_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * One subtle ordering requirement: if anything has gone wrong</span>
<span class="cm">	 * (transaction abort, IO errors, whatever), then we can still</span>
<span class="cm">	 * do these next steps (the fs will already have been marked as</span>
<span class="cm">	 * having errors), but we can&#39;t free the inode if the mark_dirty</span>
<span class="cm">	 * fails.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If that failed, just dquot_drop() and be done with that */</span>
		<span class="n">dquot_drop</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ext3_xattr_delete_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">dquot_free_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">dquot_drop</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ext3_free_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">no_delete:</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">dquot_drop</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Indirect</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_chain</span><span class="p">(</span><span class="n">Indirect</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">verify_chain</span><span class="p">(</span><span class="n">Indirect</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;=</span> <span class="n">to</span> <span class="o">&amp;&amp;</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="o">*</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span>
		<span class="n">from</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_block_to_path - parse the block number into array of offsets</span>
<span class="cm"> *	@inode: inode in question (we are only interested in its superblock)</span>
<span class="cm"> *	@i_block: block number to be parsed</span>
<span class="cm"> *	@offsets: array to store the offsets in</span>
<span class="cm"> *      @boundary: set this non-zero if the referred-to block is likely to be</span>
<span class="cm"> *             followed (on disk) by an indirect block.</span>
<span class="cm"> *</span>
<span class="cm"> *	To store the locations of file&#39;s data ext3 uses a data structure common</span>
<span class="cm"> *	for UNIX filesystems - tree of pointers anchored in the inode, with</span>
<span class="cm"> *	data blocks at leaves and indirect blocks in intermediate nodes.</span>
<span class="cm"> *	This function translates the block number into path in that tree -</span>
<span class="cm"> *	return value is the path length and @offsets[n] is the offset of</span>
<span class="cm"> *	pointer to (n+1)th node in the nth one. If @block is out of range</span>
<span class="cm"> *	(negative or too large) warning is printed and zero returned.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: function doesn&#39;t find node addresses, so no IO is needed. All</span>
<span class="cm"> *	we need to know is the capacity of indirect blocks (taken from the</span>
<span class="cm"> *	inode-&gt;i_sb).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Portability note: the last comparison (check that we fit into triple</span>
<span class="cm"> * indirect block) is spelled differently, because otherwise on an</span>
<span class="cm"> * architecture with 32-bit longs and 8Kb pages we might get into trouble</span>
<span class="cm"> * if our filesystem had 8Kb blocks. We might use long long, but that would</span>
<span class="cm"> * kill us on x86. Oh, well, at least the sign propagation does not matter -</span>
<span class="cm"> * i_block would have to be negative in the very beginning, so we would not</span>
<span class="cm"> * get there at all.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_block_to_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="kt">long</span> <span class="n">i_block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">boundary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="n">EXT3_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ptrs_bits</span> <span class="o">=</span> <span class="n">EXT3_ADDR_PER_BLOCK_BITS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">long</span> <span class="n">direct_blocks</span> <span class="o">=</span> <span class="n">EXT3_NDIR_BLOCKS</span><span class="p">,</span>
		<span class="n">indirect_blocks</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">,</span>
		<span class="n">double_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">final</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_warning</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_block_to_path&quot;</span><span class="p">,</span> <span class="s">&quot;block &lt; 0&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&lt;</span> <span class="n">direct_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="p">;</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">direct_blocks</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">direct_blocks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">indirect_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT3_IND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="p">;</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">indirect_blocks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">double_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT3_DIND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="n">ptrs_bits</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">double_blocks</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">ptrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT3_TIND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="n">ptrs_bits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ext3_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_block_to_path&quot;</span><span class="p">,</span> <span class="s">&quot;block &gt; big&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
		<span class="o">*</span><span class="n">boundary</span> <span class="o">=</span> <span class="n">final</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_get_branch - read the chain of indirect blocks leading to data</span>
<span class="cm"> *	@inode: inode in question</span>
<span class="cm"> *	@depth: depth of the chain (1 - direct pointer, etc.)</span>
<span class="cm"> *	@offsets: offsets of pointers in inode/indirect blocks</span>
<span class="cm"> *	@chain: place to store the result</span>
<span class="cm"> *	@err: here we store the error value</span>
<span class="cm"> *</span>
<span class="cm"> *	Function fills the array of triples &lt;key, p, bh&gt; and returns %NULL</span>
<span class="cm"> *	if everything went OK or the pointer to the last filled triple</span>
<span class="cm"> *	(incomplete one) otherwise. Upon the return chain[i].key contains</span>
<span class="cm"> *	the number of (i+1)-th block in the chain (as it is stored in memory,</span>
<span class="cm"> *	i.e. little-endian 32-bit), chain[i].p contains the address of that</span>
<span class="cm"> *	number (it points into struct inode for i==0 and into the bh-&gt;b_data</span>
<span class="cm"> *	for i&gt;0) and chain[i].bh points to the buffer_head of i-th indirect</span>
<span class="cm"> *	block for i&gt;0 and NULL for i==0. In other words, it holds the block</span>
<span class="cm"> *	numbers of the chain, addresses they were taken from (and where we can</span>
<span class="cm"> *	verify that chain did not change) and buffer_heads hosting these</span>
<span class="cm"> *	numbers.</span>
<span class="cm"> *</span>
<span class="cm"> *	Function stops when it stumbles upon zero pointer (absent block)</span>
<span class="cm"> *		(pointer to last triple returned, *@err == 0)</span>
<span class="cm"> *	or when it gets an IO error reading an indirect block</span>
<span class="cm"> *		(ditto, *@err == -EIO)</span>
<span class="cm"> *	or when it notices that chain had been changed while it was reading</span>
<span class="cm"> *		(ditto, *@err == -EAGAIN)</span>
<span class="cm"> *	or when it reads all @depth-1 indirect blocks successfully and finds</span>
<span class="cm"> *	the whole chain, all way to the data (returns %NULL, *err == 0).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">Indirect</span> <span class="o">*</span><span class="nf">ext3_get_branch</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span>
				 <span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* i_data is not going away, no lock needed */</span>
	<span class="n">add_chain</span> <span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span> <span class="o">+</span> <span class="o">*</span><span class="n">offsets</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_block</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="cm">/* Reader: pointers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">verify_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">changed</span><span class="p">;</span>
		<span class="n">add_chain</span><span class="p">(</span><span class="o">++</span><span class="n">p</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="o">*++</span><span class="n">offsets</span><span class="p">);</span>
		<span class="cm">/* Reader: end */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_block</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">changed:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">no_block</span><span class="p">;</span>
<span class="nl">failure:</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">no_block:</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_find_near - find a place for allocation with sufficient locality</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@ind: descriptor of indirect block.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function returns the preferred place for block allocation.</span>
<span class="cm"> *	It is used when heuristic for sequential allocation fails.</span>
<span class="cm"> *	Rules are:</span>
<span class="cm"> *	  + if there is a block to the left of our position - allocate near it.</span>
<span class="cm"> *	  + if pointer will live in indirect block - allocate near that block.</span>
<span class="cm"> *	  + if pointer will live in inode - allocate in the same</span>
<span class="cm"> *	    cylinder group.</span>
<span class="cm"> *</span>
<span class="cm"> * In the latter case we colour the starting block by the callers PID to</span>
<span class="cm"> * prevent it from clashing with concurrent allocations for a different inode</span>
<span class="cm"> * in the same block group.   The PID is used here so that functionally related</span>
<span class="cm"> * files will be close-by on-disk.</span>
<span class="cm"> *</span>
<span class="cm"> *	Caller must make sure that @ind is valid and will stay that way.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext3_fsblk_t</span> <span class="nf">ext3_find_near</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">ind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">?</span> <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">:</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">bg_start</span><span class="p">;</span>
	<span class="n">ext3_grpblk_t</span> <span class="n">colour</span><span class="p">;</span>

	<span class="cm">/* Try to find previous block */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">;</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* No such thing, so let&#39;s try location of indirect block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is going to be referred to from the inode itself? OK, just put it</span>
<span class="cm">	 * into the same cylinder group then.</span>
<span class="cm">	 */</span>
	<span class="n">bg_start</span> <span class="o">=</span> <span class="n">ext3_group_first_block_no</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_group</span><span class="p">);</span>
	<span class="n">colour</span> <span class="o">=</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">%</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span>
			<span class="p">(</span><span class="n">EXT3_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bg_start</span> <span class="o">+</span> <span class="n">colour</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_find_goal - find a preferred place for allocation.</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@block:  block we want</span>
<span class="cm"> *	@partial: pointer to the last triple within a chain</span>
<span class="cm"> *</span>
<span class="cm"> *	Normally this function find the preferred place for block allocation,</span>
<span class="cm"> *	returns it.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">ext3_fsblk_t</span> <span class="nf">ext3_find_goal</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">long</span> <span class="n">block</span><span class="p">,</span>
				   <span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span><span class="p">;</span>

	<span class="n">block_i</span> <span class="o">=</span>  <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * try the heuristic for sequential allocation,</span>
<span class="cm">	 * failing that at least try to get decent locality.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_logical_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_physical_block</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_physical_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ext3_find_near</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">partial</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_blks_to_allocate - Look up the block map and count the number</span>
<span class="cm"> *	of direct blocks need to be allocated for the given branch.</span>
<span class="cm"> *</span>
<span class="cm"> *	@branch: chain of indirect blocks</span>
<span class="cm"> *	@k: number of blocks need for indirect blocks</span>
<span class="cm"> *	@blks: number of data blocks to be mapped.</span>
<span class="cm"> *	@blocks_to_boundary:  the offset in the indirect block</span>
<span class="cm"> *</span>
<span class="cm"> *	return the total number of blocks to be allocate, including the</span>
<span class="cm"> *	direct and indirect blocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_blks_to_allocate</span><span class="p">(</span><span class="n">Indirect</span> <span class="o">*</span><span class="n">branch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blks</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">blocks_to_boundary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Simple case, [t,d]Indirect block(s) has not allocated yet</span>
<span class="cm">	 * then it&#39;s clear blocks on that path have not allocated</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* right now we don&#39;t handle cross boundary allocation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blks</span> <span class="o">&lt;</span> <span class="n">blocks_to_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">blks</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">blocks_to_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">blks</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">blocks_to_boundary</span> <span class="o">&amp;&amp;</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">count</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_alloc_blocks - multiple allocate blocks needed for a branch</span>
<span class="cm"> *	@handle: handle for this transaction</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@goal: preferred place for allocation</span>
<span class="cm"> *	@indirect_blks: the number of blocks need to allocate for indirect</span>
<span class="cm"> *			blocks</span>
<span class="cm"> *	@blks:	number of blocks need to allocated for direct blocks</span>
<span class="cm"> *	@new_blocks: on return it will store the new block numbers for</span>
<span class="cm"> *	the indirect blocks(if needed) and the first direct block,</span>
<span class="cm"> *	@err: here we store the error value</span>
<span class="cm"> *</span>
<span class="cm"> *	return the number of direct blocks allocated</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_alloc_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blks</span><span class="p">,</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">new_blocks</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">current_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here we try to allocate the requested multiple blocks at once,</span>
<span class="cm">	 * on a best-effort basis.</span>
<span class="cm">	 * To build a branch, we should allocate blocks for</span>
<span class="cm">	 * the indirect blocks(if not allocated yet), and at least</span>
<span class="cm">	 * the first direct block of this branch.  That&#39;s the</span>
<span class="cm">	 * minimum number of blocks need to allocate(required)</span>
<span class="cm">	 */</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">blks</span> <span class="o">+</span> <span class="n">indirect_blks</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="cm">/* allocating blocks for indirect blocks and direct blocks */</span>
		<span class="n">current_block</span> <span class="o">=</span> <span class="n">ext3_new_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">inode</span><span class="p">,</span><span class="n">goal</span><span class="p">,</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed_out</span><span class="p">;</span>

		<span class="n">target</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
		<span class="cm">/* allocate blocks for indirect blocks */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">indirect_blks</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_blocks</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_block</span><span class="o">++</span><span class="p">;</span>
			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save the new block number for the first direct block */</span>
	<span class="n">new_blocks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_block</span><span class="p">;</span>

	<span class="cm">/* total number of blocks allocated for direct blocks */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">failed_out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ext3_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_alloc_branch - allocate and set up a chain of blocks.</span>
<span class="cm"> *	@handle: handle for this transaction</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@indirect_blks: number of allocated indirect blocks</span>
<span class="cm"> *	@blks: number of allocated direct blocks</span>
<span class="cm"> *	@goal: preferred place for allocation</span>
<span class="cm"> *	@offsets: offsets (in the blocks) to store the pointers to next.</span>
<span class="cm"> *	@branch: place to store the chain in.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function allocates blocks, zeroes out all but the last one,</span>
<span class="cm"> *	links them into chain and (if we are synchronous) writes them to disk.</span>
<span class="cm"> *	In other words, it prepares a branch that can be spliced onto the</span>
<span class="cm"> *	inode. It stores the information about that chain in the branch[], in</span>
<span class="cm"> *	the same format as ext3_get_branch() would do. We are calling it after</span>
<span class="cm"> *	we had read the existing part of chain and partial points to the last</span>
<span class="cm"> *	triple of that (one with zero -&gt;key). Upon the exit we have the same</span>
<span class="cm"> *	picture as after the successful ext3_get_block(), except that in one</span>
<span class="cm"> *	place chain is disconnected - *branch-&gt;p is still zero (we did not</span>
<span class="cm"> *	set the last link), but branch-&gt;key contains the number that should</span>
<span class="cm"> *	be placed into *branch-&gt;p to fill that gap.</span>
<span class="cm"> *</span>
<span class="cm"> *	If allocation fails we free all blocks we&#39;ve allocated (and forget</span>
<span class="cm"> *	their buffer_heads) and return the error value the from failed</span>
<span class="cm"> *	ext3_alloc_block() (normally -ENOSPC). Otherwise we set the chain</span>
<span class="cm"> *	as described above and return 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_alloc_branch</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">blks</span><span class="p">,</span> <span class="n">ext3_fsblk_t</span> <span class="n">goal</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">branch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">new_blocks</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">current_block</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">ext3_alloc_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span>
				<span class="o">*</span><span class="n">blks</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * metadata blocks and data blocks are allocated.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">indirect_blks</span><span class="p">;</span>  <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get buffer_head for parent block, zero it out</span>
<span class="cm">		 * and set the pointer to new one, then send</span>
<span class="cm">		 * parent to disk.</span>
<span class="cm">		 */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call get_create_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_create_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">=</span> <span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="n">indirect_blks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">current_block</span> <span class="o">=</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * End of chain, update the last new metablock of</span>
<span class="cm">			 * the chain to point to the new allocated</span>
<span class="cm">			 * data blocks numbers</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="o">*</span><span class="p">(</span><span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">++</span><span class="n">current_block</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;marking uptodate&quot;</span><span class="p">);</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">blks</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">failed:</span>
	<span class="cm">/* Allocation failed, free what we already allocated */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">branch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call journal_forget&quot;</span><span class="p">);</span>
		<span class="n">ext3_journal_forget</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">branch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">indirect_blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ext3_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ext3_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">num</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_splice_branch - splice the allocated branch onto inode.</span>
<span class="cm"> * @handle: handle for this transaction</span>
<span class="cm"> * @inode: owner</span>
<span class="cm"> * @block: (logical) number of block we are adding</span>
<span class="cm"> * @where: location of missing link</span>
<span class="cm"> * @num:   number of indirect blocks we are adding</span>
<span class="cm"> * @blks:  number of direct blocks we are adding</span>
<span class="cm"> *</span>
<span class="cm"> * This function fills the missing link and does all housekeeping needed in</span>
<span class="cm"> * inode (-&gt;i_blocks, etc.). In case of success we end up with the full</span>
<span class="cm"> * chain to new block and return 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_splice_branch</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="kt">long</span> <span class="n">block</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">current_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">block_i</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re splicing into a [td]indirect block (as opposed to the</span>
<span class="cm">	 * inode) then we need to get write access to the [td]indirect block</span>
<span class="cm">	 * before the splice.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* That&#39;s it */</span>

	<span class="o">*</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">where</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the host buffer_head or inode to point to more just allocated</span>
<span class="cm">	 * direct blocks blocks</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">blks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">current_block</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * update the most recently allocated logical &amp; physical block</span>
<span class="cm">	 * in i_block_alloc_info, to assist find the proper goal block for next</span>
<span class="cm">	 * allocation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_logical_block</span> <span class="o">=</span> <span class="n">block</span> <span class="o">+</span> <span class="n">blks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_physical_block</span> <span class="o">=</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="n">blks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We are done with atomic stuff, now do the rest of housekeeping */</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* ext3_mark_inode_dirty already updated i_sync_tid */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>

	<span class="cm">/* had we spliced it onto indirect block? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we spliced it onto an indirect block, we haven&#39;t</span>
<span class="cm">		 * altered the inode.  Note however that if it is being spliced</span>
<span class="cm">		 * onto an indirect block at the very end of the file (the</span>
<span class="cm">		 * file is growing) then we *will* alter the inode to reflect</span>
<span class="cm">		 * the new i_size.  But that is not done here - it is done in</span>
<span class="cm">		 * generic_commit_write-&gt;__mark_inode_dirty-&gt;ext3_dirty_inode.</span>
<span class="cm">		 */</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;splicing indirect only</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * OK, we spliced it into the inode itself on a direct block.</span>
<span class="cm">		 * Inode was dirtied above.</span>
<span class="cm">		 */</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;splicing direct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call journal_forget&quot;</span><span class="p">);</span>
		<span class="n">ext3_journal_forget</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">where</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">ext3_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="n">inode</span><span class="p">,</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext3_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">key</span><span class="p">),</span> <span class="n">blks</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocation strategy is simple: if we have to allocate something, we will</span>
<span class="cm"> * have to go the whole way to leaf. So let&#39;s do it before attaching anything</span>
<span class="cm"> * to tree, set linkage between the newborn blocks, write them if sync is</span>
<span class="cm"> * required, recheck the path, free and repeat if check fails, otherwise</span>
<span class="cm"> * set the last missing link (that will protect us from any truncate-generated</span>
<span class="cm"> * removals - all blocks on the path are immune now) and possibly force the</span>
<span class="cm"> * write on the parent block.</span>
<span class="cm"> * That has a nice additional property: no special recovery from the failed</span>
<span class="cm"> * allocations is needed - we simply release blocks and do not touch anything</span>
<span class="cm"> * reachable from inode.</span>
<span class="cm"> *</span>
<span class="cm"> * `handle&#39; can be NULL if create == 0.</span>
<span class="cm"> *</span>
<span class="cm"> * The BKL may not be held on entry here.  Be sure to take it early.</span>
<span class="cm"> * return &gt; 0, # of blocks mapped or allocated.</span>
<span class="cm"> * return = 0, if plain lookup failed.</span>
<span class="cm"> * return &lt; 0, error case.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_get_blocks_handle</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxblocks</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">goal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blocks_to_boundary</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">first_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="n">trace_ext3_get_blocks_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">maxblocks</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">handle</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">create</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext3_block_to_path</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">iblock</span><span class="p">,</span><span class="n">offsets</span><span class="p">,</span><span class="o">&amp;</span><span class="n">blocks_to_boundary</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext3_get_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>

	<span class="cm">/* Simplest case - block found, no allocation needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
		<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/*map more blocks*/</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">maxblocks</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">blocks_to_boundary</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_fsblk_t</span> <span class="n">blk</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">verify_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Indirect block might be removed by</span>
<span class="cm">				 * truncate while we were reading it.</span>
<span class="cm">				 * Handling of that case: forget what we&#39;ve</span>
<span class="cm">				 * got now. Flag the err as EAGAIN, so it</span>
<span class="cm">				 * will reread.</span>
<span class="cm">				 */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">count</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">blk</span> <span class="o">==</span> <span class="n">first_block</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">got_it</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Next simple case - plain lookup or failed read of indirect block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">create</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Block out ext3_truncate while we alter the tree</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the indirect block is missing while we are reading</span>
<span class="cm">	 * the chain(ext3_get_branch() returns -EAGAIN err), or</span>
<span class="cm">	 * if the chain has been changed after we grab the semaphore,</span>
<span class="cm">	 * (either because another process truncated this branch, or</span>
<span class="cm">	 * another get_block allocated this branch) re-grab the chain to see if</span>
<span class="cm">	 * the request block has been allocated or not.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since we already block the truncate/other get_block</span>
<span class="cm">	 * at this point, we will have the current copy of the chain when we</span>
<span class="cm">	 * splice the branch into the tree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="o">!</span><span class="n">verify_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">partial</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">partial</span> <span class="o">=</span> <span class="n">ext3_get_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
			<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">got_it</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Okay, we need to do block allocation.  Lazily initialize the block</span>
<span class="cm">	 * allocation info here if necessary</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">))</span>
		<span class="n">ext3_init_block_alloc_info</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">goal</span> <span class="o">=</span> <span class="n">ext3_find_goal</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">partial</span><span class="p">);</span>

	<span class="cm">/* the number of blocks need to allocate for [d,t]indirect blocks */</span>
	<span class="n">indirect_blks</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain</span> <span class="o">+</span> <span class="n">depth</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Next look up the indirect map to count the totoal number of</span>
<span class="cm">	 * direct blocks to allocate for this branch.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">ext3_blks_to_allocate</span><span class="p">(</span><span class="n">partial</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span>
					<span class="n">maxblocks</span><span class="p">,</span> <span class="n">blocks_to_boundary</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_alloc_branch</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span>
				<span class="n">offsets</span> <span class="o">+</span> <span class="p">(</span><span class="n">partial</span> <span class="o">-</span> <span class="n">chain</span><span class="p">),</span> <span class="n">partial</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ext3_splice_branch call will free and forget any buffers</span>
<span class="cm">	 * on the new chain if there is a failure, but that risks using</span>
<span class="cm">	 * up transaction credits, especially for bitmaps where the</span>
<span class="cm">	 * credits cannot be returned.  Can we handle this somehow?  We</span>
<span class="cm">	 * may need to return -EAGAIN upwards in the worst case.  --sct</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_splice_branch</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span>
					<span class="n">partial</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
<span class="nl">got_it:</span>
	<span class="n">map_bh</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">blocks_to_boundary</span><span class="p">)</span>
		<span class="n">set_buffer_boundary</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/* Clean up and exit */</span>
	<span class="n">partial</span> <span class="o">=</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* the whole chain */</span>
<span class="nl">cleanup:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call brelse&quot;</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="s">&quot;returned&quot;</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">trace_ext3_get_blocks_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span>
				   <span class="n">depth</span> <span class="o">?</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="n">count</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Maximum number of blocks we map for direct IO at once. */</span>
<span class="cp">#define DIO_MAX_BLOCKS 4096</span>
<span class="cm">/*</span>
<span class="cm"> * Number of credits we need for writing DIO_MAX_BLOCKS:</span>
<span class="cm"> * We need sb + group descriptor + bitmap + inode -&gt; 4</span>
<span class="cm"> * For B blocks with A block pointers per block we need:</span>
<span class="cm"> * 1 (triple ind.) + (B/A/A + 2) (doubly ind.) + (B/A + 2) (indirect).</span>
<span class="cm"> * If we plug in 4096 for B and 256 for A (for 1KB block size), we get 25.</span>
<span class="cm"> */</span>
<span class="cp">#define DIO_CREDITS 25</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_current_handle</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">started</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">max_blocks</span> <span class="o">=</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Direct IO write... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_blocks</span> <span class="o">&gt;</span> <span class="n">DIO_MAX_BLOCKS</span><span class="p">)</span>
			<span class="n">max_blocks</span> <span class="o">=</span> <span class="n">DIO_MAX_BLOCKS</span><span class="p">;</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">DIO_CREDITS</span> <span class="o">+</span>
				<span class="n">EXT3_MAXQUOTAS_TRANS_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_get_blocks_handle</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span>
					<span class="n">max_blocks</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">started</span><span class="p">)</span>
		<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext3_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">generic_block_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				    <span class="n">ext3_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * `handle&#39; can be NULL if create is zero</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">ext3_getblk</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="kt">long</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fatal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">handle</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">create</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dummy</span><span class="p">.</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dummy</span><span class="p">.</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span><span class="p">;</span>
	<span class="n">buffer_trace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">.</span><span class="n">b_history</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_get_blocks_handle</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * ext3_get_blocks_handle() returns number of blocks</span>
<span class="cm">	 * mapped. 0 in case of a HOLE.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_mapped</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">dummy</span><span class="p">.</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">create</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">handle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Now that we do not always journal data, we should</span>
<span class="cm">			 * keep in mind whether this should always journal the</span>
<span class="cm">			 * new buffer as metadata.  For now, regular file</span>
<span class="cm">			 * writes use ext3_get_block instead, so it&#39;s not a</span>
<span class="cm">			 * problem.</span>
<span class="cm">			 */</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call get_create_access&quot;</span><span class="p">);</span>
			<span class="n">fatal</span> <span class="o">=</span> <span class="n">ext3_journal_get_create_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fatal</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fatal</span><span class="p">)</span>
				<span class="n">fatal</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;not a new buffer&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatal</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">fatal</span><span class="p">;</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">ext3_bread</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">ext3_getblk</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">create</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh_uptodate_or_lock</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
	<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span> <span class="o">|</span> <span class="n">REQ_META</span> <span class="o">|</span> <span class="n">REQ_PRIO</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">walk_page_buffers</span><span class="p">(</span>	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">to</span><span class="p">,</span>
				<span class="kt">int</span> <span class="o">*</span><span class="n">partial</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span>	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span>	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">block_start</span><span class="p">);</span>
		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&lt;=</span> <span class="n">from</span> <span class="o">||</span> <span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="o">*</span><span class="n">partial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To preserve ordering, it is essential that the hole instantiation and</span>
<span class="cm"> * the data write be encapsulated in a single transaction.  We cannot</span>
<span class="cm"> * close off a transaction and start a new one between the ext3_get_block()</span>
<span class="cm"> * and the commit_write().  So doing the journal_start at the start of</span>
<span class="cm"> * prepare_write() is the right place.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, this function can nest inside ext3_writepage() -&gt;</span>
<span class="cm"> * block_write_full_page(). In that case, we *know* that ext3_writepage()</span>
<span class="cm"> * has generated enough buffer credits to do the whole page.  So we won&#39;t</span>
<span class="cm"> * block on the journal in that case, which is good, because the caller may</span>
<span class="cm"> * be PF_MEMALLOC.</span>
<span class="cm"> *</span>
<span class="cm"> * By accident, ext3 can be reentered when a transaction is open via</span>
<span class="cm"> * quota file writes.  If we were to commit the transaction while thus</span>
<span class="cm"> * reentered, there can be a deadlock - we would be holding a quota</span>
<span class="cm"> * lock, and the commit would never complete if another thread had a</span>
<span class="cm"> * transaction open and was blocking on the quota lock - a ranking</span>
<span class="cm"> * violation.</span>
<span class="cm"> *</span>
<span class="cm"> * So what we do is to rely on the fact that journal_stop/journal_start</span>
<span class="cm"> * will _not_ run commit under these circumstances because handle-&gt;h_ref</span>
<span class="cm"> * is elevated.  We&#39;ll still have enough credits for the tiny quotafile</span>
<span class="cm"> * write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_journal_get_write_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * __block_prepare_write() could have dirtied some buffers. Clean</span>
<span class="cm">	 * the dirty bit as jbd2_journal_get_write_access() could complain</span>
<span class="cm">	 * otherwise about fs integrity issues. Setting of the dirty bit</span>
<span class="cm">	 * by __block_prepare_write() isn&#39;t a real problem here as we clear</span>
<span class="cm">	 * the bit before releasing a page lock and thus writeback cannot</span>
<span class="cm">	 * ever write the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">dirty</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Truncate blocks that were not used by write. We have to truncate the</span>
<span class="cm"> * pagecache as well so that corresponding buffers get properly unmapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext3_truncate_failed_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">ext3_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Truncate blocks that were not used by direct IO write. We have to zero out</span>
<span class="cm"> * the last file block as well because direct IO might have written to it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext3_truncate_failed_direct_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_block_truncate_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">ext3_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
	<span class="cm">/* Reserve one block more for addition to orphan list in case</span>
<span class="cm">	 * we allocate blocks but write fails for some reason */</span>
	<span class="kt">int</span> <span class="n">needed_blocks</span> <span class="o">=</span> <span class="n">ext3_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">trace_ext3_write_begin</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">needed_blocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ext3_get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">write_begin_failed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
				<span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">do_journal_get_write_access</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">write_begin_failed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * block_write_begin may have instantiated a few blocks</span>
<span class="cm">		 * outside i_size.  Trim these off again. Don&#39;t need</span>
<span class="cm">		 * i_size_read because we hold i_mutex.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Add inode to orphan list in case we crash before truncate</span>
<span class="cm">		 * finishes. Do this only if ext3_can_truncate() agrees so</span>
<span class="cm">		 * that orphan processing code is happy.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
			<span class="n">ext3_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">ext3_journal_dirty_data</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">journal_dirty_data</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ext3_journal_abort_handle</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
						<span class="n">bh</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For ordered writepage and write_end functions */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_dirty_data_fn</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Write could have mapped the buffer but it didn&#39;t copy the data in</span>
<span class="cm">	 * yet. So avoid filing such buffer into a transaction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ext3_journal_dirty_data</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For write_end() in data=journal mode */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_end_fn</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is nasty and subtle: ext3_write_begin() could have allocated blocks</span>
<span class="cm"> * for the whole page but later we failed to copy the data in. Update inode</span>
<span class="cm"> * size according to what we managed to copy. The rest is going to be</span>
<span class="cm"> * truncated in write_end function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_file_sizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* What matters to us is i_disksize. We don&#39;t write i_size anywhere */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">&gt;</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">;</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to pick up the new inode size which generic_commit_write gave us</span>
<span class="cm"> * `file&#39; can be NULL - eg, when called from page_symlink().</span>
<span class="cm"> *</span>
<span class="cm"> * ext3 never places buffers on inode-&gt;i_mapping-&gt;private_list.  metadata</span>
<span class="cm"> * buffers are managed internally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_ordered_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_current_handle</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="n">trace_ext3_ordered_write_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">block_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>

	<span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">copied</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
		<span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">journal_dirty_data_fn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">update_file_sizes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * There may be allocated blocks outside of i_size because</span>
<span class="cm">	 * we failed to copy some data. Prepare for truncate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">ext3_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_writeback_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_current_handle</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">trace_ext3_writeback_write_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">block_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
	<span class="n">update_file_sizes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * There may be allocated blocks outside of i_size because</span>
<span class="cm">	 * we failed to copy some data. Prepare for truncate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">ext3_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_journalled_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_current_handle</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">partial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>

	<span class="n">trace_ext3_journalled_write_end</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">page_zero_new_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">from</span> <span class="o">+</span> <span class="n">copied</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
		<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">copied</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">from</span><span class="p">,</span>
				<span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">partial</span><span class="p">,</span> <span class="n">write_end_fn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * There may be allocated blocks outside of i_size because</span>
<span class="cm">	 * we failed to copy some data. Prepare for truncate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ext3_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_JDATA</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
		<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">ext3_truncate_failed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bmap() is special.  It gets used by applications such as lilo and by</span>
<span class="cm"> * the swapper to find the on-disk block of a specific piece of data.</span>
<span class="cm"> *</span>
<span class="cm"> * Naturally, this is dangerous if the block concerned is still in the</span>
<span class="cm"> * journal.  If somebody makes a swapfile on an ext3 data-journaling</span>
<span class="cm"> * filesystem and enables swap, then they may get a nasty shock when the</span>
<span class="cm"> * data getting swapped to that swapfile suddenly gets overwritten by</span>
<span class="cm"> * the original zero&#39;s written out previously to the journal and</span>
<span class="cm"> * awaiting writeback in the kernel&#39;s buffer cache.</span>
<span class="cm"> *</span>
<span class="cm"> * So, if we see any bmap calls here on a modified, data-journaled file,</span>
<span class="cm"> * take extra steps to flush any blocks which might be in the cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">ext3_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_JDATA</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is a REALLY heavyweight approach, but the use of</span>
<span class="cm">		 * bmap on dirty files is expected to be extremely rare:</span>
<span class="cm">		 * only if we run lilo or swapon on a freshly made file</span>
<span class="cm">		 * do we expect this to happen.</span>
<span class="cm">		 *</span>
<span class="cm">		 * (bmap requires CAP_SYS_RAWIO so this does not</span>
<span class="cm">		 * represent an unprivileged user DOS attack --- we&#39;d be</span>
<span class="cm">		 * in trouble if mortal users could trigger this path at</span>
<span class="cm">		 * will.)</span>
<span class="cm">		 *</span>
<span class="cm">		 * NB. EXT3_STATE_JDATA is not set on files other than</span>
<span class="cm">		 * regular files.  If somebody wants to bmap a directory</span>
<span class="cm">		 * or symlink and gets confused because the buffer</span>
<span class="cm">		 * hasn&#39;t yet been flushed to disk, they deserve</span>
<span class="cm">		 * everything they get.</span>
<span class="cm">		 */</span>

		<span class="n">ext3_clear_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_JDATA</span><span class="p">);</span>
		<span class="n">journal</span> <span class="o">=</span> <span class="n">EXT3_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">journal_lock_updates</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_flush</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">journal_unlock_updates</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">generic_block_bmap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span><span class="n">block</span><span class="p">,</span><span class="n">ext3_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bget_one</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bput_one</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">buffer_unmapped</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note that we always start a transaction even if we&#39;re not journalling</span>
<span class="cm"> * data.  This is to preserve ordering: any hole instantiation within</span>
<span class="cm"> * __block_write_full_page -&gt; ext3_get_block() should be journalled</span>
<span class="cm"> * along with the data so we don&#39;t crash and then get metadata which</span>
<span class="cm"> * refers to old data.</span>
<span class="cm"> *</span>
<span class="cm"> * In all journalling modes block_write_full_page() will start the I/O.</span>
<span class="cm"> *</span>
<span class="cm"> * Problem:</span>
<span class="cm"> *</span>
<span class="cm"> *	ext3_writepage() -&gt; kmalloc() -&gt; __alloc_pages() -&gt; page_launder() -&gt;</span>
<span class="cm"> *		ext3_writepage()</span>
<span class="cm"> *</span>
<span class="cm"> * Similar for:</span>
<span class="cm"> *</span>
<span class="cm"> *	ext3_file_write() -&gt; generic_file_write() -&gt; __alloc_pages() -&gt; ...</span>
<span class="cm"> *</span>
<span class="cm"> * Same applies to ext3_get_block().  We will deadlock on various things like</span>
<span class="cm"> * lock_journal and i_truncate_mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * Setting PF_MEMALLOC here doesn&#39;t work - too many internal memory</span>
<span class="cm"> * allocations fail.</span>
<span class="cm"> *</span>
<span class="cm"> * 16May01: If we&#39;re reentered then journal_current_handle() will be</span>
<span class="cm"> *	    non-zero. We simply *return*.</span>
<span class="cm"> *</span>
<span class="cm"> * 1 July 2001: @@@ FIXME:</span>
<span class="cm"> *   In journalled data mode, a data buffer may be metadata against the</span>
<span class="cm"> *   current transaction.  But the same file is part of a shared mapping</span>
<span class="cm"> *   and someone does a writepage() on it.</span>
<span class="cm"> *</span>
<span class="cm"> *   We will move the buffer onto the async_data list, but *after* it has</span>
<span class="cm"> *   been dirtied. So there&#39;s a small window where we have dirty data on</span>
<span class="cm"> *   BJ_Metadata.</span>
<span class="cm"> *</span>
<span class="cm"> *   Note that this only applies to the last partial page in the file.  The</span>
<span class="cm"> *   bit which block_write_full_page() uses prepare/commit for.  (That&#39;s</span>
<span class="cm"> *   broken code anyway: it&#39;s wrong for msync()).</span>
<span class="cm"> *</span>
<span class="cm"> *   It&#39;s a rare case: affects the final partial page, for journalled data</span>
<span class="cm"> *   where the file is subject to bith write() and writepage() in the same</span>
<span class="cm"> *   transction.  To fix it we&#39;ll need a custom block_write_full_page().</span>
<span class="cm"> *   We&#39;ll probably need that anyway for journalling writepage() output.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t honour synchronous mounts for writepage().  That would be</span>
<span class="cm"> * disastrous.  Any write() or metadata operation will sync the fs for</span>
<span class="cm"> * us.</span>
<span class="cm"> *</span>
<span class="cm"> * AKPM2: if all the page&#39;s buffers are mapped to disk and !data=journal,</span>
<span class="cm"> * we don&#39;t need to open a transaction here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_ordered_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">page_bufs</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to warn for emergency remount. The condition is</span>
<span class="cm">	 * ordered to avoid dereferencing inode-&gt;i_sb in non-error case to</span>
<span class="cm">	 * avoid slow-downs.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">IS_RDONLY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_mount_state</span> <span class="o">&amp;</span> <span class="n">EXT3_ERROR_FS</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * We give up here if we&#39;re reentered, because it might be for a</span>
<span class="cm">	 * different filesystem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_journal_current_handle</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">trace_ext3_ordered_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">,</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Dirty</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Uptodate</span><span class="p">));</span>
		<span class="n">page_bufs</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">page_bufs</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">walk_page_buffers</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span>
				       <span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer_unmapped</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Provide NULL get_block() to catch bugs if buffers</span>
<span class="cm">			 * weren&#39;t really mapped */</span>
			<span class="k">return</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext3_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bget_one</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ext3_get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page can become unlocked at any point now, and</span>
<span class="cm">	 * truncate can then come in and change things.  So we</span>
<span class="cm">	 * can&#39;t touch *page from now on.  But *page_bufs is</span>
<span class="cm">	 * safe due to elevated refcount.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * And attach them to the current transaction.  But only if</span>
<span class="cm">	 * block_write_full_page() succeeded.  Otherwise they are unmapped,</span>
<span class="cm">	 * and generally junk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="n">journal_dirty_data_fn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_bufs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bput_one</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out_fail:</span>
	<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_writeback_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to warn for emergency remount. The condition is</span>
<span class="cm">	 * ordered to avoid dereferencing inode-&gt;i_sb in non-error case to</span>
<span class="cm">	 * avoid slow-downs.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">IS_RDONLY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_mount_state</span> <span class="o">&amp;</span> <span class="n">EXT3_ERROR_FS</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_journal_current_handle</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">trace_ext3_writeback_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">walk_page_buffers</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer_unmapped</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Provide NULL get_block() to catch bugs if buffers</span>
<span class="cm">			 * weren&#39;t really mapped */</span>
			<span class="k">return</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext3_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ext3_get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out_fail:</span>
	<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_journalled_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to warn for emergency remount. The condition is</span>
<span class="cm">	 * ordered to avoid dereferencing inode-&gt;i_sb in non-error case to</span>
<span class="cm">	 * avoid slow-downs.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">IS_RDONLY</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_mount_state</span> <span class="o">&amp;</span> <span class="n">EXT3_ERROR_FS</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_journal_current_handle</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">no_write</span><span class="p">;</span>

	<span class="n">trace_ext3_journalled_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext3_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_write</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s mmapped pagecache.  Add buffers and journal it.  There</span>
<span class="cm">		 * doesn&#39;t seem much point in redirtying the page here.</span>
<span class="cm">		 */</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span>
					  <span class="n">ext3_get_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">do_journal_get_write_access</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">walk_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">write_end_fn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">ext3_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_JDATA</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span><span class="p">,</span>
			   <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It may be a page full of checkpoint-mode buffers.  We don&#39;t</span>
<span class="cm">		 * really know unless we go poke around in the buffer_heads.</span>
<span class="cm">		 * But block_write_full_page will do the right thing.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ext3_get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">no_write:</span>
	<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_ext3_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mpage_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ext3_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext3_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">ext3_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext3_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">EXT3_JOURNAL</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">trace_ext3_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s a full truncate we just forget about the pending dirtying</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">journal_invalidatepage</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_releasepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">EXT3_JOURNAL</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">trace_ext3_releasepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">journal_try_to_free_buffers</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the O_DIRECT write will extend the file then add this inode to the</span>
<span class="cm"> * orphan list.  So recovery will truncate it back to the original size</span>
<span class="cm"> * if the machine crashes during the write.</span>
<span class="cm"> *</span>
<span class="cm"> * If the O_DIRECT write is intantiating holes inside i_size and the machine</span>
<span class="cm"> * crashes then stale disk data _may_ be exposed inside the file. But current</span>
<span class="cm"> * VFS code falls back into buffered path in that case so we are safe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ext3_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orphan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_ext3_direct_IO_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">),</span> <span class="n">rw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">final_size</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">final_size</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Credits for sb + inode write */</span>
			<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">orphan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
			<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
				 <span class="n">ext3_get_block</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * In case of error extending write may have instantiated a few</span>
<span class="cm">	 * blocks outside i_size. Trim these off again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
			<span class="n">ext3_truncate_failed_direct_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">orphan</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="cm">/* Credits for sb + inode write */</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This is really bad luck. We&#39;ve written the data</span>
<span class="cm">			 * but cannot extend i_size. Truncate allocated blocks</span>
<span class="cm">			 * and pretend the write failed... */</span>
			<span class="n">ext3_truncate_failed_direct_write</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
			<span class="n">ext3_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
				<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * We&#39;re going to return a positive `ret&#39;</span>
<span class="cm">				 * here due to non-zero-length I/O, so there&#39;s</span>
<span class="cm">				 * no way of reporting error returns from</span>
<span class="cm">				 * ext3_mark_inode_dirty() to userspace.  So</span>
<span class="cm">				 * ignore it.</span>
<span class="cm">				 */</span>
				<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">trace_ext3_direct_IO_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">),</span> <span class="n">rw</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pages can be marked dirty completely asynchronously from ext3&#39;s journalling</span>
<span class="cm"> * activity.  By filemap_sync_pte(), try_to_unmap_one(), etc.  We cannot do</span>
<span class="cm"> * much here because -&gt;set_page_dirty is called under VFS locks.  The page is</span>
<span class="cm"> * not necessarily locked.</span>
<span class="cm"> *</span>
<span class="cm"> * We cannot just dirty the page and leave attached buffers clean, because the</span>
<span class="cm"> * buffers&#39; dirty state is &quot;definitive&quot;.  We cannot just set the buffers dirty</span>
<span class="cm"> * or jbddirty because all the journalling code will explode.</span>
<span class="cm"> *</span>
<span class="cm"> * So what we do is to mark the page &quot;pending dirty&quot; and next time writepage</span>
<span class="cm"> * is called, propagate that into the buffers appropriately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_journalled_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext3_ordered_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext3_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext3_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext3_ordered_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext3_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">ext3_ordered_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext3_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">ext3_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>		<span class="o">=</span> <span class="n">ext3_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">ext3_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">migratepage</span>		<span class="o">=</span> <span class="n">buffer_migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext3_writeback_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext3_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext3_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext3_writeback_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext3_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">ext3_writeback_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext3_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">ext3_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>		<span class="o">=</span> <span class="n">ext3_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">ext3_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">migratepage</span>		<span class="o">=</span> <span class="n">buffer_migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext3_journalled_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext3_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext3_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext3_journalled_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext3_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">ext3_journalled_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span>		<span class="o">=</span> <span class="n">ext3_journalled_set_page_dirty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext3_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">ext3_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>		<span class="o">=</span> <span class="n">ext3_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">ext3_set_aops</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_should_order_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_ordered_aops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ext3_should_writeback_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_writeback_aops</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_journalled_aops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext3_block_truncate_page() zeroes out a mapping from file offset `from&#39;</span>
<span class="cm"> * up to the end of the block which corresponds to `from&#39;.</span>
<span class="cm"> * This required during truncate. We need to physically zero the tail end</span>
<span class="cm"> * of that block so it doesn&#39;t yield old data if the file is later grown.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_block_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Truncated on block boundary - nothing to do */</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">from</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">iblock</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Find the buffer that contains &quot;offset&quot; */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">iblock</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;freed: skip&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;unmapped&quot;</span><span class="p">);</span>
		<span class="n">ext3_get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* unmapped? It&#39;s a hole - nothing to do */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;still unmapped&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Ok, it&#39;s mapped. Make sure it&#39;s up-to-date */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh_uptodate_or_lock</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">bh_submit_read</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="cm">/* Uhhuh. Read error. Complain and punt. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* data=writeback mode doesn&#39;t need transaction to zero-out data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_should_writeback_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We journal at most one block */</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_highpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get write access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">stop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;zeroed end of block&quot;</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext3_should_order_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_data</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">stop:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">)</span>
		<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probably it should be a library function... search for first non-zero word</span>
<span class="cm"> * or memcmp with zero_page, whatever is better for particular architecture.</span>
<span class="cm"> * Linus?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">all_zeroes</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_find_shared - find the indirect blocks for partial truncation.</span>
<span class="cm"> *	@inode:	  inode in question</span>
<span class="cm"> *	@depth:	  depth of the affected branch</span>
<span class="cm"> *	@offsets: offsets of pointers in that branch (see ext3_block_to_path)</span>
<span class="cm"> *	@chain:	  place to store the pointers to partial indirect blocks</span>
<span class="cm"> *	@top:	  place to the (detached) top of branch</span>
<span class="cm"> *</span>
<span class="cm"> *	This is a helper function used by ext3_truncate().</span>
<span class="cm"> *</span>
<span class="cm"> *	When we do truncate() we may have to clean the ends of several</span>
<span class="cm"> *	indirect blocks but leave the blocks themselves alive. Block is</span>
<span class="cm"> *	partially truncated if some data below the new i_size is referred</span>
<span class="cm"> *	from it (and it is on the path to the first completely truncated</span>
<span class="cm"> *	data block, indeed).  We have to free the top of that path along</span>
<span class="cm"> *	with everything to the right of the path. Since no allocation</span>
<span class="cm"> *	past the truncation point is possible until ext3_truncate()</span>
<span class="cm"> *	finishes, we may safely do the latter, but top of branch may</span>
<span class="cm"> *	require special attention - pageout below the truncation point</span>
<span class="cm"> *	might try to populate it.</span>
<span class="cm"> *</span>
<span class="cm"> *	We atomically detach the top of branch from the tree, store the</span>
<span class="cm"> *	block number of its root in *@top, pointers to buffer_heads of</span>
<span class="cm"> *	partially truncated blocks - in @chain[].bh and pointers to</span>
<span class="cm"> *	their last elements that should not be removed - in</span>
<span class="cm"> *	@chain[].p. Return value is the pointer to last filled element</span>
<span class="cm"> *	of @chain.</span>
<span class="cm"> *</span>
<span class="cm"> *	The work left to caller to do the actual freeing of subtrees:</span>
<span class="cm"> *		a) free the subtree starting from *@top</span>
<span class="cm"> *		b) free the subtrees whose roots are stored in</span>
<span class="cm"> *			(@chain[i].p+1 .. end of @chain[i].bh-&gt;b_data)</span>
<span class="cm"> *		c) free the subtrees growing from the inode past the @chain[0].</span>
<span class="cm"> *			(no partially truncated stuff there).  */</span>

<span class="k">static</span> <span class="n">Indirect</span> <span class="o">*</span><span class="nf">ext3_find_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">top</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Make k index the deepest non-null offset + 1 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext3_get_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="cm">/* Writer: pointers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span>
		<span class="n">partial</span> <span class="o">=</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the branch acquired continuation since we&#39;ve looked at it -</span>
<span class="cm">	 * fine, it should all survive and (new) top doesn&#39;t belong to us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span>
		<span class="cm">/* Writer: end */</span>
		<span class="k">goto</span> <span class="n">no_top</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">partial</span><span class="p">;</span> <span class="n">p</span><span class="o">&gt;</span><span class="n">chain</span> <span class="o">&amp;&amp;</span> <span class="n">all_zeroes</span><span class="p">((</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * OK, we&#39;ve found the last block that must survive. The rest of our</span>
<span class="cm">	 * branch should be detached before unlocking. However, if that rest</span>
<span class="cm">	 * of branch is all ours and does not grow immediately from the inode</span>
<span class="cm">	 * it&#39;s easier to cheat and just decrement partial-&gt;p.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
		<span class="cm">/* Nope, don&#39;t do this in ext3.  Must leave the tree intact */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		*p-&gt;p = 0;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="cm">/* Writer: end */</span>

	<span class="k">while</span><span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">no_top:</span>
	<span class="k">return</span> <span class="n">partial</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Zero a number of block pointers in either an inode or an indirect block.</span>
<span class="cm"> * If we restart the transaction we must again get write access to the</span>
<span class="cm"> * indirect block for further modification.</span>
<span class="cm"> *</span>
<span class="cm"> * We release `count&#39; blocks on disk, but (last - first) may be greater</span>
<span class="cm"> * than `count&#39; because there can be holes in there.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext3_clear_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">ext3_fsblk_t</span> <span class="n">block_to_free</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">try_to_extend_transaction</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">truncate_restart_transaction</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;retaking write access&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Any buffers which are on the journal will be in memory. We find</span>
<span class="cm">	 * them on the hash table so journal_revoke() will run journal_forget()</span>
<span class="cm">	 * on them.  We&#39;ve already detached each block from the file, so</span>
<span class="cm">	 * bforget() in journal_forget() should be safe.</span>
<span class="cm">	 *</span>
<span class="cm">	 * AKPM: turn on bforget in journal_forget()!!!</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_find_get_block</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
			<span class="n">ext3_forget</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ext3_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">block_to_free</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext3_free_data - free a list of data blocks</span>
<span class="cm"> * @handle:	handle for this transaction</span>
<span class="cm"> * @inode:	inode we are dealing with</span>
<span class="cm"> * @this_bh:	indirect buffer_head which contains *@first and *@last</span>
<span class="cm"> * @first:	array of block numbers</span>
<span class="cm"> * @last:	points immediately past the end of array</span>
<span class="cm"> *</span>
<span class="cm"> * We are freeing all blocks referred from that array (numbers are stored as</span>
<span class="cm"> * little-endian 32-bit) and updating @inode-&gt;i_blocks appropriately.</span>
<span class="cm"> *</span>
<span class="cm"> * We accumulate contiguous runs of blocks to free.  Conveniently, if these</span>
<span class="cm"> * blocks are contiguous then releasing them at one time will only affect one</span>
<span class="cm"> * or two bitmap blocks (+ group descriptor(s) and superblock) and we won&#39;t</span>
<span class="cm"> * actually use a lot of journal space.</span>
<span class="cm"> *</span>
<span class="cm"> * @this_bh will be %NULL if @first and @last point into the inode&#39;s direct</span>
<span class="cm"> * block pointers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext3_free_data</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">this_bh</span><span class="p">,</span>
			   <span class="n">__le32</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">block_to_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="cm">/* Starting block # of a run */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	    <span class="cm">/* Number of blocks in the run */</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">block_to_free_p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	    <span class="cm">/* Pointer into inode/ind</span>
<span class="cm">					       corresponding to</span>
<span class="cm">					       block_to_free */</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">nr</span><span class="p">;</span>		    <span class="cm">/* Current block # */</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>			    <span class="cm">/* Pointer into inode/ind</span>
<span class="cm">					       for current block */</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_bh</span><span class="p">)</span> <span class="p">{</span>				<span class="cm">/* For indirect block */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">this_bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">this_bh</span><span class="p">);</span>
		<span class="cm">/* Important: if we can&#39;t update the indirect pointers</span>
<span class="cm">		 * to the blocks, we can&#39;t free them. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* accumulate blocks to free if they&#39;re contiguous */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">block_to_free</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
				<span class="n">block_to_free_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="n">block_to_free</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ext3_clear_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">this_bh</span><span class="p">,</span>
						  <span class="n">block_to_free</span><span class="p">,</span>
						  <span class="n">count</span><span class="p">,</span> <span class="n">block_to_free_p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
				<span class="n">block_to_free</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
				<span class="n">block_to_free_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ext3_clear_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">this_bh</span><span class="p">,</span> <span class="n">block_to_free</span><span class="p">,</span>
				  <span class="n">count</span><span class="p">,</span> <span class="n">block_to_free_p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">this_bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The buffer head should have an attached journal head at this</span>
<span class="cm">		 * point. However, if the data is corrupted and an indirect</span>
<span class="cm">		 * block pointed to itself, it would have been detached when</span>
<span class="cm">		 * the block was cleared. Check for this instead of OOPSing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh2jh</span><span class="p">(</span><span class="n">this_bh</span><span class="p">))</span>
			<span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">this_bh</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ext3_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_free_data&quot;</span><span class="p">,</span>
				   <span class="s">&quot;circular indirect block detected, &quot;</span>
				   <span class="s">&quot;inode=%lu, block=%llu&quot;</span><span class="p">,</span>
				   <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">this_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext3_free_branches - free an array of branches</span>
<span class="cm"> *	@handle: JBD handle for this transaction</span>
<span class="cm"> *	@inode:	inode we are dealing with</span>
<span class="cm"> *	@parent_bh: the buffer_head which contains *@first and *@last</span>
<span class="cm"> *	@first:	array of block numbers</span>
<span class="cm"> *	@last:	pointer immediately past the end of array</span>
<span class="cm"> *	@depth:	depth of the branches to free</span>
<span class="cm"> *</span>
<span class="cm"> *	We are freeing all blocks referred from these branches (numbers are</span>
<span class="cm"> *	stored as little-endian 32-bit) and updating @inode-&gt;i_blocks</span>
<span class="cm"> *	appropriately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext3_free_branches</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">parent_bh</span><span class="p">,</span>
			       <span class="n">__le32</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">addr_per_block</span> <span class="o">=</span> <span class="n">EXT3_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">first</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>		<span class="cm">/* A hole */</span>

			<span class="cm">/* Go read the buffer for the next level down */</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * A read failure? Report error and clear slot</span>
<span class="cm">			 * (should be rare).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ext3_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_free_branches&quot;</span><span class="p">,</span>
					   <span class="s">&quot;Read failure, inode=%lu, block=&quot;</span><span class="n">E3FSBLK</span><span class="p">,</span>
					   <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* This zaps the entire block.  Bottom up. */</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;free child branches&quot;</span><span class="p">);</span>
			<span class="n">ext3_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">addr_per_block</span><span class="p">,</span>
					   <span class="n">depth</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Everything below this this pointer has been</span>
<span class="cm">			 * released.  Now let this top-of-subtree go.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We want the freeing of this indirect block to be</span>
<span class="cm">			 * atomic in the journal with the updating of the</span>
<span class="cm">			 * bitmap block which owns it.  So make some room in</span>
<span class="cm">			 * the journal.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We zero the parent pointer *after* freeing its</span>
<span class="cm">			 * pointee in the bitmaps, so if extend_transaction()</span>
<span class="cm">			 * for some reason fails to put the bitmap changes and</span>
<span class="cm">			 * the release into the same transaction, recovery</span>
<span class="cm">			 * will merely complain about releasing a free block,</span>
<span class="cm">			 * rather than leaking blocks.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">try_to_extend_transaction</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">truncate_restart_transaction</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * We&#39;ve probably journalled the indirect block several</span>
<span class="cm">			 * times during the truncate.  But it&#39;s no longer</span>
<span class="cm">			 * needed and we now drop it from the transaction via</span>
<span class="cm">			 * journal_revoke().</span>
<span class="cm">			 *</span>
<span class="cm">			 * That&#39;s easy if it&#39;s exclusively part of this</span>
<span class="cm">			 * transaction.  But if it&#39;s part of the committing</span>
<span class="cm">			 * transaction then journal_forget() will simply</span>
<span class="cm">			 * brelse() it.  That means that if the underlying</span>
<span class="cm">			 * block is reallocated in ext3_get_block(),</span>
<span class="cm">			 * unmap_underlying_metadata() will find this block</span>
<span class="cm">			 * and will try to get rid of it.  damn, damn. Thus</span>
<span class="cm">			 * we don&#39;t allow a block to be reallocated until</span>
<span class="cm">			 * a transaction freeing it has fully committed.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We also have to make sure journal replay after a</span>
<span class="cm">			 * crash does not overwrite non-journaled data blocks</span>
<span class="cm">			 * with old metadata when the block got reallocated for</span>
<span class="cm">			 * data.  Thus we have to store a revoke record for a</span>
<span class="cm">			 * block in the same transaction in which we free the</span>
<span class="cm">			 * block.</span>
<span class="cm">			 */</span>
			<span class="n">ext3_forget</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>

			<span class="n">ext3_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">parent_bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The block which we have just freed is</span>
<span class="cm">				 * pointed to by an indirect block: journal it</span>
<span class="cm">				 */</span>
				<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">parent_bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
								   <span class="n">parent_bh</span><span class="p">)){</span>
					<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">parent_bh</span><span class="p">,</span>
					<span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
					<span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
								    <span class="n">parent_bh</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We have reached the bottom of the tree. */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">parent_bh</span><span class="p">,</span> <span class="s">&quot;free data blocks&quot;</span><span class="p">);</span>
		<span class="n">ext3_free_data</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">parent_bh</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext3_can_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">ext3_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext3_truncate()</span>
<span class="cm"> *</span>
<span class="cm"> * We block out ext3_get_block() block instantiations across the entire</span>
<span class="cm"> * transaction, and VFS/VM ensures that ext3_truncate() cannot run</span>
<span class="cm"> * simultaneously on behalf of the same inode.</span>
<span class="cm"> *</span>
<span class="cm"> * As we work through the truncate and commit bits of it to the journal there</span>
<span class="cm"> * is one core, guiding principle: the file&#39;s tree must always be consistent on</span>
<span class="cm"> * disk.  We must be able to restart the truncate after a crash.</span>
<span class="cm"> *</span>
<span class="cm"> * The file&#39;s tree may be transiently inconsistent in memory (although it</span>
<span class="cm"> * probably isn&#39;t), but whenever we close off and commit a journal transaction,</span>
<span class="cm"> * the contents of (the filesystem + the journal) must be consistent and</span>
<span class="cm"> * restartable.  It&#39;s pretty simple, really: bottom up, right to left (although</span>
<span class="cm"> * left-to-right works OK too).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that at recovery time, journal replay occurs *before* the restart of</span>
<span class="cm"> * truncate against the orphan inode list.</span>
<span class="cm"> *</span>
<span class="cm"> * The committed inode has the new, desired i_size (which is the same as</span>
<span class="cm"> * i_disksize in this case).  After a crash, ext3_orphan_cleanup() will see</span>
<span class="cm"> * that this inode&#39;s truncate did not complete and it will again call</span>
<span class="cm"> * ext3_truncate() to have another go.  So there will be instantiated blocks</span>
<span class="cm"> * to the right of the truncation point in a crashed ext3 filesystem.  But</span>
<span class="cm"> * that&#39;s fine - as long as they are linked from the inode, the post-crash</span>
<span class="cm"> * ext3_truncate() run will find them and release them.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext3_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">i_data</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr_per_block</span> <span class="o">=</span> <span class="n">EXT3_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">last_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>

	<span class="n">trace_ext3_truncate_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_can_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_notrans</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ext3_should_writeback_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext3_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_FLUSH_ON_CLOSE</span><span class="p">);</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">start_transaction</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_notrans</span><span class="p">;</span>

	<span class="n">last_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
					<span class="o">&gt;&gt;</span> <span class="n">EXT3_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">ext3_block_to_path</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">last_block</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>	<span class="cm">/* error */</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK.  This truncate is going to happen.  We add the inode to the</span>
<span class="cm">	 * orphan list, so that if this truncate spans multiple transactions,</span>
<span class="cm">	 * and we crash, we will resume the truncate when the filesystem</span>
<span class="cm">	 * recovers.  It also marks the inode dirty, to catch the new size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Implication: the file must always be in a sane, consistent</span>
<span class="cm">	 * truncatable state while each transaction commits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The orphan list entry will now protect us from any crash which</span>
<span class="cm">	 * occurs before the truncate completes, so it is now safe to propagate</span>
<span class="cm">	 * the new, shorter inode size (held for now in i_size) into the</span>
<span class="cm">	 * on-disk inode. We do this via i_disksize, which is the value which</span>
<span class="cm">	 * ext3 *really* writes onto the disk inode.</span>
<span class="cm">	 */</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * From here we block out all ext3_get_block() callers who want to</span>
<span class="cm">	 * modify the block allocation tree.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* direct blocks */</span>
		<span class="n">ext3_free_data</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i_data</span><span class="o">+</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">i_data</span> <span class="o">+</span> <span class="n">EXT3_NDIR_BLOCKS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">do_indirects</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext3_find_shared</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">);</span>
	<span class="cm">/* Kill the top of shared branch (not detached) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">partial</span> <span class="o">==</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Shared branch grows from the inode */</span>
			<span class="n">ext3_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">chain</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
			<span class="o">*</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * We mark the inode dirty prior to restart,</span>
<span class="cm">			 * and prior to stop.  No need for it here.</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Shared branch grows from an indirect block */</span>
			<span class="n">ext3_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span>
					<span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span>
					<span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">chain</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Clear the ends of indirect blocks on the shared branch */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="o">+</span><span class="n">addr_per_block</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">chain</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call brelse&quot;</span><span class="p">);</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">do_indirects:</span>
	<span class="cm">/* Kill the remaining (whole) subtrees */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT3_IND_BLOCK</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">i_data</span><span class="p">[</span><span class="n">EXT3_IND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">EXT3_IND_BLOCK</span>:
		<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT3_DIND_BLOCK</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">i_data</span><span class="p">[</span><span class="n">EXT3_DIND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">EXT3_DIND_BLOCK</span>:
		<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT3_TIND_BLOCK</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_free_branches</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">i_data</span><span class="p">[</span><span class="n">EXT3_TIND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">EXT3_TIND_BLOCK</span>:
		<span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ext3_discard_reservation</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In a multi-transaction truncate, we only make the final transaction</span>
<span class="cm">	 * synchronous</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out_stop:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this was a simple ftruncate(), and the file will remain alive</span>
<span class="cm">	 * then we need to clear up the orphan record which we created above.</span>
<span class="cm">	 * However, if this was a real unlink then we were called by</span>
<span class="cm">	 * ext3_evict_inode(), and we allow that function to clean up the</span>
<span class="cm">	 * orphan info for us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">ext3_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">trace_ext3_truncate_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out_notrans:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Delete the inode from orphan list so that it doesn&#39;t stay there</span>
<span class="cm">	 * forever and trigger assertion on umount.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">ext3_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">trace_ext3_truncate_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ext3_fsblk_t</span> <span class="nf">ext3_get_inode_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_group</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext3_valid_inum</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This error is already checked for in namei.c unless we are</span>
<span class="cm">		 * looking at an NFS filehandle, in which case no error</span>
<span class="cm">		 * report is needed</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block_group</span> <span class="o">=</span> <span class="p">(</span><span class="n">ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">EXT3_INODES_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Figure out the offset within the block group inode table</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">EXT3_INODES_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="o">*</span>
		<span class="n">EXT3_INODE_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">EXT3_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>

	<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">block_group</span> <span class="o">=</span> <span class="n">block_group</span><span class="p">;</span>
	<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EXT3_BLOCK_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext3_get_inode_loc returns with an extra refcount against the inode&#39;s</span>
<span class="cm"> * underlying buffer_head on success. If &#39;in_mem&#39; is true, we have all</span>
<span class="cm"> * data in memory that is needed to recreate the on-disk version of this</span>
<span class="cm"> * inode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ext3_get_inode_loc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext3_fsblk_t</span> <span class="n">block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">ext3_get_inode_block</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">iloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext3_error</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_get_inode_loc&quot;</span><span class="p">,</span>
				<span class="s">&quot;unable to read inode block - &quot;</span>
				<span class="s">&quot;inode=%lu, block=&quot;</span><span class="n">E3FSBLK</span><span class="p">,</span>
				 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the buffer has the write error flag, we have failed</span>
<span class="cm">		 * to write out another inode in the same block.  In this</span>
<span class="cm">		 * case, we don&#39;t have to read the block because we may</span>
<span class="cm">		 * read the old inode data successfully.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* someone brought it uptodate while we waited */</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">has_buffer</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we have all information of the inode in memory and this</span>
<span class="cm">		 * is the only valid inode in the block, we need not read the</span>
<span class="cm">		 * block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_mem</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ext3_group_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">inodes_per_buffer</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">inode_offset</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">block_group</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">start</span><span class="p">;</span>

			<span class="n">block_group</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
					<span class="n">EXT3_INODES_PER_GROUP</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
			<span class="n">inodes_per_buffer</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">/</span>
				<span class="n">EXT3_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
			<span class="n">inode_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
					<span class="n">EXT3_INODES_PER_GROUP</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">inode_offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">inodes_per_buffer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* Is the inode bitmap in cache? */</span>
			<span class="n">desc</span> <span class="o">=</span> <span class="n">ext3_get_group_desc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
						<span class="n">block_group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">make_io</span><span class="p">;</span>

			<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_bitmap</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">make_io</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the inode bitmap isn&#39;t in cache then the</span>
<span class="cm">			 * optimisation may end up performing two reads instead</span>
<span class="cm">			 * of one, so skip it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">make_io</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">inodes_per_buffer</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">inode_offset</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ext3_test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">start</span> <span class="o">+</span> <span class="n">inodes_per_buffer</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* all other inodes are free, so skip I/O */</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">has_buffer</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="nl">make_io:</span>
		<span class="cm">/*</span>
<span class="cm">		 * There are other valid inodes in the buffer, this inode</span>
<span class="cm">		 * has in-inode xattrs, or we don&#39;t have this inode in memory.</span>
<span class="cm">		 * Read the block from disk.</span>
<span class="cm">		 */</span>
		<span class="n">trace_ext3_load_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
		<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span> <span class="o">|</span> <span class="n">REQ_META</span> <span class="o">|</span> <span class="n">REQ_PRIO</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext3_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext3_get_inode_loc&quot;</span><span class="p">,</span>
					<span class="s">&quot;unable to read inode block - &quot;</span>
					<span class="s">&quot;inode=%lu, block=&quot;</span><span class="n">E3FSBLK</span><span class="p">,</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">has_buffer:</span>
	<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext3_get_inode_loc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We have all inode data except xattrs in memory here. */</span>
	<span class="k">return</span> <span class="n">__ext3_get_inode_loc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iloc</span><span class="p">,</span>
		<span class="o">!</span><span class="n">ext3_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_XATTR</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ext3_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">S_SYNC</span><span class="o">|</span><span class="n">S_APPEND</span><span class="o">|</span><span class="n">S_IMMUTABLE</span><span class="o">|</span><span class="n">S_NOATIME</span><span class="o">|</span><span class="n">S_DIRSYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT3_SYNC_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_SYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT3_APPEND_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_APPEND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT3_IMMUTABLE_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_IMMUTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT3_NOATIME_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOATIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT3_DIRSYNC_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DIRSYNC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Propagate flags from i_flags to EXT3_I(inode)-&gt;i_flags */</span>
<span class="kt">void</span> <span class="nf">ext3_get_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_flags</span><span class="p">;</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EXT3_SYNC_FL</span><span class="o">|</span><span class="n">EXT3_APPEND_FL</span><span class="o">|</span>
			<span class="n">EXT3_IMMUTABLE_FL</span><span class="o">|</span><span class="n">EXT3_NOATIME_FL</span><span class="o">|</span><span class="n">EXT3_DIRSYNC_FL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_SYNC</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT3_SYNC_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_APPEND</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT3_APPEND_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_IMMUTABLE</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT3_IMMUTABLE_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_NOATIME</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT3_NOATIME_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_DIRSYNC</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT3_DIRSYNC_FL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ext3_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="n">iloc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_journal</span><span class="p">;</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">i_uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">i_gid</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__ext3_get_inode_loc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">raw_inode</span> <span class="o">=</span> <span class="n">ext3_raw_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">i_uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span><span class="p">);</span>
	<span class="n">i_gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_opt</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NO_UID32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">i_uid</span> <span class="o">|=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">i_gid</span> <span class="o">|=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i_uid_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_uid</span><span class="p">);</span>
	<span class="n">i_gid_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_gid</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_links_count</span><span class="p">));</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_state_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dir_start_lookup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">);</span>
	<span class="cm">/* We now have enough fields to check if the inode was active or not.</span>
<span class="cm">	 * This is needed because nfsd might try to access dead inodes</span>
<span class="cm">	 * the test is that same one that e2fsck uses</span>
<span class="cm">	 * NeilBrown 1999oct15</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_mount_state</span> <span class="o">&amp;</span> <span class="n">EXT3_ORPHAN_FS</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* this inode is deleted */</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* The only unlinked inodes we let through here have</span>
<span class="cm">		 * valid i_mode and are being read by the orphan</span>
<span class="cm">		 * recovery code: that&#39;s fine, we&#39;re about to complete</span>
<span class="cm">		 * the process of deleting those. */</span>
	<span class="p">}</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
<span class="cp">#ifdef EXT3_FRAGMENTS</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_faddr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_faddr</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_frag_no</span> <span class="o">=</span> <span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_frag</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_frag_size</span> <span class="o">=</span> <span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_fsize</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_file_acl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">|=</span>
			<span class="p">((</span><span class="n">__u64</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_high</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_group</span> <span class="o">=</span> <span class="n">iloc</span><span class="p">.</span><span class="n">block_group</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * NOTE! The in-memory inode i_data array is in little-endian order</span>
<span class="cm">	 * even on big-endian machines: we do NOT byteswap the block numbers!</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">EXT3_N_BLOCKS</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_orphan</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set transaction id&#39;s of transactions that have to be committed</span>
<span class="cm">	 * to finish f[data]sync. We set them to currently running transaction</span>
<span class="cm">	 * as we cannot be sure that the inode or some of its metadata isn&#39;t</span>
<span class="cm">	 * part of the transaction - the inode could have been reclaimed and</span>
<span class="cm">	 * now it is reread from disk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span>
			<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="p">)</span>
			<span class="n">tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tid</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_sync_tid</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_datasync_tid</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&gt;=</span> <span class="n">EXT3_FIRST_INO</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">EXT3_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT3_GOOD_OLD_INODE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * When mke2fs creates big inodes it does not zero out</span>
<span class="cm">		 * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,</span>
<span class="cm">		 * so ignore those first few inodes.</span>
<span class="cm">		 */</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">EXT3_GOOD_OLD_INODE_SIZE</span> <span class="o">+</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">&gt;</span>
		    <span class="n">EXT3_INODE_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The extra space is currently unused. Use it. */</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext3_inode</span><span class="p">)</span> <span class="o">-</span>
					    <span class="n">EXT3_GOOD_OLD_INODE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="o">*</span><span class="n">magic</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_inode</span> <span class="o">+</span>
					<span class="n">EXT3_GOOD_OLD_INODE_SIZE</span> <span class="o">+</span>
					<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT3_XATTR_MAGIC</span><span class="p">))</span>
				 <span class="n">ext3_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_XATTR</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_file_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_file_operations</span><span class="p">;</span>
		<span class="n">ext3_set_aops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_dir_operations</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext3_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_fast_symlink_inode_operations</span><span class="p">;</span>
			<span class="n">nd_terminate_link</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_symlink_inode_operations</span><span class="p">;</span>
			<span class="n">ext3_set_aops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext3_special_inode_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
			   <span class="n">old_decode_dev</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">])));</span>
		<span class="k">else</span>
			<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
			   <span class="n">new_decode_dev</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">])));</span>
	<span class="p">}</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ext3_set_inode_flags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

<span class="nl">bad_inode:</span>
	<span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Post the struct inode info into an on-disk inode location in the</span>
<span class="cm"> * buffer-cache.  This gobbles the caller&#39;s reference to the</span>
<span class="cm"> * buffer_head in the inode location struct.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have write access to iloc-&gt;bh.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_do_update_inode</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_inode</span> <span class="o">*</span><span class="n">raw_inode</span> <span class="o">=</span> <span class="n">ext3_raw_inode</span><span class="p">(</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext3_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">i_uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">i_gid</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="cm">/* we can&#39;t allow multiple procs in here at once, its a bit racey */</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/* For fields not not tracking in the in-memory inode,</span>
<span class="cm">	 * initialise them to zero for new inodes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_NEW</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_inode_size</span><span class="p">);</span>

	<span class="n">ext3_get_inode_flags</span><span class="p">(</span><span class="n">ei</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">i_uid</span> <span class="o">=</span> <span class="n">i_uid_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">i_gid</span> <span class="o">=</span> <span class="n">i_gid_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NO_UID32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">low_16_bits</span><span class="p">(</span><span class="n">i_uid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">low_16_bits</span><span class="p">(</span><span class="n">i_gid</span><span class="p">));</span>
<span class="cm">/*</span>
<span class="cm"> * Fix up interoperability with old kernels. Otherwise, old inodes get</span>
<span class="cm"> * re-used with the upper 16 bits of the uid/gid intact</span>
<span class="cm"> */</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span>
				<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">high_16_bits</span><span class="p">(</span><span class="n">i_uid</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span>
				<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">high_16_bits</span><span class="p">(</span><span class="n">i_gid</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span> <span class="o">=</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fs_high2lowuid</span><span class="p">(</span><span class="n">i_uid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span> <span class="o">=</span>
			<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fs_high2lowgid</span><span class="p">(</span><span class="n">i_gid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_links_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dtime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
<span class="cp">#ifdef EXT3_FRAGMENTS</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_faddr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_faddr</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_frag</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_frag_no</span><span class="p">;</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_fsize</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_frag_size</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_high</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">&gt;</span> <span class="mh">0x7fffffffULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT3_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">EXT3_FEATURE_RO_COMPAT_LARGE_FILE</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_rev_level</span> <span class="o">==</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT3_GOOD_OLD_REV</span><span class="p">))</span> <span class="p">{</span>
			       <span class="cm">/* If this is the first large file</span>
<span class="cm">				* created, add a flag to the superblock.</span>
<span class="cm">				*/</span>
				<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
						<span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_brelse</span><span class="p">;</span>

				<span class="n">ext3_update_dynamic_rev</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
				<span class="n">EXT3_SET_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">EXT3_FEATURE_RO_COMPAT_LARGE_FILE</span><span class="p">);</span>
				<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
						<span class="n">EXT3_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_sbh</span><span class="p">);</span>
				<span class="cm">/* get our lock and start over */</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_valid_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">old_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">EXT3_N_BLOCKS</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">)</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">);</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call ext3_journal_dirty_metadata&quot;</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ext3_journal_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">ext3_clear_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_STATE_NEW</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_sync_tid</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
<span class="nl">out_brelse:</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext3_write_inode()</span>
<span class="cm"> *</span>
<span class="cm"> * We are called from a few places:</span>
<span class="cm"> *</span>
<span class="cm"> * - Within generic_file_write() for O_SYNC files.</span>
<span class="cm"> *   Here, there will be no transaction running. We wait for any running</span>
<span class="cm"> *   trasnaction to commit.</span>
<span class="cm"> *</span>
<span class="cm"> * - Within sys_sync(), kupdate and such.</span>
<span class="cm"> *   We wait on commit, if tol to.</span>
<span class="cm"> *</span>
<span class="cm"> * - Within prune_icache() (PF_MEMALLOC == true)</span>
<span class="cm"> *   Here we simply return.  We can&#39;t afford to block kswapd on the</span>
<span class="cm"> *   journal commit.</span>
<span class="cm"> *</span>
<span class="cm"> * In all cases it is actually safe for us to return without doing anything,</span>
<span class="cm"> * because the inode has been copied into a raw inode buffer in</span>
<span class="cm"> * ext3_mark_inode_dirty().  This is a correctness thing for O_SYNC and for</span>
<span class="cm"> * knfsd.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we are absolutely dependent upon all inode dirtiers doing the</span>
<span class="cm"> * right thing: they *must* call mark_inode_dirty() after dirtying info in</span>
<span class="cm"> * which we are interested.</span>
<span class="cm"> *</span>
<span class="cm"> * It would be a bug for them to not do this.  The code:</span>
<span class="cm"> *</span>
<span class="cm"> *	mark_inode_dirty(inode)</span>
<span class="cm"> *	stuff();</span>
<span class="cm"> *	inode-&gt;i_size = expr;</span>
<span class="cm"> *</span>
<span class="cm"> * is in error because a kswapd-driven write_inode() could occur while</span>
<span class="cm"> * `stuff()&#39; is running, and the new i_size will be lost.  Plus the inode</span>
<span class="cm"> * will no longer be on the superblock&#39;s dirty inode list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_journal_current_handle</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;called recursively, non-PF_MEMALLOC!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ext3_force_commit</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext3_setattr()</span>
<span class="cm"> *</span>
<span class="cm"> * Called from notify_change.</span>
<span class="cm"> *</span>
<span class="cm"> * We want to trap VFS attempts to truncate the file as soon as</span>
<span class="cm"> * possible.  In particular, we want to make sure that when the VFS</span>
<span class="cm"> * shrinks i_size, we put the inode on the orphan list and modify</span>
<span class="cm"> * i_disksize immediately, so that during the subsequent flushing of</span>
<span class="cm"> * dirty pages and freeing of disk blocks, we can guarantee that any</span>
<span class="cm"> * commit will leave the blocks being flushed in an unused state on</span>
<span class="cm"> * disk.  (On recovery, the inode will get truncated and the blocks will</span>
<span class="cm"> * be freed, so we have a strong guarantee that no future commit will</span>
<span class="cm"> * leave these blocks visible to the user.)</span>
<span class="cm"> *</span>
<span class="cm"> * Called with inode-&gt;sem down.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ia_valid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_quota_modification</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

		<span class="cm">/* (user+group)*(old+new) structure, inode write (sb,</span>
<span class="cm">		 * inode block, ? - but truncate inode update has it) */</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT3_MAXQUOTAS_INIT_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">+</span>
					<span class="n">EXT3_MAXQUOTAS_DEL_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dquot_transfer</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Update corresponding info in inode so that everything is in</span>
<span class="cm">		 * one transaction */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span>
		<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">ext3_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Some hard fs error must have happened. Bail out. */</span>
			<span class="n">ext3_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ext3_block_truncate_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Cleanup orphan list and exit */</span>
			<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ext3_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ext3_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">!=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="n">ext3_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ext3_acl_chmod</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * How many blocks doth make a writepage()?</span>
<span class="cm"> *</span>
<span class="cm"> * With N blocks per page, it may be:</span>
<span class="cm"> * N data blocks</span>
<span class="cm"> * 2 indirect block</span>
<span class="cm"> * 2 dindirect</span>
<span class="cm"> * 1 tindirect</span>
<span class="cm"> * N+5 bitmap blocks (from the above)</span>
<span class="cm"> * N+5 group descriptor summary blocks</span>
<span class="cm"> * 1 inode block</span>
<span class="cm"> * 1 superblock.</span>
<span class="cm"> * 2 * EXT3_SINGLEDATA_TRANS_BLOCKS for the quote files</span>
<span class="cm"> *</span>
<span class="cm"> * 3 * (N + 5) + 2 + 2 * EXT3_SINGLEDATA_TRANS_BLOCKS</span>
<span class="cm"> *</span>
<span class="cm"> * With ordered or writeback data it&#39;s the same, less the N data blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * If the inode&#39;s direct blocks can hold an integral number of pages then a</span>
<span class="cm"> * page cannot straddle two indirect blocks, and we can only touch one indirect</span>
<span class="cm"> * and dindirect block, and the &quot;5&quot; above becomes &quot;3&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * This still overestimates under most circumstances.  If we were to pass the</span>
<span class="cm"> * start and end offsets in here as well we could do block_to_path() on each</span>
<span class="cm"> * block and work out the exact number of indirects which are touched.  Pah.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext3_writepage_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bpp</span> <span class="o">=</span> <span class="n">ext3_journal_blocks_per_page</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">indirects</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXT3_NDIR_BLOCKS</span> <span class="o">%</span> <span class="n">bpp</span><span class="p">)</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext3_should_journal_data</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">bpp</span> <span class="o">+</span> <span class="n">indirects</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">bpp</span> <span class="o">+</span> <span class="n">indirects</span><span class="p">)</span> <span class="o">+</span> <span class="n">indirects</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="cm">/* We know that structure was already allocated during dquot_initialize so</span>
<span class="cm">	 * we will be updating only the data blocks + inodes */</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">EXT3_MAXQUOTAS_TRANS_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The caller must have previously called ext3_reserve_inode_write().</span>
<span class="cm"> * Give this, we know that the caller already has write access to iloc-&gt;bh.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* the do_update_inode consumes one bh-&gt;b_count */</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/* ext3_do_update_inode() does journal_dirty_metadata */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_do_update_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iloc</span><span class="p">);</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On success, We end up with an outstanding reference count against</span>
<span class="cm"> * iloc-&gt;bh.  This _must_ be cleaned up later.</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">ext3_reserve_inode_write</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_get_inode_loc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iloc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;get_write_access&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * What we do here is to mark the in-core inode as clean with respect to inode</span>
<span class="cm"> * dirtiness (it may still be data-dirty).</span>
<span class="cm"> * This means that the in-core inode may be reaped by prune_icache</span>
<span class="cm"> * without having to perform any I/O.  This is a very good thing,</span>
<span class="cm"> * because *any* task may call prune_icache - even ones which</span>
<span class="cm"> * have a transaction open against a different journal.</span>
<span class="cm"> *</span>
<span class="cm"> * Is this cheating?  Not really.  Sure, we haven&#39;t written the</span>
<span class="cm"> * inode out, but prune_icache isn&#39;t a user-visible syncing function.</span>
<span class="cm"> * Whenever the user wants stuff synced (sys_sync, sys_msync, sys_fsync)</span>
<span class="cm"> * we start and wait on commits.</span>
<span class="cm"> *</span>
<span class="cm"> * Is this efficient/effective?  Well, we&#39;re being nice to the system</span>
<span class="cm"> * by cleaning up our inodes proactively so they can be reaped</span>
<span class="cm"> * without I/O.  But we are potentially leaving up to five seconds&#39;</span>
<span class="cm"> * worth of inodes floating about which prune_icache wants us to</span>
<span class="cm"> * write out.  One way to fix that would be to get prune_icache()</span>
<span class="cm"> * to do a write_super() to free up some memory.  It has the desired</span>
<span class="cm"> * effect.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext3_iloc</span> <span class="n">iloc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">trace_ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_reserve_inode_write</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_mark_iloc_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext3_dirty_inode() is called from __mark_inode_dirty()</span>
<span class="cm"> *</span>
<span class="cm"> * We&#39;re really interested in the case where a file is being extended.</span>
<span class="cm"> * i_size has been changed by generic_commit_write() and we thus need</span>
<span class="cm"> * to include the updated inode in the current transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, dquot_alloc_space() will always dirty the inode when blocks</span>
<span class="cm"> * are allocated to the file.</span>
<span class="cm"> *</span>
<span class="cm"> * If the inode is marked synchronous, we don&#39;t honour that here - doing</span>
<span class="cm"> * so would cause a commit on atime updates, which we don&#39;t bother doing.</span>
<span class="cm"> * We handle synchronous inodes at the highest possible level.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext3_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">current_handle</span> <span class="o">=</span> <span class="n">ext3_journal_current_handle</span><span class="p">();</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_handle</span> <span class="o">&amp;&amp;</span>
		<span class="n">current_handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span> <span class="o">!=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This task has a transaction open against a different fs */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;%s: transactions do not match!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;marking dirty.  outer handle=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current_handle</span><span class="p">);</span>
		<span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> * Bind an inode&#39;s backing buffer_head into this transaction, to prevent</span>
<span class="c"> * it from being flushed to disk early.  Unlike</span>
<span class="c"> * ext3_reserve_inode_write, this leaves behind no bh reference and</span>
<span class="c"> * returns no iloc structure, so the caller needs to repeat the iloc</span>
<span class="c"> * lookup to mark the inode dirty later.</span>
<span class="c"> */</span>
<span class="c">static int ext3_pin_inode(handle_t *handle, struct inode *inode)</span>
<span class="c">{</span>
<span class="c">	struct ext3_iloc iloc;</span>

<span class="c">	int err = 0;</span>
<span class="c">	if (handle) {</span>
<span class="c">		err = ext3_get_inode_loc(inode, &amp;iloc);</span>
<span class="c">		if (!err) {</span>
<span class="c">			BUFFER_TRACE(iloc.bh, &quot;get_write_access&quot;);</span>
<span class="c">			err = journal_get_write_access(handle, iloc.bh);</span>
<span class="c">			if (!err)</span>
<span class="c">				err = ext3_journal_dirty_metadata(handle,</span>
<span class="c">								  iloc.bh);</span>
<span class="c">			brelse(iloc.bh);</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="c">	ext3_std_error(inode-&gt;i_sb, err);</span>
<span class="c">	return err;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">ext3_change_inode_journal_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to be very careful here: changing a data block&#39;s</span>
<span class="cm">	 * journaling status dynamically is dangerous.  If we write a</span>
<span class="cm">	 * data block to the journal, change the status and then delete</span>
<span class="cm">	 * that block, we risk forgetting to revoke the old log record</span>
<span class="cm">	 * from the journal and so a subsequent replay can corrupt data.</span>
<span class="cm">	 * So, first we make sure that the journal is empty and that</span>
<span class="cm">	 * nobody is changing anything.</span>
<span class="cm">	 */</span>

	<span class="n">journal</span> <span class="o">=</span> <span class="n">EXT3_JOURNAL</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">journal_lock_updates</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="n">journal_flush</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, there are no updates running now, and all cached data is</span>
<span class="cm">	 * synced to disk.  We are now in a completely consistent state</span>
<span class="cm">	 * which doesn&#39;t have anything in the journal, and we know that</span>
<span class="cm">	 * no filesystem updates are running, so it is safe to modify</span>
<span class="cm">	 * the inode&#39;s in-core data-journaling state flag now.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT3_JOURNAL_DATA_FL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">EXT3_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXT3_JOURNAL_DATA_FL</span><span class="p">;</span>
	<span class="n">ext3_set_aops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">journal_unlock_updates</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/* Finally we can mark the inode as dirty. */</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext3_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext3_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ext3_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">ext3_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
