<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › adfs › map.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>map.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/adfs/map.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1997-2002 Russell King</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &quot;adfs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * The ADFS map is basically a set of sectors.  Each sector is called a</span>
<span class="cm"> * zone which contains a bitstream made up of variable sized fragments.</span>
<span class="cm"> * Each bit refers to a set of bytes in the filesystem, defined by</span>
<span class="cm"> * log2bpmb.  This may be larger or smaller than the sector size, but</span>
<span class="cm"> * the overall size it describes will always be a round number of</span>
<span class="cm"> * sectors.  A fragment id is always idlen bits long.</span>
<span class="cm"> *</span>
<span class="cm"> *  &lt; idlen &gt; &lt;       n        &gt; &lt;1&gt;</span>
<span class="cm"> * +---------+-------//---------+---+</span>
<span class="cm"> * | frag id |  0000....000000  | 1 |</span>
<span class="cm"> * +---------+-------//---------+---+</span>
<span class="cm"> *</span>
<span class="cm"> * The physical disk space used by a fragment is taken from the start of</span>
<span class="cm"> * the fragment id up to and including the &#39;1&#39; bit - ie, idlen + n + 1</span>
<span class="cm"> * bits.</span>
<span class="cm"> *</span>
<span class="cm"> * A fragment id can be repeated multiple times in the whole map for</span>
<span class="cm"> * large or fragmented files.  The first map zone a fragment starts in</span>
<span class="cm"> * is given by fragment id / ids_per_zone - this allows objects to start</span>
<span class="cm"> * from any zone on the disk.</span>
<span class="cm"> *</span>
<span class="cm"> * Free space is described by a linked list of fragments.  Each free</span>
<span class="cm"> * fragment describes free space in the same way as the other fragments,</span>
<span class="cm"> * however, the frag id specifies an offset (in map bits) from the end</span>
<span class="cm"> * of this fragment to the start of the next free fragment.</span>
<span class="cm"> *</span>
<span class="cm"> * Objects stored on the disk are allocated object ids (we use these as</span>
<span class="cm"> * our inode numbers.)  Object ids contain a fragment id and an optional</span>
<span class="cm"> * offset.  This allows a directory fragment to contain small files</span>
<span class="cm"> * associated with that directory.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * For the future...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">adfs_map_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is fun.  We need to load up to 19 bits from the map at an</span>
<span class="cm"> * arbitrary bit alignment.  (We&#39;re limited to 19 bits by F+ version 2).</span>
<span class="cm"> */</span>
<span class="cp">#define GET_FRAG_ID(_map,_start,_idmask)				\</span>
<span class="cp">	({								\</span>
<span class="cp">		unsigned char *_m = _map + (_start &gt;&gt; 3);		\</span>
<span class="cp">		u32 _frag = get_unaligned_le32(_m);			\</span>
<span class="cp">		_frag &gt;&gt;= (_start &amp; 7);					\</span>
<span class="cp">		_frag &amp; _idmask;					\</span>
<span class="cp">	})</span>

<span class="cm">/*</span>
<span class="cm"> * return the map bit offset of the fragment frag_id in the zone dm.</span>
<span class="cm"> * Note that the loop is optimised for best asm code - look at the</span>
<span class="cm"> * output of:</span>
<span class="cm"> *  gcc -D__KERNEL__ -O2 -I../../include -o - -S map.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lookup_zone</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">adfs_discmap</span> <span class="o">*</span><span class="n">dm</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlen</span><span class="p">,</span>
	    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mapsize</span> <span class="o">=</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">dm_endbit</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">idmask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">idlen</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">dm_bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">dm_startbit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mapptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frag</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">GET_FRAG_ID</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">idmask</span><span class="p">);</span>
		<span class="n">mapptr</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">idlen</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * find end of fragment</span>
<span class="cm">		 */</span>
		<span class="p">{</span>
			<span class="n">__le32</span> <span class="o">*</span><span class="n">_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">map</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">v</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">_map</span><span class="p">[</span><span class="n">mapptr</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">mapptr</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mapptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">mapptr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">31</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mapptr</span> <span class="o">&gt;=</span> <span class="n">mapsize</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="n">v</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">_map</span><span class="p">[</span><span class="n">mapptr</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="n">mapptr</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">v</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">==</span> <span class="n">frag_id</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
<span class="nl">again:</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">mapptr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mapptr</span> <span class="o">&lt;</span> <span class="n">mapsize</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;adfs: oversized fragment 0x%x at 0x%x-0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">frag</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mapptr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">mapptr</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">offset</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">start</span> <span class="o">+</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan the free space map, for this zone, calculating the total</span>
<span class="cm"> * number of map bits in each free space fragment.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: idmask is limited to 15 bits [3.2]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">scan_free_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">adfs_sb_info</span> <span class="o">*</span><span class="n">asb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">adfs_discmap</span> <span class="o">*</span><span class="n">dm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mapsize</span> <span class="o">=</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">dm_endbit</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlen</span>  <span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_idlen</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_idlen</span> <span class="o">=</span> <span class="n">idlen</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="o">?</span> <span class="n">idlen</span> <span class="o">:</span> <span class="mi">15</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">idmask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">frag_idlen</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">dm_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">mapptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">frag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * get fragment id</span>
<span class="cm">	 */</span>
	<span class="n">frag</span> <span class="o">=</span> <span class="n">GET_FRAG_ID</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">idmask</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the freelink is null, then no free fragments</span>
<span class="cm">	 * exist in this zone.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">frag</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * get fragment id</span>
<span class="cm">		 */</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">GET_FRAG_ID</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">idmask</span><span class="p">);</span>
		<span class="n">mapptr</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">idlen</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * find end of fragment</span>
<span class="cm">		 */</span>
		<span class="p">{</span>
			<span class="n">__le32</span> <span class="o">*</span><span class="n">_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">map</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">v</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">_map</span><span class="p">[</span><span class="n">mapptr</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">mapptr</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mapptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">mapptr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">31</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mapptr</span> <span class="o">&gt;=</span> <span class="n">mapsize</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="n">v</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">_map</span><span class="p">[</span><span class="n">mapptr</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="n">mapptr</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">v</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">total</span> <span class="o">+=</span> <span class="n">mapptr</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">frag</span> <span class="o">&gt;=</span> <span class="n">idlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;adfs: undersized free fragment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;adfs: oversized free fragment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">scan_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">adfs_sb_info</span> <span class="o">*</span><span class="n">asb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zone</span><span class="p">,</span>
	 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mapoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idlen</span> <span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_idlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">adfs_discmap</span> <span class="o">*</span><span class="n">dm</span><span class="p">,</span> <span class="o">*</span><span class="n">dm_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">dm</span>	<span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map</span> <span class="o">+</span> <span class="n">zone</span><span class="p">;</span>
	<span class="n">zone</span>	<span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map_size</span><span class="p">;</span>
	<span class="n">dm_end</span>	<span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map</span> <span class="o">+</span> <span class="n">zone</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">lookup_zone</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">idlen</span><span class="p">,</span> <span class="n">frag_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapoff</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

		<span class="n">dm</span> <span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dm</span> <span class="o">==</span> <span class="n">dm_end</span><span class="p">)</span>
			<span class="n">dm</span> <span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">zone</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">result</span> <span class="o">-=</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">dm_startbit</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">dm_startblk</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * calculate the amount of free blocks in the map.</span>
<span class="cm"> *</span>
<span class="cm"> *              n=1</span>
<span class="cm"> *  total_free = E(free_in_zone_n)</span>
<span class="cm"> *              nzones</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">adfs_map_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adfs_sb_info</span> <span class="o">*</span><span class="n">asb</span> <span class="o">=</span> <span class="n">ADFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">adfs_discmap</span> <span class="o">*</span><span class="n">dm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zone</span><span class="p">;</span>

	<span class="n">dm</span>   <span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map</span><span class="p">;</span>
	<span class="n">zone</span> <span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map_size</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">scan_free_map</span><span class="p">(</span><span class="n">asb</span><span class="p">,</span> <span class="n">dm</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">zone</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">signed_asl</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map2blk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">adfs_map_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_id</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">adfs_sb_info</span> <span class="o">*</span><span class="n">asb</span> <span class="o">=</span> <span class="n">ADFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zone</span><span class="p">,</span> <span class="n">mapoff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * map &amp; root fragment is special - it starts in the center of the</span>
<span class="cm">	 * disk.  The other fragments start at zone (frag / ids_per_zone)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frag_id</span> <span class="o">==</span> <span class="n">ADFS_ROOT_FRAG</span><span class="p">)</span>
		<span class="n">zone</span> <span class="o">=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map_size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">zone</span> <span class="o">=</span> <span class="n">frag_id</span> <span class="o">/</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_ids_per_zone</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zone</span> <span class="o">&gt;=</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fragment</span><span class="p">;</span>

	<span class="cm">/* Convert sector offset to map offset */</span>
	<span class="n">mapoff</span> <span class="o">=</span> <span class="n">signed_asl</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map2blk</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adfs_map_lock</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">scan_map</span><span class="p">(</span><span class="n">asb</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">frag_id</span><span class="p">,</span> <span class="n">mapoff</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adfs_map_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">secoff</span><span class="p">;</span>

		<span class="cm">/* Calculate sector offset into map block */</span>
		<span class="n">secoff</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">signed_asl</span><span class="p">(</span><span class="n">mapoff</span><span class="p">,</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map2blk</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">secoff</span> <span class="o">+</span> <span class="n">signed_asl</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map2blk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">adfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;fragment 0x%04x at offset %d not found in map&quot;</span><span class="p">,</span>
		   <span class="n">frag_id</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad_fragment:</span>
	<span class="n">adfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;invalid fragment 0x%04x (zone = %d, max = %d)&quot;</span><span class="p">,</span>
		   <span class="n">frag_id</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">asb</span><span class="o">-&gt;</span><span class="n">s_map_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
