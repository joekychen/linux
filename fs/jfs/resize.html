<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jfs › resize.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>resize.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   Copyright (C) International Business Machines  Corp., 2000-2004</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program;  if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &quot;jfs_incore.h&quot;</span>
<span class="cp">#include &quot;jfs_filsys.h&quot;</span>
<span class="cp">#include &quot;jfs_metapage.h&quot;</span>
<span class="cp">#include &quot;jfs_dinode.h&quot;</span>
<span class="cp">#include &quot;jfs_imap.h&quot;</span>
<span class="cp">#include &quot;jfs_dmap.h&quot;</span>
<span class="cp">#include &quot;jfs_superblock.h&quot;</span>
<span class="cp">#include &quot;jfs_txnmgr.h&quot;</span>
<span class="cp">#include &quot;jfs_debug.h&quot;</span>

<span class="cp">#define BITSPERPAGE	(PSIZE &lt;&lt; 3)</span>
<span class="cp">#define L2MEGABYTE	20</span>
<span class="cp">#define MEGABYTE	(1 &lt;&lt; L2MEGABYTE)</span>
<span class="cp">#define MEGABYTE32	(MEGABYTE &lt;&lt; 5)</span>

<span class="cm">/* convert block number to bmap file page number */</span>
<span class="cp">#define BLKTODMAPN(b)\</span>
<span class="cp">	(((b) &gt;&gt; 13) + ((b) &gt;&gt; 23) + ((b) &gt;&gt; 33) + 3 + 1)</span>

<span class="cm">/*</span>
<span class="cm"> *	jfs_extendfs()</span>
<span class="cm"> *</span>
<span class="cm"> * function: extend file system;</span>
<span class="cm"> *</span>
<span class="cm"> *   |-------------------------------|----------|----------|</span>
<span class="cm"> *   file system space               fsck       inline log</span>
<span class="cm"> *                                   workspace  space</span>
<span class="cm"> *</span>
<span class="cm"> * input:</span>
<span class="cm"> *	new LVSize: in LV blocks (required)</span>
<span class="cm"> *	new LogSize: in LV blocks (optional)</span>
<span class="cm"> *	new FSSize: in LV blocks (optional)</span>
<span class="cm"> *</span>
<span class="cm"> * new configuration:</span>
<span class="cm"> * 1. set new LogSize as specified or default from new LVSize;</span>
<span class="cm"> * 2. compute new FSCKSize from new LVSize;</span>
<span class="cm"> * 3. set new FSSize as MIN(FSSize, LVSize-(LogSize+FSCKSize)) where</span>
<span class="cm"> *    assert(new FSSize &gt;= old FSSize),</span>
<span class="cm"> *    i.e., file system must not be shrunk;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jfs_extendfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">s64</span> <span class="n">newLVSize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newLogSize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">newLogAddress</span><span class="p">,</span> <span class="n">newFSCKAddress</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">newFSCKSize</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">newMapSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mapSize</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">XAddress</span><span class="p">,</span> <span class="n">XSize</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">xoff</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">t64</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">oldLVSize</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">newFSSize</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">VolumeSize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">newNpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nPages</span><span class="p">,</span> <span class="n">newPage</span><span class="p">,</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">t32</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">log_formatted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">iplist</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">jfs_superblock</span> <span class="o">*</span><span class="n">j_sb</span><span class="p">,</span> <span class="o">*</span><span class="n">j_sb2</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">old_agsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">agsizechanged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">bh2</span><span class="p">;</span>

	<span class="cm">/* If the volume hasn&#39;t grown, get out now */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">&amp;</span> <span class="n">JFS_INLINELOG</span><span class="p">)</span>
		<span class="n">oldLVSize</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">logpxd</span><span class="p">)</span> <span class="o">+</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">logpxd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">oldLVSize</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">fsckpxd</span><span class="p">)</span> <span class="o">+</span>
		    <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">fsckpxd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oldLVSize</span> <span class="o">&gt;=</span> <span class="n">newLVSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;jfs_extendfs: volume hasn&#39;t grown, returning</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">VolumeSize</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VolumeSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newLVSize</span> <span class="o">&gt;</span> <span class="n">VolumeSize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;jfs_extendfs: invalid size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* check the device */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">newLVSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;jfs_extendfs: invalid size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bforget</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Can&#39;t extend write-protected drive */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isReadOnly</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;jfs_extendfs: read-only file system</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	reconfigure LV spaces</span>
<span class="cm">	 *	---------------------</span>
<span class="cm">	 *</span>
<span class="cm">	 * validate new size, or, if not specified, determine new size</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * reconfigure inline log space:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">&amp;</span> <span class="n">JFS_INLINELOG</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newLogSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * no size specified: default to 1/256 of aggregate</span>
<span class="cm">			 * size; rounded up to a megabyte boundary;</span>
<span class="cm">			 */</span>
			<span class="n">newLogSize</span> <span class="o">=</span> <span class="n">newLVSize</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">t32</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">newLogSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">newLogSize</span> <span class="o">+</span> <span class="n">t32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">t32</span><span class="p">;</span>
			<span class="n">newLogSize</span> <span class="o">=</span>
			    <span class="n">min</span><span class="p">(</span><span class="n">newLogSize</span><span class="p">,</span> <span class="n">MEGABYTE32</span> <span class="o">&gt;&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * convert the newLogSize to fs blocks.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Since this is given in megabytes, it will always be</span>
<span class="cm">			 * an even number of pages.</span>
<span class="cm">			 */</span>
			<span class="n">newLogSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">newLogSize</span> <span class="o">*</span> <span class="n">MEGABYTE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span>
		<span class="n">newLogSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">newLogAddress</span> <span class="o">=</span> <span class="n">newLVSize</span> <span class="o">-</span> <span class="n">newLogSize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * reconfigure fsck work space:</span>
<span class="cm">	 *</span>
<span class="cm">	 * configure it to the end of the logical volume regardless of</span>
<span class="cm">	 * whether file system extends to the end of the aggregate;</span>
<span class="cm">	 * Need enough 4k pages to cover:</span>
<span class="cm">	 *  - 1 bit per block in aggregate rounded up to BPERDMAP boundary</span>
<span class="cm">	 *  - 1 extra page to handle control page and intermediate level pages</span>
<span class="cm">	 *  - 50 extra pages for the chkdsk service log</span>
<span class="cm">	 */</span>
	<span class="n">t64</span> <span class="o">=</span> <span class="p">((</span><span class="n">newLVSize</span> <span class="o">-</span> <span class="n">newLogSize</span> <span class="o">+</span> <span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2BPERDMAP</span><span class="p">)</span>
	    <span class="o">&lt;&lt;</span> <span class="n">L2BPERDMAP</span><span class="p">;</span>
	<span class="n">t32</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">t64</span><span class="p">,</span> <span class="n">BITSPERPAGE</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">50</span><span class="p">;</span>
	<span class="n">newFSCKSize</span> <span class="o">=</span> <span class="n">t32</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>
	<span class="n">newFSCKAddress</span> <span class="o">=</span> <span class="n">newLogAddress</span> <span class="o">-</span> <span class="n">newFSCKSize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * compute new file system space;</span>
<span class="cm">	 */</span>
	<span class="n">newFSSize</span> <span class="o">=</span> <span class="n">newLVSize</span> <span class="o">-</span> <span class="n">newLogSize</span> <span class="o">-</span> <span class="n">newFSCKSize</span><span class="p">;</span>

	<span class="cm">/* file system cannot be shrunk */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newFSSize</span> <span class="o">&lt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re expanding enough that the inline log does not overlap</span>
<span class="cm">	 * the old one, we can format the new log before we quiesce the</span>
<span class="cm">	 * filesystem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">&amp;</span> <span class="n">JFS_INLINELOG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">newLogAddress</span> <span class="o">&gt;</span> <span class="n">oldLVSize</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">lmLogFormat</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">newLogAddress</span><span class="p">,</span> <span class="n">newLogSize</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">log_formatted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	quiesce file system</span>
<span class="cm">	 *</span>
<span class="cm">	 * (prepare to move the inline log and to prevent map update)</span>
<span class="cm">	 *</span>
<span class="cm">	 * block any new transactions and wait for completion of</span>
<span class="cm">	 * all wip transactions and flush modified pages s.t.</span>
<span class="cm">	 * on-disk file system is in consistent state and</span>
<span class="cm">	 * log is not required for recovery.</span>
<span class="cm">	 */</span>
	<span class="n">txQuiesce</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* Reset size of direct inode */</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">direct_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span>  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">&amp;</span> <span class="n">JFS_INLINELOG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * deactivate old inline log</span>
<span class="cm">		 */</span>
		<span class="n">lmLogShutdown</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * mark on-disk super block for fs in transition;</span>
<span class="cm">		 *</span>
<span class="cm">		 * update on-disk superblock for the new space configuration</span>
<span class="cm">		 * of inline log space and fsck work space descriptors:</span>
<span class="cm">		 * N.B. FS descriptor is NOT updated;</span>
<span class="cm">		 *</span>
<span class="cm">		 * crash recovery:</span>
<span class="cm">		 * logredo(): if FM_EXTENDFS, return to fsck() for cleanup;</span>
<span class="cm">		 * fsck(): if FM_EXTENDFS, reformat inline log and fsck</span>
<span class="cm">		 * workspace from superblock inline log descriptor and fsck</span>
<span class="cm">		 * workspace descriptor;</span>
<span class="cm">		 */</span>

		<span class="cm">/* read in superblock */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">readSuper</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="n">j_sb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_superblock</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

		<span class="cm">/* mark extendfs() in progress */</span>
		<span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">FM_EXTENDFS</span><span class="p">);</span>
		<span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_xsize</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">newFSSize</span><span class="p">);</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_xfsckpxd</span><span class="p">,</span> <span class="n">newFSCKAddress</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_xfsckpxd</span><span class="p">,</span> <span class="n">newFSCKSize</span><span class="p">);</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_xlogpxd</span><span class="p">,</span> <span class="n">newLogAddress</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_xlogpxd</span><span class="p">,</span> <span class="n">newLogSize</span><span class="p">);</span>

		<span class="cm">/* synchronously update superblock */</span>
		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * format new inline log synchronously;</span>
<span class="cm">		 *</span>
<span class="cm">		 * crash recovery: if log move in progress,</span>
<span class="cm">		 * reformat log and exit success;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">log_formatted</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">lmLogFormat</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">newLogAddress</span><span class="p">,</span> <span class="n">newLogSize</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * activate new log</span>
<span class="cm">		 */</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">newLogAddress</span><span class="p">;</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">newLogSize</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">L2LOGPSIZE</span> <span class="o">-</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">lmLogInit</span><span class="p">(</span><span class="n">log</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	extend block allocation map</span>
<span class="cm">	 *	---------------------------</span>
<span class="cm">	 *</span>
<span class="cm">	 * extendfs() for new extension, retry after crash recovery;</span>
<span class="cm">	 *</span>
<span class="cm">	 * note: both logredo() and fsck() rebuild map from</span>
<span class="cm">	 * the bitmap and configuration parameter from superblock</span>
<span class="cm">	 * (disregarding all other control information in the map);</span>
<span class="cm">	 *</span>
<span class="cm">	 * superblock:</span>
<span class="cm">	 *  s_size: aggregate size in physical blocks;</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 *	compute the new block allocation map configuration</span>
<span class="cm">	 *</span>
<span class="cm">	 * map dinode:</span>
<span class="cm">	 *  di_size: map file size in byte;</span>
<span class="cm">	 *  di_nblocks: number of blocks allocated for map file;</span>
<span class="cm">	 *  di_mapsize: number of blocks in aggregate (covered by map);</span>
<span class="cm">	 * map control page:</span>
<span class="cm">	 *  db_mapsize: number of blocks in aggregate (covered by map);</span>
<span class="cm">	 */</span>
	<span class="n">newMapSize</span> <span class="o">=</span> <span class="n">newFSSize</span><span class="p">;</span>
	<span class="cm">/* number of data pages of new bmap file:</span>
<span class="cm">	 * roundup new size to full dmap page boundary and</span>
<span class="cm">	 * add 1 extra dmap page for next extendfs()</span>
<span class="cm">	 */</span>
	<span class="n">t64</span> <span class="o">=</span> <span class="p">(</span><span class="n">newMapSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">BPERDMAP</span><span class="p">;</span>
	<span class="n">newNpages</span> <span class="o">=</span> <span class="n">BLKTODMAPN</span><span class="p">(</span><span class="n">t64</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	extend map from current map (WITHOUT growing mapfile)</span>
<span class="cm">	 *</span>
<span class="cm">	 * map new extension with unmapped part of the last partial</span>
<span class="cm">	 * dmap page, if applicable, and extra page(s) allocated</span>
<span class="cm">	 * at end of bmap by mkfs() or previous extendfs();</span>
<span class="cm">	 */</span>
      <span class="nl">extendBmap:</span>
	<span class="cm">/* compute number of blocks requested to extend */</span>
	<span class="n">mapSize</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">;</span>
	<span class="n">XAddress</span> <span class="o">=</span> <span class="n">mapSize</span><span class="p">;</span>	<span class="cm">/* eXtension Address */</span>
	<span class="n">XSize</span> <span class="o">=</span> <span class="n">newMapSize</span> <span class="o">-</span> <span class="n">mapSize</span><span class="p">;</span>	<span class="cm">/* eXtension Size */</span>
	<span class="n">old_agsize</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span><span class="p">;</span>	<span class="cm">/* We need to know if this changes */</span>

	<span class="cm">/* compute number of blocks that can be extended by current mapfile */</span>
	<span class="n">t64</span> <span class="o">=</span> <span class="n">dbMapFileSizeToMapSize</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapSize</span> <span class="o">&gt;</span> <span class="n">t64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;jfs_extendfs: mapSize (0x%Lx) &gt; t64 (0x%Lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">mapSize</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">t64</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">t64</span> <span class="o">-</span> <span class="n">mapSize</span><span class="p">,</span> <span class="n">XSize</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * update map pages for new extension:</span>
<span class="cm">	 *</span>
<span class="cm">	 * update/init dmap and bubble up the control hierarchy</span>
<span class="cm">	 * incrementally fold up dmaps into upper levels;</span>
<span class="cm">	 * update bmap control page;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbExtendFS</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">XAddress</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="n">agsizechanged</span> <span class="o">|=</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span> <span class="o">!=</span> <span class="n">old_agsize</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * the map now has extended to cover additional nblocks:</span>
<span class="cm">	 * dn_mapsize = oldMapsize + nblocks;</span>
<span class="cm">	 */</span>
	<span class="cm">/* ipbmap-&gt;i_mapsize += nblocks; */</span>
	<span class="n">XSize</span> <span class="o">-=</span> <span class="n">nblocks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	grow map file to cover remaining extension</span>
<span class="cm">	 *	and/or one extra dmap page for next extendfs();</span>
<span class="cm">	 *</span>
<span class="cm">	 * allocate new map pages and its backing blocks, and</span>
<span class="cm">	 * update map file xtree</span>
<span class="cm">	 */</span>
	<span class="cm">/* compute number of data pages of current bmap file */</span>
	<span class="n">nPages</span> <span class="o">=</span> <span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">L2PSIZE</span><span class="p">;</span>

	<span class="cm">/* need to grow map file ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nPages</span> <span class="o">==</span> <span class="n">newNpages</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">finalizeBmap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * grow bmap file for the new map pages required:</span>
<span class="cm">	 *</span>
<span class="cm">	 * allocate growth at the start of newly extended region;</span>
<span class="cm">	 * bmap file only grows sequentially, i.e., both data pages</span>
<span class="cm">	 * and possibly xtree index pages may grow in append mode,</span>
<span class="cm">	 * s.t. logredo() can reconstruct pre-extension state</span>
<span class="cm">	 * by washing away bmap file of pages outside s_size boundary;</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * journal map file growth as if a regular file growth:</span>
<span class="cm">	 * (note: bmap is created with di_mode = IFJOURNAL|IFREG);</span>
<span class="cm">	 *</span>
<span class="cm">	 * journaling of bmap file growth is not required since</span>
<span class="cm">	 * logredo() do/can not use log records of bmap file growth</span>
<span class="cm">	 * but it provides careful write semantics, pmap update, etc.;</span>
<span class="cm">	 */</span>
	<span class="cm">/* synchronous write of data pages: bmap data pages are</span>
<span class="cm">	 * cached in meta-data cache, and not written out</span>
<span class="cm">	 * by txCommit();</span>
<span class="cm">	 */</span>
	<span class="n">filemap_fdatawait</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="n">diWriteSpecial</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">newPage</span> <span class="o">=</span> <span class="n">nPages</span><span class="p">;</span>	<span class="cm">/* first new page number */</span>
	<span class="n">xoff</span> <span class="o">=</span> <span class="n">newPage</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>
	<span class="n">xlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">newNpages</span> <span class="o">-</span> <span class="n">nPages</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>
	<span class="n">xlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">xlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xaddr</span> <span class="o">=</span> <span class="n">XAddress</span><span class="p">;</span>

	<span class="n">tid</span> <span class="o">=</span> <span class="n">txBegin</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">xtAppend</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ipbmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xoff</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* update bmap file size */</span>
	<span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">xlen</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>
	<span class="n">inode_add_bytes</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">xlen</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">);</span>

	<span class="n">iplist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipbmap</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">txCommit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iplist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>

	<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * map file has been grown now to cover extension to further out;</span>
<span class="cm">	 * di_size = new map file size;</span>
<span class="cm">	 *</span>
<span class="cm">	 * if huge extension, the previous extension based on previous</span>
<span class="cm">	 * map file size may not have been sufficient to cover whole extension</span>
<span class="cm">	 * (it could have been used up for new map pages),</span>
<span class="cm">	 * but the newly grown map file now covers lot bigger new free space</span>
<span class="cm">	 * available for further extension of map;</span>
<span class="cm">	 */</span>
	<span class="cm">/* any more blocks to extend ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XSize</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">extendBmap</span><span class="p">;</span>

      <span class="nl">finalizeBmap:</span>
	<span class="cm">/* finalize bmap */</span>
	<span class="n">dbFinalizeBmap</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	update inode allocation map</span>
<span class="cm">	 *	---------------------------</span>
<span class="cm">	 *</span>
<span class="cm">	 * move iag lists from old to new iag;</span>
<span class="cm">	 * agstart field is not updated for logredo() to reconstruct</span>
<span class="cm">	 * iag lists if system crash occurs.</span>
<span class="cm">	 * (computation of ag number from agstart based on agsize</span>
<span class="cm">	 * will correctly identify the new ag);</span>
<span class="cm">	 */</span>
	<span class="cm">/* if new AG size the same as old AG size, done! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agsizechanged</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diExtendFS</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">ipbmap</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

		<span class="cm">/* finalize imap */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diSync</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	finalize</span>
<span class="cm">	 *	--------</span>
<span class="cm">	 *</span>
<span class="cm">	 * extension is committed when on-disk super block is</span>
<span class="cm">	 * updated with new descriptors: logredo will recover</span>
<span class="cm">	 * crash before it to pre-extension state;</span>
<span class="cm">	 */</span>

	<span class="cm">/* sync log to skip log replay of bmap file growth transaction; */</span>
	<span class="cm">/* lmLogSync(log, 1); */</span>

	<span class="cm">/*</span>
<span class="cm">	 * synchronous write bmap global control page;</span>
<span class="cm">	 * for crash before completion of write</span>
<span class="cm">	 * logredo() will recover to pre-extendfs state;</span>
<span class="cm">	 * for crash after completion of write,</span>
<span class="cm">	 * logredo() will recover post-extendfs state;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbSync</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * copy primary bmap inode to secondary bmap inode</span>
<span class="cm">	 */</span>

	<span class="n">ipbmap2</span> <span class="o">=</span> <span class="n">diReadSpecial</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">BMAP_I</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipbmap2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;jfs_extendfs: diReadSpecial(bmap) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipbmap2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_xtroot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_xtroot</span><span class="p">,</span> <span class="mi">288</span><span class="p">);</span>
	<span class="n">ipbmap2</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">ipbmap2</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">;</span>

	<span class="n">diWriteSpecial</span><span class="p">(</span><span class="n">ipbmap2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">diFreeSpecial</span><span class="p">(</span><span class="n">ipbmap2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	update superblock</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">readSuper</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="n">j_sb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_superblock</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="cm">/* mark extendfs() completion */</span>
	<span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">FM_EXTENDFS</span><span class="p">);</span>
	<span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span> <span class="o">&lt;&lt;</span>
				   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_l2bfactor</span><span class="p">));</span>
	<span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_agsize</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span><span class="p">);</span>

	<span class="cm">/* update inline log space descriptor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">&amp;</span> <span class="n">JFS_INLINELOG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_logpxd</span><span class="p">),</span> <span class="n">newLogAddress</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_logpxd</span><span class="p">),</span> <span class="n">newLogSize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* record log&#39;s mount serial number */</span>
	<span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_logserial</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>

	<span class="cm">/* update fsck work space descriptor */</span>
	<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_fsckpxd</span><span class="p">),</span> <span class="n">newFSCKAddress</span><span class="p">);</span>
	<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_fsckpxd</span><span class="p">),</span> <span class="n">newFSCKSize</span><span class="p">);</span>
	<span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_fscklog</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* sb-&gt;s_fsckloglen remains the same */</span>

	<span class="cm">/* Update secondary superblock */</span>
	<span class="n">bh2</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SUPER2_OFF</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">j_sb2</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_superblock</span> <span class="o">*</span><span class="p">)</span><span class="n">bh2</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">j_sb2</span><span class="p">,</span> <span class="n">j_sb</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_superblock</span><span class="p">));</span>

		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* write primary superblock */</span>
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">resume</span><span class="p">;</span>

      <span class="nl">error_out:</span>
	<span class="n">jfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;jfs_extendfs&quot;</span><span class="p">);</span>

      <span class="nl">resume:</span>
	<span class="cm">/*</span>
<span class="cm">	 *	resume file system transactions</span>
<span class="cm">	 */</span>
	<span class="n">txResume</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

      <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
