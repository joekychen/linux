<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jfs › jfs_txnmgr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jfs_txnmgr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   Copyright (C) International Business Machines Corp., 2000-2005</span>
<span class="cm"> *   Portions Copyright (C) Christoph Hellwig, 2001-2002</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program;  if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	jfs_txnmgr.c: transaction manager</span>
<span class="cm"> *</span>
<span class="cm"> * notes:</span>
<span class="cm"> * transaction starts with txBegin() and ends with txCommit()</span>
<span class="cm"> * or txAbort().</span>
<span class="cm"> *</span>
<span class="cm"> * tlock is acquired at the time of update;</span>
<span class="cm"> * (obviate scan at commit time for xtree and dtree)</span>
<span class="cm"> * tlock and mp points to each other;</span>
<span class="cm"> * (no hashlist for mp -&gt; tlock).</span>
<span class="cm"> *</span>
<span class="cm"> * special cases:</span>
<span class="cm"> * tlock on in-memory inode:</span>
<span class="cm"> * in-place tlock in the in-memory inode itself;</span>
<span class="cm"> * converted to page lock by iWrite() at commit time.</span>
<span class="cm"> *</span>
<span class="cm"> * tlock during write()/mmap() under anonymous transaction (tid = 0):</span>
<span class="cm"> * transferred (?) to transaction at commit time.</span>
<span class="cm"> *</span>
<span class="cm"> * use the page itself to update allocation maps</span>
<span class="cm"> * (obviate intermediate replication of allocation/deallocation data)</span>
<span class="cm"> * hold on to mp+lock thru update of maps</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &quot;jfs_incore.h&quot;</span>
<span class="cp">#include &quot;jfs_inode.h&quot;</span>
<span class="cp">#include &quot;jfs_filsys.h&quot;</span>
<span class="cp">#include &quot;jfs_metapage.h&quot;</span>
<span class="cp">#include &quot;jfs_dinode.h&quot;</span>
<span class="cp">#include &quot;jfs_imap.h&quot;</span>
<span class="cp">#include &quot;jfs_dmap.h&quot;</span>
<span class="cp">#include &quot;jfs_superblock.h&quot;</span>
<span class="cp">#include &quot;jfs_debug.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *	transaction management structures</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">freetid</span><span class="p">;</span>		<span class="cm">/* index of a free tid structure */</span>
	<span class="kt">int</span> <span class="n">freelock</span><span class="p">;</span>		<span class="cm">/* index first free lock word */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">freewait</span><span class="p">;</span>	<span class="cm">/* eventlist of free tblock */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">freelockwait</span><span class="p">;</span>	<span class="cm">/* eventlist of free tlock */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">lowlockwait</span><span class="p">;</span>	<span class="cm">/* eventlist of ample tlocks */</span>
	<span class="kt">int</span> <span class="n">tlocksInUse</span><span class="p">;</span>	<span class="cm">/* Number of tlocks in use */</span>
	<span class="n">spinlock_t</span> <span class="n">LazyLock</span><span class="p">;</span>	<span class="cm">/* synchronize sync_queue &amp; unlock_queue */</span>
<span class="cm">/*	struct tblock *sync_queue; * Transactions waiting for data sync */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">unlock_queue</span><span class="p">;</span>	<span class="cm">/* Txns waiting to be released */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">anon_list</span><span class="p">;</span>	<span class="cm">/* inodes having anonymous txns */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">anon_list2</span><span class="p">;</span>	<span class="cm">/* inodes having anonymous txns</span>
<span class="cm">					   that couldn&#39;t be sync&#39;ed */</span>
<span class="p">}</span> <span class="n">TxAnchor</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">jfs_tlocks_low</span><span class="p">;</span>		<span class="cm">/* Indicates low number of available tlocks */</span>

<span class="cp">#ifdef CONFIG_JFS_STATISTICS</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">uint</span> <span class="n">txBegin</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">txBegin_barrier</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">txBegin_lockslow</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">txBegin_freetid</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">txBeginAnon</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">txBeginAnon_barrier</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">txBeginAnon_lockslow</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">txLockAlloc</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">txLockAlloc_freelock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">TxStat</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nTxBlock</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* number of transaction blocks */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">nTxBlock</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nTxBlock</span><span class="p">,</span>
		 <span class="s">&quot;Number of transaction blocks (max:65536)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nTxLock</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* number of transaction locks */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">nTxLock</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nTxLock</span><span class="p">,</span>
		 <span class="s">&quot;Number of transaction locks (max:65536)&quot;</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">TxBlock</span><span class="p">;</span>	<span class="cm">/* transaction block table */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">TxLockLWM</span><span class="p">;</span>	<span class="cm">/* Low water mark for number of txLocks used */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">TxLockHWM</span><span class="p">;</span>	<span class="cm">/* High water mark for number of txLocks used */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">TxLockVHWM</span><span class="p">;</span>	<span class="cm">/* Very High water mark */</span>
<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">TxLock</span><span class="p">;</span>	<span class="cm">/* transaction lock table */</span>

<span class="cm">/*</span>
<span class="cm"> *	transaction management lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">jfsTxnLock</span><span class="p">);</span>

<span class="cp">#define TXN_LOCK()		spin_lock(&amp;jfsTxnLock)</span>
<span class="cp">#define TXN_UNLOCK()		spin_unlock(&amp;jfsTxnLock)</span>

<span class="cp">#define LAZY_LOCK_INIT()	spin_lock_init(&amp;TxAnchor.LazyLock);</span>
<span class="cp">#define LAZY_LOCK(flags)	spin_lock_irqsave(&amp;TxAnchor.LazyLock, flags)</span>
<span class="cp">#define LAZY_UNLOCK(flags) spin_unlock_irqrestore(&amp;TxAnchor.LazyLock, flags)</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">jfs_commit_thread_wait</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jfs_commit_thread_waking</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Retry logic exist outside these macros to protect from spurrious wakeups.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TXN_SLEEP_DROP_LOCK</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">TXN_UNLOCK</span><span class="p">();</span>
	<span class="n">io_schedule</span><span class="p">();</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TXN_SLEEP(event)\</span>
<span class="cp">{\</span>
<span class="cp">	TXN_SLEEP_DROP_LOCK(event);\</span>
<span class="cp">	TXN_LOCK();\</span>
<span class="cp">}</span>

<span class="cp">#define TXN_WAKEUP(event) wake_up_all(event)</span>

<span class="cm">/*</span>
<span class="cm"> *	statistics</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">tid_t</span> <span class="n">maxtid</span><span class="p">;</span>		<span class="cm">/* 4: biggest tid ever used */</span>
	<span class="n">lid_t</span> <span class="n">maxlid</span><span class="p">;</span>		<span class="cm">/* 4: biggest lid ever used */</span>
	<span class="kt">int</span> <span class="n">ntid</span><span class="p">;</span>		<span class="cm">/* 4: # of transactions performed */</span>
	<span class="kt">int</span> <span class="n">nlid</span><span class="p">;</span>		<span class="cm">/* 4: # of tlocks acquired */</span>
	<span class="kt">int</span> <span class="n">waitlock</span><span class="p">;</span>		<span class="cm">/* 4: # of tlock wait */</span>
<span class="p">}</span> <span class="n">stattx</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * forward references</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">,</span> <span class="k">struct</span> <span class="n">commit</span> <span class="o">*</span> <span class="n">cd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dataLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dtLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mapLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">txAllocPMap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span> <span class="n">maplock</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">txForce</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">txLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">commit</span> <span class="o">*</span> <span class="n">cd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">txUpdateMap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">txRelease</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">xtLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
	   <span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">LogSyncRelease</span><span class="p">(</span><span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span> <span class="n">mp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *		transaction block/lock management</span>
<span class="cm"> *		---------------------------------</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Get a transaction lock from the free list.  If the number in use is</span>
<span class="cm"> * greater than the high water mark, wake up the sync daemon.  This should</span>
<span class="cm"> * free some anonymous transaction locks.  (TXN_LOCK must be held.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">lid_t</span> <span class="nf">txLockAlloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>

	<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txLockAlloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txLockAlloc_freelock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lid</span> <span class="o">=</span> <span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelock</span><span class="p">))</span>
		<span class="n">TXN_SLEEP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelockwait</span><span class="p">);</span>
	<span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelock</span> <span class="o">=</span> <span class="n">TxLock</span><span class="p">[</span><span class="n">lid</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="n">HIGHWATERMARK</span><span class="p">(</span><span class="n">stattx</span><span class="p">.</span><span class="n">maxlid</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">++</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">tlocksInUse</span> <span class="o">&gt;</span> <span class="n">TxLockHWM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">jfs_tlocks_low</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txLockAlloc tlocks low&quot;</span><span class="p">);</span>
		<span class="n">jfs_tlocks_low</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">jfsSyncThread</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">txLockFree</span><span class="p">(</span><span class="n">lid_t</span> <span class="n">lid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">TxLock</span><span class="p">[</span><span class="n">lid</span><span class="p">].</span><span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">TxLock</span><span class="p">[</span><span class="n">lid</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelock</span><span class="p">;</span>
	<span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelock</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
	<span class="n">TxAnchor</span><span class="p">.</span><span class="n">tlocksInUse</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jfs_tlocks_low</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">tlocksInUse</span> <span class="o">&lt;</span> <span class="n">TxLockLWM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txLockFree jfs_tlocks_low no more&quot;</span><span class="p">);</span>
		<span class="n">jfs_tlocks_low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">TXN_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">lowlockwait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">TXN_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelockwait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	txInit()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initialize transaction management structures</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: single thread at jfs_init()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">txInit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">si</span><span class="p">;</span>

	<span class="cm">/* Set defaults for nTxLock and nTxBlock if unset */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nTxLock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nTxBlock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Base default on memory size */</span>
			<span class="n">si_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="p">.</span><span class="n">totalram</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span> <span class="cm">/* 1 GB */</span>
				<span class="n">nTxLock</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">nTxLock</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">totalram</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nTxBlock</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span>
			<span class="n">nTxLock</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">nTxLock</span> <span class="o">=</span> <span class="n">nTxBlock</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nTxBlock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">nTxBlock</span> <span class="o">=</span> <span class="n">nTxLock</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* Verify tunable parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nTxBlock</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">nTxBlock</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* No one should set it this low */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nTxBlock</span> <span class="o">&gt;</span> <span class="mi">65536</span><span class="p">)</span>
		<span class="n">nTxBlock</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nTxLock</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span>
		<span class="n">nTxLock</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>	<span class="cm">/* No one should set it this low */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nTxLock</span> <span class="o">&gt;</span> <span class="mi">65536</span><span class="p">)</span>
		<span class="n">nTxLock</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;JFS: nTxBlock = %d, nTxLock = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">nTxBlock</span><span class="p">,</span> <span class="n">nTxLock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * initialize transaction block (tblock) table</span>
<span class="cm">	 *</span>
<span class="cm">	 * transaction id (tid) = tblock index</span>
<span class="cm">	 * tid = 0 is reserved.</span>
<span class="cm">	 */</span>
	<span class="n">TxLockLWM</span> <span class="o">=</span> <span class="p">(</span><span class="n">nTxLock</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">TxLockHWM</span> <span class="o">=</span> <span class="p">(</span><span class="n">nTxLock</span> <span class="o">*</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">TxLockVHWM</span> <span class="o">=</span> <span class="p">(</span><span class="n">nTxLock</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span><span class="p">)</span> <span class="o">*</span> <span class="n">nTxBlock</span><span class="p">;</span>
	<span class="n">TxBlock</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TxBlock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nTxBlock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">TxBlock</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxBlock</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">gcwait</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxBlock</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">waitor</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">TxBlock</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxBlock</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">gcwait</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxBlock</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">waitor</span><span class="p">);</span>

	<span class="n">TxAnchor</span><span class="p">.</span><span class="n">freetid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freewait</span><span class="p">);</span>

	<span class="n">stattx</span><span class="p">.</span><span class="n">maxtid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* statistics */</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize transaction lock (tlock) table</span>
<span class="cm">	 *</span>
<span class="cm">	 * transaction lock id = tlock index</span>
<span class="cm">	 * tlock id = 0 is reserved.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlock</span><span class="p">)</span> <span class="o">*</span> <span class="n">nTxLock</span><span class="p">;</span>
	<span class="n">TxLock</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TxLock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">TxBlock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize tlock table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nTxLock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">TxLock</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">TxLock</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelockwait</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">lowlockwait</span><span class="p">);</span>

	<span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">TxAnchor</span><span class="p">.</span><span class="n">tlocksInUse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list2</span><span class="p">);</span>

	<span class="n">LAZY_LOCK_INIT</span><span class="p">();</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">unlock_queue</span><span class="p">);</span>

	<span class="n">stattx</span><span class="p">.</span><span class="n">maxlid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* statistics */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	txExit()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	clean up when module is unloaded</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txExit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">TxLock</span><span class="p">);</span>
	<span class="n">TxLock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">TxBlock</span><span class="p">);</span>
	<span class="n">TxBlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	txBegin()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	start a transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETER:	sb	- superblock</span>
<span class="cm"> *		flag	- force for nested tx;</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:	tid	- transaction id</span>
<span class="cm"> *</span>
<span class="cm"> * note: flag force allows to start tx for nested tx</span>
<span class="cm"> * to prevent deadlock on logsync barrier;</span>
<span class="cm"> */</span>
<span class="n">tid_t</span> <span class="nf">txBegin</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tid_t</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">tblk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txBegin: flag = 0x%x&quot;</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">log</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>

	<span class="n">TXN_LOCK</span><span class="p">();</span>

	<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin</span><span class="p">);</span>

      <span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">COMMIT_FORCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * synchronize with logsync barrier</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">log_SYNCBARRIER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">log_QUIESCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin_barrier</span><span class="p">);</span>
			<span class="n">TXN_SLEEP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">syncwait</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t begin transaction if we&#39;re getting starved for tlocks</span>
<span class="cm">		 * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately</span>
<span class="cm">		 * free tlocks)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">tlocksInUse</span> <span class="o">&gt;</span> <span class="n">TxLockVHWM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin_lockslow</span><span class="p">);</span>
			<span class="n">TXN_SLEEP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">lowlockwait</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate transaction id/block</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">TxAnchor</span><span class="p">.</span><span class="n">freetid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txBegin: waiting for free tid&quot;</span><span class="p">);</span>
		<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin_freetid</span><span class="p">);</span>
		<span class="n">TXN_SLEEP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freewait</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tblk</span> <span class="o">=</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">COMMIT_FORCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t let a non-forced transaction take the last tblk */</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txBegin: waiting for free tid&quot;</span><span class="p">);</span>
		<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin_freetid</span><span class="p">);</span>
		<span class="n">TXN_SLEEP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freewait</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TxAnchor</span><span class="p">.</span><span class="n">freetid</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize transaction</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t zero the whole thing or we screw up another thread being</span>
<span class="cm">	 * awakened after sleeping on tblk-&gt;waitor</span>
<span class="cm">	 *</span>
<span class="cm">	 * memset(tblk, 0, sizeof(struct tblock));</span>
<span class="cm">	 */</span>
	<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="o">++</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">logtid</span><span class="p">;</span>
	<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">logtid</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">logtid</span><span class="p">;</span>

	<span class="o">++</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>

	<span class="n">HIGHWATERMARK</span><span class="p">(</span><span class="n">stattx</span><span class="p">.</span><span class="n">maxtid</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>	<span class="cm">/* statistics */</span>
	<span class="n">INCREMENT</span><span class="p">(</span><span class="n">stattx</span><span class="p">.</span><span class="n">ntid</span><span class="p">);</span>	<span class="cm">/* statistics */</span>

	<span class="n">TXN_UNLOCK</span><span class="p">();</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txBegin: returning tid = %d&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	txBeginAnon()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	start an anonymous transaction.</span>
<span class="cm"> *		Blocks if logsync or available tlocks are low to prevent</span>
<span class="cm"> *		anonymous tlocks from depleting supply.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETER:	sb	- superblock</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:	none</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txBeginAnon</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>

	<span class="n">log</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>

	<span class="n">TXN_LOCK</span><span class="p">();</span>
	<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txBeginAnon</span><span class="p">);</span>

      <span class="nl">retry:</span>
	<span class="cm">/*</span>
<span class="cm">	 * synchronize with logsync barrier</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">log_SYNCBARRIER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">log_QUIESCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txBeginAnon_barrier</span><span class="p">);</span>
		<span class="n">TXN_SLEEP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">syncwait</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t begin transaction if we&#39;re getting starved for tlocks</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">tlocksInUse</span> <span class="o">&gt;</span> <span class="n">TxLockVHWM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INCREMENT</span><span class="p">(</span><span class="n">TxStat</span><span class="p">.</span><span class="n">txBeginAnon_lockslow</span><span class="p">);</span>
		<span class="n">TXN_SLEEP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">lowlockwait</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">TXN_UNLOCK</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txEnd()</span>
<span class="cm"> *</span>
<span class="cm"> * function: free specified transaction block.</span>
<span class="cm"> *</span>
<span class="cm"> *	logsync barrier processing:</span>
<span class="cm"> *</span>
<span class="cm"> * serialization:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txEnd</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">tblk</span> <span class="o">=</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txEnd: tid = %d&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="n">TXN_LOCK</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * wakeup transactions waiting on the page locked</span>
<span class="cm">	 * by the current transaction</span>
<span class="cm">	 */</span>
	<span class="n">TXN_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">waitor</span><span class="p">);</span>

	<span class="n">log</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lazy commit thread can&#39;t free this guy until we mark it UNLOCKED,</span>
<span class="cm">	 * otherwise, we would be left with a transaction that may have been</span>
<span class="cm">	 * reused.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Lazy commit thread will turn off tblkGC_LAZY before calling this</span>
<span class="cm">	 * routine.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tblkGC_LAZY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txEnd called w/lazy tid: %d, tblk = 0x%p&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
		<span class="n">TXN_UNLOCK</span><span class="p">();</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">gclock</span><span class="p">);</span>	<span class="c1">// LOGGC_LOCK</span>
		<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tblkGC_UNLOCKED</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">gclock</span><span class="p">);</span>	<span class="c1">// LOGGC_UNLOCK</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txEnd: tid: %d, tblk = 0x%p&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>

	<span class="n">assert</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * insert tblock back on freelist</span>
<span class="cm">	 */</span>
	<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">TxAnchor</span><span class="p">.</span><span class="n">freetid</span><span class="p">;</span>
	<span class="n">TxAnchor</span><span class="p">.</span><span class="n">freetid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mark the tblock not active</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">log_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * synchronize with logsync barrier</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">log_SYNCBARRIER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">TXN_UNLOCK</span><span class="p">();</span>

			<span class="cm">/* write dirty metadata &amp; forward log syncpt */</span>
			<span class="n">jfs_syncpt</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;log barrier off: 0x%x&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">lsn</span><span class="p">);</span>

			<span class="cm">/* enable new transactions start */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">log_SYNCBARRIER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">);</span>

			<span class="cm">/* wakeup all waitors for logsync barrier */</span>
			<span class="n">TXN_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">syncwait</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">wakeup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">TXN_UNLOCK</span><span class="p">();</span>
<span class="nl">wakeup:</span>
	<span class="cm">/*</span>
<span class="cm">	 * wakeup all waitors for a free tblock</span>
<span class="cm">	 */</span>
	<span class="n">TXN_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freewait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txLock()</span>
<span class="cm"> *</span>
<span class="cm"> * function: acquire a transaction lock on the specified &lt;mp&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return:	transaction lock id</span>
<span class="cm"> *</span>
<span class="cm"> * serialization:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="nf">txLock</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span> <span class="n">mp</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dir_xtree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">xtid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xtlock</span> <span class="o">*</span><span class="n">xtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="n">linelock</span><span class="p">;</span>
	<span class="n">xtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">tblk</span><span class="p">;</span>

	<span class="n">TXN_LOCK</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckXTREE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PAGE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Directory inode is special.  It can have both an xtree tlock</span>
<span class="cm">		 * and a dtree tlock associated with it.</span>
<span class="cm">		 */</span>
		<span class="n">dir_xtree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lid</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">xtlid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lid</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">lid</span><span class="p">;</span>

	<span class="cm">/* is page not locked by a transaction ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">allocateLock</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txLock: tid:%d ip:0x%p mp:0x%p lid:%d&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>

	<span class="cm">/* is page locked by the requester transaction ? */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">xtid</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">)</span> <span class="o">==</span> <span class="n">tid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">TXN_UNLOCK</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">grantLock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * is page locked by anonymous transaction/lock ?</span>
<span class="cm">	 *</span>
<span class="cm">	 * (page update without transaction (i.e., file write) is</span>
<span class="cm">	 * locked under anonymous transaction tid = 0:</span>
<span class="cm">	 * anonymous tlocks maintained on anonymous tlock list of</span>
<span class="cm">	 * the inode of the page and available to all anonymous</span>
<span class="cm">	 * transactions until txCommit() time at which point</span>
<span class="cm">	 * they are transferred to the transaction tlock list of</span>
<span class="cm">	 * the committing transaction of the inode)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xtid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
		<span class="n">TXN_UNLOCK</span><span class="p">();</span>
		<span class="n">tblk</span> <span class="o">=</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The order of the tlocks in the transaction is important</span>
<span class="cm">		 * (during truncate, child xtree pages must be freed before</span>
<span class="cm">		 * parent&#39;s tlocks change the working map).</span>
<span class="cm">		 * Take tlock off anonymous list and add to tail of</span>
<span class="cm">		 * transaction list</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note:  We really need to get rid of the tid &amp; lid and</span>
<span class="cm">		 * use list_head&#39;s.  This code is getting UGLY!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span> <span class="o">==</span> <span class="n">lid</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">==</span> <span class="n">lid</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* only anonymous txn.</span>
<span class="cm">				 * Remove from anon_list</span>
<span class="cm">				 */</span>
				<span class="n">TXN_LOCK</span><span class="p">();</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">anon_inode_list</span><span class="p">);</span>
				<span class="n">TXN_UNLOCK</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lid_t</span> <span class="n">last</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">last</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span><span class="p">;</span>
			     <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">last</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">lid</span><span class="p">;</span>
			     <span class="n">last</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">last</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">assert</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">last</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">==</span> <span class="n">lid</span><span class="p">)</span>
				<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* insert the tlock at tail of transaction tlock list */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">grantLock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">waitLock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate a tlock</span>
<span class="cm">	 */</span>
      <span class="nl">allocateLock:</span>
	<span class="n">lid</span> <span class="o">=</span> <span class="n">txLockAlloc</span><span class="p">();</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize tlock</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>

	<span class="n">TXN_UNLOCK</span><span class="p">();</span>

	<span class="cm">/* mark tlock for meta-data page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PAGE</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">tlckPAGELOCK</span><span class="p">;</span>

		<span class="cm">/* mark the page dirty and nohomeok */</span>
		<span class="n">metapage_nohomeok</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p&quot;</span><span class="p">,</span>
			 <span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">nohomeok</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>

		<span class="cm">/* if anonymous transaction, and buffer is on the group</span>
<span class="cm">		 * commit synclist, mark inode to show this.  This will</span>
<span class="cm">		 * prevent the buffer from being marked nohomeok for too</span>
<span class="cm">		 * long a time.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span><span class="p">)</span>
			<span class="n">set_cflag</span><span class="p">(</span><span class="n">COMMIT_Synclist</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* mark tlock for in-memory inode */</span>
	<span class="k">else</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">tlckINODELOCK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckDIRECTORY</span><span class="p">;</span>

	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* bind the tlock and the page */</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir_xtree</span><span class="p">)</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">xtlid</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">lid</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * enqueue transaction lock to transaction/inode</span>
<span class="cm">	 */</span>
	<span class="cm">/* insert the tlock at tail of transaction tlock list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tblk</span> <span class="o">=</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* anonymous transaction:</span>
<span class="cm">	 * insert the tlock at head of inode anonymous tlock list</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span><span class="p">;</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This inode&#39;s first anonymous transaction */</span>
			<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
			<span class="n">TXN_LOCK</span><span class="p">();</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">anon_inode_list</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">);</span>
			<span class="n">TXN_UNLOCK</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* initialize type dependent area for linelock */</span>
	<span class="n">linelock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">tlckLINELOCK</span><span class="p">;</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">maxcnt</span> <span class="o">=</span> <span class="n">TLOCKSHORT</span><span class="p">;</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckTYPE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">tlckDTREE</span>:
		<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">l2linesize</span> <span class="o">=</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">tlckXTREE</span>:
		<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">l2linesize</span> <span class="o">=</span> <span class="n">L2XTSLOTSIZE</span><span class="p">;</span>

		<span class="n">xtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xtlock</span> <span class="o">*</span><span class="p">)</span> <span class="n">linelock</span><span class="p">;</span>
		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckNEW</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">lwm</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">XTENTRYSTART</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PAGE</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">xtpage_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_xtroot</span><span class="p">;</span>
			<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">lwm</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span>
			    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">lwm</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* ! */</span>
		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">twm</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">hwm</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">tlckINODE</span>:
		<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">l2linesize</span> <span class="o">=</span> <span class="n">L2INODESLOTSIZE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">tlckDATA</span>:
		<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">l2linesize</span> <span class="o">=</span> <span class="n">L2DATASLOTSIZE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;UFO tlock:0x%p&quot;</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * update tlock vector</span>
<span class="cm">	 */</span>
      <span class="nl">grantLock:</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tlck</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * page is being locked by another transaction:</span>
<span class="cm">	 */</span>
      <span class="nl">waitLock:</span>
	<span class="cm">/* Only locks on ipimap or ipaimap should reach here */</span>
	<span class="cm">/* assert(jfs_ip-&gt;fileset == AGGREGATE_I); */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">fileset</span> <span class="o">!=</span> <span class="n">AGGREGATE_I</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;txLock: trying to lock locked page!&quot;</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;ip: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
			       <span class="n">ip</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ip</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;mp: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
			       <span class="n">mp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Locker&#39;s tblock: &quot;</span><span class="p">,</span>
			       <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">tid</span><span class="p">),</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Tlock: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
			       <span class="n">tlck</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tlck</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">INCREMENT</span><span class="p">(</span><span class="n">stattx</span><span class="p">.</span><span class="n">waitlock</span><span class="p">);</span>	<span class="cm">/* statistics */</span>
	<span class="n">TXN_UNLOCK</span><span class="p">();</span>
	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">TXN_LOCK</span><span class="p">();</span>
	<span class="n">xtid</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">;</span>	<span class="cm">/* reacquire after dropping TXN_LOCK */</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txLock: in waitLock, tid = %d, xtid = %d, lid = %d&quot;</span><span class="p">,</span>
		 <span class="n">tid</span><span class="p">,</span> <span class="n">xtid</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>

	<span class="cm">/* Recheck everything since dropping TXN_LOCK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xtid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">==</span> <span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">lid</span> <span class="o">==</span> <span class="n">lid</span><span class="p">))</span>
		<span class="n">TXN_SLEEP_DROP_LOCK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">xtid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">waitor</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">TXN_UNLOCK</span><span class="p">();</span>
	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txLock: awakened     tid = %d, lid = %d&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	txRelease()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Release buffers associated with transaction locks, but don&#39;t</span>
<span class="cm"> *		mark homeok yet.  The allows other transactions to modify</span>
<span class="cm"> *		buffers, but won&#39;t let them go to disk until commit record</span>
<span class="cm"> *		actually gets written.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETER:</span>
<span class="cm"> *		tblk	-</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:	Errors from subroutines.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">txRelease</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>

	<span class="n">TXN_LOCK</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">lid</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">lid</span><span class="p">;</span> <span class="n">lid</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckBTROOT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PAGE</span><span class="p">);</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">lid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * wakeup transactions waiting on a page locked</span>
<span class="cm">	 * by the current transaction</span>
<span class="cm">	 */</span>
	<span class="n">TXN_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">waitor</span><span class="p">);</span>

	<span class="n">TXN_UNLOCK</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	txUnlock()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Initiates pageout of pages modified by tid in journalled</span>
<span class="cm"> *		objects and frees their lockwords.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">txUnlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="n">linelock</span><span class="p">;</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">llid</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">difft</span><span class="p">,</span> <span class="n">diffp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txUnlock: tblk = 0x%p&quot;</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
	<span class="n">log</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mark page under tlock homeok (its log has been written):</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lid</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">lid</span><span class="p">;</span> <span class="n">lid</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;unlocking lid = %d, tlck = 0x%p&quot;</span><span class="p">,</span> <span class="n">lid</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>

		<span class="cm">/* unbind page from tlock */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckBTROOT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PAGE</span><span class="p">);</span>

			<span class="cm">/* hold buffer</span>
<span class="cm">			 */</span>
			<span class="n">hold_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

			<span class="n">assert</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nohomeok</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">_metapage_homeok</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

			<span class="cm">/* inherit younger/larger clsn */</span>
			<span class="n">LOGSYNC_LOCK</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">logdiff</span><span class="p">(</span><span class="n">difft</span><span class="p">,</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
				<span class="n">logdiff</span><span class="p">(</span><span class="n">diffp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">difft</span> <span class="o">&gt;</span> <span class="n">diffp</span><span class="p">)</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">;</span>
			<span class="n">LOGSYNC_UNLOCK</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tlckFREEPAGE</span><span class="p">));</span>

			<span class="n">put_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* insert tlock, and linelock(s) of the tlock if any,</span>
<span class="cm">		 * at head of freelist</span>
<span class="cm">		 */</span>
		<span class="n">TXN_LOCK</span><span class="p">();</span>

		<span class="n">llid</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">llid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">linelock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">llid</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">linelock</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">txLockFree</span><span class="p">(</span><span class="n">llid</span><span class="p">);</span>
			<span class="n">llid</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">txLockFree</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>

		<span class="n">TXN_UNLOCK</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * remove tblock from logsynclist</span>
<span class="cm">	 * (allocation map pages inherited lsn of tblk and</span>
<span class="cm">	 * has been inserted in logsync list at txUpdateMap())</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">lsn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LOGSYNC_LOCK</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">);</span>
		<span class="n">LOGSYNC_UNLOCK</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txMaplock()</span>
<span class="cm"> *</span>
<span class="cm"> * function: allocate a transaction lock for freed page/entry;</span>
<span class="cm"> *	for freed page, maplock is used as xtlock/dtlock type;</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="nf">txMaplock</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">tblk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span><span class="n">maplock</span><span class="p">;</span>

	<span class="n">TXN_LOCK</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate a tlock</span>
<span class="cm">	 */</span>
	<span class="n">lid</span> <span class="o">=</span> <span class="n">txLockAlloc</span><span class="p">();</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize tlock</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>

	<span class="cm">/* bind the tlock and the object */</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">tlckINODELOCK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckDIRECTORY</span><span class="p">;</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * enqueue transaction lock to transaction/inode</span>
<span class="cm">	 */</span>
	<span class="cm">/* insert the tlock at tail of transaction tlock list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tblk</span> <span class="o">=</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* anonymous transaction:</span>
<span class="cm">	 * insert the tlock at head of inode anonymous tlock list</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span><span class="p">;</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This inode&#39;s first anonymous transaction */</span>
			<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">anon_inode_list</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">TXN_UNLOCK</span><span class="p">();</span>

	<span class="cm">/* initialize type dependent area for maplock */</span>
	<span class="n">maplock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">maxcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tlck</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txLinelock()</span>
<span class="cm"> *</span>
<span class="cm"> * function: allocate a transaction lock for log vector list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="nf">txLinelock</span><span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span> <span class="n">tlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="n">linelock</span><span class="p">;</span>

	<span class="n">TXN_LOCK</span><span class="p">();</span>

	<span class="cm">/* allocate a TxLock structure */</span>
	<span class="n">lid</span> <span class="o">=</span> <span class="n">txLockAlloc</span><span class="p">();</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>

	<span class="n">TXN_UNLOCK</span><span class="p">();</span>

	<span class="cm">/* initialize linelock */</span>
	<span class="n">linelock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="n">tlck</span><span class="p">;</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">tlckLINELOCK</span><span class="p">;</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">maxcnt</span> <span class="o">=</span> <span class="n">TLOCKLONG</span><span class="p">;</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tlckDIRECTORY</span><span class="p">)</span>
		<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckDIRECTORY</span><span class="p">;</span>

	<span class="cm">/* append linelock after tlock */</span>
	<span class="n">linelock</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tlock</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">tlock</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">linelock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *		transaction commit management</span>
<span class="cm"> *		-----------------------------</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	txCommit()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	commit the changes to the objects specified in</span>
<span class="cm"> *		clist.  For journalled segments only the</span>
<span class="cm"> *		changes of the caller are committed, ie by tid.</span>
<span class="cm"> *		for non-journalled segments the data are flushed to</span>
<span class="cm"> *		disk and then the change to the disk inode and indirect</span>
<span class="cm"> *		blocks committed (so blocks newly allocated to the</span>
<span class="cm"> *		segment will be made a part of the segment atomically).</span>
<span class="cm"> *</span>
<span class="cm"> *		all of the segments specified in clist must be in</span>
<span class="cm"> *		one file system. no more than 6 segments are needed</span>
<span class="cm"> *		to handle all unix svcs.</span>
<span class="cm"> *</span>
<span class="cm"> *		if the i_nlink field (i.e. disk inode link count)</span>
<span class="cm"> *		is zero, and the type of inode is a regular file or</span>
<span class="cm"> *		directory, or symbolic link , the inode is truncated</span>
<span class="cm"> *		to zero length. the truncation is committed but the</span>
<span class="cm"> *		VM resources are unaffected until it is closed (see</span>
<span class="cm"> *		iput and iclose).</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETER:</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:</span>
<span class="cm"> *</span>
<span class="cm"> * serialization:</span>
<span class="cm"> *		on entry the inode lock on each segment is assumed</span>
<span class="cm"> *		to be held.</span>
<span class="cm"> *</span>
<span class="cm"> * i/o error:</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">txCommit</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span>		<span class="cm">/* transaction identifier */</span>
	     <span class="kt">int</span> <span class="n">nip</span><span class="p">,</span>		<span class="cm">/* number of inodes to commit */</span>
	     <span class="k">struct</span> <span class="n">inode</span> <span class="o">**</span><span class="n">iplist</span><span class="p">,</span>	<span class="cm">/* list of inode to commit */</span>
	     <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">commit</span> <span class="n">cd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">tblk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span><span class="n">lrd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">top</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txCommit, tid = %d, flag = %d&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="cm">/* is read-only file system ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isReadOnly</span><span class="p">(</span><span class="n">iplist</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">TheEnd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">cd</span><span class="p">.</span><span class="n">sb</span> <span class="o">=</span> <span class="n">iplist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">cd</span><span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="n">txBegin</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tblk</span> <span class="o">=</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize commit structure</span>
<span class="cm">	 */</span>
	<span class="n">log</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>
	<span class="n">cd</span><span class="p">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span><span class="p">;</span>

	<span class="cm">/* initialize log record descriptor in commit */</span>
	<span class="n">lrd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cd</span><span class="p">.</span><span class="n">lrd</span><span class="p">;</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">logtid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">logtid</span><span class="p">);</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">|=</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">COMMIT_FORCE</span> <span class="o">|</span> <span class="n">COMMIT_SYNC</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">|=</span> <span class="n">COMMIT_LAZY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	prepare non-journaled objects for commit</span>
<span class="cm">	 *</span>
<span class="cm">	 * flush data pages of non-journaled file</span>
<span class="cm">	 * to prevent the file getting non-initialized disk blocks</span>
<span class="cm">	 * in case of crash.</span>
<span class="cm">	 * (new blocks - )</span>
<span class="cm">	 */</span>
	<span class="n">cd</span><span class="p">.</span><span class="n">iplist</span> <span class="o">=</span> <span class="n">iplist</span><span class="p">;</span>
	<span class="n">cd</span><span class="p">.</span><span class="n">nip</span> <span class="o">=</span> <span class="n">nip</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	acquire transaction lock on (on-disk) inodes</span>
<span class="cm">	 *</span>
<span class="cm">	 * update on-disk inode from in-memory inode</span>
<span class="cm">	 * acquiring transaction locks for AFTER records</span>
<span class="cm">	 * on the on-disk inode of file object</span>
<span class="cm">	 *</span>
<span class="cm">	 * sort the inodes array by inode number in descending order</span>
<span class="cm">	 * to prevent deadlock when acquiring transaction lock</span>
<span class="cm">	 * of on-disk inodes on multiple on-disk inode pages by</span>
<span class="cm">	 * multiple concurrent transactions</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cd</span><span class="p">.</span><span class="n">nip</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">top</span> <span class="o">=</span> <span class="p">(</span><span class="n">cd</span><span class="p">.</span><span class="n">iplist</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">cd</span><span class="p">.</span><span class="n">nip</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ip</span> <span class="o">=</span> <span class="n">cd</span><span class="p">.</span><span class="n">iplist</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&gt;</span> <span class="n">top</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">top</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
				<span class="n">cd</span><span class="p">.</span><span class="n">iplist</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">cd</span><span class="p">.</span><span class="n">iplist</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
				<span class="n">cd</span><span class="p">.</span><span class="n">iplist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ip</span> <span class="o">=</span> <span class="n">cd</span><span class="p">.</span><span class="n">iplist</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * BUGBUG - This code has temporarily been removed.  The</span>
<span class="cm">		 * intent is to ensure that any file data is written before</span>
<span class="cm">		 * the metadata is committed to the journal.  This prevents</span>
<span class="cm">		 * uninitialized data from appearing in a file after the</span>
<span class="cm">		 * journal has been replayed.  (The uninitialized data</span>
<span class="cm">		 * could be sensitive data removed by another user.)</span>
<span class="cm">		 *</span>
<span class="cm">		 * The problem now is that we are holding the IWRITELOCK</span>
<span class="cm">		 * on the inode, and calling filemap_fdatawrite on an</span>
<span class="cm">		 * unmapped page will cause a deadlock in jfs_get_block.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The long term solution is to pare down the use of</span>
<span class="cm">		 * IWRITELOCK.  We are currently holding it too long.</span>
<span class="cm">		 * We could also be smarter about which data pages need</span>
<span class="cm">		 * to be written before the transaction is committed and</span>
<span class="cm">		 * when we don&#39;t need to worry about it at all.</span>
<span class="cm">		 *</span>
<span class="cm">		 * if ((!S_ISDIR(ip-&gt;i_mode))</span>
<span class="cm">		 *    &amp;&amp; (tblk-&gt;flag &amp; COMMIT_DELETE) == 0)</span>
<span class="cm">		 *	filemap_write_and_wait(ip-&gt;i_mapping);</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mark inode as not dirty.  It will still be on the dirty</span>
<span class="cm">		 * inode list, but we&#39;ll know not to commit it again unless</span>
<span class="cm">		 * it gets marked dirty again</span>
<span class="cm">		 */</span>
		<span class="n">clear_cflag</span><span class="p">(</span><span class="n">COMMIT_Dirty</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

		<span class="cm">/* inherit anonymous tlock(s) of inode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span>
				<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span><span class="p">;</span>
			<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">TXN_LOCK</span><span class="p">();</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">anon_inode_list</span><span class="p">);</span>
			<span class="n">TXN_UNLOCK</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * acquire transaction lock on on-disk inode page</span>
<span class="cm">		 * (become first tlock of the tblk&#39;s tlock list)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diWrite</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">))))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	write log records from transaction locks</span>
<span class="cm">	 *</span>
<span class="cm">	 * txUpdateMap() resets XAD_NEW in XAD.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">txLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cd</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">TheEnd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that inode isn&#39;t reused before</span>
<span class="cm">	 * lazy commit thread finishes processing</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_DELETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Avoid a rare deadlock</span>
<span class="cm">		 *</span>
<span class="cm">		 * If the inode is locked, we may be blocked in</span>
<span class="cm">		 * jfs_commit_inode.  If so, we don&#39;t want the</span>
<span class="cm">		 * lazy_commit thread doing the last iput() on the inode</span>
<span class="cm">		 * since that may block on the locked inode.  Instead,</span>
<span class="cm">		 * commit the transaction synchronously, so the last iput</span>
<span class="cm">		 * will be done by the calling thread (or later)</span>
<span class="cm">		 */</span>
		<span class="cm">/*</span>
<span class="cm">		 * I believe this code is no longer needed.  Splitting I_LOCK</span>
<span class="cm">		 * into two bits, I_NEW and I_SYNC should prevent this</span>
<span class="cm">		 * deadlock as well.  But since I don&#39;t have a JFS testload</span>
<span class="cm">		 * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.</span>
<span class="cm">		 * Joern</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">)</span>
			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">COMMIT_LAZY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_DELETE</span><span class="p">))</span> <span class="o">||</span>
	       <span class="p">((</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">test_cflag</span><span class="p">(</span><span class="n">COMMIT_Nolink</span><span class="p">,</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 *	write COMMIT log record</span>
<span class="cm">	 */</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_COMMIT</span><span class="p">);</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">lmGroupCommit</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	- transaction is now committed -</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * force pages in careful update</span>
<span class="cm">	 * (imap addressing structure update)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">COMMIT_FORCE</span><span class="p">)</span>
		<span class="n">txForce</span><span class="p">(</span><span class="n">tblk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	update allocation map.</span>
<span class="cm">	 *</span>
<span class="cm">	 * update inode allocation map and inode:</span>
<span class="cm">	 * free pager lock on memory object of inode if any.</span>
<span class="cm">	 * update block allocation map.</span>
<span class="cm">	 *</span>
<span class="cm">	 * txUpdateMap() resets XAD_NEW in XAD.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_FORCE</span><span class="p">)</span>
		<span class="n">txUpdateMap</span><span class="p">(</span><span class="n">tblk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	free transaction locks and pageout/free pages</span>
<span class="cm">	 */</span>
	<span class="n">txRelease</span><span class="p">(</span><span class="n">tblk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tblkGC_LAZY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">txUnlock</span><span class="p">(</span><span class="n">tblk</span><span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 *	reset in-memory object state</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cd</span><span class="p">.</span><span class="n">nip</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">cd</span><span class="p">.</span><span class="n">iplist</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * reset in-memory inode state</span>
<span class="cm">		 */</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">bxflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">blid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">txAbort</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

      <span class="nl">TheEnd:</span>
	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txCommit: tid = %d, returning %d&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	txLog()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Writes AFTER log records for all lines modified</span>
<span class="cm"> *		by tid for segments specified by inodes in comdata.</span>
<span class="cm"> *		Code assumes only WRITELOCKS are recorded in lockwords.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN :</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">txLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">commit</span> <span class="o">*</span> <span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span><span class="n">lrd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">lrd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * write log record(s) for each tlock of transaction,</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lid</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">lid</span><span class="p">;</span> <span class="n">lid</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>

		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckLOG</span><span class="p">;</span>

		<span class="cm">/* initialize lrd common */</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">aggregate</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">aggregate</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">fileset</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fileset</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

		<span class="cm">/* write log record of page from the tlock */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckTYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">tlckXTREE</span>:
			<span class="n">xtLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">tlckDTREE</span>:
			<span class="n">dtLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">tlckINODE</span>:
			<span class="n">diLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">tlckMAP</span>:
			<span class="n">mapLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">tlckDATA</span>:
			<span class="n">dataLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;UFO tlock:0x%p&quot;</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	diLog()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	log inode tlock and format maplock to update bmap;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">diLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">,</span> <span class="k">struct</span> <span class="n">commit</span> <span class="o">*</span> <span class="n">cd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>

	<span class="cm">/* initialize as REDOPAGE record format */</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_INODE</span><span class="p">);</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">l2linesize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">L2INODESLOTSIZE</span><span class="p">);</span>

	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">pxd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	inode after image</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckENTRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* log after-image for logredo(): */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_REDOPAGE</span><span class="p">);</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span>
			  <span class="n">mp</span><span class="o">-&gt;</span><span class="n">logical_size</span> <span class="o">&gt;&gt;</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>

		<span class="cm">/* mark page as homeward bound */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckWRITEPAGE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckFREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	free inode extent</span>
<span class="cm">		 *</span>
<span class="cm">		 * (pages of the freed inode extent have been invalidated and</span>
<span class="cm">		 * a maplock for free of the extent has been formatted at</span>
<span class="cm">		 * txLock() time);</span>
<span class="cm">		 *</span>
<span class="cm">		 * the tlock had been acquired on the inode allocation map page</span>
<span class="cm">		 * (iag) that specifies the freed extent, even though the map</span>
<span class="cm">		 * page is not itself logged, to prevent pageout of the map</span>
<span class="cm">		 * page before the log;</span>
<span class="cm">		 */</span>

		<span class="cm">/* log LOG_NOREDOINOEXT of the freed inode extent for</span>
<span class="cm">		 * logredo() to start NoRedoPage filters, and to update</span>
<span class="cm">		 * imap and bmap for free of the extent;</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_NOREDOINOEXT</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * For the LOG_NOREDOINOEXT record, we need</span>
<span class="cm">		 * to pass the IAG number and inode extent</span>
<span class="cm">		 * index (within that IAG) from which the</span>
<span class="cm">		 * the extent being released.  These have been</span>
<span class="cm">		 * passed to us in the iplist[1] and iplist[2].</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">noredoinoext</span><span class="p">.</span><span class="n">iagnum</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">iplist</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">noredoinoext</span><span class="p">.</span><span class="n">inoext_idx</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">iplist</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

		<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">;</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>

		<span class="cm">/* update bmap */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>

		<span class="cm">/* mark page as homeward bound */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckWRITEPAGE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diLog: UFO type tlck:0x%p&quot;</span><span class="p">,</span> <span class="n">tlck</span><span class="p">);</span>
<span class="cp">#ifdef  _JFS_WIP</span>
	<span class="cm">/*</span>
<span class="cm">	 *	alloc/free external EA extent</span>
<span class="cm">	 *</span>
<span class="cm">	 * a maplock for txUpdateMap() to update bPWMAP for alloc/free</span>
<span class="cm">	 * of the extent has been formatted at txLock() time;</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckEA</span><span class="p">);</span>

		<span class="cm">/* log LOG_UPDATEMAP for logredo() to update bmap for</span>
<span class="cm">		 * alloc of new (and free of old) external EA extent;</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_UPDATEMAP</span><span class="p">);</span>
		<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="n">nlock</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlock</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pxdlock</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckALLOCPXD</span><span class="p">)</span>
				<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span>
				    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_ALLOCPXD</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span>
				    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_FREEPXD</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">nxd</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">;</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* update bmap */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* _JFS_WIP */</span><span class="cp"></span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	dataLog()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	log data tlock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dataLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
	    <span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>

	<span class="cm">/* initialize as REDOPAGE record format */</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_DATA</span><span class="p">);</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">l2linesize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">L2DATASLOTSIZE</span><span class="p">);</span>

	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">pxd</span><span class="p">;</span>

	<span class="cm">/* log after-image for logredo(): */</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_REDOPAGE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jfs_dirtable_inline</span><span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The table has been truncated, we&#39;ve must have deleted</span>
<span class="cm">		 * the last entry, so don&#39;t bother logging this</span>
<span class="cm">		 */</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">lid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">grab_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">metapage_homeok</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">discard_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">logical_size</span> <span class="o">&gt;&gt;</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>

	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>

	<span class="cm">/* mark page as homeward bound */</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckWRITEPAGE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	dtLog()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	log dtree tlock and format maplock to update bmap;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
	   <span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>

	<span class="cm">/* initialize as REDOPAGE/NOREDOPAGE record format */</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_DTREE</span><span class="p">);</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">l2linesize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">L2DTSLOTSIZE</span><span class="p">);</span>

	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">pxd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckBTROOT</span><span class="p">)</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_BTROOT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	page extension via relocation: entry insertion;</span>
<span class="cm">	 *	page extension in-place: entry insertion;</span>
<span class="cm">	 *	new right page from page split, reinitialized in-line</span>
<span class="cm">	 *	root from root page split: entry insertion;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tlckNEW</span> <span class="o">|</span> <span class="n">tlckEXTEND</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* log after-image of the new page for logredo():</span>
<span class="cm">		 * mark log (LOG_NEW) for logredo() to initialize</span>
<span class="cm">		 * freelist and update bmap for alloc of the new page;</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_REDOPAGE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckEXTEND</span><span class="p">)</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_EXTEND</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_NEW</span><span class="p">);</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span>
			  <span class="n">mp</span><span class="o">-&gt;</span><span class="n">logical_size</span> <span class="o">&gt;&gt;</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>

		<span class="cm">/* format a maplock for txUpdateMap() to update bPMAP for</span>
<span class="cm">		 * alloc of the new page;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckBTROOT</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
		<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckALLOCPXD</span><span class="p">;</span>
		<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span> <span class="o">=</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

		<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* mark page as homeward bound */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckWRITEPAGE</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	entry insertion/deletion,</span>
<span class="cm">	 *	sibling page link update (old right page before split);</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tlckENTRY</span> <span class="o">|</span> <span class="n">tlckRELINK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* log after-image for logredo(): */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_REDOPAGE</span><span class="p">);</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span>
			  <span class="n">mp</span><span class="o">-&gt;</span><span class="n">logical_size</span> <span class="o">&gt;&gt;</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>

		<span class="cm">/* mark page as homeward bound */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckWRITEPAGE</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	page deletion: page has been invalidated</span>
<span class="cm">	 *	page relocation: source extent</span>
<span class="cm">	 *</span>
<span class="cm">	 *	a maplock for free of the page has been formatted</span>
<span class="cm">	 *	at txLock() time);</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tlckFREE</span> <span class="o">|</span> <span class="n">tlckRELOCATE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* log LOG_NOREDOPAGE of the deleted page for logredo()</span>
<span class="cm">		 * to start NoRedoPage filter and to update bmap for free</span>
<span class="cm">		 * of the deletd page</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_NOREDOPAGE</span><span class="p">);</span>
		<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">;</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>

		<span class="cm">/* a maplock for txUpdateMap() for free of the page</span>
<span class="cm">		 * has been formatted at txLock() time;</span>
<span class="cm">		 */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	xtLog()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	log xtree tlock and format maplock to update bmap;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">xtLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
	   <span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xtlock</span> <span class="o">*</span><span class="n">xtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span><span class="n">maplock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="n">xadlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">page_pxd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next</span><span class="p">,</span> <span class="n">lwm</span><span class="p">,</span> <span class="n">hwm</span><span class="p">;</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>

	<span class="cm">/* initialize as REDOPAGE/NOREDOPAGE record format */</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_XTREE</span><span class="p">);</span>
	<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">l2linesize</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">L2XTSLOTSIZE</span><span class="p">);</span>

	<span class="n">page_pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">pxd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckBTROOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_BTROOT</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_xtroot</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">type</span> <span class="o">|=</span>
			    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_DIR_XTREE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">xtpage_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">);</span>

	<span class="n">xtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xtlock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="n">maplock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">xadlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	entry insertion/extension;</span>
<span class="cm">	 *	sibling page link update (old right page before split);</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tlckNEW</span> <span class="o">|</span> <span class="n">tlckGROW</span> <span class="o">|</span> <span class="n">tlckRELINK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* log after-image for logredo():</span>
<span class="cm">		 * logredo() will update bmap for alloc of new/extended</span>
<span class="cm">		 * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from</span>
<span class="cm">		 * after-image of XADlist;</span>
<span class="cm">		 * logredo() resets (XAD_NEW|XAD_EXTEND) flag when</span>
<span class="cm">		 * applying the after-image to the meta-data page.</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_REDOPAGE</span><span class="p">);</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="n">page_pxd</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="n">page_pxd</span><span class="p">,</span>
			  <span class="n">mp</span><span class="o">-&gt;</span><span class="n">logical_size</span> <span class="o">&gt;&gt;</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>

		<span class="cm">/* format a maplock for txUpdateMap() to update bPMAP</span>
<span class="cm">		 * for alloc of new/extended extents of XAD[lwm:next)</span>
<span class="cm">		 * from the page itself;</span>
<span class="cm">		 * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.</span>
<span class="cm">		 */</span>
		<span class="n">lwm</span> <span class="o">=</span> <span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">lwm</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lwm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lwm</span> <span class="o">=</span> <span class="n">XTPAGEMAXSLOT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lwm</span> <span class="o">==</span> <span class="n">next</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lwm</span> <span class="o">&gt;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;xtLog: lwm &gt; next</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
		<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckALLOCXADLIST</span><span class="p">;</span>
		<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">lwm</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_LAZY</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Lazy commit may allow xtree to be modified before</span>
<span class="cm">			 * txUpdateMap runs.  Copy xad into linelock to</span>
<span class="cm">			 * preserve correct data.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We can fit twice as may pxd&#39;s as xads in the lock</span>
<span class="cm">			 */</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckALLOCPXDLIST</span><span class="p">;</span>
			<span class="n">pxd</span> <span class="o">=</span> <span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">xdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">pxdlock</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">addressXAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lwm</span> <span class="o">+</span> <span class="n">i</span><span class="p">]));</span>
				<span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">lengthXAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lwm</span> <span class="o">+</span> <span class="n">i</span><span class="p">]));</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lwm</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">flag</span> <span class="o">&amp;=</span>
				    <span class="o">~</span><span class="p">(</span><span class="n">XAD_NEW</span> <span class="o">|</span> <span class="n">XAD_EXTENDED</span><span class="p">);</span>
				<span class="n">pxd</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * xdlist will point to into inode&#39;s xtree, ensure</span>
<span class="cm">			 * that transaction is not committed lazily.</span>
<span class="cm">			 */</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckALLOCXADLIST</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">xdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lwm</span><span class="p">];</span>
			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">COMMIT_LAZY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d &quot;</span>
			 <span class="s">&quot;count:%d&quot;</span><span class="p">,</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlck</span><span class="p">,</span> <span class="n">lwm</span><span class="p">,</span> <span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

		<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	      <span class="nl">out:</span>
		<span class="cm">/* mark page as homeward bound */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckWRITEPAGE</span><span class="p">;</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	page deletion: file deletion/truncation (ref. xtTruncate())</span>
<span class="cm">	 *</span>
<span class="cm">	 * (page will be invalidated after log is written and bmap</span>
<span class="cm">	 * is updated from the page);</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckFREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* LOG_NOREDOPAGE log for NoRedoPage filter:</span>
<span class="cm">		 * if page free from file delete, NoRedoFile filter from</span>
<span class="cm">		 * inode image of zero link count will subsume NoRedoPage</span>
<span class="cm">		 * filters for each page;</span>
<span class="cm">		 * if page free from file truncattion, write NoRedoPage</span>
<span class="cm">		 * filter;</span>
<span class="cm">		 *</span>
<span class="cm">		 * upadte of block allocation map for the page itself:</span>
<span class="cm">		 * if page free from deletion and truncation, LOG_UPDATEMAP</span>
<span class="cm">		 * log for the page itself is generated from processing</span>
<span class="cm">		 * its parent page xad entries;</span>
<span class="cm">		 */</span>
		<span class="cm">/* if page free from file truncation, log LOG_NOREDOPAGE</span>
<span class="cm">		 * of the deleted page for logredo() to start NoRedoPage</span>
<span class="cm">		 * filter for the page;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_TRUNCATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* write NOREDOPAGE for the page */</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_NOREDOPAGE</span><span class="p">);</span>
			<span class="n">PXDaddress</span><span class="p">(</span><span class="n">page_pxd</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
			<span class="n">PXDlength</span><span class="p">(</span><span class="n">page_pxd</span><span class="p">,</span>
				  <span class="n">mp</span><span class="o">-&gt;</span><span class="n">logical_size</span> <span class="o">&gt;&gt;</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span>
				  <span class="n">s_blocksize_bits</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckBTROOT</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Empty xtree must be logged */</span>
				<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_REDOPAGE</span><span class="p">);</span>
				<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span>
				    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* init LOG_UPDATEMAP of the freed extents</span>
<span class="cm">		 * XAD[XTENTRYSTART:hwm) from the deleted page itself</span>
<span class="cm">		 * for logredo() to update bmap;</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_UPDATEMAP</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_FREEXADLIST</span><span class="p">);</span>
		<span class="n">xtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xtlock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="n">hwm</span> <span class="o">=</span> <span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">hwm</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">nxd</span> <span class="o">=</span>
		    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">hwm</span> <span class="o">-</span> <span class="n">XTENTRYSTART</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* reformat linelock for lmLog() */</span>
		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">XTENTRYSTART</span><span class="p">;</span>
		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">hwm</span> <span class="o">-</span> <span class="n">XTENTRYSTART</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>

		<span class="cm">/* format a maplock for txUpdateMap() to update bmap</span>
<span class="cm">		 * to free extents of XAD[XTENTRYSTART:hwm) from the</span>
<span class="cm">		 * deleted page itself;</span>
<span class="cm">		 */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
		<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">hwm</span> <span class="o">-</span> <span class="n">XTENTRYSTART</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_LAZY</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Lazy commit may allow xtree to be modified before</span>
<span class="cm">			 * txUpdateMap runs.  Copy xad into linelock to</span>
<span class="cm">			 * preserve correct data.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We can fit twice as may pxd&#39;s as xads in the lock</span>
<span class="cm">			 */</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEPXDLIST</span><span class="p">;</span>
			<span class="n">pxd</span> <span class="o">=</span> <span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">xdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">pxdlock</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span>
					<span class="n">addressXAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">XTENTRYSTART</span> <span class="o">+</span> <span class="n">i</span><span class="p">]));</span>
				<span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span>
					<span class="n">lengthXAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">XTENTRYSTART</span> <span class="o">+</span> <span class="n">i</span><span class="p">]));</span>
				<span class="n">pxd</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * xdlist will point to into inode&#39;s xtree, ensure</span>
<span class="cm">			 * that transaction is not committed lazily.</span>
<span class="cm">			 */</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEXADLIST</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">xdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">XTENTRYSTART</span><span class="p">];</span>
			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">COMMIT_LAZY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;xtLog: free ip:0x%p mp:0x%p count:%d lwm:2&quot;</span><span class="p">,</span>
			 <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

		<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* mark page as invalid */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PWMAP</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckBTROOT</span><span class="p">))</span>
			<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckFREEPAGE</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		   else (tblk-&gt;xflag &amp; COMMIT_PMAP)</span>
<span class="cm">		   ? release the page;</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	page/entry truncation: file truncation (ref. xtTruncate())</span>
<span class="cm">	 *</span>
<span class="cm">	 *	|----------+------+------+---------------|</span>
<span class="cm">	 *		   |      |      |</span>
<span class="cm">	 *		   |      |     hwm - hwm before truncation</span>
<span class="cm">	 *		   |     next - truncation point</span>
<span class="cm">	 *		  lwm - lwm before truncation</span>
<span class="cm">	 * header ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckTRUNCATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This odd declaration suppresses a bogus gcc warning */</span>
		<span class="n">pxd_t</span> <span class="n">pxd</span> <span class="o">=</span> <span class="n">pxd</span><span class="p">;</span>	<span class="cm">/* truncated extent of xad */</span>
		<span class="kt">int</span> <span class="n">twm</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For truncation the entire linelock may be used, so it would</span>
<span class="cm">		 * be difficult to store xad list in linelock itself.</span>
<span class="cm">		 * Therefore, we&#39;ll just force transaction to be committed</span>
<span class="cm">		 * synchronously, so that xtree pages won&#39;t be changed before</span>
<span class="cm">		 * txUpdateMap runs.</span>
<span class="cm">		 */</span>
		<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">COMMIT_LAZY</span><span class="p">;</span>
		<span class="n">lwm</span> <span class="o">=</span> <span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">lwm</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lwm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lwm</span> <span class="o">=</span> <span class="n">XTPAGEMAXSLOT</span><span class="p">;</span>
		<span class="n">hwm</span> <span class="o">=</span> <span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">hwm</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">twm</span> <span class="o">=</span> <span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">twm</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	write log records</span>
<span class="cm">		 */</span>
		<span class="cm">/* log after-image for logredo():</span>
<span class="cm">		 *</span>
<span class="cm">		 * logredo() will update bmap for alloc of new/extended</span>
<span class="cm">		 * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from</span>
<span class="cm">		 * after-image of XADlist;</span>
<span class="cm">		 * logredo() resets (XAD_NEW|XAD_EXTEND) flag when</span>
<span class="cm">		 * applying the after-image to the meta-data page.</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_REDOPAGE</span><span class="p">);</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="n">page_pxd</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="n">page_pxd</span><span class="p">,</span>
			  <span class="n">mp</span><span class="o">-&gt;</span><span class="n">logical_size</span> <span class="o">&gt;&gt;</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * truncate entry XAD[twm == next - 1]:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">twm</span> <span class="o">==</span> <span class="n">next</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* init LOG_UPDATEMAP for logredo() to update bmap for</span>
<span class="cm">			 * free of truncated delta extent of the truncated</span>
<span class="cm">			 * entry XAD[next - 1]:</span>
<span class="cm">			 * (xtlck-&gt;pxdlock = truncated delta extent);</span>
<span class="cm">			 */</span>
			<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">pxdlock</span><span class="p">;</span>
			<span class="cm">/* assert(pxdlock-&gt;type &amp; tlckTRUNCATE); */</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_UPDATEMAP</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_FREEPXD</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">nxd</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">;</span>
			<span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">;</span>	<span class="cm">/* save to format maplock */</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * free entries XAD[next:hwm]:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwm</span> <span class="o">&gt;=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* init LOG_UPDATEMAP of the freed extents</span>
<span class="cm">			 * XAD[next:hwm] from the deleted page itself</span>
<span class="cm">			 * for logredo() to update bmap;</span>
<span class="cm">			 */</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_UPDATEMAP</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span>
			    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_FREEXADLIST</span><span class="p">);</span>
			<span class="n">xtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xtlock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
			<span class="n">hwm</span> <span class="o">=</span> <span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">hwm</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">nxd</span> <span class="o">=</span>
			    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">hwm</span> <span class="o">-</span> <span class="n">next</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/* reformat linelock for lmLog() */</span>
			<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">hwm</span> <span class="o">-</span> <span class="n">next</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="n">tlck</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *	format maplock(s) for txUpdateMap() to update bmap</span>
<span class="cm">		 */</span>
		<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * allocate entries XAD[lwm:next):</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lwm</span> <span class="o">&lt;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* format a maplock for txUpdateMap() to update bPMAP</span>
<span class="cm">			 * for alloc of new/extended extents of XAD[lwm:next)</span>
<span class="cm">			 * from the page itself;</span>
<span class="cm">			 * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.</span>
<span class="cm">			 */</span>
			<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckALLOCXADLIST</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">lwm</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">xdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lwm</span><span class="p">];</span>

			<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;xtLog: alloc ip:0x%p mp:0x%p count:%d &quot;</span>
				 <span class="s">&quot;lwm:%d next:%d&quot;</span><span class="p">,</span>
				 <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">lwm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
			<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * truncate entry XAD[twm == next - 1]:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">twm</span> <span class="o">==</span> <span class="n">next</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* format a maplock for txUpdateMap() to update bmap</span>
<span class="cm">			 * to free truncated delta extent of the truncated</span>
<span class="cm">			 * entry XAD[next - 1];</span>
<span class="cm">			 * (xtlck-&gt;pxdlock = truncated delta extent);</span>
<span class="cm">			 */</span>
			<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
			<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">xadlock</span><span class="p">;</span>
			<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEPXD</span><span class="p">;</span>
			<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxd</span><span class="p">;</span>

			<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;xtLog: truncate ip:0x%p mp:0x%p count:%d &quot;</span>
				 <span class="s">&quot;hwm:%d&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">hwm</span><span class="p">);</span>
			<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * free entries XAD[next:hwm]:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwm</span> <span class="o">&gt;=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* format a maplock for txUpdateMap() to update bmap</span>
<span class="cm">			 * to free extents of XAD[next:hwm] from thedeleted</span>
<span class="cm">			 * page itself;</span>
<span class="cm">			 */</span>
			<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEXADLIST</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">hwm</span> <span class="o">-</span> <span class="n">next</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">xdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>

			<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;xtLog: free ip:0x%p mp:0x%p count:%d &quot;</span>
				 <span class="s">&quot;next:%d hwm:%d&quot;</span><span class="p">,</span>
				 <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">xadlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">hwm</span><span class="p">);</span>
			<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* mark page as homeward bound */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckWRITEPAGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	mapLog()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	log from maplock of freed data extents;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mapLog</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lrd</span> <span class="o">*</span> <span class="n">lrd</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span> <span class="n">tlck</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nlock</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	page relocation: free the source page extent</span>
<span class="cm">	 *</span>
<span class="cm">	 * a maplock for txUpdateMap() for free of the page</span>
<span class="cm">	 * has been formatted at txLock() time saving the src</span>
<span class="cm">	 * relocated page address;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckRELOCATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* log LOG_NOREDOPAGE of the old relocated page</span>
<span class="cm">		 * for logredo() to start NoRedoPage filter;</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_NOREDOPAGE</span><span class="p">);</span>
		<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">redopage</span><span class="p">.</span><span class="n">pxd</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">;</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>

		<span class="cm">/* (N.B. currently, logredo() does NOT update bmap</span>
<span class="cm">		 * for free of the page itself for (LOG_XTREE|LOG_NOREDOPAGE);</span>
<span class="cm">		 * if page free from relocation, LOG_UPDATEMAP log is</span>
<span class="cm">		 * specifically generated now for logredo()</span>
<span class="cm">		 * to update bmap for free of src relocated page;</span>
<span class="cm">		 * (new flag LOG_RELOCATE may be introduced which will</span>
<span class="cm">		 * inform logredo() to start NORedoPage filter and also</span>
<span class="cm">		 * update block allocation map at the same time, thus</span>
<span class="cm">		 * avoiding an extra log write);</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_UPDATEMAP</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_FREEPXD</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">nxd</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">;</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>

		<span class="cm">/* a maplock for txUpdateMap() for free of the page</span>
<span class="cm">		 * has been formatted at txLock() time;</span>
<span class="cm">		 */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>

<span class="cm">	 * Otherwise it&#39;s not a relocate request</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* log LOG_UPDATEMAP for logredo() to update bmap for</span>
<span class="cm">		 * free of truncated/relocated delta extent of the data;</span>
<span class="cm">		 * e.g.: external EA extent, relocated/truncated extent</span>
<span class="cm">		 * from xtTailgate();</span>
<span class="cm">		 */</span>
		<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_UPDATEMAP</span><span class="p">);</span>
		<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="n">nlock</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlock</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">pxdlock</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckALLOCPXD</span><span class="p">)</span>
				<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span>
				    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_ALLOCPXD</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span>
				    <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">LOG_FREEPXD</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">nxd</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">.</span><span class="n">updatemap</span><span class="p">.</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">;</span>
			<span class="n">lrd</span><span class="o">-&gt;</span><span class="n">backchain</span> <span class="o">=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lmLog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tblk</span><span class="p">,</span> <span class="n">lrd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
			<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;mapLog: xaddr:0x%lx xlen:0x%x&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">),</span>
				 <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* update bmap */</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tlckUPDATEMAP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txEA()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	acquire maplock for EA/ACL extents or</span>
<span class="cm"> *		set COMMIT_INLINE flag;</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txEA</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">dxd_t</span> <span class="o">*</span> <span class="n">oldea</span><span class="p">,</span> <span class="n">dxd_t</span> <span class="o">*</span> <span class="n">newea</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">maplock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">pxdlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * format maplock for alloc of new EA extent</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newea</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Since the newea could be a completely zeroed entry we need to</span>
<span class="cm">		 * check for the two flags which indicate we should actually</span>
<span class="cm">		 * commit new EA data</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newea</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">DXD_EXTENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tlck</span> <span class="o">=</span> <span class="n">txMaplock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">tlckMAP</span><span class="p">);</span>
			<span class="n">maplock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
			<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
			<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckALLOCPXD</span><span class="p">;</span>
			<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">,</span> <span class="n">addressDXD</span><span class="p">(</span><span class="n">newea</span><span class="p">));</span>
			<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">,</span> <span class="n">lengthDXD</span><span class="p">(</span><span class="n">newea</span><span class="p">));</span>
			<span class="n">pxdlock</span><span class="o">++</span><span class="p">;</span>
			<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">newea</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">DXD_INLINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tlck</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">set_cflag</span><span class="p">(</span><span class="n">COMMIT_Inlineea</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * format maplock for free of old EA extent</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_cflag</span><span class="p">(</span><span class="n">COMMIT_Nolink</span><span class="p">,</span> <span class="n">ip</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">oldea</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">DXD_EXTENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tlck</span> <span class="o">=</span> <span class="n">txMaplock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">tlckMAP</span><span class="p">);</span>
			<span class="n">maplock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
			<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
			<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEPXD</span><span class="p">;</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">,</span> <span class="n">addressDXD</span><span class="p">(</span><span class="n">oldea</span><span class="p">));</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">,</span> <span class="n">lengthDXD</span><span class="p">(</span><span class="n">oldea</span><span class="p">));</span>
		<span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txForce()</span>
<span class="cm"> *</span>
<span class="cm"> * function: synchronously write pages locked by transaction</span>
<span class="cm"> *	     after txLog() but before txUpdateMap();</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">txForce</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * reverse the order of transaction tlocks in</span>
<span class="cm">	 * careful update order of address index pages</span>
<span class="cm">	 * (right to left, bottom up)</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="n">lid</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="n">lid</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * synchronously write the page, and</span>
<span class="cm">	 * hold the page for txUpdateMap();</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lid</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">lid</span><span class="p">;</span> <span class="n">lid</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckBTROOT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PAGE</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tlckWRITEPAGE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tlckWRITEPAGE</span><span class="p">;</span>

				<span class="cm">/* do not release page to freelist */</span>
				<span class="n">force_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">				/*</span>
<span class="c">				 * The &quot;right&quot; thing to do here is to</span>
<span class="c">				 * synchronously write the metadata.</span>
<span class="c">				 * With the current implementation this</span>
<span class="c">				 * is hard since write_metapage requires</span>
<span class="c">				 * us to kunmap &amp; remap the page.  If we</span>
<span class="c">				 * have tlocks pointing into the metadata</span>
<span class="c">				 * pages, we don&#39;t want to do this.  I think</span>
<span class="c">				 * we can get by with synchronously writing</span>
<span class="c">				 * the pages when they are released.</span>
<span class="c">				 */</span>
<span class="c">				assert(mp-&gt;nohomeok);</span>
<span class="c">				set_bit(META_dirty, &amp;mp-&gt;flag);</span>
<span class="c">				set_bit(META_sync, &amp;mp-&gt;flag);</span>
<span class="cp">#endif</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txUpdateMap()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	update persistent allocation map (and working map</span>
<span class="cm"> *		if appropriate);</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">txUpdateMap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span><span class="n">maplock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="n">pxdlock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maptype</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">nlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ipimap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipimap</span><span class="p">;</span>

	<span class="n">maptype</span> <span class="o">=</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PMAP</span><span class="p">)</span> <span class="o">?</span> <span class="n">COMMIT_PMAP</span> <span class="o">:</span> <span class="n">COMMIT_PWMAP</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 *	update block allocation map</span>
<span class="cm">	 *</span>
<span class="cm">	 * update allocation state in pmap (and wmap) and</span>
<span class="cm">	 * update lsn of the pmap page;</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * scan each tlock/page of transaction for block allocation/free:</span>
<span class="cm">	 *</span>
<span class="cm">	 * for each tlock/page of transaction, update map.</span>
<span class="cm">	 *  ? are there tlock for pmap and pwmap at the same time ?</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lid</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">lid</span><span class="p">;</span> <span class="n">lid</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tlckUPDATEMAP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tlckFREEPAGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Another thread may attempt to reuse freed space</span>
<span class="cm">			 * immediately, so we want to get rid of the metapage</span>
<span class="cm">			 * before anyone else has a chance to get it.</span>
<span class="cm">			 * Lock metapage, update maps, then invalidate</span>
<span class="cm">			 * the metapage.</span>
<span class="cm">			 */</span>
			<span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PAGE</span><span class="p">);</span>
			<span class="n">grab_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * extent list:</span>
<span class="cm">		 * . in-line PXD list:</span>
<span class="cm">		 * . out-of-line XAD list:</span>
<span class="cm">		 */</span>
		<span class="n">maplock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="n">nlock</span> <span class="o">=</span> <span class="n">maplock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nlock</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">maplock</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * allocate blocks in persistent map:</span>
<span class="cm">			 *</span>
<span class="cm">			 * blocks have been allocated from wmap at alloc time;</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">maplock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckALLOC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">txAllocPMap</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">maplock</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * free blocks in persistent and working map:</span>
<span class="cm">			 * blocks will be freed in pmap and then in wmap;</span>
<span class="cm">			 *</span>
<span class="cm">			 * ? tblock specifies the PMAP/PWMAP based upon</span>
<span class="cm">			 * transaction</span>
<span class="cm">			 *</span>
<span class="cm">			 * free blocks in persistent map:</span>
<span class="cm">			 * blocks will be freed from wmap at last reference</span>
<span class="cm">			 * release of the object for regular files;</span>
<span class="cm">			 *</span>
<span class="cm">			 * Alway free blocks from both persistent &amp; working</span>
<span class="cm">			 * maps for directories</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="p">{</span>	<span class="cm">/* (maplock-&gt;flag &amp; mlckFREE) */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tlckDIRECTORY</span><span class="p">)</span>
					<span class="n">txFreeMap</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">maplock</span><span class="p">,</span>
						  <span class="n">tblk</span><span class="p">,</span> <span class="n">COMMIT_PWMAP</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">txFreeMap</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">maplock</span><span class="p">,</span>
						  <span class="n">tblk</span><span class="p">,</span> <span class="n">maptype</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tlckFREEPAGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tblkGC_LAZY</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* This is equivalent to txRelease */</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">lid</span> <span class="o">==</span> <span class="n">lid</span><span class="p">);</span>
				<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">lid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nohomeok</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">metapage_homeok</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">discard_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	update inode allocation map</span>
<span class="cm">	 *</span>
<span class="cm">	 * update allocation state in pmap and</span>
<span class="cm">	 * update lsn of the pmap page;</span>
<span class="cm">	 * update in-memory inode flag/state</span>
<span class="cm">	 *</span>
<span class="cm">	 * unlock mapper/write lock</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_CREATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">diUpdatePMap</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
		<span class="cm">/* update persistent block allocation map</span>
<span class="cm">		 * for the allocation of inode extent;</span>
<span class="cm">		 */</span>
		<span class="n">pxdlock</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckALLOCPXD</span><span class="p">;</span>
		<span class="n">pxdlock</span><span class="p">.</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ixpxd</span><span class="p">;</span>
		<span class="n">pxdlock</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">txAllocPMap</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pxdlock</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_DELETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip</span><span class="p">;</span>
		<span class="n">diUpdatePMap</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txAllocPMap()</span>
<span class="cm"> *</span>
<span class="cm"> * function: allocate from persistent map;</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *	ipbmap	-</span>
<span class="cm"> *	malock	-</span>
<span class="cm"> *		xad list:</span>
<span class="cm"> *		pxd:</span>
<span class="cm"> *</span>
<span class="cm"> *	maptype -</span>
<span class="cm"> *		allocate from persistent map;</span>
<span class="cm"> *		free from persistent map;</span>
<span class="cm"> *		(e.g., tmp file - free from working map at releae</span>
<span class="cm"> *		 of last reference);</span>
<span class="cm"> *		free from persistent and working map;</span>
<span class="cm"> *</span>
<span class="cm"> *	lsn	- log sequence number;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">txAllocPMap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span> <span class="n">maplock</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="n">xadlistlock</span><span class="p">;</span>
	<span class="n">xad_t</span> <span class="o">*</span><span class="n">xad</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="n">pxdlistlock</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate from persistent map;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maplock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckALLOCXADLIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xadlistlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
		<span class="n">xad</span> <span class="o">=</span> <span class="n">xadlistlock</span><span class="o">-&gt;</span><span class="n">xdlist</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">xadlistlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">xad</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xad</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XAD_NEW</span> <span class="o">|</span> <span class="n">XAD_EXTENDED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressXAD</span><span class="p">(</span><span class="n">xad</span><span class="p">);</span>
				<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthXAD</span><span class="p">(</span><span class="n">xad</span><span class="p">);</span>
				<span class="n">dbUpdatePMap</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
				<span class="n">xad</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XAD_NEW</span> <span class="o">|</span> <span class="n">XAD_EXTENDED</span><span class="p">);</span>
				<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;allocPMap: xaddr:0x%lx xlen:%d&quot;</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maplock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckALLOCPXD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
		<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">);</span>
		<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">);</span>
		<span class="n">dbUpdatePMap</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;allocPMap: xaddr:0x%lx xlen:%d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* (maplock-&gt;flag &amp; mlckALLOCPXDLIST) */</span>

		<span class="n">pxdlistlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
		<span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlistlock</span><span class="o">-&gt;</span><span class="n">xdlist</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">pxdlistlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">pxd</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
			<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
			<span class="n">dbUpdatePMap</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span>
				     <span class="n">tblk</span><span class="p">);</span>
			<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;allocPMap: xaddr:0x%lx xlen:%d&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txFreeMap()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	free from persistent and/or working map;</span>
<span class="cm"> *</span>
<span class="cm"> * todo: optimization</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txFreeMap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">maplock</span> <span class="o">*</span> <span class="n">maplock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maptype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="n">xadlistlock</span><span class="p">;</span>
	<span class="n">xad_t</span> <span class="o">*</span><span class="n">xad</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="n">pxdlistlock</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x&quot;</span><span class="p">,</span>
		 <span class="n">tblk</span><span class="p">,</span> <span class="n">maplock</span><span class="p">,</span> <span class="n">maptype</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * free from persistent map;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maptype</span> <span class="o">==</span> <span class="n">COMMIT_PMAP</span> <span class="o">||</span> <span class="n">maptype</span> <span class="o">==</span> <span class="n">COMMIT_PWMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maplock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckFREEXADLIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xadlistlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
			<span class="n">xad</span> <span class="o">=</span> <span class="n">xadlistlock</span><span class="o">-&gt;</span><span class="n">xdlist</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">xadlistlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">xad</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xad</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">XAD_NEW</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressXAD</span><span class="p">(</span><span class="n">xad</span><span class="p">);</span>
					<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthXAD</span><span class="p">(</span><span class="n">xad</span><span class="p">);</span>
					<span class="n">dbUpdatePMap</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span>
						     <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
					<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;freePMap: xaddr:0x%lx &quot;</span>
						 <span class="s">&quot;xlen:%d&quot;</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maplock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckFREEPXD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
			<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">);</span>
			<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">);</span>
			<span class="n">dbUpdatePMap</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span>
				     <span class="n">tblk</span><span class="p">);</span>
			<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;freePMap: xaddr:0x%lx xlen:%d&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* (maplock-&gt;flag &amp; mlckALLOCPXDLIST) */</span>

			<span class="n">pxdlistlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
			<span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlistlock</span><span class="o">-&gt;</span><span class="n">xdlist</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">pxdlistlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">pxd</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
				<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
				<span class="n">dbUpdatePMap</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span>
					     <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
				<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;freePMap: xaddr:0x%lx xlen:%d&quot;</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * free from working map;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maptype</span> <span class="o">==</span> <span class="n">COMMIT_PWMAP</span> <span class="o">||</span> <span class="n">maptype</span> <span class="o">==</span> <span class="n">COMMIT_WMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maplock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckFREEXADLIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xadlistlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
			<span class="n">xad</span> <span class="o">=</span> <span class="n">xadlistlock</span><span class="o">-&gt;</span><span class="n">xdlist</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">xadlistlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">xad</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressXAD</span><span class="p">(</span><span class="n">xad</span><span class="p">);</span>
				<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthXAD</span><span class="p">(</span><span class="n">xad</span><span class="p">);</span>
				<span class="n">dbFree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">);</span>
				<span class="n">xad</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;freeWMap: xaddr:0x%lx xlen:%d&quot;</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maplock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">mlckFREEPXD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
			<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">);</span>
			<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">);</span>
			<span class="n">dbFree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">);</span>
			<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;freeWMap: xaddr:0x%lx xlen:%d&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* (maplock-&gt;flag &amp; mlckFREEPXDLIST) */</span>

			<span class="n">pxdlistlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xdlistlock</span> <span class="o">*</span><span class="p">)</span> <span class="n">maplock</span><span class="p">;</span>
			<span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlistlock</span><span class="o">-&gt;</span><span class="n">xdlist</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">pxdlistlock</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">pxd</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
				<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
				<span class="n">dbFree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">);</span>
				<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;freeWMap: xaddr:0x%lx xlen:%d&quot;</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txFreelock()</span>
<span class="cm"> *</span>
<span class="cm"> * function:	remove tlock from inode anonymous locklist</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txFreelock</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">xtlck</span><span class="p">,</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="n">lid_t</span> <span class="n">xlid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">TXN_LOCK</span><span class="p">();</span>
	<span class="n">xtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">lid</span> <span class="o">=</span> <span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tlckFREELOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xtlck</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">txLockFree</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xtlck</span> <span class="o">=</span> <span class="n">tlck</span><span class="p">;</span>
			<span class="n">xlid</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span><span class="p">)</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">=</span> <span class="n">xlid</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If inode was on anon_list, remove it</span>
<span class="cm">		 */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">anon_inode_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">TXN_UNLOCK</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txAbort()</span>
<span class="cm"> *</span>
<span class="cm"> * function: abort tx before commit;</span>
<span class="cm"> *</span>
<span class="cm"> * frees line-locks and segment locks for all</span>
<span class="cm"> * segments in comdata structure.</span>
<span class="cm"> * Optionally sets state of file-system to FM_DIRTY in super-block.</span>
<span class="cm"> * log age of page-frames in memory for which caller has</span>
<span class="cm"> * are reset to 0 (to avoid logwarap).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txAbort</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">tblk</span> <span class="o">=</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * free tlocks of the transaction</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lid</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">lid</span><span class="p">;</span> <span class="n">lid</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
		<span class="n">JFS_IP</span><span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xtlid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">lid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * reset lsn of page to avoid logwarap:</span>
<span class="cm">			 *</span>
<span class="cm">			 * (page may have been previously committed by another</span>
<span class="cm">			 * transaction(s) but has not been paged, i.e.,</span>
<span class="cm">			 * it may be on logsync list even though it has not</span>
<span class="cm">			 * been logged for the current tx.)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">&amp;</span> <span class="n">COMMIT_PAGE</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span><span class="p">)</span>
				<span class="n">LogSyncRelease</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* insert tlock at head of freelist */</span>
		<span class="n">TXN_LOCK</span><span class="p">();</span>
		<span class="n">txLockFree</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="n">TXN_UNLOCK</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* caller will free the transaction block */</span>

	<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mark filesystem dirty</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;txAbort&quot;</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txLazyCommit(void)</span>
<span class="cm"> *</span>
<span class="cm"> *	All transactions except those changing ipimap (COMMIT_FORCE) are</span>
<span class="cm"> *	processed by this routine.  This insures that the inode and block</span>
<span class="cm"> *	allocation maps are updated in order.  For synchronous transactions,</span>
<span class="cm"> *	let the user thread finish processing after txUpdateMap() is called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">txLazyCommit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(((</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tblkGC_READY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">((</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tblkGC_UNLOCKED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We must have gotten ahead of the user thread</span>
<span class="cm">		 */</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;jfs_lazycommit: tblk 0x%p not unlocked&quot;</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
		<span class="n">yield</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txLazyCommit: processing tblk 0x%p&quot;</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>

	<span class="n">txUpdateMap</span><span class="p">(</span><span class="n">tblk</span><span class="p">);</span>

	<span class="n">log</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="p">)</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">gclock</span><span class="p">);</span>	<span class="c1">// LOGGC_LOCK</span>

	<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">tblkGC_COMMITTED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tblkGC_READY</span><span class="p">)</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">gcrtc</span><span class="o">--</span><span class="p">;</span>

	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">gcwait</span><span class="p">);</span>	<span class="c1">// LOGGC_WAKEUP</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t release log-&gt;gclock until we&#39;ve tested tblk-&gt;flag</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">tblkGC_LAZY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">gclock</span><span class="p">);</span>	<span class="c1">// LOGGC_UNLOCK</span>
		<span class="n">txUnlock</span><span class="p">(</span><span class="n">tblk</span><span class="p">);</span>
		<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">tblkGC_LAZY</span><span class="p">;</span>
		<span class="n">txEnd</span><span class="p">(</span><span class="n">tblk</span> <span class="o">-</span> <span class="n">TxBlock</span><span class="p">);</span>	<span class="cm">/* Convert back to tid */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">gclock</span><span class="p">);</span>	<span class="c1">// LOGGC_UNLOCK</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;txLazyCommit: done: tblk = 0x%p&quot;</span><span class="p">,</span> <span class="n">tblk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	jfs_lazycommit(void)</span>
<span class="cm"> *</span>
<span class="cm"> *	To be run as a kernel daemon.  If lbmIODone is called in an interrupt</span>
<span class="cm"> *	context, or where blocking is not wanted, this routine will process</span>
<span class="cm"> *	committed transactions from the unlock queue.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jfs_lazycommit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">WorkDone</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">tblk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">LAZY_LOCK</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">jfs_commit_thread_waking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* OK to wake another thread */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">unlock_queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WorkDone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tblk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">unlock_queue</span><span class="p">,</span>
					    <span class="n">cqueue</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * For each volume, the transactions must be</span>
<span class="cm">				 * handled in order.  If another commit thread</span>
<span class="cm">				 * is handling a tblk for this superblock,</span>
<span class="cm">				 * skip it</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">commit_state</span> <span class="o">&amp;</span> <span class="n">IN_LAZYCOMMIT</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">commit_state</span> <span class="o">|=</span> <span class="n">IN_LAZYCOMMIT</span><span class="p">;</span>
				<span class="n">WorkDone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Remove transaction from queue</span>
<span class="cm">				 */</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">cqueue</span><span class="p">);</span>

				<span class="n">LAZY_UNLOCK</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">txLazyCommit</span><span class="p">(</span><span class="n">tblk</span><span class="p">);</span>
				<span class="n">LAZY_LOCK</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

				<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">commit_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IN_LAZYCOMMIT</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * Don&#39;t continue in the for loop.  (We can&#39;t</span>
<span class="cm">				 * anyway, it&#39;s unsafe!)  We want to go back to</span>
<span class="cm">				 * the beginning of the list.</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* If there was nothing to do, don&#39;t continue */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WorkDone</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* In case a wakeup came while all threads were active */</span>
		<span class="n">jfs_commit_thread_waking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">LAZY_UNLOCK</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">try_to_freeze</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_commit_thread_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">LAZY_UNLOCK</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_commit_thread_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">unlock_queue</span><span class="p">))</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;jfs_lazycommit being killed w/pending transactions!&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;jfs_lazycommit being killed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">txLazyUnlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">LAZY_LOCK</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">cqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">unlock_queue</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t wake up a commit thread if there is already one servicing</span>
<span class="cm">	 * this superblock, or if the last one we woke up hasn&#39;t started yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">JFS_SBI</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">commit_state</span> <span class="o">&amp;</span> <span class="n">IN_LAZYCOMMIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">jfs_commit_thread_waking</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_commit_thread_waking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_commit_thread_wait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">LAZY_UNLOCK</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">LogSyncRelease</span><span class="p">(</span><span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span> <span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>

	<span class="n">assert</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">nohomeok</span><span class="p">);</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="n">metapage_homeok</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	txQuiesce</span>
<span class="cm"> *</span>
<span class="cm"> *	Block all new transactions and push anonymous transactions to</span>
<span class="cm"> *	completion</span>
<span class="cm"> *</span>
<span class="cm"> *	This does almost the same thing as jfs_sync below.  We don&#39;t</span>
<span class="cm"> *	worry about deadlocking when jfs_tlocks_low is set, since we would</span>
<span class="cm"> *	expect jfs_sync to get us out of that jam.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txQuiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">log_QUIESCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">);</span>

	<span class="n">TXN_LOCK</span><span class="p">();</span>
<span class="nl">restart:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">jfs_inode_info</span><span class="p">,</span>
				    <span class="n">anon_inode_list</span><span class="p">);</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * inode will be removed from anonymous list</span>
<span class="cm">		 * when it is committed</span>
<span class="cm">		 */</span>
		<span class="n">TXN_UNLOCK</span><span class="p">();</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="n">txBegin</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">COMMIT_INODE</span> <span class="o">|</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>
		<span class="n">txCommit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Just to be safe.  I don&#39;t know how</span>
<span class="cm">		 * long we can run without blocking</span>
<span class="cm">		 */</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">TXN_LOCK</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If jfs_sync is running in parallel, there could be some inodes</span>
<span class="cm">	 * on anon_list2.  Let&#39;s check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">TXN_UNLOCK</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may need to kick off the group commit</span>
<span class="cm">	 */</span>
	<span class="n">jfs_flush_journal</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * txResume()</span>
<span class="cm"> *</span>
<span class="cm"> * Allows transactions to start again following txQuiesce</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">txResume</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">log_QUIESCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">);</span>
	<span class="n">TXN_WAKEUP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">syncwait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	jfs_sync(void)</span>
<span class="cm"> *</span>
<span class="cm"> *	To be run as a kernel daemon.  This is awakened when tlocks run low.</span>
<span class="cm"> *	We write any inodes that have anonymous tlocks so they will become</span>
<span class="cm"> *	available.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jfs_sync</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * write each inode on the anonymous inode list</span>
<span class="cm">		 */</span>
		<span class="n">TXN_LOCK</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">jfs_tlocks_low</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">jfs_inode_info</span><span class="p">,</span>
					    <span class="n">anon_inode_list</span><span class="p">);</span>
			<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">igrab</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Inode is being freed</span>
<span class="cm">				 */</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">anon_inode_list</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * inode will be removed from anonymous list</span>
<span class="cm">				 * when it is committed</span>
<span class="cm">				 */</span>
				<span class="n">TXN_UNLOCK</span><span class="p">();</span>
				<span class="n">tid</span> <span class="o">=</span> <span class="n">txBegin</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">COMMIT_INODE</span><span class="p">);</span>
				<span class="n">txCommit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>

				<span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Just to be safe.  I don&#39;t know how</span>
<span class="cm">				 * long we can run without blocking</span>
<span class="cm">				 */</span>
				<span class="n">cond_resched</span><span class="p">();</span>
				<span class="n">TXN_LOCK</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* We can&#39;t get the commit mutex.  It may</span>
<span class="cm">				 * be held by a thread waiting for tlock&#39;s</span>
<span class="cm">				 * so let&#39;s not block here.  Save it to</span>
<span class="cm">				 * put back on the anon_list.</span>
<span class="cm">				 */</span>

				<span class="cm">/* Take off anon_list */</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">anon_inode_list</span><span class="p">);</span>

				<span class="cm">/* Put on anon_list2 */</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">anon_inode_list</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list2</span><span class="p">);</span>

				<span class="n">TXN_UNLOCK</span><span class="p">();</span>
				<span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
				<span class="n">TXN_LOCK</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Add anon_list2 back to anon_list */</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">anon_list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">TXN_UNLOCK</span><span class="p">();</span>
			<span class="n">try_to_freeze</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">TXN_UNLOCK</span><span class="p">();</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">());</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;jfs_sync being killed&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_PROC_FS) &amp;&amp; defined(CONFIG_JFS_DEBUG)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">jfs_txanchor_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">freewait</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">freelockwait</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">lowlockwait</span><span class="p">;</span>

	<span class="n">freewait</span> <span class="o">=</span>
	    <span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freewait</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;active&quot;</span> <span class="o">:</span> <span class="s">&quot;empty&quot;</span><span class="p">;</span>
	<span class="n">freelockwait</span> <span class="o">=</span>
	    <span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelockwait</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;active&quot;</span> <span class="o">:</span> <span class="s">&quot;empty&quot;</span><span class="p">;</span>
	<span class="n">lowlockwait</span> <span class="o">=</span>
	    <span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">lowlockwait</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;active&quot;</span> <span class="o">:</span> <span class="s">&quot;empty&quot;</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
		       <span class="s">&quot;JFS TxAnchor</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;============</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;freetid = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;freewait = %s</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;freelock = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;freelockwait = %s</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;lowlockwait = %s</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;tlocksInUse = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;jfs_tlocks_low = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;unlock_queue is %sempty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">TxAnchor</span><span class="p">.</span><span class="n">freetid</span><span class="p">,</span>
		       <span class="n">freewait</span><span class="p">,</span>
		       <span class="n">TxAnchor</span><span class="p">.</span><span class="n">freelock</span><span class="p">,</span>
		       <span class="n">freelockwait</span><span class="p">,</span>
		       <span class="n">lowlockwait</span><span class="p">,</span>
		       <span class="n">TxAnchor</span><span class="p">.</span><span class="n">tlocksInUse</span><span class="p">,</span>
		       <span class="n">jfs_tlocks_low</span><span class="p">,</span>
		       <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TxAnchor</span><span class="p">.</span><span class="n">unlock_queue</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jfs_txanchor_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">jfs_txanchor_proc_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">jfs_txanchor_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">jfs_txanchor_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_PROC_FS) &amp;&amp; defined(CONFIG_JFS_STATISTICS)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">jfs_txstats_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
		       <span class="s">&quot;JFS TxStats</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;===========</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;calls to txBegin = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;txBegin blocked by sync barrier = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;txBegin blocked by tlocks low = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;txBegin blocked by no free tid = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;calls to txBeginAnon = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;txBeginAnon blocked by sync barrier = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;txBeginAnon blocked by tlocks low = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;calls to txLockAlloc = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;tLockAlloc blocked by no free lock = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin_barrier</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin_lockslow</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txBegin_freetid</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txBeginAnon</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txBeginAnon_barrier</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txBeginAnon_lockslow</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txLockAlloc</span><span class="p">,</span>
		       <span class="n">TxStat</span><span class="p">.</span><span class="n">txLockAlloc_freelock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jfs_txstats_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">jfs_txstats_proc_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">jfs_txstats_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">jfs_txstats_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
