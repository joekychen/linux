<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jfs › jfs_dmap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jfs_dmap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   Copyright (C) International Business Machines Corp., 2000-2004</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program;  if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;jfs_incore.h&quot;</span>
<span class="cp">#include &quot;jfs_superblock.h&quot;</span>
<span class="cp">#include &quot;jfs_dmap.h&quot;</span>
<span class="cp">#include &quot;jfs_imap.h&quot;</span>
<span class="cp">#include &quot;jfs_lock.h&quot;</span>
<span class="cp">#include &quot;jfs_metapage.h&quot;</span>
<span class="cp">#include &quot;jfs_debug.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *	SERIALIZATION of the Block Allocation Map.</span>
<span class="cm"> *</span>
<span class="cm"> *	the working state of the block allocation map is accessed in</span>
<span class="cm"> *	two directions:</span>
<span class="cm"> *</span>
<span class="cm"> *	1) allocation and free requests that start at the dmap</span>
<span class="cm"> *	   level and move up through the dmap control pages (i.e.</span>
<span class="cm"> *	   the vast majority of requests).</span>
<span class="cm"> *</span>
<span class="cm"> *	2) allocation requests that start at dmap control page</span>
<span class="cm"> *	   level and work down towards the dmaps.</span>
<span class="cm"> *</span>
<span class="cm"> *	the serialization scheme used here is as follows.</span>
<span class="cm"> *</span>
<span class="cm"> *	requests which start at the bottom are serialized against each</span>
<span class="cm"> *	other through buffers and each requests holds onto its buffers</span>
<span class="cm"> *	as it works it way up from a single dmap to the required level</span>
<span class="cm"> *	of dmap control page.</span>
<span class="cm"> *	requests that start at the top are serialized against each other</span>
<span class="cm"> *	and request that start from the bottom by the multiple read/single</span>
<span class="cm"> *	write inode lock of the bmap inode. requests starting at the top</span>
<span class="cm"> *	take this lock in write mode while request starting at the bottom</span>
<span class="cm"> *	take the lock in read mode.  a single top-down request may proceed</span>
<span class="cm"> *	exclusively while multiple bottoms-up requests may proceed</span>
<span class="cm"> *	simultaneously (under the protection of busy buffers).</span>
<span class="cm"> *</span>
<span class="cm"> *	in addition to information found in dmaps and dmap control pages,</span>
<span class="cm"> *	the working state of the block allocation map also includes read/</span>
<span class="cm"> *	write information maintained in the bmap descriptor (i.e. total</span>
<span class="cm"> *	free block count, allocation group level free block counts).</span>
<span class="cm"> *	a single exclusive lock (BMAP_LOCK) is used to guard this information</span>
<span class="cm"> *	in the face of multiple-bottoms up requests.</span>
<span class="cm"> *	(lock ordering: IREAD_LOCK, BMAP_LOCK);</span>
<span class="cm"> *</span>
<span class="cm"> *	accesses to the persistent state of the block allocation map (limited</span>
<span class="cm"> *	to the persistent bitmaps in dmaps) is guarded by (busy) buffers.</span>
<span class="cm"> */</span>

<span class="cp">#define BMAP_LOCK_INIT(bmp)	mutex_init(&amp;bmp-&gt;db_bmaplock)</span>
<span class="cp">#define BMAP_LOCK(bmp)		mutex_lock(&amp;bmp-&gt;db_bmaplock)</span>
<span class="cp">#define BMAP_UNLOCK(bmp)	mutex_unlock(&amp;bmp-&gt;db_bmaplock)</span>

<span class="cm">/*</span>
<span class="cm"> * forward references</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dbAllocBits</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dbSplit</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leafno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">splitsz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbBackSplit</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leafno</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbJoin</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leafno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dbAdjTree</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leafno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAdjCtl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAllocAny</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAllocNext</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAllocNear</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">nblocks</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAllocDmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAllocDmapLev</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span>
			  <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAllocAG</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span>
		     <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAllocCtl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		      <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbExtend</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">s64</span> <span class="n">addnblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbFindBits</span><span class="p">(</span><span class="n">u32</span> <span class="n">word</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbFindCtl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">blkno</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbFindLeaf</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">leafidx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbFreeBits</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbFreeDmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbMaxBud</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span> <span class="n">cp</span><span class="p">);</span>
<span class="n">s64</span> <span class="n">dbMapFileSizeToMapSize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">blkstol2</span><span class="p">(</span><span class="n">s64</span> <span class="n">nb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cntlz</span><span class="p">(</span><span class="n">u32</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cnttz</span><span class="p">(</span><span class="n">u32</span> <span class="n">word</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dbAllocDmapBU</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbInitDmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbInitDmapTree</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbInitTree</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmaptree</span> <span class="o">*</span> <span class="n">dtp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbInitDmapCtl</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span> <span class="n">dcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dbGetL2AGSize</span><span class="p">(</span><span class="n">s64</span> <span class="n">nblocks</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	buddy table</span>
<span class="cm"> *</span>
<span class="cm"> * table used for determining buddy sizes within characters of</span>
<span class="cm"> * dmap bitmap words.  the characters themselves serve as indexes</span>
<span class="cm"> * into the table, with the table elements yielding the maximum</span>
<span class="cm"> * binary buddy of free bits within the character.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">s8</span> <span class="n">budtab</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbMount()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initializate the block allocation map.</span>
<span class="cm"> *</span>
<span class="cm"> *		memory is allocated for the in-core bmap descriptor and</span>
<span class="cm"> *		the in-core descriptor is initialized from disk.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ipbmap	- pointer to in-core inode for the block map.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOMEM	- insufficient memory</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbMount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dbmap_disk</span> <span class="o">*</span><span class="n">dbmp_le</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate/initialize the in-memory bmap descriptor</span>
<span class="cm">	 */</span>
	<span class="cm">/* allocate memory for the in-memory bmap descriptor */</span>
	<span class="n">bmp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* read the on-disk bmap descriptor. */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span>
			   <span class="n">BMAPBLKNO</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">,</span>
			   <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy the on-disk bmap descriptor to its in-memory version. */</span>
	<span class="n">dbmp_le</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbmap_disk</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_mapsize</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_nfree</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_nfree</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_l2nbperpage</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_numag</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxlevel</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_maxlevel</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_maxag</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agpref</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_aglevel</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_aglevel</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agheight</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agheight</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agwidth</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agwidth</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agstart</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agstart</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agl2size</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXAG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agfree</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agsize</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxfreebud</span> <span class="o">=</span> <span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_maxfreebud</span><span class="p">;</span>

	<span class="cm">/* release the buffer. */</span>
	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/* bind the bmap inode and the bmap descriptor to each other. */</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span> <span class="o">=</span> <span class="n">ipbmap</span><span class="p">;</span>
	<span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span> <span class="o">=</span> <span class="n">bmp</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_active</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_active</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate/initialize the bmap lock</span>
<span class="cm">	 */</span>
	<span class="n">BMAP_LOCK_INIT</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbUnmount()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	terminate the block allocation map in preparation for</span>
<span class="cm"> *		file system unmount.</span>
<span class="cm"> *</span>
<span class="cm"> *		the in-core bmap descriptor is written to disk and</span>
<span class="cm"> *		the memory for this descriptor is freed.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ipbmap	- pointer to in-core inode for the block map.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbUnmount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mounterror</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mounterror</span> <span class="o">||</span> <span class="n">isReadOnly</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">)))</span>
		<span class="n">dbSync</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invalidate the page cache buffers</span>
<span class="cm">	 */</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* free the memory for the in-memory bmap. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	dbSync()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbSync</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dbmap_disk</span> <span class="o">*</span><span class="n">dbmp_le</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * write bmap global control page</span>
<span class="cm">	 */</span>
	<span class="cm">/* get the buffer for the on-disk bmap descriptor. */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span>
			   <span class="n">BMAPBLKNO</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">,</span>
			   <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;dbSync: read_metapage failed!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* copy the in-memory version of the bmap to the on-disk version */</span>
	<span class="n">dbmp_le</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dbmap_disk</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_mapsize</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_nfree</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_nfree</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_l2nbperpage</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_numag</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_maxlevel</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxlevel</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_maxag</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agpref</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_aglevel</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_aglevel</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agheight</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agheight</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agwidth</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agwidth</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agstart</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agstart</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agl2size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXAG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agfree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_agsize</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span><span class="p">);</span>
	<span class="n">dbmp_le</span><span class="o">-&gt;</span><span class="n">dn_maxfreebud</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxfreebud</span><span class="p">;</span>

	<span class="cm">/* write the buffer */</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * write out dirty pages of bmap</span>
<span class="cm">	 */</span>
	<span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>

	<span class="n">diWriteSpecial</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbFree()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	free the specified block range from the working block</span>
<span class="cm"> *		allocation map.</span>
<span class="cm"> *</span>
<span class="cm"> *		the blocks will be free from the working map one dmap</span>
<span class="cm"> *		at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip	- pointer to in-core inode;</span>
<span class="cm"> *	blkno	- starting block number to be freed.</span>
<span class="cm"> *	nblocks	- number of blocks to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbFree</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nb</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">rem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>

	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">RDWRLOCK_DMAP</span><span class="p">);</span>

	<span class="cm">/* block to be freed better be within the mapsize. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">blkno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;blkno = %Lx, nblocks = %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">blkno</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbFree: block to be freed is outside the map&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * free the blocks a dmap at a time.</span>
<span class="cm">	 */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rem</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rem</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">blkno</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* release previous dmap if any */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* get the buffer for the current dmap. */</span>
		<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* determine the number of blocks to be freed from</span>
<span class="cm">		 * this dmap.</span>
<span class="cm">		 */</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">BPERDMAP</span> <span class="o">-</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>

		<span class="cm">/* free the blocks. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbFreeDmap</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nb</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;dbFree: error in block map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* write the last buffer. */</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbUpdatePMap()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	update the allocation state (free or allocate) of the</span>
<span class="cm"> *		specified block range in the persistent block allocation map.</span>
<span class="cm"> *</span>
<span class="cm"> *		the blocks will be updated in the persistent map one</span>
<span class="cm"> *		dmap at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ipbmap	- pointer to in-core inode for the block map.</span>
<span class="cm"> *	free	- &#39;true&#39; if block range is to be freed from the persistent</span>
<span class="cm"> *		  map; &#39;false&#39; if it is to be allocated.</span>
<span class="cm"> *	blkno	- starting block number of the range.</span>
<span class="cm"> *	nblocks	- number of contiguous blocks in the range.</span>
<span class="cm"> *	tblk	- transaction block;</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">dbUpdatePMap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nblks</span><span class="p">,</span> <span class="n">dbitno</span><span class="p">,</span> <span class="n">wbitno</span><span class="p">,</span> <span class="n">rbits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">word</span><span class="p">,</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">nwords</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">rem</span><span class="p">,</span> <span class="n">lastlblkno</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lsn</span><span class="p">,</span> <span class="n">difft</span><span class="p">,</span> <span class="n">diffp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* the blocks better be within the mapsize. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;blkno = %Lx, nblocks = %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">blkno</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbUpdatePMap: blocks are outside the map&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* compute delta of transaction lsn from log syncpt */</span>
	<span class="n">lsn</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">lsn</span><span class="p">;</span>
	<span class="n">log</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="p">)</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>
	<span class="n">logdiff</span><span class="p">(</span><span class="n">difft</span><span class="p">,</span> <span class="n">lsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * update the block state a dmap at a time.</span>
<span class="cm">	 */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lastlblkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rem</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rem</span> <span class="o">-=</span> <span class="n">nblks</span><span class="p">,</span> <span class="n">blkno</span> <span class="o">+=</span> <span class="n">nblks</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get the buffer for the current dmap. */</span>
		<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lblkno</span> <span class="o">!=</span> <span class="n">lastlblkno</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span>
					   <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">metapage_wait_for_io</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* determine the bit number and word within the dmap of</span>
<span class="cm">		 * the starting block.  also determine how many blocks</span>
<span class="cm">		 * are to be updated within this dmap.</span>
<span class="cm">		 */</span>
		<span class="n">dbitno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
		<span class="n">nblks</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="n">dbitno</span><span class="p">);</span>

		<span class="cm">/* update the bits of the dmap words. the first and last</span>
<span class="cm">		 * words may only have a subset of their bits updated. if</span>
<span class="cm">		 * this is the case, we&#39;ll work against that word (i.e.</span>
<span class="cm">		 * partial first and/or last) only in a single pass.  a</span>
<span class="cm">		 * single pass will also be used to update all words that</span>
<span class="cm">		 * are to have all their bits updated.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">rbits</span> <span class="o">=</span> <span class="n">nblks</span><span class="p">;</span> <span class="n">rbits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">rbits</span> <span class="o">-=</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">dbitno</span> <span class="o">+=</span> <span class="n">nbits</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* determine the bit number within the word and</span>
<span class="cm">			 * the number of bits within the word.</span>
<span class="cm">			 */</span>
			<span class="n">wbitno</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">nbits</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rbits</span><span class="p">,</span> <span class="n">DBWORD</span> <span class="o">-</span> <span class="n">wbitno</span><span class="p">);</span>

			<span class="cm">/* check if only part of the word is to be updated. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">&lt;</span> <span class="n">DBWORD</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* update (free or allocate) the bits</span>
<span class="cm">				 * in this word.</span>
<span class="cm">				 */</span>
				<span class="n">mask</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="n">nbits</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">wbitno</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">free</span><span class="p">)</span>
					<span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&amp;=</span>
					    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">|=</span>
					    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

				<span class="n">word</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* one or more words are to have all</span>
<span class="cm">				 * their bits updated.  determine how</span>
<span class="cm">				 * many words and how many bits.</span>
<span class="cm">				 */</span>
				<span class="n">nwords</span> <span class="o">=</span> <span class="n">rbits</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
				<span class="n">nbits</span> <span class="o">=</span> <span class="n">nwords</span> <span class="o">&lt;&lt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

				<span class="cm">/* update (free or allocate) the bits</span>
<span class="cm">				 * in these words.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">free</span><span class="p">)</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">word</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">nwords</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">word</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ONES</span><span class="p">,</span>
					       <span class="n">nwords</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

				<span class="n">word</span> <span class="o">+=</span> <span class="n">nwords</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * update dmap lsn</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lblkno</span> <span class="o">==</span> <span class="n">lastlblkno</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">lastlblkno</span> <span class="o">=</span> <span class="n">lblkno</span><span class="p">;</span>

		<span class="n">LOGSYNC_LOCK</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* inherit older/smaller lsn */</span>
			<span class="n">logdiff</span><span class="p">(</span><span class="n">diffp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">difft</span> <span class="o">&lt;</span> <span class="n">diffp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span> <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>

				<span class="cm">/* move bp after tblock in logsync list */</span>
				<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* inherit younger/larger clsn */</span>
			<span class="n">logdiff</span><span class="p">(</span><span class="n">difft</span><span class="p">,</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
			<span class="n">logdiff</span><span class="p">(</span><span class="n">diffp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">difft</span> <span class="o">&gt;</span> <span class="n">diffp</span><span class="p">)</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span><span class="p">;</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span> <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>

			<span class="cm">/* insert bp after tblock in logsync list */</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">);</span>

			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">LOGSYNC_UNLOCK</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* write the last buffer. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbNextAG()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	find the preferred allocation group for new allocations.</span>
<span class="cm"> *</span>
<span class="cm"> *		Within the allocation groups, we maintain a preferred</span>
<span class="cm"> *		allocation group which consists of a group with at least</span>
<span class="cm"> *		average free space.  It is the preferred group that we target</span>
<span class="cm"> *		new inode allocation towards.  The tie-in between inode</span>
<span class="cm"> *		allocation and block allocation occurs as we allocate the</span>
<span class="cm"> *		first (data) block of an inode and specify the inode (block)</span>
<span class="cm"> *		as the allocation hint for this block.</span>
<span class="cm"> *</span>
<span class="cm"> *		We try to avoid having more than one open file growing in</span>
<span class="cm"> *		an allocation group, as this will lead to fragmentation.</span>
<span class="cm"> *		This differs from the old OS/2 method of trying to keep</span>
<span class="cm"> *		empty ags around for large allocations.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ipbmap	- pointer to in-core inode for the block map.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	the preferred allocation group number.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbNextAG</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">avgfree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">agpref</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">hwm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_best</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>

	<span class="n">BMAP_LOCK</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="cm">/* determine the average number of free blocks within the ags. */</span>
	<span class="n">avgfree</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_nfree</span> <span class="o">/</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the current preferred ag does not have an active allocator</span>
<span class="cm">	 * and has at least average freespace, return it</span>
<span class="cm">	 */</span>
	<span class="n">agpref</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_active</span><span class="p">[</span><span class="n">agpref</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agpref</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">avgfree</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* From the last preferred ag, find the next one with at least</span>
<span class="cm">	 * average free space.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">agpref</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agpref</span> <span class="o">==</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span><span class="p">)</span>
			<span class="n">agpref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_active</span><span class="p">[</span><span class="n">agpref</span><span class="p">]))</span>
			<span class="cm">/* open file is currently growing in this ag */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agpref</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">avgfree</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Return this one */</span>
			<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span> <span class="o">=</span> <span class="n">agpref</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agpref</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hwm</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Less than avg. freespace, but best so far */</span>
			<span class="n">hwm</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agpref</span><span class="p">];</span>
			<span class="n">next_best</span> <span class="o">=</span> <span class="n">agpref</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If no inactive ag was found with average freespace, use the</span>
<span class="cm">	 * next best</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_best</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span> <span class="o">=</span> <span class="n">next_best</span><span class="p">;</span>
	<span class="cm">/* else leave db_agpref unchanged */</span>
<span class="nl">unlock:</span>
	<span class="n">BMAP_UNLOCK</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="cm">/* return the preferred group.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAlloc()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to allocate a specified number of contiguous free</span>
<span class="cm"> *		blocks from the working allocation block map.</span>
<span class="cm"> *</span>
<span class="cm"> *		the block allocation policy uses hints and a multi-step</span>
<span class="cm"> *		approach.</span>
<span class="cm"> *</span>
<span class="cm"> *		for allocation requests smaller than the number of blocks</span>
<span class="cm"> *		per dmap, we first try to allocate the new blocks</span>
<span class="cm"> *		immediately following the hint.  if these blocks are not</span>
<span class="cm"> *		available, we try to allocate blocks near the hint.  if</span>
<span class="cm"> *		no blocks near the hint are available, we next try to</span>
<span class="cm"> *		allocate within the same dmap as contains the hint.</span>
<span class="cm"> *</span>
<span class="cm"> *		if no blocks are available in the dmap or the allocation</span>
<span class="cm"> *		request is larger than the dmap size, we try to allocate</span>
<span class="cm"> *		within the same allocation group as contains the hint. if</span>
<span class="cm"> *		this does not succeed, we finally try to allocate anywhere</span>
<span class="cm"> *		within the aggregate.</span>
<span class="cm"> *</span>
<span class="cm"> *		we also try to allocate anywhere within the aggregate for</span>
<span class="cm"> *		for allocation requests larger than the allocation group</span>
<span class="cm"> *		size or requests that specify no hint value.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip	- pointer to in-core inode;</span>
<span class="cm"> *	hint	- allocation hint.</span>
<span class="cm"> *	nblocks	- number of contiguous blocks in the range.</span>
<span class="cm"> *	results	- on successful return, set to the starting block number</span>
<span class="cm"> *		  of the newly allocated contiguous range.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbAlloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">hint</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">agno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">l2nb</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">mapSize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">writers</span><span class="p">;</span>

	<span class="cm">/* assert that nblocks is valid */</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">nblocks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* get the log2 number of blocks to be allocated.</span>
<span class="cm">	 * if the number of blocks is not a log2 multiple,</span>
<span class="cm">	 * it will be rounded up to the next log2 multiple.</span>
<span class="cm">	 */</span>
	<span class="n">l2nb</span> <span class="o">=</span> <span class="n">BLKSTOL2</span><span class="p">(</span><span class="n">nblocks</span><span class="p">);</span>

	<span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>

	<span class="n">mapSize</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">;</span>

	<span class="cm">/* the hint should be within the map */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span> <span class="o">&gt;=</span> <span class="n">mapSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;dbAlloc: the hint is outside the map&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if the number of blocks to be allocated is greater than the</span>
<span class="cm">	 * allocation group size, try to allocate anywhere.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IWRITE_LOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">RDWRLOCK_DMAP</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocAny</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">write_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If no hint, let dbNextAG recommend an allocation group</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">pref_ag</span><span class="p">;</span>

	<span class="cm">/* we would like to allocate close to the hint.  adjust the</span>
<span class="cm">	 * hint to the block following the hint since the allocators</span>
<span class="cm">	 * will start looking for free space starting at this point.</span>
<span class="cm">	 */</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="n">hint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&gt;=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">pref_ag</span><span class="p">;</span>

	<span class="n">agno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">;</span>

	<span class="cm">/* check if blkno crosses over into a new allocation group.</span>
<span class="cm">	 * if so, check if we should allow allocations within this</span>
<span class="cm">	 * allocation group.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* check if the AG is currently being written to.</span>
<span class="cm">		 * if so, call dbNextAG() to find a non-busy</span>
<span class="cm">		 * AG with sufficient free space.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_active</span><span class="p">[</span><span class="n">agno</span><span class="p">]))</span>
			<span class="k">goto</span> <span class="n">pref_ag</span><span class="p">;</span>

	<span class="cm">/* check if the allocation request size can be satisfied from a</span>
<span class="cm">	 * single dmap.  if so, try to allocate from the dmap containing</span>
<span class="cm">	 * the hint using a tiered strategy.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">&lt;=</span> <span class="n">BPERDMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">RDWRLOCK_DMAP</span><span class="p">);</span>

		<span class="cm">/* get the buffer for the dmap containing the hint.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">read_unlock</span><span class="p">;</span>

		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* first, try to satisfy the allocation request with the</span>
<span class="cm">		 * blocks beginning at the hint.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocNext</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">))</span>
		    <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">results</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
				<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">read_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">writers</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_active</span><span class="p">[</span><span class="n">agno</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">writers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">writers</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">active_ag</span> <span class="o">!=</span> <span class="n">agno</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Someone else is writing in this allocation</span>
<span class="cm">			 * group.  To avoid fragmenting, try another ag</span>
<span class="cm">			 */</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">pref_ag</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* next, try to satisfy the allocation request with blocks</span>
<span class="cm">		 * near the hint.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span>
		     <span class="n">dbAllocNear</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">results</span><span class="p">))</span>
		    <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">read_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* try to satisfy the allocation request with blocks within</span>
<span class="cm">		 * the same dmap as the hint.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocDmapLev</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">results</span><span class="p">))</span>
		    <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">read_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* try to satisfy the allocation request with blocks within</span>
<span class="cm">	 * the same allocation group as the hint.</span>
<span class="cm">	 */</span>
	<span class="n">IWRITE_LOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">RDWRLOCK_DMAP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocAG</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">results</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">write_unlock</span><span class="p">;</span>

	<span class="n">IWRITE_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>


      <span class="nl">pref_ag:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Let dbNextAG recommend a preferred allocation group</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">dbNextAG</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
	<span class="n">IWRITE_LOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">RDWRLOCK_DMAP</span><span class="p">);</span>

	<span class="cm">/* Try to allocate within this allocation group.  if that fails, try to</span>
<span class="cm">	 * allocate anywhere in the map.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocAG</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">results</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocAny</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>

      <span class="nl">write_unlock:</span>
	<span class="n">IWRITE_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>

      <span class="nl">read_unlock:</span>
	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef _NOTYET</span>
<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocExact()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	try to allocate the requested extent;</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip	- pointer to in-core inode;</span>
<span class="cm"> *	blkno	- extent address;</span>
<span class="cm"> *	nblocks	- extent length;</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbAllocExact</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">lblkno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">RDWRLOCK_DMAP</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * validate extent request:</span>
<span class="cm">	 *</span>
<span class="cm">	 * note: defragfs policy:</span>
<span class="cm">	 *  max 64 blocks will be moved.</span>
<span class="cm">	 *  allocation request size must be satisfied from a single dmap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nblocks</span> <span class="o">&gt;</span> <span class="n">BPERDMAP</span> <span class="o">||</span> <span class="n">blkno</span> <span class="o">&gt;=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxfreebud</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* the free space is no longer available */</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* read in the dmap covering the extent */</span>
	<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* try to allocate the requested extent */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocNext</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>

	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* _NOTYET */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	dbReAlloc()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to extend a current allocation by a specified</span>
<span class="cm"> *		number of blocks.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine attempts to satisfy the allocation request</span>
<span class="cm"> *		by first trying to extend the existing allocation in</span>
<span class="cm"> *		place by allocating the additional blocks as the blocks</span>
<span class="cm"> *		immediately following the current allocation.  if these</span>
<span class="cm"> *		blocks are not available, this routine will attempt to</span>
<span class="cm"> *		allocate a new set of contiguous blocks large enough</span>
<span class="cm"> *		to cover the existing allocation plus the additional</span>
<span class="cm"> *		number of blocks required.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip	    -  pointer to in-core inode requiring allocation.</span>
<span class="cm"> *	blkno	    -  starting block of the current allocation.</span>
<span class="cm"> *	nblocks	    -  number of contiguous blocks within the current</span>
<span class="cm"> *		       allocation.</span>
<span class="cm"> *	addnblocks  -  number of blocks to add to the allocation.</span>
<span class="cm"> *	results	-      on successful return, set to the starting block number</span>
<span class="cm"> *		       of the existing allocation if the existing allocation</span>
<span class="cm"> *		       was extended in place or to a newly allocated contiguous</span>
<span class="cm"> *		       range if the existing allocation could not be extended</span>
<span class="cm"> *		       in place.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">dbReAlloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	  <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">s64</span> <span class="n">addnblocks</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* try to extend the allocation in place.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbExtend</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">addnblocks</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">results</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* could not extend the allocation in place, so allocate a</span>
<span class="cm">	 * new set of blocks for the entire request (i.e. try to get</span>
<span class="cm">	 * a range of contiguous blocks large enough to cover the</span>
<span class="cm">	 * existing allocation plus the additional blocks.)</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dbAlloc</span>
		<span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">blkno</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">addnblocks</span> <span class="o">+</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">results</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbExtend()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to extend a current allocation by a specified</span>
<span class="cm"> *		number of blocks.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine attempts to satisfy the allocation request</span>
<span class="cm"> *		by first trying to extend the existing allocation in</span>
<span class="cm"> *		place by allocating the additional blocks as the blocks</span>
<span class="cm"> *		immediately following the current allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip	    -  pointer to in-core inode requiring allocation.</span>
<span class="cm"> *	blkno	    -  starting block of the current allocation.</span>
<span class="cm"> *	nblocks	    -  number of contiguous blocks within the current</span>
<span class="cm"> *		       allocation.</span>
<span class="cm"> *	addnblocks  -  number of blocks to add to the allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbExtend</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">s64</span> <span class="n">addnblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">s64</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">lastblkno</span><span class="p">,</span> <span class="n">extblkno</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">rel_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want a non-aligned extent to cross a page boundary</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">rel_block</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rel_block</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">+</span> <span class="n">addnblocks</span> <span class="o">&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* get the last block of the current allocation */</span>
	<span class="n">lastblkno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* determine the block number of the block following</span>
<span class="cm">	 * the existing allocation.</span>
<span class="cm">	 */</span>
	<span class="n">extblkno</span> <span class="o">=</span> <span class="n">lastblkno</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">RDWRLOCK_DMAP</span><span class="p">);</span>

	<span class="cm">/* better be within the file system */</span>
	<span class="n">bmp</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastblkno</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lastblkno</span> <span class="o">&gt;=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbExtend: the block is outside the filesystem&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;ll attempt to extend the current allocation in place by</span>
<span class="cm">	 * allocating the additional blocks as the blocks immediately</span>
<span class="cm">	 * following the current allocation.  we only try to extend the</span>
<span class="cm">	 * current allocation in place if the number of additional blocks</span>
<span class="cm">	 * can fit into a dmap, the last block of the current allocation</span>
<span class="cm">	 * is not the last block of the file system, and the start of the</span>
<span class="cm">	 * inplace extension is not on an allocation group boundary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addnblocks</span> <span class="o">&gt;</span> <span class="n">BPERDMAP</span> <span class="o">||</span> <span class="n">extblkno</span> <span class="o">&gt;=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">extblkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the buffer for the dmap containing the first block</span>
<span class="cm">	 * of the extension.</span>
<span class="cm">	 */</span>
	<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">extblkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* try to allocate the blocks immediately following the</span>
<span class="cm">	 * current allocation.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocNext</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">extblkno</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">addnblocks</span><span class="p">);</span>

	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>

	<span class="cm">/* were we successful ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* we were not successful */</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>


	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocNext()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to allocate the blocks of the specified block</span>
<span class="cm"> *		range within a dmap.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	dp	-  pointer to dmap.</span>
<span class="cm"> *	blkno	-  starting block number of the range.</span>
<span class="cm"> *	nblocks	-  number of contiguous free blocks of the range.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbAllocNext</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dbitno</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">rembits</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">nwords</span><span class="p">,</span> <span class="n">wbitno</span><span class="p">,</span> <span class="n">nw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">l2size</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">leafidx</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LEAFIND</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbAllocNext: Corrupt dmap page&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* pick up a pointer to the leaves of the dmap tree.</span>
<span class="cm">	 */</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">leafidx</span><span class="p">);</span>

	<span class="cm">/* determine the bit number and word within the dmap of the</span>
<span class="cm">	 * starting block.</span>
<span class="cm">	 */</span>
	<span class="n">dbitno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

	<span class="cm">/* check if the specified block range is contained within</span>
<span class="cm">	 * this dmap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbitno</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">&gt;</span> <span class="n">BPERDMAP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* check if the starting leaf indicates that anything</span>
<span class="cm">	 * is free.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">==</span> <span class="n">NOFREE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* check the dmaps words corresponding to block range to see</span>
<span class="cm">	 * if the block range is free.  not all bits of the first and</span>
<span class="cm">	 * last words may be contained within the block range.  if this</span>
<span class="cm">	 * is the case, we&#39;ll work against those words (i.e. partial first</span>
<span class="cm">	 * and/or last) on an individual basis (a single pass) and examine</span>
<span class="cm">	 * the actual bits to determine if they are free.  a single pass</span>
<span class="cm">	 * will be used for all dmap words fully contained within the</span>
<span class="cm">	 * specified range.  within this pass, the leaves of the dmap</span>
<span class="cm">	 * tree will be examined to determine if the blocks are free. a</span>
<span class="cm">	 * single leaf may describe the free space of multiple dmap</span>
<span class="cm">	 * words, so we may visit only a subset of the actual leaves</span>
<span class="cm">	 * corresponding to the dmap words of the block range.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rembits</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">rembits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rembits</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">dbitno</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* determine the bit number within the word and</span>
<span class="cm">		 * the number of bits within the word.</span>
<span class="cm">		 */</span>
		<span class="n">wbitno</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rembits</span><span class="p">,</span> <span class="n">DBWORD</span> <span class="o">-</span> <span class="n">wbitno</span><span class="p">);</span>

		<span class="cm">/* check if only part of the word is to be examined.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&lt;</span> <span class="n">DBWORD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* check if the bits are free.</span>
<span class="cm">			 */</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="n">nb</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">wbitno</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">]))</span> <span class="o">!=</span> <span class="n">mask</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

			<span class="n">word</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* one or more dmap words are fully contained</span>
<span class="cm">			 * within the block range.  determine how many</span>
<span class="cm">			 * words and how many bits.</span>
<span class="cm">			 */</span>
			<span class="n">nwords</span> <span class="o">=</span> <span class="n">rembits</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">nwords</span> <span class="o">&lt;&lt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

			<span class="cm">/* now examine the appropriate leaves to determine</span>
<span class="cm">			 * if the blocks are free.</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">nwords</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* does the leaf describe any free space ?</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">BUDMIN</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

				<span class="cm">/* determine the l2 number of bits provided</span>
<span class="cm">				 * by this leaf.</span>
<span class="cm">				 */</span>
				<span class="n">l2size</span> <span class="o">=</span>
				    <span class="n">min</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">leaf</span><span class="p">[</span><span class="n">word</span><span class="p">],</span> <span class="n">NLSTOL2BSZ</span><span class="p">(</span><span class="n">nwords</span><span class="p">));</span>

				<span class="cm">/* determine how many words were handled.</span>
<span class="cm">				 */</span>
				<span class="n">nw</span> <span class="o">=</span> <span class="n">BUDSIZE</span><span class="p">(</span><span class="n">l2size</span><span class="p">,</span> <span class="n">BUDMIN</span><span class="p">);</span>

				<span class="n">nwords</span> <span class="o">-=</span> <span class="n">nw</span><span class="p">;</span>
				<span class="n">word</span> <span class="o">+=</span> <span class="n">nw</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* allocate the blocks.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dbAllocDmap</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocNear()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to allocate a number of contiguous free blocks near</span>
<span class="cm"> *		a specified block (hint) within a dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		starting with the dmap leaf that covers the hint, we&#39;ll</span>
<span class="cm"> *		check the next four contiguous leaves for sufficient free</span>
<span class="cm"> *		space.  if sufficient free space is found, we&#39;ll allocate</span>
<span class="cm"> *		the desired free space.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	dp	-  pointer to dmap.</span>
<span class="cm"> *	blkno	-  block number to allocate near.</span>
<span class="cm"> *	nblocks	-  actual number of contiguous free blocks desired.</span>
<span class="cm"> *	l2nb	-  log2 number of contiguous free blocks desired.</span>
<span class="cm"> *	results	-  on successful return, set to the starting block number</span>
<span class="cm"> *		   of the newly allocated range.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dbAllocNear</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span>
	    <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">word</span><span class="p">,</span> <span class="n">lword</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">leafidx</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LEAFIND</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbAllocNear: Corrupt dmap page&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">leafidx</span><span class="p">);</span>

	<span class="cm">/* determine the word within the dmap that holds the hint</span>
<span class="cm">	 * (i.e. blkno).  also, determine the last word in the dmap</span>
<span class="cm">	 * that we&#39;ll include in our examination.</span>
<span class="cm">	 */</span>
	<span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
	<span class="n">lword</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">word</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">LPERDMAP</span><span class="p">);</span>

	<span class="cm">/* examine the leaves for sufficient free space.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">word</span> <span class="o">&lt;</span> <span class="n">lword</span><span class="p">;</span> <span class="n">word</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* does the leaf describe sufficient free space ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">l2nb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* determine the block number within the file system</span>
<span class="cm">		 * of the first block described by this dmap word.</span>
<span class="cm">		 */</span>
		<span class="n">blkno</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="n">L2DBWORD</span><span class="p">);</span>

		<span class="cm">/* if not all bits of the dmap word are free, get the</span>
<span class="cm">		 * starting bit number within the dmap word of the required</span>
<span class="cm">		 * string of free bits and adjust the block number with the</span>
<span class="cm">		 * value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">BUDMIN</span><span class="p">)</span>
			<span class="n">blkno</span> <span class="o">+=</span>
			    <span class="n">dbFindBits</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">]),</span> <span class="n">l2nb</span><span class="p">);</span>

		<span class="cm">/* allocate the blocks.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocDmap</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">results</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>

		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocAG()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to allocate the specified number of contiguous</span>
<span class="cm"> *		free blocks within the specified allocation group.</span>
<span class="cm"> *</span>
<span class="cm"> *		unless the allocation group size is equal to the number</span>
<span class="cm"> *		of blocks per dmap, the dmap control pages will be used to</span>
<span class="cm"> *		find the required free space, if available.  we start the</span>
<span class="cm"> *		search at the highest dmap control page level which</span>
<span class="cm"> *		distinctly describes the allocation group&#39;s free space</span>
<span class="cm"> *		(i.e. the highest level at which the allocation group&#39;s</span>
<span class="cm"> *		free space is not mixed in with that of any other group).</span>
<span class="cm"> *		in addition, we start the search within this level at a</span>
<span class="cm"> *		height of the dmapctl dmtree at which the nodes distinctly</span>
<span class="cm"> *		describe the allocation group&#39;s free space.  at this height,</span>
<span class="cm"> *		the allocation group&#39;s free space may be represented by 1</span>
<span class="cm"> *		or two sub-trees, depending on the allocation group size.</span>
<span class="cm"> *		we search the top nodes of these subtrees left to right for</span>
<span class="cm"> *		sufficient free space.  if sufficient free space is found,</span>
<span class="cm"> *		the subtree is searched to find the leftmost leaf that</span>
<span class="cm"> *		has free space.  once we have made it to the leaf, we</span>
<span class="cm"> *		move the search to the next lower level dmap control page</span>
<span class="cm"> *		corresponding to this leaf.  we continue down the dmap control</span>
<span class="cm"> *		pages until we find the dmap that contains or starts the</span>
<span class="cm"> *		sufficient free space and we allocate at this dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		if the allocation group size is equal to the dmap size,</span>
<span class="cm"> *		we&#39;ll start at the dmap corresponding to the allocation</span>
<span class="cm"> *		group and attempt the allocation at this level.</span>
<span class="cm"> *</span>
<span class="cm"> *		the dmap control page search is also not performed if the</span>
<span class="cm"> *		allocation group is completely free and we go to the first</span>
<span class="cm"> *		dmap of the allocation group to do the allocation.  this is</span>
<span class="cm"> *		done because the allocation group may be part (not the first</span>
<span class="cm"> *		part) of a larger binary buddy system, causing the dmap</span>
<span class="cm"> *		control pages to indicate no free space (NOFREE) within</span>
<span class="cm"> *		the allocation group.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	agno	- allocation group number.</span>
<span class="cm"> *	nblocks	-  actual number of contiguous free blocks desired.</span>
<span class="cm"> *	l2nb	-  log2 number of contiguous free blocks desired.</span>
<span class="cm"> *	results	-  on successful return, set to the starting block number</span>
<span class="cm"> *		   of the newly allocated range.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * note: IWRITE_LOCK(ipmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dbAllocAG</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="n">dcp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">agperlev</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">budmin</span><span class="p">;</span>

	<span class="cm">/* allocation request should not be for more than the</span>
<span class="cm">	 * allocation group size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbAllocAG: allocation request is larger than the &quot;</span>
			  <span class="s">&quot;allocation group size&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* determine the starting block number of the allocation</span>
<span class="cm">	 * group.</span>
<span class="cm">	 */</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">agno</span> <span class="o">&lt;&lt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">;</span>

	<span class="cm">/* check if the allocation group size is the minimum allocation</span>
<span class="cm">	 * group size or if the allocation group is completely free. if</span>
<span class="cm">	 * the allocation group size is the minimum size of BPERDMAP (i.e.</span>
<span class="cm">	 * 1 dmap), there is no need to search the dmap control page (below)</span>
<span class="cm">	 * that fully describes the allocation group since the allocation</span>
<span class="cm">	 * group is already fully described by a dmap.  in this case, we</span>
<span class="cm">	 * just call dbAllocCtl() to search the dmap tree and allocate the</span>
<span class="cm">	 * required space if available.</span>
<span class="cm">	 *</span>
<span class="cm">	 * if the allocation group is completely free, dbAllocCtl() is</span>
<span class="cm">	 * also called to allocate the required space.  this is done for</span>
<span class="cm">	 * two reasons.  first, it makes no sense searching the dmap control</span>
<span class="cm">	 * pages for free space when we know that free space exists.  second,</span>
<span class="cm">	 * the dmap control pages may indicate that the allocation group</span>
<span class="cm">	 * has no free space if the allocation group is part (not the first</span>
<span class="cm">	 * part) of a larger binary buddy system.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span> <span class="o">==</span> <span class="n">BPERDMAP</span>
	    <span class="o">||</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agno</span><span class="p">]</span> <span class="o">==</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agno</span><span class="p">]</span> <span class="o">==</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;blkno = %Lx, blocks = %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">blkno</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;dbAllocAG: dbAllocCtl failed in free AG&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* the buffer for the dmap control page that fully describes the</span>
<span class="cm">	 * allocation group.</span>
<span class="cm">	 */</span>
	<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTOCTL</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_aglevel</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">dcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">budmin</span> <span class="o">=</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">budmin</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">leafidx</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">CTLLEAFIND</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbAllocAG: Corrupt dmapctl page&quot;</span><span class="p">);</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* search the subtree(s) of the dmap control page that describes</span>
<span class="cm">	 * the allocation group, looking for sufficient free space.  to begin,</span>
<span class="cm">	 * determine how many allocation groups are represented in a dmap</span>
<span class="cm">	 * control page at the control page level (i.e. L0, L1, L2) that</span>
<span class="cm">	 * fully describes an allocation group. next, determine the starting</span>
<span class="cm">	 * tree index of this allocation group within the control page.</span>
<span class="cm">	 */</span>
	<span class="n">agperlev</span> <span class="o">=</span>
	    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">L2LPERCTL</span> <span class="o">-</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agheight</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">/</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agwidth</span><span class="p">;</span>
	<span class="n">ti</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agstart</span> <span class="o">+</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agwidth</span> <span class="o">*</span> <span class="p">(</span><span class="n">agno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">agperlev</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* dmap control page trees fan-out by 4 and a single allocation</span>
<span class="cm">	 * group may be described by 1 or 2 subtrees within the ag level</span>
<span class="cm">	 * dmap control page, depending upon the ag size. examine the ag&#39;s</span>
<span class="cm">	 * subtrees for sufficient free space, starting with the leftmost</span>
<span class="cm">	 * subtree.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agwidth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ti</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* is there sufficient free space ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&gt;</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ti</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* sufficient free space found in a subtree. now search down</span>
<span class="cm">		 * the subtree to find the leftmost leaf that describes this</span>
<span class="cm">		 * free space.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agheight</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">ti</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&lt;=</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">ti</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					  <span class="s">&quot;dbAllocAG: failed descending stree&quot;</span><span class="p">);</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* determine the block number within the file system</span>
<span class="cm">		 * that corresponds to this leaf.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_aglevel</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_aglevel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">blkno</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MAXL1SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>		<span class="cm">/* bmp-&gt;db_aglevel == 0 */</span>
			<span class="n">blkno</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MAXL0SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">blkno</span> <span class="o">+=</span>
		    <span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="p">(</span><span class="n">ti</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">leafidx</span><span class="p">)))</span> <span class="o">&lt;&lt;</span> <span class="n">budmin</span><span class="p">;</span>

		<span class="cm">/* release the buffer in preparation for going down</span>
<span class="cm">		 * the next level of dmap control pages.</span>
<span class="cm">		 */</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="cm">/* check if we need to continue to search down the lower</span>
<span class="cm">		 * level dmap control pages.  we need to if the number of</span>
<span class="cm">		 * blocks required is less than maximum number of blocks</span>
<span class="cm">		 * described at the next lower level.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&lt;</span> <span class="n">budmin</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* search the lower level dmap control pages to get</span>
<span class="cm">			 * the starting block number of the dmap that</span>
<span class="cm">			 * contains or starts off the free space.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span>
			     <span class="n">dbFindCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_aglevel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">blkno</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
						  <span class="s">&quot;dbAllocAG: control page &quot;</span>
						  <span class="s">&quot;inconsistent&quot;</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* allocate the blocks.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;dbAllocAG: unable to allocate blocks&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* no space in the allocation group.  release the buffer and</span>
<span class="cm">	 * return -ENOSPC.</span>
<span class="cm">	 */</span>
	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocAny()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to allocate the specified number of contiguous</span>
<span class="cm"> *		free blocks anywhere in the file system.</span>
<span class="cm"> *</span>
<span class="cm"> *		dbAllocAny() attempts to find the sufficient free space by</span>
<span class="cm"> *		searching down the dmap control pages, starting with the</span>
<span class="cm"> *		highest level (i.e. L0, L1, L2) control page.  if free space</span>
<span class="cm"> *		large enough to satisfy the desired free space is found, the</span>
<span class="cm"> *		desired free space is allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	nblocks	 -  actual number of contiguous free blocks desired.</span>
<span class="cm"> *	l2nb	 -  log2 number of contiguous free blocks desired.</span>
<span class="cm"> *	results	-  on successful return, set to the starting block number</span>
<span class="cm"> *		   of the newly allocated range.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbAllocAny</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* starting with the top level dmap control page, search</span>
<span class="cm">	 * down the dmap control levels for sufficient free space.</span>
<span class="cm">	 * if free space is found, dbFindCtl() returns the starting</span>
<span class="cm">	 * block number of the dmap that contains or starts off the</span>
<span class="cm">	 * range of free space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbFindCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxlevel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">)))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>

	<span class="cm">/* allocate the blocks.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbAllocAny: unable to allocate blocks&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbFindCtl()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	starting at a specified dmap control page level and block</span>
<span class="cm"> *		number, search down the dmap control levels for a range of</span>
<span class="cm"> *		contiguous free blocks large enough to satisfy an allocation</span>
<span class="cm"> *		request for the specified number of free blocks.</span>
<span class="cm"> *</span>
<span class="cm"> *		if sufficient contiguous free blocks are found, this routine</span>
<span class="cm"> *		returns the starting block number within a dmap page that</span>
<span class="cm"> *		contains or starts a range of contiqious free blocks that</span>
<span class="cm"> *		is sufficient in size.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	level	-  starting dmap control page level.</span>
<span class="cm"> *	l2nb	-  log2 number of contiguous free blocks desired.</span>
<span class="cm"> *	*blkno	-  on entry, starting block number for conducting the search.</span>
<span class="cm"> *		   on successful return, the first block within a dmap page</span>
<span class="cm"> *		   that contains or starts a range of contiguous free blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbFindCtl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">blkno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">leafidx</span><span class="p">,</span> <span class="n">lev</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">b</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="n">dcp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">budmin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="cm">/* starting at the specified dmap control page level and block</span>
<span class="cm">	 * number, search down the dmap control levels for the starting</span>
<span class="cm">	 * block number of a dmap page that contains or starts off</span>
<span class="cm">	 * sufficient free blocks.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lev</span> <span class="o">=</span> <span class="n">level</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="n">blkno</span><span class="p">;</span> <span class="n">lev</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lev</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get the buffer of the dmap control page for the block</span>
<span class="cm">		 * number and level (i.e. L0, L1, L2).</span>
<span class="cm">		 */</span>
		<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTOCTL</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">,</span> <span class="n">lev</span><span class="p">);</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">dcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">budmin</span> <span class="o">=</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">budmin</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">leafidx</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">CTLLEAFIND</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;dbFindCtl: Corrupt dmapctl page&quot;</span><span class="p">);</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* search the tree within the dmap control page for</span>
<span class="cm">		 * sufficient free space.  if sufficient free space is found,</span>
<span class="cm">		 * dbFindLeaf() returns the index of the leaf at which</span>
<span class="cm">		 * free space was found.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dbFindLeaf</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dcp</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leafidx</span><span class="p">);</span>

		<span class="cm">/* release the buffer.</span>
<span class="cm">		 */</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="cm">/* space found ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lev</span> <span class="o">!=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					  <span class="s">&quot;dbFindCtl: dmap inconsistent&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* adjust the block number to reflect the location within</span>
<span class="cm">		 * the dmap control page (i.e. the leaf) at which free</span>
<span class="cm">		 * space was found.</span>
<span class="cm">		 */</span>
		<span class="n">b</span> <span class="o">+=</span> <span class="p">(((</span><span class="n">s64</span><span class="p">)</span> <span class="n">leafidx</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">budmin</span><span class="p">);</span>

		<span class="cm">/* we stop the search at this dmap control page level if</span>
<span class="cm">		 * the number of blocks required is greater than or equal</span>
<span class="cm">		 * to the maximum number of blocks described at the next</span>
<span class="cm">		 * (lower) level.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&gt;=</span> <span class="n">budmin</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocCtl()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to allocate a specified number of contiguous</span>
<span class="cm"> *		blocks starting within a specific dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine is called by higher level routines that search</span>
<span class="cm"> *		the dmap control pages above the actual dmaps for contiguous</span>
<span class="cm"> *		free space.  the result of successful searches by these</span>
<span class="cm"> *		routines are the starting block numbers within dmaps, with</span>
<span class="cm"> *		the dmaps themselves containing the desired contiguous free</span>
<span class="cm"> *		space or starting a contiguous free space of desired size</span>
<span class="cm"> *		that is made up of the blocks of one or more dmaps. these</span>
<span class="cm"> *		calls should not fail due to insufficent resources.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine is called in some cases where it is not known</span>
<span class="cm"> *		whether it will fail due to insufficient resources.  more</span>
<span class="cm"> *		specifically, this occurs when allocating from an allocation</span>
<span class="cm"> *		group whose size is equal to the number of blocks per dmap.</span>
<span class="cm"> *		in this case, the dmap control pages are not examined prior</span>
<span class="cm"> *		to calling this routine (to save pathlength) and the call</span>
<span class="cm"> *		might fail.</span>
<span class="cm"> *</span>
<span class="cm"> *		for a request size that fits within a dmap, this routine relies</span>
<span class="cm"> *		upon the dmap&#39;s dmtree to find the requested contiguous free</span>
<span class="cm"> *		space.  for request sizes that are larger than a dmap, the</span>
<span class="cm"> *		requested free space will start at the first block of the</span>
<span class="cm"> *		first dmap (i.e. blkno).</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	nblocks	 -  actual number of contiguous free blocks to allocate.</span>
<span class="cm"> *	l2nb	 -  log2 number of contiguous free blocks to allocate.</span>
<span class="cm"> *	blkno	 -  starting block number of the dmap to start the allocation</span>
<span class="cm"> *		    from.</span>
<span class="cm"> *	results	-  on successful return, set to the starting block number</span>
<span class="cm"> *		   of the newly allocated range.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dbAllocCtl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">nb</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">b</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>

	<span class="cm">/* check if the allocation request is confined to a single dmap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&lt;=</span> <span class="n">L2BPERDMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get the buffer for the dmap.</span>
<span class="cm">		 */</span>
		<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* try to allocate the blocks.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocDmapLev</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* allocation request involving multiple dmaps. it must start on</span>
<span class="cm">	 * a dmap boundary.</span>
<span class="cm">	 */</span>
	<span class="n">assert</span><span class="p">((</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* allocate the blocks dmap by dmap.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get the buffer for the dmap.</span>
<span class="cm">		 */</span>
		<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">backout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* the dmap better be all free.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">]</span> <span class="o">!=</span> <span class="n">L2BPERDMAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;dbAllocCtl: the dmap is not all free&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">backout</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* determine how many blocks to allocate from this dmap.</span>
<span class="cm">		 */</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">BPERDMAP</span><span class="p">);</span>

		<span class="cm">/* allocate the blocks from the dmap.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocDmap</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">nb</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">backout</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* write the buffer.</span>
<span class="cm">		 */</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set the results (starting block number) and return.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">results</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* something failed in handling an allocation request involving</span>
<span class="cm">	 * multiple dmaps.  we&#39;ll try to clean up by backing out any</span>
<span class="cm">	 * allocation that has already happened for this request.  if</span>
<span class="cm">	 * we fail in backing out the allocation, we&#39;ll mark the file</span>
<span class="cm">	 * system to indicate that blocks have been leaked.</span>
<span class="cm">	 */</span>
      <span class="nl">backout:</span>

	<span class="cm">/* try to backout the allocations dmap by dmap.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">nblocks</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">n</span> <span class="o">-=</span> <span class="n">BPERDMAP</span><span class="p">,</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">BPERDMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get the buffer for this dmap.</span>
<span class="cm">		 */</span>
		<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* could not back out.  mark the file system</span>
<span class="cm">			 * to indicate that we have leaked blocks.</span>
<span class="cm">			 */</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;dbAllocCtl: I/O Error: Block Leakage.&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* free the blocks is this dmap.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dbFreeDmap</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">BPERDMAP</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* could not back out.  mark the file system</span>
<span class="cm">			 * to indicate that we have leaked blocks.</span>
<span class="cm">			 */</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;dbAllocCtl: Block Leakage.&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* write the buffer.</span>
<span class="cm">		 */</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocDmapLev()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	attempt to allocate a specified number of contiguous blocks</span>
<span class="cm"> *		from a specified dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine checks if the contiguous blocks are available.</span>
<span class="cm"> *		if so, nblocks of blocks are allocated; otherwise, ENOSPC is</span>
<span class="cm"> *		returned.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	mp	-  pointer to bmap descriptor</span>
<span class="cm"> *	dp	-  pointer to dmap to attempt to allocate blocks from.</span>
<span class="cm"> *	l2nb	-  log2 number of contiguous block desired.</span>
<span class="cm"> *	nblocks	-  actual number of contiguous block desired.</span>
<span class="cm"> *	results	-  on successful return, set to the starting block number</span>
<span class="cm"> *		   of the newly allocated range.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap), e.g., from dbAlloc(), or</span>
<span class="cm"> *	IWRITE_LOCK(ipbmap), e.g., dbAllocCtl(), held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dbAllocDmapLev</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span> <span class="n">results</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leafidx</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* can&#39;t be more than a dmaps worth of blocks */</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">l2nb</span> <span class="o">&lt;=</span> <span class="n">L2BPERDMAP</span><span class="p">);</span>

	<span class="cm">/* search the tree within the dmap page for sufficient</span>
<span class="cm">	 * free space.  if sufficient free space is found, dbFindLeaf()</span>
<span class="cm">	 * returns the index of the leaf at which free space was found.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbFindLeaf</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">,</span> <span class="n">l2nb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leafidx</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* determine the block number within the file system corresponding</span>
<span class="cm">	 * to the leaf at which free space was found.</span>
<span class="cm">	 */</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">leafidx</span> <span class="o">&lt;&lt;</span> <span class="n">L2DBWORD</span><span class="p">);</span>

	<span class="cm">/* if not all bits of the dmap word are free, get the starting</span>
<span class="cm">	 * bit number within the dmap word of the required string of free</span>
<span class="cm">	 * bits and adjust the block number with this value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">leafidx</span> <span class="o">+</span> <span class="n">LEAFIND</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">BUDMIN</span><span class="p">)</span>
		<span class="n">blkno</span> <span class="o">+=</span> <span class="n">dbFindBits</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">leafidx</span><span class="p">]),</span> <span class="n">l2nb</span><span class="p">);</span>

	<span class="cm">/* allocate the blocks */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocDmap</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">results</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocDmap()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	adjust the disk allocation map to reflect the allocation</span>
<span class="cm"> *		of a specified block range within a dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine allocates the specified blocks from the dmap</span>
<span class="cm"> *		through a call to dbAllocBits(). if the allocation of the</span>
<span class="cm"> *		block range causes the maximum string of free blocks within</span>
<span class="cm"> *		the dmap to change (i.e. the value of the root of the dmap&#39;s</span>
<span class="cm"> *		dmtree), this routine will cause this change to be reflected</span>
<span class="cm"> *		up through the appropriate levels of the dmap control pages</span>
<span class="cm"> *		by a call to dbAdjCtl() for the L0 dmap control page that</span>
<span class="cm"> *		covers this dmap.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	dp	-  pointer to dmap to allocate the block range from.</span>
<span class="cm"> *	blkno	-  starting block number of the block to be allocated.</span>
<span class="cm"> *	nblocks	-  number of blocks to be allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbAllocDmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s8</span> <span class="n">oldroot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* save the current value of the root (i.e. maximum free string)</span>
<span class="cm">	 * of the dmap tree.</span>
<span class="cm">	 */</span>
	<span class="n">oldroot</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">];</span>

	<span class="cm">/* allocate the specified (blocks) bits */</span>
	<span class="n">dbAllocBits</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>

	<span class="cm">/* if the root has not changed, done. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">]</span> <span class="o">==</span> <span class="n">oldroot</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* root changed. bubble the change up to the dmap control pages.</span>
<span class="cm">	 * if the adjustment of the upper level control pages fails,</span>
<span class="cm">	 * backout the bit allocation (thus making everything consistent).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAdjCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="n">dbFreeBits</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbFreeDmap()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	adjust the disk allocation map to reflect the allocation</span>
<span class="cm"> *		of a specified block range within a dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine frees the specified blocks from the dmap through</span>
<span class="cm"> *		a call to dbFreeBits(). if the deallocation of the block range</span>
<span class="cm"> *		causes the maximum string of free blocks within the dmap to</span>
<span class="cm"> *		change (i.e. the value of the root of the dmap&#39;s dmtree), this</span>
<span class="cm"> *		routine will cause this change to be reflected up through the</span>
<span class="cm"> *		appropriate levels of the dmap control pages by a call to</span>
<span class="cm"> *		dbAdjCtl() for the L0 dmap control page that covers this dmap.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	dp	-  pointer to dmap to free the block range from.</span>
<span class="cm"> *	blkno	-  starting block number of the block to be freed.</span>
<span class="cm"> *	nblocks	-  number of blocks to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbFreeDmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s8</span> <span class="n">oldroot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">word</span><span class="p">;</span>

	<span class="cm">/* save the current value of the root (i.e. maximum free string)</span>
<span class="cm">	 * of the dmap tree.</span>
<span class="cm">	 */</span>
	<span class="n">oldroot</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">];</span>

	<span class="cm">/* free the specified (blocks) bits */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dbFreeBits</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>

	<span class="cm">/* if error or the root has not changed, done. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">]</span> <span class="o">==</span> <span class="n">oldroot</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>

	<span class="cm">/* root changed. bubble the change up to the dmap control pages.</span>
<span class="cm">	 * if the adjustment of the upper level control pages fails,</span>
<span class="cm">	 * backout the deallocation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAdjCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

		<span class="cm">/* as part of backing out the deallocation, we will have</span>
<span class="cm">		 * to back split the dmap tree if the deallocation caused</span>
<span class="cm">		 * the freed blocks to become part of a larger binary buddy</span>
<span class="cm">		 * system.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">==</span> <span class="n">NOFREE</span><span class="p">)</span>
			<span class="n">dbBackSplit</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>

		<span class="n">dbAllocBits</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocBits()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	allocate a specified block range from a dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine updates the dmap to reflect the working</span>
<span class="cm"> *		state allocation of the specified block range. it directly</span>
<span class="cm"> *		updates the bits of the working map and causes the adjustment</span>
<span class="cm"> *		of the binary buddy system described by the dmap&#39;s dmtree</span>
<span class="cm"> *		leaves to reflect the bits allocated.  it also causes the</span>
<span class="cm"> *		dmap&#39;s dmtree, as a whole, to reflect the allocated range.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	dp	-  pointer to dmap to allocate bits from.</span>
<span class="cm"> *	blkno	-  starting block number of the bits to be allocated.</span>
<span class="cm"> *	nblocks	-  number of bits to be allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES: none</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dbAllocBits</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dbitno</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">rembits</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">nwords</span><span class="p">,</span> <span class="n">wbitno</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">agno</span><span class="p">;</span>
	<span class="n">dmtree_t</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>

	<span class="cm">/* pick up a pointer to the leaves of the dmap tree */</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">.</span><span class="n">stree</span> <span class="o">+</span> <span class="n">LEAFIND</span><span class="p">;</span>

	<span class="cm">/* determine the bit number and word within the dmap of the</span>
<span class="cm">	 * starting block.</span>
<span class="cm">	 */</span>
	<span class="n">dbitno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

	<span class="cm">/* block range better be within the dmap */</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">dbitno</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">&lt;=</span> <span class="n">BPERDMAP</span><span class="p">);</span>

	<span class="cm">/* allocate the bits of the dmap&#39;s words corresponding to the block</span>
<span class="cm">	 * range. not all bits of the first and last words may be contained</span>
<span class="cm">	 * within the block range.  if this is the case, we&#39;ll work against</span>
<span class="cm">	 * those words (i.e. partial first and/or last) on an individual basis</span>
<span class="cm">	 * (a single pass), allocating the bits of interest by hand and</span>
<span class="cm">	 * updating the leaf corresponding to the dmap word. a single pass</span>
<span class="cm">	 * will be used for all dmap words fully contained within the</span>
<span class="cm">	 * specified range.  within this pass, the bits of all fully contained</span>
<span class="cm">	 * dmap words will be marked as free in a single shot and the leaves</span>
<span class="cm">	 * will be updated. a single leaf may describe the free space of</span>
<span class="cm">	 * multiple dmap words, so we may update only a subset of the actual</span>
<span class="cm">	 * leaves corresponding to the dmap words of the block range.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rembits</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">rembits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rembits</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">dbitno</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* determine the bit number within the word and</span>
<span class="cm">		 * the number of bits within the word.</span>
<span class="cm">		 */</span>
		<span class="n">wbitno</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rembits</span><span class="p">,</span> <span class="n">DBWORD</span> <span class="o">-</span> <span class="n">wbitno</span><span class="p">);</span>

		<span class="cm">/* check if only part of a word is to be allocated.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&lt;</span> <span class="n">DBWORD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* allocate (set to 1) the appropriate bits within</span>
<span class="cm">			 * this dmap word.</span>
<span class="cm">			 */</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="n">nb</span><span class="p">)</span>
						      <span class="o">&gt;&gt;</span> <span class="n">wbitno</span><span class="p">);</span>

			<span class="cm">/* update the leaf for this dmap word. in addition</span>
<span class="cm">			 * to setting the leaf value to the binary buddy max</span>
<span class="cm">			 * of the updated dmap word, dbSplit() will split</span>
<span class="cm">			 * the binary system of the leaves if need be.</span>
<span class="cm">			 */</span>
			<span class="n">dbSplit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">BUDMIN</span><span class="p">,</span>
				<span class="n">dbMaxBud</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">]));</span>

			<span class="n">word</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* one or more dmap words are fully contained</span>
<span class="cm">			 * within the block range.  determine how many</span>
<span class="cm">			 * words and allocate (set to 1) the bits of these</span>
<span class="cm">			 * words.</span>
<span class="cm">			 */</span>
			<span class="n">nwords</span> <span class="o">=</span> <span class="n">rembits</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ONES</span><span class="p">,</span> <span class="n">nwords</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

			<span class="cm">/* determine how many bits.</span>
<span class="cm">			 */</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">nwords</span> <span class="o">&lt;&lt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

			<span class="cm">/* now update the appropriate leaves to reflect</span>
<span class="cm">			 * the allocated words.</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">nwords</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nwords</span> <span class="o">-=</span> <span class="n">nw</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">BUDMIN</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
						  <span class="s">&quot;dbAllocBits: leaf page &quot;</span>
						  <span class="s">&quot;corrupt&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* determine what the leaf value should be</span>
<span class="cm">				 * updated to as the minimum of the l2 number</span>
<span class="cm">				 * of bits being allocated and the l2 number</span>
<span class="cm">				 * of bits currently described by this leaf.</span>
<span class="cm">				 */</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">leaf</span><span class="p">[</span><span class="n">word</span><span class="p">],</span> <span class="n">NLSTOL2BSZ</span><span class="p">(</span><span class="n">nwords</span><span class="p">));</span>

				<span class="cm">/* update the leaf to reflect the allocation.</span>
<span class="cm">				 * in addition to setting the leaf value to</span>
<span class="cm">				 * NOFREE, dbSplit() will split the binary</span>
<span class="cm">				 * system of the leaves to reflect the current</span>
<span class="cm">				 * allocation (size).</span>
<span class="cm">				 */</span>
				<span class="n">dbSplit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">NOFREE</span><span class="p">);</span>

				<span class="cm">/* get the number of dmap words handled */</span>
				<span class="n">nw</span> <span class="o">=</span> <span class="n">BUDSIZE</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">BUDMIN</span><span class="p">);</span>
				<span class="n">word</span> <span class="o">+=</span> <span class="n">nw</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* update the free count for this dmap */</span>
	<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">nfree</span><span class="p">,</span> <span class="o">-</span><span class="n">nblocks</span><span class="p">);</span>

	<span class="n">BMAP_LOCK</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="cm">/* if this allocation group is completely free,</span>
<span class="cm">	 * update the maximum allocation group number if this allocation</span>
<span class="cm">	 * group is the new max.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agno</span> <span class="o">&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span><span class="p">)</span>
		<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span> <span class="o">=</span> <span class="n">agno</span><span class="p">;</span>

	<span class="cm">/* update the free count for the allocation group and map */</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agno</span><span class="p">]</span> <span class="o">-=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_nfree</span> <span class="o">-=</span> <span class="n">nblocks</span><span class="p">;</span>

	<span class="n">BMAP_UNLOCK</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbFreeBits()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	free a specified block range from a dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine updates the dmap to reflect the working</span>
<span class="cm"> *		state allocation of the specified block range. it directly</span>
<span class="cm"> *		updates the bits of the working map and causes the adjustment</span>
<span class="cm"> *		of the binary buddy system described by the dmap&#39;s dmtree</span>
<span class="cm"> *		leaves to reflect the bits freed.  it also causes the dmap&#39;s</span>
<span class="cm"> *		dmtree, as a whole, to reflect the deallocated range.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	dp	-  pointer to dmap to free bits from.</span>
<span class="cm"> *	blkno	-  starting block number of the bits to be freed.</span>
<span class="cm"> *	nblocks	-  number of bits to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES: 0 for success</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbFreeBits</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dbitno</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">rembits</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">nwords</span><span class="p">,</span> <span class="n">wbitno</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">agno</span><span class="p">;</span>
	<span class="n">dmtree_t</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* determine the bit number and word within the dmap of the</span>
<span class="cm">	 * starting block.</span>
<span class="cm">	 */</span>
	<span class="n">dbitno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

	<span class="cm">/* block range better be within the dmap.</span>
<span class="cm">	 */</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">dbitno</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">&lt;=</span> <span class="n">BPERDMAP</span><span class="p">);</span>

	<span class="cm">/* free the bits of the dmaps words corresponding to the block range.</span>
<span class="cm">	 * not all bits of the first and last words may be contained within</span>
<span class="cm">	 * the block range.  if this is the case, we&#39;ll work against those</span>
<span class="cm">	 * words (i.e. partial first and/or last) on an individual basis</span>
<span class="cm">	 * (a single pass), freeing the bits of interest by hand and updating</span>
<span class="cm">	 * the leaf corresponding to the dmap word. a single pass will be used</span>
<span class="cm">	 * for all dmap words fully contained within the specified range.</span>
<span class="cm">	 * within this pass, the bits of all fully contained dmap words will</span>
<span class="cm">	 * be marked as free in a single shot and the leaves will be updated. a</span>
<span class="cm">	 * single leaf may describe the free space of multiple dmap words,</span>
<span class="cm">	 * so we may update only a subset of the actual leaves corresponding</span>
<span class="cm">	 * to the dmap words of the block range.</span>
<span class="cm">	 *</span>
<span class="cm">	 * dbJoin() is used to update leaf values and will join the binary</span>
<span class="cm">	 * buddy system of the leaves if the new leaf values indicate this</span>
<span class="cm">	 * should be done.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rembits</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">rembits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rembits</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">dbitno</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* determine the bit number within the word and</span>
<span class="cm">		 * the number of bits within the word.</span>
<span class="cm">		 */</span>
		<span class="n">wbitno</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rembits</span><span class="p">,</span> <span class="n">DBWORD</span> <span class="o">-</span> <span class="n">wbitno</span><span class="p">);</span>

		<span class="cm">/* check if only part of a word is to be freed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&lt;</span> <span class="n">DBWORD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* free (zero) the appropriate bits within this</span>
<span class="cm">			 * dmap word.</span>
<span class="cm">			 */</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&amp;=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="n">nb</span><span class="p">)</span>
					  <span class="o">&gt;&gt;</span> <span class="n">wbitno</span><span class="p">));</span>

			<span class="cm">/* update the leaf for this dmap word.</span>
<span class="cm">			 */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">dbJoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span>
				    <span class="n">dbMaxBud</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">]));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

			<span class="n">word</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* one or more dmap words are fully contained</span>
<span class="cm">			 * within the block range.  determine how many</span>
<span class="cm">			 * words and free (zero) the bits of these words.</span>
<span class="cm">			 */</span>
			<span class="n">nwords</span> <span class="o">=</span> <span class="n">rembits</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nwords</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

			<span class="cm">/* determine how many bits.</span>
<span class="cm">			 */</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">nwords</span> <span class="o">&lt;&lt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

			<span class="cm">/* now update the appropriate leaves to reflect</span>
<span class="cm">			 * the freed words.</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">nwords</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nwords</span> <span class="o">-=</span> <span class="n">nw</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* determine what the leaf value should be</span>
<span class="cm">				 * updated to as the minimum of the l2 number</span>
<span class="cm">				 * of bits being freed and the l2 (max) number</span>
<span class="cm">				 * of bits that can be described by this leaf.</span>
<span class="cm">				 */</span>
				<span class="n">size</span> <span class="o">=</span>
				    <span class="n">min</span><span class="p">(</span><span class="n">LITOL2BSZ</span>
					<span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">L2LPERDMAP</span><span class="p">,</span> <span class="n">BUDMIN</span><span class="p">),</span>
					<span class="n">NLSTOL2BSZ</span><span class="p">(</span><span class="n">nwords</span><span class="p">));</span>

				<span class="cm">/* update the leaf.</span>
<span class="cm">				 */</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">dbJoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

				<span class="cm">/* get the number of dmap words handled.</span>
<span class="cm">				 */</span>
				<span class="n">nw</span> <span class="o">=</span> <span class="n">BUDSIZE</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">BUDMIN</span><span class="p">);</span>
				<span class="n">word</span> <span class="o">+=</span> <span class="n">nw</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* update the free count for this dmap.</span>
<span class="cm">	 */</span>
	<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">nfree</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>

	<span class="n">BMAP_LOCK</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="cm">/* update the free count for the allocation group and</span>
<span class="cm">	 * map.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_nfree</span> <span class="o">+=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agno</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nblocks</span><span class="p">;</span>

	<span class="cm">/* check if this allocation group is not completely free and</span>
<span class="cm">	 * if it is currently the maximum (rightmost) allocation group.</span>
<span class="cm">	 * if so, establish the new maximum allocation group number by</span>
<span class="cm">	 * searching left for the first allocation group with allocation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agno</span><span class="p">]</span> <span class="o">==</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span> <span class="o">&amp;&amp;</span> <span class="n">agno</span> <span class="o">==</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">agno</span> <span class="o">==</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	     <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agno</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span> <span class="n">db_mapsize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span><span class="p">]</span> <span class="o">!=</span>
			    <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* re-establish the allocation group preference if the</span>
<span class="cm">		 * current preference is right of the maximum allocation</span>
<span class="cm">		 * group.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span> <span class="o">&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span><span class="p">)</span>
			<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BMAP_UNLOCK</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAdjCtl()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	adjust a dmap control page at a specified level to reflect</span>
<span class="cm"> *		the change in a lower level dmap or dmap control page&#39;s</span>
<span class="cm"> *		maximum string of free blocks (i.e. a change in the root</span>
<span class="cm"> *		of the lower level object&#39;s dmtree) due to the allocation</span>
<span class="cm"> *		or deallocation of a range of blocks with a single dmap.</span>
<span class="cm"> *</span>
<span class="cm"> *		on entry, this routine is provided with the new value of</span>
<span class="cm"> *		the lower level dmap or dmap control page root and the</span>
<span class="cm"> *		starting block number of the block range whose allocation</span>
<span class="cm"> *		or deallocation resulted in the root change.  this range</span>
<span class="cm"> *		is respresented by a single leaf of the current dmapctl</span>
<span class="cm"> *		and the leaf will be updated with this value, possibly</span>
<span class="cm"> *		causing a binary buddy system within the leaves to be</span>
<span class="cm"> *		split or joined.  the update may also cause the dmapctl&#39;s</span>
<span class="cm"> *		dmtree to be updated.</span>
<span class="cm"> *</span>
<span class="cm"> *		if the adjustment of the dmap control page, itself, causes its</span>
<span class="cm"> *		root to change, this change will be bubbled up to the next dmap</span>
<span class="cm"> *		control level by a recursive call to this routine, specifying</span>
<span class="cm"> *		the new root value and the next dmap control page level to</span>
<span class="cm"> *		be adjusted.</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	bmp	-  pointer to bmap descriptor</span>
<span class="cm"> *	blkno	-  the first block of a block range within a dmap.  it is</span>
<span class="cm"> *		   the allocation or deallocation of this block range that</span>
<span class="cm"> *		   requires the dmap control page to be adjusted.</span>
<span class="cm"> *	newval	-  the new value of the lower level dmap or dmap control</span>
<span class="cm"> *		   page root.</span>
<span class="cm"> *	alloc	-  &#39;true&#39; if adjustment is due to an allocation.</span>
<span class="cm"> *	level	-  current level of dmap control page (i.e. L0, L1, L2) to</span>
<span class="cm"> *		   be adjusted.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dbAdjCtl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">oldroot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oldval</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">lblkno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="n">dcp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">leafno</span><span class="p">,</span> <span class="n">ti</span><span class="p">;</span>

	<span class="cm">/* get the buffer for the dmap control page for the specified</span>
<span class="cm">	 * block number and control page level.</span>
<span class="cm">	 */</span>
	<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTOCTL</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">dcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">leafidx</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">CTLLEAFIND</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;dbAdjCtl: Corrupt dmapctl page&quot;</span><span class="p">);</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* determine the leaf number corresponding to the block and</span>
<span class="cm">	 * the index within the dmap control tree.</span>
<span class="cm">	 */</span>
	<span class="n">leafno</span> <span class="o">=</span> <span class="n">BLKTOCTLLEAF</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">budmin</span><span class="p">);</span>
	<span class="n">ti</span> <span class="o">=</span> <span class="n">leafno</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">leafidx</span><span class="p">);</span>

	<span class="cm">/* save the current leaf value and the current root level (i.e.</span>
<span class="cm">	 * maximum l2 free string described by this dmapctl).</span>
<span class="cm">	 */</span>
	<span class="n">oldval</span> <span class="o">=</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ti</span><span class="p">];</span>
	<span class="n">oldroot</span> <span class="o">=</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">];</span>

	<span class="cm">/* check if this is a control page update for an allocation.</span>
<span class="cm">	 * if so, update the leaf to reflect the new leaf value using</span>
<span class="cm">	 * dbSplit(); otherwise (deallocation), use dbJoin() to update</span>
<span class="cm">	 * the leaf with the new value.  in addition to updating the</span>
<span class="cm">	 * leaf, dbSplit() will also split the binary buddy system of</span>
<span class="cm">	 * the leaves, if required, and bubble new values within the</span>
<span class="cm">	 * dmapctl tree, if required.  similarly, dbJoin() will join</span>
<span class="cm">	 * the binary buddy system of leaves and bubble new values up</span>
<span class="cm">	 * the dmapctl tree as required by the new leaf value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check if we are in the middle of a binary buddy</span>
<span class="cm">		 * system.  this happens when we are performing the</span>
<span class="cm">		 * first allocation out of an allocation group that</span>
<span class="cm">		 * is part (not the first part) of a larger binary</span>
<span class="cm">		 * buddy system.  if we are in the middle, back split</span>
<span class="cm">		 * the system prior to calling dbSplit() which assumes</span>
<span class="cm">		 * that it is at the front of a binary buddy system.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldval</span> <span class="o">==</span> <span class="n">NOFREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">dbBackSplit</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dcp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="n">oldval</span> <span class="o">=</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ti</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">dbSplit</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dcp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">,</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">budmin</span><span class="p">,</span> <span class="n">newval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dbJoin</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dcp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">,</span> <span class="n">newval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if the root of the current dmap control page changed due</span>
<span class="cm">	 * to the update and if the current dmap control page is not at</span>
<span class="cm">	 * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.</span>
<span class="cm">	 * root changed and this is not the top level), call this routine</span>
<span class="cm">	 * again (recursion) for the next higher level of the mapping to</span>
<span class="cm">	 * reflect the change in root for the current dmap control page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">]</span> <span class="o">!=</span> <span class="n">oldroot</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* are we below the top level of the map.  if so,</span>
<span class="cm">		 * bubble the root up to the next higher level.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxlevel</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* bubble up the new root of this dmap control page to</span>
<span class="cm">			 * the next level.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span>
			     <span class="n">dbAdjCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">],</span> <span class="n">alloc</span><span class="p">,</span>
				      <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/* something went wrong in bubbling up the new</span>
<span class="cm">				 * root value, so backout the changes to the</span>
<span class="cm">				 * current dmap control page.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dbJoin</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dcp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">,</span>
					       <span class="n">oldval</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* the dbJoin() above might have</span>
<span class="cm">					 * caused a larger binary buddy system</span>
<span class="cm">					 * to form and we may now be in the</span>
<span class="cm">					 * middle of it.  if this is the case,</span>
<span class="cm">					 * back split the buddies.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> <span class="o">==</span> <span class="n">NOFREE</span><span class="p">)</span>
						<span class="n">dbBackSplit</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span>
							    <span class="n">dcp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">);</span>
					<span class="n">dbSplit</span><span class="p">((</span><span class="n">dmtree_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">dcp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">,</span>
						<span class="n">dcp</span><span class="o">-&gt;</span><span class="n">budmin</span><span class="p">,</span> <span class="n">oldval</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/* release the buffer and return the error.</span>
<span class="cm">				 */</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* we&#39;re at the top level of the map. update</span>
<span class="cm">			 * the bmap control page to reflect the size</span>
<span class="cm">			 * of the maximum free buddy system.</span>
<span class="cm">			 */</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxlevel</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxfreebud</span> <span class="o">!=</span> <span class="n">oldroot</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jfs_error</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					  <span class="s">&quot;dbAdjCtl: the maximum free buddy is &quot;</span>
					  <span class="s">&quot;not the old root&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxfreebud</span> <span class="o">=</span> <span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* write the buffer.</span>
<span class="cm">	 */</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbSplit()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	update the leaf of a dmtree with a new value, splitting</span>
<span class="cm"> *		the leaf from the binary buddy system of the dmtree&#39;s</span>
<span class="cm"> *		leaves, as required.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	tp	- pointer to the tree containing the leaf.</span>
<span class="cm"> *	leafno	- the number of the leaf to be updated.</span>
<span class="cm"> *	splitsz	- the size the binary buddy system starting at the leaf</span>
<span class="cm"> *		  must be split to, specified as the log2 number of blocks.</span>
<span class="cm"> *	newval	- the new value for the leaf.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES: none</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dbSplit</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leafno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">splitsz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">budsz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cursz</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">leaf</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_leafidx</span><span class="p">);</span>

	<span class="cm">/* check if the leaf needs to be split.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">leafno</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_budmin</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the split occurs by cutting the buddy system in half</span>
<span class="cm">		 * at the specified leaf until we reach the specified</span>
<span class="cm">		 * size.  pick up the starting split size (current size</span>
<span class="cm">		 * - 1 in l2) and the corresponding buddy size.</span>
<span class="cm">		 */</span>
		<span class="n">cursz</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">[</span><span class="n">leafno</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">budsz</span> <span class="o">=</span> <span class="n">BUDSIZE</span><span class="p">(</span><span class="n">cursz</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_budmin</span><span class="p">);</span>

		<span class="cm">/* split until we reach the specified size.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cursz</span> <span class="o">&gt;=</span> <span class="n">splitsz</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* update the buddy&#39;s leaf with its new value.</span>
<span class="cm">			 */</span>
			<span class="n">dbAdjTree</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">leafno</span> <span class="o">^</span> <span class="n">budsz</span><span class="p">,</span> <span class="n">cursz</span><span class="p">);</span>

			<span class="cm">/* on to the next size and buddy.</span>
<span class="cm">			 */</span>
			<span class="n">cursz</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">budsz</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* adjust the dmap tree to reflect the specified leaf&#39;s new</span>
<span class="cm">	 * value.</span>
<span class="cm">	 */</span>
	<span class="n">dbAdjTree</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">,</span> <span class="n">newval</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbBackSplit()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	back split the binary buddy system of dmtree leaves</span>
<span class="cm"> *		that hold a specified leaf until the specified leaf</span>
<span class="cm"> *		starts its own binary buddy system.</span>
<span class="cm"> *</span>
<span class="cm"> *		the allocators typically perform allocations at the start</span>
<span class="cm"> *		of binary buddy systems and dbSplit() is used to accomplish</span>
<span class="cm"> *		any required splits.  in some cases, however, allocation</span>
<span class="cm"> *		may occur in the middle of a binary system and requires a</span>
<span class="cm"> *		back split, with the split proceeding out from the middle of</span>
<span class="cm"> *		the system (less efficient) rather than the start of the</span>
<span class="cm"> *		system (more efficient).  the cases in which a back split</span>
<span class="cm"> *		is required are rare and are limited to the first allocation</span>
<span class="cm"> *		within an allocation group which is a part (not first part)</span>
<span class="cm"> *		of a larger binary buddy system and a few exception cases</span>
<span class="cm"> *		in which a previous join operation must be backed out.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	tp	- pointer to the tree containing the leaf.</span>
<span class="cm"> *	leafno	- the number of the leaf to be updated.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES: none</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbBackSplit</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leafno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">budsz</span><span class="p">,</span> <span class="n">bud</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bsz</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cursz</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">leaf</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_leafidx</span><span class="p">);</span>

	<span class="cm">/* leaf should be part (not first part) of a binary</span>
<span class="cm">	 * buddy system.</span>
<span class="cm">	 */</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">leafno</span><span class="p">]</span> <span class="o">==</span> <span class="n">NOFREE</span><span class="p">);</span>

	<span class="cm">/* the back split is accomplished by iteratively finding the leaf</span>
<span class="cm">	 * that starts the buddy system that contains the specified leaf and</span>
<span class="cm">	 * splitting that system in two.  this iteration continues until</span>
<span class="cm">	 * the specified leaf becomes the start of a buddy system.</span>
<span class="cm">	 *</span>
<span class="cm">	 * determine maximum possible l2 size for the specified leaf.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span>
	    <span class="n">LITOL2BSZ</span><span class="p">(</span><span class="n">leafno</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_l2nleafs</span><span class="p">),</span>
		      <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_budmin</span><span class="p">);</span>

	<span class="cm">/* determine the number of leaves covered by this size.  this</span>
<span class="cm">	 * is the buddy size that we will start with as we search for</span>
<span class="cm">	 * the buddy system that contains the specified leaf.</span>
<span class="cm">	 */</span>
	<span class="n">budsz</span> <span class="o">=</span> <span class="n">BUDSIZE</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_budmin</span><span class="p">);</span>

	<span class="cm">/* back split.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">leafno</span><span class="p">]</span> <span class="o">==</span> <span class="n">NOFREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* find the leftmost buddy leaf.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">leafno</span><span class="p">,</span> <span class="n">bsz</span> <span class="o">=</span> <span class="n">budsz</span><span class="p">;;</span> <span class="n">bsz</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span>
		     <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="n">bud</span><span class="p">)</span> <span class="o">?</span> <span class="n">w</span> <span class="o">:</span> <span class="n">bud</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bsz</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_nleafs</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;JFS: block map error in dbBackSplit&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* determine the buddy.</span>
<span class="cm">			 */</span>
			<span class="n">bud</span> <span class="o">=</span> <span class="n">w</span> <span class="o">^</span> <span class="n">bsz</span><span class="p">;</span>

			<span class="cm">/* check if this buddy is the start of the system.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">bud</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NOFREE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* split the leaf at the start of the</span>
<span class="cm">				 * system in two.</span>
<span class="cm">				 */</span>
				<span class="n">cursz</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">[</span><span class="n">bud</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">dbSplit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bud</span><span class="p">,</span> <span class="n">cursz</span><span class="p">,</span> <span class="n">cursz</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="p">[</span><span class="n">leafno</span><span class="p">]</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;JFS: wrong leaf value in dbBackSplit&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbJoin()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	update the leaf of a dmtree with a new value, joining</span>
<span class="cm"> *		the leaf with other leaves of the dmtree into a multi-leaf</span>
<span class="cm"> *		binary buddy system, as required.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	tp	- pointer to the tree containing the leaf.</span>
<span class="cm"> *	leafno	- the number of the leaf to be updated.</span>
<span class="cm"> *	newval	- the new value for the leaf.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES: none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbJoin</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leafno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">budsz</span><span class="p">,</span> <span class="n">buddy</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>

	<span class="cm">/* can the new leaf value require a join with other leaves ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&gt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_budmin</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pickup a pointer to the leaves of the tree.</span>
<span class="cm">		 */</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_leafidx</span><span class="p">);</span>

		<span class="cm">/* try to join the specified leaf into a large binary</span>
<span class="cm">		 * buddy system.  the join proceeds by attempting to join</span>
<span class="cm">		 * the specified leafno with its buddy (leaf) at new value.</span>
<span class="cm">		 * if the join occurs, we attempt to join the left leaf</span>
<span class="cm">		 * of the joined buddies with its buddy at new value + 1.</span>
<span class="cm">		 * we continue to join until we find a buddy that cannot be</span>
<span class="cm">		 * joined (does not have a value equal to the size of the</span>
<span class="cm">		 * last join) or until all leaves have been joined into a</span>
<span class="cm">		 * single system.</span>
<span class="cm">		 *</span>
<span class="cm">		 * get the buddy size (number of words covered) of</span>
<span class="cm">		 * the new value.</span>
<span class="cm">		 */</span>
		<span class="n">budsz</span> <span class="o">=</span> <span class="n">BUDSIZE</span><span class="p">(</span><span class="n">newval</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_budmin</span><span class="p">);</span>

		<span class="cm">/* try to join.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">budsz</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_nleafs</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* get the buddy leaf.</span>
<span class="cm">			 */</span>
			<span class="n">buddy</span> <span class="o">=</span> <span class="n">leafno</span> <span class="o">^</span> <span class="n">budsz</span><span class="p">;</span>

			<span class="cm">/* if the leaf&#39;s new value is greater than its</span>
<span class="cm">			 * buddy&#39;s value, we join no more.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&gt;</span> <span class="n">leaf</span><span class="p">[</span><span class="n">buddy</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* It shouldn&#39;t be less */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&lt;</span> <span class="n">leaf</span><span class="p">[</span><span class="n">buddy</span><span class="p">])</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

			<span class="cm">/* check which (leafno or buddy) is the left buddy.</span>
<span class="cm">			 * the left buddy gets to claim the blocks resulting</span>
<span class="cm">			 * from the join while the right gets to claim none.</span>
<span class="cm">			 * the left buddy is also eligible to participate in</span>
<span class="cm">			 * a join at the next higher level while the right</span>
<span class="cm">			 * is not.</span>
<span class="cm">			 *</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">leafno</span> <span class="o">&lt;</span> <span class="n">buddy</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* leafno is the left buddy.</span>
<span class="cm">				 */</span>
				<span class="n">dbAdjTree</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">buddy</span><span class="p">,</span> <span class="n">NOFREE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* buddy is the left buddy and becomes</span>
<span class="cm">				 * leafno.</span>
<span class="cm">				 */</span>
				<span class="n">dbAdjTree</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">,</span> <span class="n">NOFREE</span><span class="p">);</span>
				<span class="n">leafno</span> <span class="o">=</span> <span class="n">buddy</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* on to try the next join.</span>
<span class="cm">			 */</span>
			<span class="n">newval</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">budsz</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* update the leaf value.</span>
<span class="cm">	 */</span>
	<span class="n">dbAdjTree</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">leafno</span><span class="p">,</span> <span class="n">newval</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAdjTree()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	update a leaf of a dmtree with a new value, adjusting</span>
<span class="cm"> *		the dmtree, as required, to reflect the new leaf value.</span>
<span class="cm"> *		the combination of any buddies must already be done before</span>
<span class="cm"> *		this is called.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	tp	- pointer to the tree to be adjusted.</span>
<span class="cm"> *	leafno	- the number of the leaf to be updated.</span>
<span class="cm"> *	newval	- the new value for the leaf.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES: none</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dbAdjTree</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leafno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lp</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>

	<span class="cm">/* pick up the index of the leaf for this leafno.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">leafno</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_leafidx</span><span class="p">);</span>

	<span class="cm">/* is the current value the same as the old value ?  if so,</span>
<span class="cm">	 * there is nothing to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span><span class="p">[</span><span class="n">lp</span><span class="p">]</span> <span class="o">==</span> <span class="n">newval</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* set the new value.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span><span class="p">[</span><span class="n">lp</span><span class="p">]</span> <span class="o">=</span> <span class="n">newval</span><span class="p">;</span>

	<span class="cm">/* bubble the new value up the tree as required.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_height</span><span class="p">);</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get the index of the first leaf of the 4 leaf</span>
<span class="cm">		 * group containing the specified leaf (leafno).</span>
<span class="cm">		 */</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="p">((</span><span class="n">lp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x03</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* get the index of the parent of this 4 leaf group.</span>
<span class="cm">		 */</span>
		<span class="n">pp</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* determine the maximum of the 4 leaves.</span>
<span class="cm">		 */</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">TREEMAX</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span><span class="p">[</span><span class="n">lp</span><span class="p">]);</span>

		<span class="cm">/* if the maximum of the 4 is the same as the</span>
<span class="cm">		 * parent&#39;s value, we&#39;re done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">==</span> <span class="n">max</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* parent gets new value.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

		<span class="cm">/* parent becomes leaf for next go-round.</span>
<span class="cm">		 */</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbFindLeaf()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	search a dmtree_t for sufficient free blocks, returning</span>
<span class="cm"> *		the index of a leaf describing the free blocks if</span>
<span class="cm"> *		sufficient free blocks are found.</span>
<span class="cm"> *</span>
<span class="cm"> *		the search starts at the top of the dmtree_t tree and</span>
<span class="cm"> *		proceeds down the tree to the leftmost leaf with sufficient</span>
<span class="cm"> *		free space.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	tp	- pointer to the tree to be searched.</span>
<span class="cm"> *	l2nb	- log2 number of free blocks to search for.</span>
<span class="cm"> *	leafidx	- return pointer to be set to the index of the leaf</span>
<span class="cm"> *		  describing at least l2nb free blocks if sufficient</span>
<span class="cm"> *		  free blocks are found.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOSPC	- insufficient free blocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbFindLeaf</span><span class="p">(</span><span class="n">dmtree_t</span> <span class="o">*</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">leafidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ti</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* first check the root of the tree to see if there is</span>
<span class="cm">	 * sufficient free space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* sufficient free space available. now search down the tree</span>
<span class="cm">	 * starting at the next level for the leftmost leaf that</span>
<span class="cm">	 * describes sufficient free space.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_height</span><span class="p">),</span> <span class="n">ti</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	     <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">,</span> <span class="n">ti</span> <span class="o">=</span> <span class="p">((</span><span class="n">ti</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* search the four nodes at this level, starting from</span>
<span class="cm">		 * the left.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* sufficient free space found.  move to the next</span>
<span class="cm">			 * level (or quit if this is the last level).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">&lt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_stree</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* better have found something since the higher</span>
<span class="cm">		 * levels of the tree said it was here.</span>
<span class="cm">		 */</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set the return to the leftmost leaf describing sufficient</span>
<span class="cm">	 * free space.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">leafidx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">dmt_leafidx</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbFindBits()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	find a specified number of binary buddy free bits within a</span>
<span class="cm"> *		dmap bitmap word value.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine searches the bitmap value for (1 &lt;&lt; l2nb) free</span>
<span class="cm"> *		bits at (1 &lt;&lt; l2nb) alignments within the value.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	word	-  dmap bitmap word value.</span>
<span class="cm"> *	l2nb	-  number of free bits specified as a log2 number.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	starting bit number of free bits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbFindBits</span><span class="p">(</span><span class="n">u32</span> <span class="n">word</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bitno</span><span class="p">,</span> <span class="n">nb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* get the number of bits.</span>
<span class="cm">	 */</span>
	<span class="n">nb</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">l2nb</span><span class="p">;</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">nb</span> <span class="o">&lt;=</span> <span class="n">DBWORD</span><span class="p">);</span>

	<span class="cm">/* complement the word so we can use a mask (i.e. 0s represent</span>
<span class="cm">	 * free bits) and compute the mask.</span>
<span class="cm">	 */</span>
	<span class="n">word</span> <span class="o">=</span> <span class="o">~</span><span class="n">word</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="n">nb</span><span class="p">);</span>

	<span class="cm">/* scan the word for nb free bits at nb alignments.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bitno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bitno</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bitno</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="cm">/* return the bit number.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bitno</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbMaxBud(u8 *cp)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	determine the largest binary buddy string of free</span>
<span class="cm"> *		bits within 32-bits of the map.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	cp	-  pointer to the 32-bit value.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	largest binary buddy of free bits within a dmap word.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbMaxBud</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span> <span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">signed</span> <span class="kt">char</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>

	<span class="cm">/* check if the wmap word is all free. if so, the</span>
<span class="cm">	 * free buddy size is BUDMIN.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span> <span class="n">cp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">BUDMIN</span><span class="p">);</span>

	<span class="cm">/* check if the wmap word is half free. if so, the</span>
<span class="cm">	 * free buddy size is BUDMIN-1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">cp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">cp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">BUDMIN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* not all free or half free. determine the free buddy</span>
<span class="cm">	 * size thru table lookup using quarters of the wmap word.</span>
<span class="cm">	 */</span>
	<span class="n">tmp1</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">budtab</span><span class="p">[</span><span class="n">cp</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">budtab</span><span class="p">[</span><span class="n">cp</span><span class="p">[</span><span class="mi">3</span><span class="p">]]);</span>
	<span class="n">tmp2</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">budtab</span><span class="p">[</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">budtab</span><span class="p">[</span><span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	cnttz(uint word)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	determine the number of trailing zeros within a 32-bit</span>
<span class="cm"> *		value.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	value	-  32-bit value to be examined.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	count of trailing zeros</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cnttz</span><span class="p">(</span><span class="n">u32</span> <span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">word</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	cntlz(u32 value)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	determine the number of leading zeros within a 32-bit</span>
<span class="cm"> *		value.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	value	-  32-bit value to be examined.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	count of leading zeros</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cntlz</span><span class="p">(</span><span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">value</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">HIGHORDER</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	blkstol2(s64 nb)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	convert a block count to its log2 value. if the block</span>
<span class="cm"> *		count is not a l2 multiple, it is rounded up to the next</span>
<span class="cm"> *		larger l2 multiple.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	nb	-  number of blocks</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	log2 number of blocks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">blkstol2</span><span class="p">(</span><span class="n">s64</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">l2nb</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">mask</span><span class="p">;</span>		<span class="cm">/* meant to be signed */</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* count the leading bits.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l2nb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l2nb</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">l2nb</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* leading bit found.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* determine the l2 value.</span>
<span class="cm">			 */</span>
			<span class="n">l2nb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">l2nb</span><span class="p">;</span>

			<span class="cm">/* check if we need to round up.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">nb</span><span class="p">)</span>
				<span class="n">l2nb</span><span class="o">++</span><span class="p">;</span>

			<span class="k">return</span> <span class="p">(</span><span class="n">l2nb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* fix compiler warning */</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbAllocBottomUp()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	alloc the specified block range from the working block</span>
<span class="cm"> *		allocation map.</span>
<span class="cm"> *</span>
<span class="cm"> *		the blocks will be alloc from the working map one dmap</span>
<span class="cm"> *		at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip	-  pointer to in-core inode;</span>
<span class="cm"> *	blkno	-  starting block number to be freed.</span>
<span class="cm"> *	nblocks	-  number of blocks to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbAllocBottomUp</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nb</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">rem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>

	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">RDWRLOCK_DMAP</span><span class="p">);</span>

	<span class="cm">/* block to be allocated better be within the mapsize. */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nblocks</span> <span class="o">&lt;=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span> <span class="o">-</span> <span class="n">blkno</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate the blocks a dmap at a time.</span>
<span class="cm">	 */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rem</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rem</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">blkno</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* release previous dmap if any */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* get the buffer for the current dmap. */</span>
		<span class="n">lblkno</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_l2nbperpage</span><span class="p">);</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* determine the number of blocks to be allocated from</span>
<span class="cm">		 * this dmap.</span>
<span class="cm">		 */</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">BPERDMAP</span> <span class="o">-</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>

		<span class="cm">/* allocate the blocks. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAllocDmapBU</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nb</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* write the last buffer. */</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbAllocDmapBU</span><span class="p">(</span><span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span> <span class="n">bmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dbitno</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">rembits</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">nwords</span><span class="p">,</span> <span class="n">wbitno</span><span class="p">,</span> <span class="n">agno</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">oldroot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmaptree</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmaptree</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>

	<span class="cm">/* save the current value of the root (i.e. maximum free string)</span>
<span class="cm">	 * of the dmap tree.</span>
<span class="cm">	 */</span>
	<span class="n">oldroot</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">];</span>

	<span class="cm">/* determine the bit number and word within the dmap of the</span>
<span class="cm">	 * starting block.</span>
<span class="cm">	 */</span>
	<span class="n">dbitno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

	<span class="cm">/* block range better be within the dmap */</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">dbitno</span> <span class="o">+</span> <span class="n">nblocks</span> <span class="o">&lt;=</span> <span class="n">BPERDMAP</span><span class="p">);</span>

	<span class="cm">/* allocate the bits of the dmap&#39;s words corresponding to the block</span>
<span class="cm">	 * range. not all bits of the first and last words may be contained</span>
<span class="cm">	 * within the block range.  if this is the case, we&#39;ll work against</span>
<span class="cm">	 * those words (i.e. partial first and/or last) on an individual basis</span>
<span class="cm">	 * (a single pass), allocating the bits of interest by hand and</span>
<span class="cm">	 * updating the leaf corresponding to the dmap word. a single pass</span>
<span class="cm">	 * will be used for all dmap words fully contained within the</span>
<span class="cm">	 * specified range.  within this pass, the bits of all fully contained</span>
<span class="cm">	 * dmap words will be marked as free in a single shot and the leaves</span>
<span class="cm">	 * will be updated. a single leaf may describe the free space of</span>
<span class="cm">	 * multiple dmap words, so we may update only a subset of the actual</span>
<span class="cm">	 * leaves corresponding to the dmap words of the block range.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rembits</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">rembits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rembits</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">dbitno</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* determine the bit number within the word and</span>
<span class="cm">		 * the number of bits within the word.</span>
<span class="cm">		 */</span>
		<span class="n">wbitno</span> <span class="o">=</span> <span class="n">dbitno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rembits</span><span class="p">,</span> <span class="n">DBWORD</span> <span class="o">-</span> <span class="n">wbitno</span><span class="p">);</span>

		<span class="cm">/* check if only part of a word is to be allocated.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&lt;</span> <span class="n">DBWORD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* allocate (set to 1) the appropriate bits within</span>
<span class="cm">			 * this dmap word.</span>
<span class="cm">			 */</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="n">nb</span><span class="p">)</span>
						      <span class="o">&gt;&gt;</span> <span class="n">wbitno</span><span class="p">);</span>

			<span class="n">word</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* one or more dmap words are fully contained</span>
<span class="cm">			 * within the block range.  determine how many</span>
<span class="cm">			 * words and allocate (set to 1) the bits of these</span>
<span class="cm">			 * words.</span>
<span class="cm">			 */</span>
			<span class="n">nwords</span> <span class="o">=</span> <span class="n">rembits</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">word</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ONES</span><span class="p">,</span> <span class="n">nwords</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

			<span class="cm">/* determine how many bits */</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">nwords</span> <span class="o">&lt;&lt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">+=</span> <span class="n">nwords</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* update the free count for this dmap */</span>
	<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">nfree</span><span class="p">,</span> <span class="o">-</span><span class="n">nblocks</span><span class="p">);</span>

	<span class="cm">/* reconstruct summary tree */</span>
	<span class="n">dbInitDmapTree</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>

	<span class="n">BMAP_LOCK</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="cm">/* if this allocation group is completely free,</span>
<span class="cm">	 * update the highest active allocation group number</span>
<span class="cm">	 * if this allocation group is the new max.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agno</span> <span class="o">&gt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span><span class="p">)</span>
		<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span> <span class="o">=</span> <span class="n">agno</span><span class="p">;</span>

	<span class="cm">/* update the free count for the allocation group and map */</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agno</span><span class="p">]</span> <span class="o">-=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_nfree</span> <span class="o">-=</span> <span class="n">nblocks</span><span class="p">;</span>

	<span class="n">BMAP_UNLOCK</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

	<span class="cm">/* if the root has not changed, done. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">]</span> <span class="o">==</span> <span class="n">oldroot</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* root changed. bubble the change up to the dmap control pages.</span>
<span class="cm">	 * if the adjustment of the upper level control pages fails,</span>
<span class="cm">	 * backout the bit allocation (thus making everything consistent).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAdjCtl</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">ROOT</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="n">dbFreeBits</span><span class="p">(</span><span class="n">bmp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbExtendFS()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	extend bmap from blkno for nblocks;</span>
<span class="cm"> *		dbExtendFS() updates bmap ready for dbAllocBottomUp();</span>
<span class="cm"> *</span>
<span class="cm"> * L2</span>
<span class="cm"> *  |</span>
<span class="cm"> *   L1---------------------------------L1</span>
<span class="cm"> *    |					 |</span>
<span class="cm"> *     L0---------L0---------L0		  L0---------L0---------L0</span>
<span class="cm"> *      |	   |	      |		   |	      |		 |</span>
<span class="cm"> *	 d0,...,dn  d0,...,dn  d0,...,dn    d0,...,dn  d0,...,dn  d0,.,dm;</span>
<span class="cm"> * L2L1L0d0,...,dnL0d0,...,dnL0d0,...,dnL1L0d0,...,dnL0d0,...,dnL0d0,..dm</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;---old---&gt;&lt;----------------------------extend-----------------------&gt;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbExtendFS</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>	<span class="n">s64</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nbperpage</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">i0</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j0</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">newsize</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">l2mp</span><span class="p">,</span> <span class="o">*</span><span class="n">l1mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">l0mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="n">l2dcp</span><span class="p">,</span> <span class="o">*</span><span class="n">l1dcp</span><span class="p">,</span> <span class="o">*</span><span class="n">l0dcp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">l0leaf</span><span class="p">,</span> <span class="o">*</span><span class="n">l1leaf</span><span class="p">,</span> <span class="o">*</span><span class="n">l2leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="n">l2agsize</span><span class="p">,</span> <span class="n">oldl2agsize</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">ag_rem</span><span class="p">;</span>

	<span class="n">newsize</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">+</span> <span class="n">nblocks</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">blkno</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">nblocks</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">newsize</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	initialize bmap control page.</span>
<span class="cm">	 *</span>
<span class="cm">	 * all the data in bmap control page should exclude</span>
<span class="cm">	 * the mkfs hidden dmap page.</span>
<span class="cm">	 */</span>

	<span class="cm">/* update mapsize */</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span> <span class="o">=</span> <span class="n">newsize</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxlevel</span> <span class="o">=</span> <span class="n">BMAPSZTOLEV</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span><span class="p">);</span>

	<span class="cm">/* compute new AG size */</span>
	<span class="n">l2agsize</span> <span class="o">=</span> <span class="n">dbGetL2AGSize</span><span class="p">(</span><span class="n">newsize</span><span class="p">);</span>
	<span class="n">oldl2agsize</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">;</span>

	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span> <span class="o">=</span> <span class="n">l2agsize</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">l2agsize</span><span class="p">;</span>

	<span class="cm">/* compute new number of AG */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span> <span class="o">=</span> <span class="n">newsize</span> <span class="o">&gt;&gt;</span> <span class="n">l2agsize</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span> <span class="o">+=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">newsize</span> <span class="o">%</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	reconfigure db_agfree[]</span>
<span class="cm">	 * from old AG configuration to new AG configuration;</span>
<span class="cm">	 *</span>
<span class="cm">	 * coalesce contiguous k (newAGSize/oldAGSize) AGs;</span>
<span class="cm">	 * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;</span>
<span class="cm">	 * note: new AG size = old AG size * (2**x).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l2agsize</span> <span class="o">==</span> <span class="n">oldl2agsize</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">extend</span><span class="p">;</span>
	<span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">l2agsize</span> <span class="o">-</span> <span class="n">oldl2agsize</span><span class="p">);</span>
	<span class="n">ag_rem</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* save agfree[0] */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">agno</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* init collection point */</span>

		<span class="cm">/* coalesce contiguous k AGs; */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">agno</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* merge AGi to AGn */</span>
			<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ag_rem</span><span class="p">;</span>	<span class="cm">/* restore agfree[0] */</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">MAXAG</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * update highest active ag number</span>
<span class="cm">	 */</span>

	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span> <span class="o">/</span> <span class="n">k</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	extend bmap</span>
<span class="cm">	 *</span>
<span class="cm">	 * update bit maps and corresponding level control pages;</span>
<span class="cm">	 * global control page db_nfree, db_agfree[agno], db_maxfreebud;</span>
<span class="cm">	 */</span>
      <span class="nl">extend:</span>
	<span class="cm">/* get L2 page */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">BMAPBLKNO</span> <span class="o">+</span> <span class="n">nbperpage</span><span class="p">;</span>	<span class="cm">/* L2 page */</span>
	<span class="n">l2mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l2mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;dbExtendFS: L2 page could not be read&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">l2dcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="p">)</span> <span class="n">l2mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* compute start L1 */</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">L2MAXL1SIZE</span><span class="p">;</span>
	<span class="n">l2leaf</span> <span class="o">=</span> <span class="n">l2dcp</span><span class="o">-&gt;</span><span class="n">stree</span> <span class="o">+</span> <span class="n">CTLLEAFIND</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">BLKTOL1</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">);</span>	<span class="cm">/* L1 page */</span>

	<span class="cm">/*</span>
<span class="cm">	 * extend each L1 in L2</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">LPERCTL</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">nbperpage</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get L1 page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* read in L1 page: (blkno &amp; (MAXL1SIZE - 1)) */</span>
			<span class="n">l1mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">l1mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
			<span class="n">l1dcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="p">)</span> <span class="n">l1mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

			<span class="cm">/* compute start L0 */</span>
			<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAXL1SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">L2MAXL0SIZE</span><span class="p">;</span>
			<span class="n">l1leaf</span> <span class="o">=</span> <span class="n">l1dcp</span><span class="o">-&gt;</span><span class="n">stree</span> <span class="o">+</span> <span class="n">CTLLEAFIND</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">BLKTOL0</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">);</span>
			<span class="n">j0</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* assign/init L1 page */</span>
			<span class="n">l1mp</span> <span class="o">=</span> <span class="n">get_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">l1mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

			<span class="n">l1dcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="p">)</span> <span class="n">l1mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

			<span class="cm">/* compute start L0 */</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">l1leaf</span> <span class="o">=</span> <span class="n">l1dcp</span><span class="o">-&gt;</span><span class="n">stree</span> <span class="o">+</span> <span class="n">CTLLEAFIND</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">nbperpage</span><span class="p">;</span>	<span class="cm">/* 1st L0 of L1.k */</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * extend each L0 in L1</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">LPERCTL</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* get L0 page */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* read in L0 page: (blkno &amp; (MAXL0SIZE - 1)) */</span>

				<span class="n">l0mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l0mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
				<span class="n">l0dcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="p">)</span> <span class="n">l0mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

				<span class="cm">/* compute start dmap */</span>
				<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAXL0SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
				    <span class="n">L2BPERDMAP</span><span class="p">;</span>
				<span class="n">l0leaf</span> <span class="o">=</span> <span class="n">l0dcp</span><span class="o">-&gt;</span><span class="n">stree</span> <span class="o">+</span> <span class="n">CTLLEAFIND</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">BLKTODMAP</span><span class="p">(</span><span class="n">blkno</span><span class="p">,</span>
					      <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">);</span>
				<span class="n">i0</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* assign/init L0 page */</span>
				<span class="n">l0mp</span> <span class="o">=</span> <span class="n">get_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l0mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

				<span class="n">l0dcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span><span class="p">)</span> <span class="n">l0mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

				<span class="cm">/* compute start dmap */</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">l0leaf</span> <span class="o">=</span> <span class="n">l0dcp</span><span class="o">-&gt;</span><span class="n">stree</span> <span class="o">+</span> <span class="n">CTLLEAFIND</span><span class="p">;</span>
				<span class="n">p</span> <span class="o">+=</span> <span class="n">nbperpage</span><span class="p">;</span>	<span class="cm">/* 1st dmap of L0.j */</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * extend each dmap in L0</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPERCTL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * reconstruct the dmap page, and</span>
<span class="cm">				 * initialize corresponding parent L0 leaf</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* read in dmap page: */</span>
					<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
							   <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
					<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nblocks</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="n">n</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* assign/init dmap page */</span>
					<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
							   <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

					<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nblocks</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">BPERDMAP</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="o">*</span><span class="n">l0leaf</span> <span class="o">=</span> <span class="n">dbInitDmap</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

				<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_nfree</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
				<span class="n">agno</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">l2agsize</span><span class="p">;</span>
				<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">agno</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

				<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

				<span class="n">l0leaf</span><span class="o">++</span><span class="p">;</span>
				<span class="n">p</span> <span class="o">+=</span> <span class="n">nbperpage</span><span class="p">;</span>

				<span class="n">blkno</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
				<span class="n">nblocks</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>	<span class="cm">/* for each dmap in a L0 */</span>

			<span class="cm">/*</span>
<span class="cm">			 * build current L0 page from its leaves, and</span>
<span class="cm">			 * initialize corresponding parent L1 leaf</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">l1leaf</span> <span class="o">=</span> <span class="n">dbInitDmapCtl</span><span class="p">(</span><span class="n">l0dcp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">++</span><span class="n">i</span><span class="p">);</span>
			<span class="n">write_metapage</span><span class="p">(</span><span class="n">l0mp</span><span class="p">);</span>
			<span class="n">l0mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span><span class="p">)</span>
				<span class="n">l1leaf</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* continue for next L0 */</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* more than 1 L0 ? */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>	<span class="cm">/* build L1 page */</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* summarize in global bmap page */</span>
					<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxfreebud</span> <span class="o">=</span> <span class="o">*</span><span class="n">l1leaf</span><span class="p">;</span>
					<span class="n">release_metapage</span><span class="p">(</span><span class="n">l1mp</span><span class="p">);</span>
					<span class="n">release_metapage</span><span class="p">(</span><span class="n">l2mp</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">finalize</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>		<span class="cm">/* for each L0 in a L1 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * build current L1 page from its leaves, and</span>
<span class="cm">		 * initialize corresponding parent L2 leaf</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">l2leaf</span> <span class="o">=</span> <span class="n">dbInitDmapCtl</span><span class="p">(</span><span class="n">l1dcp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">++</span><span class="n">j</span><span class="p">);</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">l1mp</span><span class="p">);</span>
		<span class="n">l1mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span><span class="p">)</span>
			<span class="n">l2leaf</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* continue for next L1 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* more than 1 L1 ? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* build L2 page */</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* summarize in global bmap page */</span>
				<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxfreebud</span> <span class="o">=</span> <span class="o">*</span><span class="n">l2leaf</span><span class="p">;</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">l2mp</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">finalize</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>			<span class="cm">/* for each L1 in a L2 */</span>

	<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
		  <span class="s">&quot;dbExtendFS: function has not returned as expected&quot;</span><span class="p">);</span>
<span class="nl">errout:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l0mp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">l0mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l1mp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">l1mp</span><span class="p">);</span>
	<span class="n">release_metapage</span><span class="p">(</span><span class="n">l2mp</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	finalize bmap control page</span>
<span class="cm">	 */</span>
<span class="nl">finalize:</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dbFinalizeBmap()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dbFinalizeBmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">actags</span><span class="p">,</span> <span class="n">inactags</span><span class="p">,</span> <span class="n">l2nl</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">ag_rem</span><span class="p">,</span> <span class="n">actfree</span><span class="p">,</span> <span class="n">inactfree</span><span class="p">,</span> <span class="n">avgfree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	finalize bmap control page</span>
<span class="cm">	 */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>finalize:</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/*</span>
<span class="cm">	 * compute db_agpref: preferred ag to allocate from</span>
<span class="cm">	 * (the leftmost ag with average free space in it);</span>
<span class="cm">	 */</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>agpref:</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* get the number of active ags and inacitve ags */</span>
	<span class="n">actags</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_maxag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">inactags</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span> <span class="o">-</span> <span class="n">actags</span><span class="p">;</span>
	<span class="n">ag_rem</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_mapsize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* ??? */</span>

	<span class="cm">/* determine how many blocks are in the inactive allocation</span>
<span class="cm">	 * groups. in doing this, we must account for the fact that</span>
<span class="cm">	 * the rightmost group might be a partial group (i.e. file</span>
<span class="cm">	 * system size is not a multiple of the group size).</span>
<span class="cm">	 */</span>
	<span class="n">inactfree</span> <span class="o">=</span> <span class="p">(</span><span class="n">inactags</span> <span class="o">&amp;&amp;</span> <span class="n">ag_rem</span><span class="p">)</span> <span class="o">?</span>
	    <span class="p">((</span><span class="n">inactags</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">)</span> <span class="o">+</span> <span class="n">ag_rem</span>
	    <span class="o">:</span> <span class="n">inactags</span> <span class="o">&lt;&lt;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">;</span>

	<span class="cm">/* determine how many free blocks are in the active</span>
<span class="cm">	 * allocation groups plus the average number of free blocks</span>
<span class="cm">	 * within the active ags.</span>
<span class="cm">	 */</span>
	<span class="n">actfree</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_nfree</span> <span class="o">-</span> <span class="n">inactfree</span><span class="p">;</span>
	<span class="n">avgfree</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">actfree</span> <span class="o">/</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">actags</span><span class="p">;</span>

	<span class="cm">/* if the preferred allocation group has not average free space.</span>
<span class="cm">	 * re-establish the preferred group as the leftmost</span>
<span class="cm">	 * group with average free space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">avgfree</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span> <span class="o">&lt;</span> <span class="n">actags</span><span class="p">;</span>
		     <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agfree</span><span class="p">[</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">avgfree</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agpref</span> <span class="o">&gt;=</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_numag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;cannot find ag with average freespace&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * compute db_aglevel, db_agheight, db_width, db_agstart:</span>
<span class="cm">	 * an ag is covered in aglevel dmapctl summary tree,</span>
<span class="cm">	 * at agheight level height (from leaf) with agwidth number of nodes</span>
<span class="cm">	 * each, which starts at agstart index node of the smmary tree node</span>
<span class="cm">	 * array;</span>
<span class="cm">	 */</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_aglevel</span> <span class="o">=</span> <span class="n">BMAPSZTOLEV</span><span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agsize</span><span class="p">);</span>
	<span class="n">l2nl</span> <span class="o">=</span>
	    <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span> <span class="o">-</span> <span class="p">(</span><span class="n">L2BPERDMAP</span> <span class="o">+</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_aglevel</span> <span class="o">*</span> <span class="n">L2LPERCTL</span><span class="p">);</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agheight</span> <span class="o">=</span> <span class="n">l2nl</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agwidth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">l2nl</span> <span class="o">-</span> <span class="p">(</span><span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agheight</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">-</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agheight</span><span class="p">,</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agstart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bmp</span><span class="o">-&gt;</span><span class="n">db_agstart</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbInitDmap()/ujfs_idmap_page()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initialize working/persistent bitmap of the dmap page</span>
<span class="cm"> *		for the specified number of blocks:</span>
<span class="cm"> *</span>
<span class="cm"> *		at entry, the bitmaps had been initialized as free (ZEROS);</span>
<span class="cm"> *		The number of blocks will only account for the actually</span>
<span class="cm"> *		existing blocks. Blocks which don&#39;t actually exist in</span>
<span class="cm"> *		the aggregate will be marked as allocated (ONES);</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	dp	- pointer to page of map</span>
<span class="cm"> *	nblocks	- number of blocks this page</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS: NONE</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbInitDmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span> <span class="n">s64</span> <span class="n">Blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* starting block number within the dmap */</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="n">Blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BPERDMAP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">nblocks</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">nfree</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">nblocks</span><span class="p">);</span>
		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">Blkno</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">==</span> <span class="n">BPERDMAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPERDMAP</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPERDMAP</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">initTree</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">nblocks</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">nfree</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* word number containing start block number */</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * free the bits corresponding to the block range (ZEROS):</span>
<span class="cm">	 * note: not all bits of the first and last words may be contained</span>
<span class="cm">	 * within the block range.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">blkno</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* number of bits preceding range to be freed in the word */</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* number of bits to free in the word */</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">DBWORD</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>

		<span class="cm">/* is partial word to be freed ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&lt;</span> <span class="n">DBWORD</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* free (set to 0) from the bitmap word */</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="n">nb</span><span class="p">)</span>
						     <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">));</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="n">nb</span><span class="p">)</span>
						     <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">));</span>

			<span class="cm">/* skip the word freed */</span>
			<span class="n">w</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* free (set to 0) contiguous bitmap words */</span>
			<span class="n">nw</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nw</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nw</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

			<span class="cm">/* skip the words freed */</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">nw</span> <span class="o">&lt;&lt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>
			<span class="n">w</span> <span class="o">+=</span> <span class="n">nw</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * mark bits following the range to be freed (non-existing</span>
<span class="cm">	 * blocks) as allocated (ONES)</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">==</span> <span class="n">BPERDMAP</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">initTree</span><span class="p">;</span>

	<span class="cm">/* the first word beyond the end of existing blocks */</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">L2DBWORD</span><span class="p">;</span>

	<span class="cm">/* does nblocks fall on a 32-bit boundary ? */</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* mark a partial word allocated */</span>
		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ONES</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">);</span>
		<span class="n">w</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set the rest of the words in the page to allocated (ONES) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPERDMAP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ONES</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * init tree</span>
<span class="cm">	 */</span>
      <span class="nl">initTree:</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dbInitDmapTree</span><span class="p">(</span><span class="n">dp</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbInitDmapTree()/ujfs_complete_dmap()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initialize summary tree of the specified dmap:</span>
<span class="cm"> *</span>
<span class="cm"> *		at entry, bitmap of the dmap has been initialized;</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	dp	- dmap to complete</span>
<span class="cm"> *	blkno	- starting block number for this dmap</span>
<span class="cm"> *	treemax	- will be filled in with max free for this dmap</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:	max free string at the root of the tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbInitDmapTree</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmap</span> <span class="o">*</span> <span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmaptree</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* init fixed info of tree */</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nleafs</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LPERDMAP</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">l2nleafs</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">L2LPERDMAP</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">leafidx</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LEAFIND</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">budmin</span> <span class="o">=</span> <span class="n">BUDMIN</span><span class="p">;</span>

	<span class="cm">/* init each leaf from corresponding wmap word:</span>
<span class="cm">	 * note: leaf is set to NOFREE(-1) if all blocks of corresponding</span>
<span class="cm">	 * bitmap word are allocated.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">stree</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">leafidx</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPERDMAP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">dbMaxBud</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* build the dmap&#39;s binary buddy summary tree */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dbInitTree</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbInitTree()/ujfs_adjtree()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initialize binary buddy summary tree of a dmap or dmapctl.</span>
<span class="cm"> *</span>
<span class="cm"> *		at entry, the leaves of the tree has been initialized</span>
<span class="cm"> *		from corresponding bitmap word or root of summary tree</span>
<span class="cm"> *		of the child control page;</span>
<span class="cm"> *		configure binary buddy system at the leaf level, then</span>
<span class="cm"> *		bubble up the values of the leaf nodes up the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	cp	- Pointer to the root of the tree</span>
<span class="cm"> *	l2leaves- Number of leaf nodes as a power of 2</span>
<span class="cm"> *	l2min	- Number of blocks that can be covered by a leaf</span>
<span class="cm"> *		  as a power of 2</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS: max free string at the root of the tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbInitTree</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmaptree</span> <span class="o">*</span> <span class="n">dtp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">l2max</span><span class="p">,</span> <span class="n">l2free</span><span class="p">,</span> <span class="n">bsize</span><span class="p">,</span> <span class="n">nextb</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">child</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">nparent</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="o">*</span><span class="n">cp1</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">;</span>

	<span class="cm">/* Determine the maximum free string possible for the leaves */</span>
	<span class="n">l2max</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dtp</span><span class="o">-&gt;</span><span class="n">l2nleafs</span><span class="p">)</span> <span class="o">+</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">budmin</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * configure the leaf levevl into binary buddy system</span>
<span class="cm">	 *</span>
<span class="cm">	 * Try to combine buddies starting with a buddy size of 1</span>
<span class="cm">	 * (i.e. two leaves). At a buddy size of 1 two buddy leaves</span>
<span class="cm">	 * can be combined if both buddies have a maximum free of l2min;</span>
<span class="cm">	 * the combination will result in the left-most buddy leaf having</span>
<span class="cm">	 * a maximum free of l2min+1.</span>
<span class="cm">	 * After processing all buddies for a given size, process buddies</span>
<span class="cm">	 * at the next higher buddy size (i.e. current size * 2) and</span>
<span class="cm">	 * the next maximum free (current free + 1).</span>
<span class="cm">	 * This continues until the maximum possible buddy combination</span>
<span class="cm">	 * yields maximum free.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l2free</span> <span class="o">=</span> <span class="n">dtp</span><span class="o">-&gt;</span><span class="n">budmin</span><span class="p">,</span> <span class="n">bsize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l2free</span> <span class="o">&lt;</span> <span class="n">l2max</span><span class="p">;</span>
	     <span class="n">l2free</span><span class="o">++</span><span class="p">,</span> <span class="n">bsize</span> <span class="o">=</span> <span class="n">nextb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get next buddy size == current buddy pair size */</span>
		<span class="n">nextb</span> <span class="o">=</span> <span class="n">bsize</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* scan each adjacent buddy pair at current buddy size */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cp</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dtp</span><span class="o">-&gt;</span><span class="n">leafidx</span><span class="p">);</span>
		     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dtp</span><span class="o">-&gt;</span><span class="n">nleafs</span><span class="p">);</span>
		     <span class="n">i</span> <span class="o">+=</span> <span class="n">nextb</span><span class="p">,</span> <span class="n">cp</span> <span class="o">+=</span> <span class="n">nextb</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* coalesce if both adjacent buddies are max free */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span> <span class="o">==</span> <span class="n">l2free</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">cp</span> <span class="o">+</span> <span class="n">bsize</span><span class="p">)</span> <span class="o">==</span> <span class="n">l2free</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">l2free</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* left take right */</span>
				<span class="o">*</span><span class="p">(</span><span class="n">cp</span> <span class="o">+</span> <span class="n">bsize</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* right give left */</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * bubble summary information of leaves up the tree.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Starting at the leaf node level, the four nodes described by</span>
<span class="cm">	 * the higher level parent node are compared for a maximum free and</span>
<span class="cm">	 * this maximum becomes the value of the parent node.</span>
<span class="cm">	 * when all lower level nodes are processed in this fashion then</span>
<span class="cm">	 * move up to the next level (parent becomes a lower level node) and</span>
<span class="cm">	 * continue the process for that level.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">child</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dtp</span><span class="o">-&gt;</span><span class="n">leafidx</span><span class="p">),</span>
	     <span class="n">nparent</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dtp</span><span class="o">-&gt;</span><span class="n">nleafs</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	     <span class="n">nparent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nparent</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get index of 1st node of parent level */</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* set the value of the parent node as the maximum</span>
<span class="cm">		 * of the four nodes of the current level.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cp</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="n">child</span><span class="p">,</span> <span class="n">cp1</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="n">parent</span><span class="p">;</span>
		     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nparent</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">cp</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">cp1</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="n">cp1</span> <span class="o">=</span> <span class="n">TREEMAX</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dbInitDmapCtl()</span>
<span class="cm"> *</span>
<span class="cm"> * function: initialize dmapctl page</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbInitDmapCtl</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmapctl</span> <span class="o">*</span> <span class="n">dcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* start leaf index not covered by range */</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">dcp</span><span class="o">-&gt;</span><span class="n">nleafs</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LPERCTL</span><span class="p">);</span>
	<span class="n">dcp</span><span class="o">-&gt;</span><span class="n">l2nleafs</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">L2LPERCTL</span><span class="p">);</span>
	<span class="n">dcp</span><span class="o">-&gt;</span><span class="n">leafidx</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">CTLLEAFIND</span><span class="p">);</span>
	<span class="n">dcp</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">dcp</span><span class="o">-&gt;</span><span class="n">budmin</span> <span class="o">=</span> <span class="n">L2BPERDMAP</span> <span class="o">+</span> <span class="n">L2LPERCTL</span> <span class="o">*</span> <span class="n">level</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize the leaves of current level that were not covered</span>
<span class="cm">	 * by the specified input block range (i.e. the leaves have no</span>
<span class="cm">	 * low level dmapctl or dmap).</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dcp</span><span class="o">-&gt;</span><span class="n">stree</span><span class="p">[</span><span class="n">CTLLEAFIND</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPERCTL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">NOFREE</span><span class="p">;</span>

	<span class="cm">/* build the dmap&#39;s binary buddy summary tree */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dbInitTree</span><span class="p">((</span><span class="k">struct</span> <span class="n">dmaptree</span> <span class="o">*</span><span class="p">)</span> <span class="n">dcp</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbGetL2AGSize()/ujfs_getagl2size()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Determine log2(allocation group size) from aggregate size</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	nblocks	- Number of blocks in aggregate</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS: log2(allocation group size) in aggregate blocks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbGetL2AGSize</span><span class="p">(</span><span class="n">s64</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">sz</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">l2sz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">&lt;</span> <span class="n">BPERDMAP</span> <span class="o">*</span> <span class="n">MAXAG</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">L2BPERDMAP</span><span class="p">);</span>

	<span class="cm">/* round up aggregate size to power of 2 */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l2sz</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span> <span class="n">l2sz</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l2sz</span><span class="o">--</span><span class="p">,</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&amp;</span> <span class="n">nblocks</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">l2sz</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&lt;</span> <span class="n">nblocks</span><span class="p">)</span>
		<span class="n">l2sz</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* agsize = roundupSize/max_number_of_ag */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">l2sz</span> <span class="o">-</span> <span class="n">L2MAXAG</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	dbMapFileSizeToMapSize()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	compute number of blocks the block allocation map file</span>
<span class="cm"> *		can cover from the map file size;</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:	Number of blocks which can be covered by this block map file;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * maximum number of map pages at each level including control pages</span>
<span class="cm"> */</span>
<span class="cp">#define MAXL0PAGES	(1 + LPERCTL)</span>
<span class="cp">#define MAXL1PAGES	(1 + LPERCTL * MAXL0PAGES)</span>
<span class="cp">#define MAXL2PAGES	(1 + LPERCTL * MAXL1PAGES)</span>

<span class="cm">/*</span>
<span class="cm"> * convert number of map pages to the zero origin top dmapctl level</span>
<span class="cm"> */</span>
<span class="cp">#define BMAPPGTOLEV(npages)	\</span>
<span class="cp">	(((npages) &lt;= 3 + MAXL0PAGES) ? 0 : \</span>
<span class="cp">	 ((npages) &lt;= 2 + MAXL1PAGES) ? 1 : 2)</span>

<span class="n">s64</span> <span class="nf">dbMapFileSizeToMapSize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">ipbmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">npages</span><span class="p">,</span> <span class="n">ndmaps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">complete</span><span class="p">,</span> <span class="n">factor</span><span class="p">;</span>

	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>
	<span class="n">npages</span> <span class="o">=</span> <span class="n">nblocks</span> <span class="o">&gt;&gt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">BMAPPGTOLEV</span><span class="p">(</span><span class="n">npages</span><span class="p">);</span>

	<span class="cm">/* At each level, accumulate the number of dmap pages covered by</span>
<span class="cm">	 * the number of full child levels below it;</span>
<span class="cm">	 * repeat for the last incomplete child level.</span>
<span class="cm">	 */</span>
	<span class="n">ndmaps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">npages</span><span class="o">--</span><span class="p">;</span>		<span class="cm">/* skip the first global control page */</span>
	<span class="cm">/* skip higher level control pages above top level covered by map */</span>
	<span class="n">npages</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">level</span><span class="p">);</span>
	<span class="n">npages</span><span class="o">--</span><span class="p">;</span>		<span class="cm">/* skip top level&#39;s control page */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">factor</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">MAXL1PAGES</span> <span class="o">:</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">MAXL0PAGES</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">complete</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">npages</span> <span class="o">/</span> <span class="n">factor</span><span class="p">;</span>
		<span class="n">ndmaps</span> <span class="o">+=</span> <span class="n">complete</span> <span class="o">*</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">LPERCTL</span> <span class="o">*</span> <span class="n">LPERCTL</span> <span class="o">:</span>
				      <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">LPERCTL</span> <span class="o">:</span> <span class="mi">1</span><span class="p">));</span>

		<span class="cm">/* pages in last/incomplete child */</span>
		<span class="n">npages</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">npages</span> <span class="o">%</span> <span class="n">factor</span><span class="p">;</span>
		<span class="cm">/* skip incomplete child&#39;s level control page */</span>
		<span class="n">npages</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* convert the number of dmaps into the number of blocks</span>
<span class="cm">	 * which can be covered by the dmaps;</span>
<span class="cm">	 */</span>
	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">ndmaps</span> <span class="o">&lt;&lt;</span> <span class="n">L2BPERDMAP</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">nblocks</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
