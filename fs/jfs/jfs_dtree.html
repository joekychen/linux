<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jfs › jfs_dtree.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jfs_dtree.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   Copyright (C) International Business Machines Corp., 2000-2004</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program;  if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	jfs_dtree.c: directory B+-tree manager</span>
<span class="cm"> *</span>
<span class="cm"> * B+-tree with variable length key directory:</span>
<span class="cm"> *</span>
<span class="cm"> * each directory page is structured as an array of 32-byte</span>
<span class="cm"> * directory entry slots initialized as a freelist</span>
<span class="cm"> * to avoid search/compaction of free space at insertion.</span>
<span class="cm"> * when an entry is inserted, a number of slots are allocated</span>
<span class="cm"> * from the freelist as required to store variable length data</span>
<span class="cm"> * of the entry; when the entry is deleted, slots of the entry</span>
<span class="cm"> * are returned to freelist.</span>
<span class="cm"> *</span>
<span class="cm"> * leaf entry stores full name as key and file serial number</span>
<span class="cm"> * (aka inode number) as data.</span>
<span class="cm"> * internal/router entry stores sufffix compressed name</span>
<span class="cm"> * as key and simple extent descriptor as data.</span>
<span class="cm"> *</span>
<span class="cm"> * each directory page maintains a sorted entry index table</span>
<span class="cm"> * which stores the start slot index of sorted entries</span>
<span class="cm"> * to allow binary search on the table.</span>
<span class="cm"> *</span>
<span class="cm"> * directory starts as a root/leaf page in on-disk inode</span>
<span class="cm"> * inline data area.</span>
<span class="cm"> * when it becomes full, it starts a leaf of a external extent</span>
<span class="cm"> * of length of 1 block. each time the first leaf becomes full,</span>
<span class="cm"> * it is extended rather than split (its size is doubled),</span>
<span class="cm"> * until its length becoms 4 KBytes, from then the extent is split</span>
<span class="cm"> * with new 4 Kbyte extent when it becomes full</span>
<span class="cm"> * to reduce external fragmentation of small directories.</span>
<span class="cm"> *</span>
<span class="cm"> * blah, blah, blah, for linear scan of directory in pieces by</span>
<span class="cm"> * readdir().</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *	case-insensitive directory file system</span>
<span class="cm"> *</span>
<span class="cm"> * names are stored in case-sensitive way in leaf entry.</span>
<span class="cm"> * but stored, searched and compared in case-insensitive (uppercase) order</span>
<span class="cm"> * (i.e., both search key and entry key are folded for search/compare):</span>
<span class="cm"> * (note that case-sensitive order is BROKEN in storage, e.g.,</span>
<span class="cm"> *  sensitive: Ad, aB, aC, aD -&gt; insensitive: aB, aC, aD, Ad</span>
<span class="cm"> *</span>
<span class="cm"> *  entries which folds to the same key makes up a equivalent class</span>
<span class="cm"> *  whose members are stored as contiguous cluster (may cross page boundary)</span>
<span class="cm"> *  but whose order is arbitrary and acts as duplicate, e.g.,</span>
<span class="cm"> *  abc, Abc, aBc, abC)</span>
<span class="cm"> *</span>
<span class="cm"> * once match is found at leaf, requires scan forward/backward</span>
<span class="cm"> * either for, in case-insensitive search, duplicate</span>
<span class="cm"> * or for, in case-sensitive search, for exact match</span>
<span class="cm"> *</span>
<span class="cm"> * router entry must be created/stored in case-insensitive way</span>
<span class="cm"> * in internal entry:</span>
<span class="cm"> * (right most key of left page and left most key of right page</span>
<span class="cm"> * are folded, and its suffix compression is propagated as router</span>
<span class="cm"> * key in parent)</span>
<span class="cm"> * (e.g., if split occurs &lt;abc&gt; and &lt;aBd&gt;, &lt;ABD&gt; trather than &lt;aB&gt;</span>
<span class="cm"> * should be made the router key for the split)</span>
<span class="cm"> *</span>
<span class="cm"> * case-insensitive search:</span>
<span class="cm"> *</span>
<span class="cm"> *	fold search key;</span>
<span class="cm"> *</span>
<span class="cm"> *	case-insensitive search of B-tree:</span>
<span class="cm"> *	for internal entry, router key is already folded;</span>
<span class="cm"> *	for leaf entry, fold the entry key before comparison.</span>
<span class="cm"> *</span>
<span class="cm"> *	if (leaf entry case-insensitive match found)</span>
<span class="cm"> *		if (next entry satisfies case-insensitive match)</span>
<span class="cm"> *			return EDUPLICATE;</span>
<span class="cm"> *		if (prev entry satisfies case-insensitive match)</span>
<span class="cm"> *			return EDUPLICATE;</span>
<span class="cm"> *		return match;</span>
<span class="cm"> *	else</span>
<span class="cm"> *		return no match;</span>
<span class="cm"> *</span>
<span class="cm"> *	serialization:</span>
<span class="cm"> * target directory inode lock is being held on entry/exit</span>
<span class="cm"> * of all main directory service routines.</span>
<span class="cm"> *</span>
<span class="cm"> *	log based recovery:</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;jfs_incore.h&quot;</span>
<span class="cp">#include &quot;jfs_superblock.h&quot;</span>
<span class="cp">#include &quot;jfs_filsys.h&quot;</span>
<span class="cp">#include &quot;jfs_metapage.h&quot;</span>
<span class="cp">#include &quot;jfs_dmap.h&quot;</span>
<span class="cp">#include &quot;jfs_unicode.h&quot;</span>
<span class="cp">#include &quot;jfs_debug.h&quot;</span>

<span class="cm">/* dtree split parameter */</span>
<span class="k">struct</span> <span class="n">dtsplit</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">nslot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="n">ddata_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxdlist</span> <span class="o">*</span><span class="n">pxdlist</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DT_PAGE(IP, MP) BT_PAGE(IP, MP, dtpage_t, i_dtroot)</span>

<span class="cm">/* get page buffer for specified block address */</span>
<span class="cp">#define DT_GETPAGE(IP, BN, MP, SIZE, P, RC)\</span>
<span class="cp">{\</span>
<span class="cp">	BT_GETPAGE(IP, BN, MP, dtpage_t, SIZE, P, RC, i_dtroot)\</span>
<span class="cp">	if (!(RC))\</span>
<span class="cp">	{\</span>
<span class="cp">		if (((P)-&gt;header.nextindex &gt; (((BN)==0)?DTROOTMAXSLOT:(P)-&gt;header.maxslot)) ||\</span>
<span class="cp">		    ((BN) &amp;&amp; ((P)-&gt;header.maxslot &gt; DTPAGEMAXSLOT)))\</span>
<span class="cp">		{\</span>
<span class="cp">			BT_PUTPAGE(MP);\</span>
<span class="cp">			jfs_error((IP)-&gt;i_sb, &quot;DT_GETPAGE: dtree page corrupt&quot;);\</span>
<span class="cp">			MP = NULL;\</span>
<span class="cp">			RC = -EIO;\</span>
<span class="cp">		}\</span>
<span class="cp">	}\</span>
<span class="cp">}</span>

<span class="cm">/* for consistency */</span>
<span class="cp">#define DT_PUTPAGE(MP) BT_PUTPAGE(MP)</span>

<span class="cp">#define DT_GETSEARCH(IP, LEAF, BN, MP, P, INDEX) \</span>
<span class="cp">	BT_GETSEARCH(IP, LEAF, BN, MP, dtpage_t, P, INDEX, i_dtroot)</span>

<span class="cm">/*</span>
<span class="cm"> * forward references</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dtSplitUp</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">dtsplit</span> <span class="o">*</span> <span class="n">split</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dtSplitPage</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dtsplit</span> <span class="o">*</span> <span class="n">split</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span> <span class="n">rmpp</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">**</span> <span class="n">rpp</span><span class="p">,</span> <span class="n">pxd_t</span> <span class="o">*</span> <span class="n">rxdp</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dtExtendPage</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dtsplit</span> <span class="o">*</span> <span class="n">split</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dtSplitRoot</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dtsplit</span> <span class="o">*</span> <span class="n">split</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span> <span class="n">rmpp</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dtDeleteUp</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span> <span class="n">fmp</span><span class="p">,</span>
		      <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dtRelink</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dtReadFirst</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dtReadNext</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
		      <span class="n">loff_t</span> <span class="o">*</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dtCompare</span><span class="p">(</span><span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">si</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ciCompare</span><span class="p">(</span><span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">si</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dtGetKey</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ciGetLeafPrefixKey</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">lp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">li</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">rp</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">ri</span><span class="p">,</span> <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dtInsertEntry</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span>
			  <span class="n">ddata_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dtMoveEntry</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">si</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">sdtlock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">ddtlock</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">do_index</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dtDeleteEntry</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">dtlock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dtTruncateEntry</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">dtlock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dtLinelockFreelist</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">dtlock</span><span class="p">);</span>

<span class="cp">#define ciToUpper(c)	UniStrupr((c)-&gt;name)</span>

<span class="cm">/*</span>
<span class="cm"> *	read_index_page()</span>
<span class="cm"> *</span>
<span class="cm"> *	Reads a page of a directory&#39;s index table.</span>
<span class="cm"> *	Having metadata mapped into the directory inode&#39;s address space</span>
<span class="cm"> *	presents a multitude of problems.  We avoid this by mapping to</span>
<span class="cm"> *	the absolute address space outside of the *_metapage routines</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="nf">read_index_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xflag</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">xlen</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">xtLookup</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xflag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xlen</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="p">(</span><span class="n">xaddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	get_index_page()</span>
<span class="cm"> *</span>
<span class="cm"> *	Same as get_index_page(), but get&#39;s a new page without reading</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="nf">get_index_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">xaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xflag</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">xlen</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">xtLookup</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xflag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xlen</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="p">(</span><span class="n">xaddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">get_metapage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	find_index()</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns dtree page containing directory table entry for specified</span>
<span class="cm"> *	index and pointer to its entry.</span>
<span class="cm"> *</span>
<span class="cm"> *	mp must be released by caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span><span class="nf">find_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span> <span class="n">mp</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span><span class="n">lblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">s64</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">maxWarnings</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxWarnings</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jfs_warn</span><span class="p">(</span><span class="s">&quot;find_entry called with index = %d&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">maxWarnings</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_warn</span><span class="p">(</span><span class="s">&quot;find_entry called with index &gt;= next_index&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jfs_dirtable_inline</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Inline directory table</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dirtable</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dir_table_slot</span><span class="p">);</span>
		<span class="n">page_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">blkno</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2PSIZE</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
		    <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">mp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">lblock</span> <span class="o">!=</span> <span class="n">blkno</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">);</span>
			<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">lblock</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
			<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">read_index_page</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">blkno</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;free_index: error reading directory table&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">slot</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span>
					       <span class="n">page_offset</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">slot</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_index</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span> <span class="n">mp</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="n">llck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>

	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDATA</span><span class="p">);</span>
	<span class="n">llck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">llck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">llck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
		<span class="n">llck</span> <span class="o">=</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">llck</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">llck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">llck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Linelock slot size is twice the size of directory table</span>
<span class="cm">	 *	slot size.  512 entries per page.</span>
<span class="cm">	 */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">index</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">511</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">llck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	add_index()</span>
<span class="cm"> *</span>
<span class="cm"> *	Adds an entry to the directory index table.  This is used to provide</span>
<span class="cm"> *	each directory entry with a persistent index in which to resume</span>
<span class="cm"> *	directory traversals</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">add_index</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">bn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span><span class="n">dirtab_slot</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="n">llck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">page_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">xaddr</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_warn</span><span class="p">(</span><span class="s">&quot;add_index: next_index = %d.  Resetting!&quot;</span><span class="p">,</span>
			   <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">);</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">MAX_INLINE_DIRTABLE_ENTRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * i_size reflects size of index table, or 8 bytes per entry.</span>
<span class="cm">		 */</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * dir table fits inline within inode</span>
<span class="cm">		 */</span>
		<span class="n">dirtab_slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dirtable</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">DIR_INDEX_VALID</span><span class="p">;</span>
		<span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
		<span class="n">DTSaddress</span><span class="p">(</span><span class="n">dirtab_slot</span><span class="p">,</span> <span class="n">bn</span><span class="p">);</span>

		<span class="n">set_cflag</span><span class="p">(</span><span class="n">COMMIT_Dirtable</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="p">(</span><span class="n">MAX_INLINE_DIRTABLE_ENTRY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="n">temp_table</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s time to move the inline table to an external</span>
<span class="cm">		 * page and begin to build the xtree</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dquot_alloc_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dbAlloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dquot_free_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Save the table, we&#39;re going to overwrite it with the</span>
<span class="cm">		 * xtree root</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">temp_table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dirtable</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp_table</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Initialize empty x-tree</span>
<span class="cm">		 */</span>
		<span class="n">xtInitRoot</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Add the first block to the xtree</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xtInsert</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This really shouldn&#39;t fail */</span>
			<span class="n">jfs_warn</span><span class="p">(</span><span class="s">&quot;add_index: xtInsert failed!&quot;</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dirtable</span><span class="p">,</span> <span class="n">temp_table</span><span class="p">,</span>
			       <span class="k">sizeof</span> <span class="p">(</span><span class="n">temp_table</span><span class="p">));</span>
			<span class="n">dbFree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">);</span>
			<span class="n">dquot_free_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">PSIZE</span><span class="p">;</span>

		<span class="n">mp</span> <span class="o">=</span> <span class="n">get_index_page</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;add_index: get_metapage failed!&quot;</span><span class="p">);</span>
			<span class="n">xtTruncate</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">COMMIT_PWMAP</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dirtable</span><span class="p">,</span> <span class="n">temp_table</span><span class="p">,</span>
			       <span class="k">sizeof</span> <span class="p">(</span><span class="n">temp_table</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDATA</span><span class="p">);</span>
		<span class="n">llck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">llck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">llck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>	<span class="cm">/* tlckDATA slot size is 16 bytes */</span>
		<span class="n">llck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">temp_table</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp_table</span><span class="p">));</span>

		<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Logging is now directed by xtree tlocks</span>
<span class="cm">		 */</span>
		<span class="n">clear_cflag</span><span class="p">(</span><span class="n">COMMIT_Dirtable</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dir_table_slot</span><span class="p">);</span>
	<span class="n">page_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2PSIZE</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This will be the beginning of a new page</span>
<span class="cm">		 */</span>
		<span class="n">xaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xtInsert</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jfs_warn</span><span class="p">(</span><span class="s">&quot;add_index: xtInsert failed!&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">PSIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mp</span> <span class="o">=</span> <span class="n">get_index_page</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">blkno</span><span class="p">)))</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">);</span>	<span class="cm">/* Just looks better */</span>
		<span class="k">else</span>
			<span class="n">xtTruncate</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">COMMIT_PWMAP</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">read_index_page</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">blkno</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;add_index: get/read_metapage failed!&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">clean_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">dirtab_slot</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">page_offset</span><span class="p">);</span>
	<span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">DIR_INDEX_VALID</span><span class="p">;</span>
	<span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">DTSaddress</span><span class="p">(</span><span class="n">dirtab_slot</span><span class="p">,</span> <span class="n">bn</span><span class="p">);</span>

	<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>

      <span class="nl">clean_up:</span>

	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	free_index()</span>
<span class="cm"> *</span>
<span class="cm"> *	Marks an entry to the directory index table as free.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_index</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span><span class="n">dirtab_slot</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">lblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dirtab_slot</span> <span class="o">=</span> <span class="n">find_index</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lblock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirtab_slot</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">DIR_INDEX_FREE</span><span class="p">;</span>
	<span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">addr1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">addr2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">set_cflag</span><span class="p">(</span><span class="n">COMMIT_Dirtable</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	modify_index()</span>
<span class="cm"> *</span>
<span class="cm"> *	Changes an entry in the directory index table</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">modify_index</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">s64</span> <span class="n">bn</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span> <span class="n">mp</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span><span class="n">lblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span><span class="n">dirtab_slot</span><span class="p">;</span>

	<span class="n">dirtab_slot</span> <span class="o">=</span> <span class="n">find_index</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">lblock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirtab_slot</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">DTSaddress</span><span class="p">(</span><span class="n">dirtab_slot</span><span class="p">,</span> <span class="n">bn</span><span class="p">);</span>
	<span class="n">dirtab_slot</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="o">*</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">set_cflag</span><span class="p">(</span><span class="n">COMMIT_Dirtable</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	read_index()</span>
<span class="cm"> *</span>
<span class="cm"> *	reads a directory table slot</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span> <span class="n">dirtab_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">lblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">find_index</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dirtab_slot</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dir_table_slot</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	dtSearch()</span>
<span class="cm"> *</span>
<span class="cm"> * function:</span>
<span class="cm"> *	Search for the entry with specified key</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return: 0 - search result on stack, leaf page pinned;</span>
<span class="cm"> *	   errno - I/O error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dtSearch</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">ino_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* init for empty page */</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btframe</span> <span class="o">*</span><span class="n">btsp</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">psize</span> <span class="o">=</span> <span class="mi">288</span><span class="p">;</span>	<span class="cm">/* initial in-line directory */</span>
	<span class="n">ino_t</span> <span class="n">inumber</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">component_name</span> <span class="n">ciKey</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="n">ciKey</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="n">JFS_NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">wchar_t</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ciKey</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">dtSearch_Exit2</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* uppercase search key for c-i directory */</span>
	<span class="n">UniStrcpy</span><span class="p">(</span><span class="n">ciKey</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">ciKey</span><span class="p">.</span><span class="n">namlen</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>

	<span class="cm">/* only uppercase if case-insensitive support is on */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">&amp;</span> <span class="n">JFS_OS2</span><span class="p">)</span> <span class="o">==</span> <span class="n">JFS_OS2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ciToUpper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ciKey</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BT_CLR</span><span class="p">(</span><span class="n">btstack</span><span class="p">);</span>	<span class="cm">/* reset stack */</span>

	<span class="cm">/* init level count for max pages to split */</span>
	<span class="n">btstack</span><span class="o">-&gt;</span><span class="n">nsplit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	search down tree from root:</span>
<span class="cm">	 *</span>
<span class="cm">	 * between two consecutive entries of &lt;Ki, Pi&gt; and &lt;Kj, Pj&gt; of</span>
<span class="cm">	 * internal page, child page Pi contains entry with k, Ki &lt;= K &lt; Kj.</span>
<span class="cm">	 *</span>
<span class="cm">	 * if entry with search key K is not found</span>
<span class="cm">	 * internal page search find the entry with largest key Ki</span>
<span class="cm">	 * less than K which point to the child page to search;</span>
<span class="cm">	 * leaf page search find the entry with smallest key Kj</span>
<span class="cm">	 * greater than K so that the returned index is the position of</span>
<span class="cm">	 * the entry to be shifted right for insertion of new entry.</span>
<span class="cm">	 * for empty tree, search key is greater than any key of the tree.</span>
<span class="cm">	 *</span>
<span class="cm">	 * by convention, root bn = 0.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;)</span> <span class="p">{</span>
		<span class="cm">/* get/pin the page to search */</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dtSearch_Exit1</span><span class="p">;</span>

		<span class="cm">/* get sorted entry table of the page */</span>
		<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * binary search with search key K on the current page.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">lim</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">lim</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* uppercase leaf name to compare */</span>
				<span class="n">cmp</span> <span class="o">=</span>
				    <span class="n">ciCompare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ciKey</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
					      <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mntflag</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* router key is in uppercase */</span>

				<span class="n">cmp</span> <span class="o">=</span> <span class="n">dtCompare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ciKey</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>


			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *	search hit</span>
<span class="cm">				 */</span>
				<span class="cm">/* search hit - leaf page:</span>
<span class="cm">				 * return the entry found</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">inumber</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">]])</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">);</span>

					<span class="cm">/*</span>
<span class="cm">					 * search for JFS_LOOKUP</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">JFS_LOOKUP</span><span class="p">)</span> <span class="p">{</span>
						<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">inumber</span><span class="p">;</span>
						<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="cm">/*</span>
<span class="cm">					 * search for JFS_CREATE</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">JFS_CREATE</span><span class="p">)</span> <span class="p">{</span>
						<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">inumber</span><span class="p">;</span>
						<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
						<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="cm">/*</span>
<span class="cm">					 * search for JFS_REMOVE or JFS_RENAME</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">==</span> <span class="n">JFS_REMOVE</span> <span class="o">||</span>
					     <span class="n">flag</span> <span class="o">==</span> <span class="n">JFS_RENAME</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					    <span class="o">*</span><span class="n">data</span> <span class="o">!=</span> <span class="n">inumber</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
						<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="cm">/*</span>
<span class="cm">					 * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME</span>
<span class="cm">					 */</span>
					<span class="cm">/* save search result */</span>
					<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">inumber</span><span class="p">;</span>
					<span class="n">btsp</span> <span class="o">=</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
					<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="p">;</span>
					<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
					<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>

					<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">dtSearch_Exit1</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* search hit - internal page:</span>
<span class="cm">				 * descend/search its child page</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">getChild</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">base</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="o">--</span><span class="n">lim</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *	search miss</span>
<span class="cm">		 *</span>
<span class="cm">		 * base is the smallest index with key (Kj) greater than</span>
<span class="cm">		 * search key (K) and may be zero or (maxindex + 1) index.</span>
<span class="cm">		 */</span>
		<span class="cm">/*</span>
<span class="cm">		 * search miss - leaf page</span>
<span class="cm">		 *</span>
<span class="cm">		 * return location of entry (base) where new entry with</span>
<span class="cm">		 * search key K is to be inserted.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">JFS_LOOKUP</span> <span class="o">||</span> <span class="n">flag</span> <span class="o">==</span> <span class="n">JFS_REMOVE</span> <span class="o">||</span>
			    <span class="n">flag</span> <span class="o">==</span> <span class="n">JFS_RENAME</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * search for JFS_CREATE|JFS_FINDDIR:</span>
<span class="cm">			 *</span>
<span class="cm">			 * save search result</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">btsp</span> <span class="o">=</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">dtSearch_Exit1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * search miss - internal page</span>
<span class="cm">		 *</span>
<span class="cm">		 * if base is non-zero, decrement base by one to get the parent</span>
<span class="cm">		 * entry of the child page to search.</span>
<span class="cm">		 */</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">base</span> <span class="o">?</span> <span class="n">base</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">base</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * go down to child page</span>
<span class="cm">		 */</span>
	      <span class="nl">getChild:</span>
		<span class="cm">/* update max. number of pages to split */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BT_STACK_FULL</span><span class="p">(</span><span class="n">btstack</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Something&#39;s corrupted, mark filesystem dirty so</span>
<span class="cm">			 * chkdsk will fix it.</span>
<span class="cm">			 */</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;stack overrun in dtSearch!&quot;</span><span class="p">);</span>
			<span class="n">BT_STACK_DUMP</span><span class="p">(</span><span class="n">btstack</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btstack</span><span class="o">-&gt;</span><span class="n">nsplit</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* push (bn, index) of the parent page/entry */</span>
		<span class="n">BT_PUSH</span><span class="p">(</span><span class="n">btstack</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

		<span class="cm">/* get the child page block number */</span>
		<span class="n">pxd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">]];</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
		<span class="n">psize</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>

		<span class="cm">/* unpin the parent page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

      <span class="nl">dtSearch_Exit1:</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ciKey</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

      <span class="nl">dtSearch_Exit2:</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtInsert()</span>
<span class="cm"> *</span>
<span class="cm"> * function: insert an entry to directory tree</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return: 0 - success;</span>
<span class="cm"> *	   errno - failure;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dtInsert</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	 <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="n">ino_t</span> <span class="o">*</span> <span class="n">fsn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>	<span class="cm">/* meta-page buffer */</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>		<span class="cm">/* base B+-tree index page */</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtsplit</span> <span class="n">split</span><span class="p">;</span>	<span class="cm">/* split information */</span>
	<span class="n">ddata_t</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	retrieve search result</span>
<span class="cm">	 *</span>
<span class="cm">	 * dtSearch() returns (leaf page pinned, index at which to insert).</span>
<span class="cm">	 * n.b. dtSearch() may return index of (maxindex + 1) of</span>
<span class="cm">	 * the full page.</span>
<span class="cm">	 */</span>
	<span class="n">DT_GETSEARCH</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	insert entry for new key</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">==</span> <span class="n">DIREND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EMLINK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">NDTLEAF</span><span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">);</span>
		<span class="n">data</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
		<span class="n">data</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">NDTLEAF_LEGACY</span><span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">);</span>
		<span class="n">data</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* signifies legacy directory format */</span>
	<span class="p">}</span>
	<span class="n">data</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="o">*</span><span class="n">fsn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	leaf page does not have enough room for new entry:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	extend/split the leaf page;</span>
<span class="cm">	 *</span>
<span class="cm">	 * dtSplitUp() will insert the entry and unpin the leaf page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">split</span><span class="p">.</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
		<span class="n">split</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">split</span><span class="p">.</span><span class="n">nslot</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">split</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">split</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dtSplitUp</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">split</span><span class="p">,</span> <span class="n">btstack</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	leaf page does have enough room for new entry:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	insert the new data entry into the leaf page;</span>
<span class="cm">	 */</span>
	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the leaf page</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* linelock header */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="n">dtInsertEntry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="p">);</span>

	<span class="cm">/* linelock stbl of non-root leaf page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
			<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* unpin the leaf page */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtSplitUp()</span>
<span class="cm"> *</span>
<span class="cm"> * function: propagate insertion bottom up;</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return: 0 - success;</span>
<span class="cm"> *	   errno - failure;</span>
<span class="cm"> *	leaf page unpinned;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtSplitUp</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span>
	  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dtsplit</span> <span class="o">*</span> <span class="n">split</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">smp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>		<span class="cm">/* split page */</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">rmp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>		<span class="cm">/* new right page split from sp */</span>
	<span class="n">pxd_t</span> <span class="n">rpxd</span><span class="p">;</span>		<span class="cm">/* new right page extent descriptor */</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">lmp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>		<span class="cm">/* left child page */</span>
	<span class="kt">int</span> <span class="n">skip</span><span class="p">;</span>		<span class="cm">/* index of entry of insertion */</span>
	<span class="k">struct</span> <span class="n">btframe</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>	<span class="cm">/* parent page entry on traverse stack */</span>
	<span class="n">s64</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">nxaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">xsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxdlist</span> <span class="n">pxdlist</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">component_name</span> <span class="n">key</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="n">ddata_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">quota_allocation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* get split page */</span>
	<span class="n">smp</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">DT_PAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">);</span>

	<span class="n">key</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="n">JFS_NAME_MAX</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">wchar_t</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">dtSplitUp_Exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	split leaf page</span>
<span class="cm">	 *</span>
<span class="cm">	 * The split routines insert the new entry, and</span>
<span class="cm">	 * acquire txLock as appropriate.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 *	split root leaf page:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * allocate a single extent child page</span>
<span class="cm">		 */</span>
		<span class="n">xlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">bsize</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>	<span class="cm">/* stbl size */</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="n">DTROOTMAXSLOT</span> <span class="o">-</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span><span class="p">;</span> <span class="cm">/* header + entries */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">nslot</span><span class="p">)</span>
			<span class="n">xlen</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAlloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">freeKeyName</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pxdlist</span><span class="p">.</span><span class="n">maxnpxd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pxdlist</span><span class="p">.</span><span class="n">npxd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="p">.</span><span class="n">pxd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">);</span>
		<span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
		<span class="n">split</span><span class="o">-&gt;</span><span class="n">pxdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dtSplitRoot</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">dbFree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>

		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">xlen</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">freeKeyName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	extend first leaf page</span>
<span class="cm">	 *</span>
<span class="cm">	 * extend the 1st extent if less than buffer page size</span>
<span class="cm">	 * (dtExtendPage() reurns leaf page unpinned)</span>
<span class="cm">	 */</span>
	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">;</span>
	<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
	<span class="n">xsize</span> <span class="o">=</span> <span class="n">xlen</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xsize</span> <span class="o">&lt;</span> <span class="n">PSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">xsize</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>	<span class="cm">/* stbl size */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">nslot</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">xlen</span> <span class="o">+</span> <span class="p">(</span><span class="n">xlen</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">xlen</span><span class="p">;</span>

		<span class="cm">/* Allocate blocks to quota. */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dquot_alloc_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">extendOut</span><span class="p">;</span>
		<span class="n">quota_allocation</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbReAlloc</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nxaddr</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">extendOut</span><span class="p">;</span>

		<span class="n">pxdlist</span><span class="p">.</span><span class="n">maxnpxd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pxdlist</span><span class="p">.</span><span class="n">npxd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="p">.</span><span class="n">pxd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">nxaddr</span><span class="p">)</span>
		    <span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">xlen</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">split</span><span class="o">-&gt;</span><span class="n">pxdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtExtendPage</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">btstack</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">nxaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xaddr</span> <span class="o">!=</span> <span class="n">nxaddr</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* free relocated extent */</span>
				<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
				<span class="n">dbFree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">nxaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* free extended delta */</span>
				<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span>
				<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">)</span> <span class="o">+</span> <span class="n">xlen</span><span class="p">;</span>
				<span class="n">dbFree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>


	      <span class="nl">extendOut:</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">freeKeyName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	split leaf page &lt;sp&gt; into &lt;sp&gt; and a new right page &lt;rp&gt;.</span>
<span class="cm">	 *</span>
<span class="cm">	 * return &lt;rp&gt; pinned and its extent descriptor &lt;rpxd&gt;</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * allocate new directory page extent and</span>
<span class="cm">	 * new index page(s) to cover page split(s)</span>
<span class="cm">	 *</span>
<span class="cm">	 * allocation hint: ?</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">nsplit</span><span class="p">;</span>
	<span class="n">pxdlist</span><span class="p">.</span><span class="n">maxnpxd</span> <span class="o">=</span> <span class="n">pxdlist</span><span class="p">.</span><span class="n">npxd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xlen</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">pxdlist</span><span class="p">.</span><span class="n">pxd</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">,</span> <span class="n">pxd</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAlloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">);</span>
			<span class="n">PXDlength</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
			<span class="n">pxdlist</span><span class="p">.</span><span class="n">maxnpxd</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>

		<span class="cm">/* undo allocation */</span>
		<span class="k">goto</span> <span class="n">splitOut</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">split</span><span class="o">-&gt;</span><span class="n">pxdlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtSplitPage</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpxd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>

		<span class="cm">/* undo allocation */</span>
		<span class="k">goto</span> <span class="n">splitOut</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">PSIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * propagate up the router entry for the leaf page just split</span>
<span class="cm">	 *</span>
<span class="cm">	 * insert a router entry for the new page into the parent page,</span>
<span class="cm">	 * propagate the insert/split up the tree by walking back the stack</span>
<span class="cm">	 * of (bn of parent page, index of child page entry in parent page)</span>
<span class="cm">	 * that were traversed during the search for the page that split.</span>
<span class="cm">	 *</span>
<span class="cm">	 * the propagation of insert/split up the tree stops if the root</span>
<span class="cm">	 * splits or the page inserted into doesn&#39;t have to split to hold</span>
<span class="cm">	 * the new entry.</span>
<span class="cm">	 *</span>
<span class="cm">	 * the parent entry for the split page remains the same, and</span>
<span class="cm">	 * a new entry is inserted at its right with the first key and</span>
<span class="cm">	 * block number of the new right page.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There are a maximum of 4 pages pinned at any time:</span>
<span class="cm">	 * two children, left parent and right parent (when the parent splits).</span>
<span class="cm">	 * keep the child pages pinned while working on the parent.</span>
<span class="cm">	 * make sure that all pins are released at exit.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">parent</span> <span class="o">=</span> <span class="n">BT_POP</span><span class="p">(</span><span class="n">btstack</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* parent page specified by stack frame &lt;parent&gt; */</span>

		<span class="cm">/* keep current child pages (&lt;lp&gt;, &lt;rp&gt;) pinned */</span>
		<span class="n">lmp</span> <span class="o">=</span> <span class="n">smp</span><span class="p">;</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * insert router entry in parent for new right child page &lt;rp&gt;</span>
<span class="cm">		 */</span>
		<span class="cm">/* get the parent page &lt;sp&gt; */</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bn</span><span class="p">,</span> <span class="n">smp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">lmp</span><span class="p">);</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">splitOut</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The new key entry goes ONE AFTER the index of parent entry,</span>
<span class="cm">		 * because the split was to the right.</span>
<span class="cm">		 */</span>
		<span class="n">skip</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * compute the key for the router entry</span>
<span class="cm">		 *</span>
<span class="cm">		 * key suffix compression:</span>
<span class="cm">		 * for internal pages that have leaf pages as children,</span>
<span class="cm">		 * retain only what&#39;s needed to distinguish between</span>
<span class="cm">		 * the new entry and the entry on the page to its left.</span>
<span class="cm">		 * If the keys compare equal, retain the entire key.</span>
<span class="cm">		 *</span>
<span class="cm">		 * note that compression is performed only at computing</span>
<span class="cm">		 * router key at the lowest internal level.</span>
<span class="cm">		 * further compression of the key between pairs of higher</span>
<span class="cm">		 * level internal pages loses too much information and</span>
<span class="cm">		 * the search may fail.</span>
<span class="cm">		 * (e.g., two adjacent leaf pages of {a, ..., x} {xx, ...,}</span>
<span class="cm">		 * results in two adjacent parent entries (a)(xx).</span>
<span class="cm">		 * if split occurs between these two entries, and</span>
<span class="cm">		 * if compression is applied, the router key of parent entry</span>
<span class="cm">		 * of right page (x) will divert search for x into right</span>
<span class="cm">		 * subtree and miss x in the left subtree.)</span>
<span class="cm">		 *</span>
<span class="cm">		 * the entire key must be retained for the next-to-leftmost</span>
<span class="cm">		 * internal key at any level of the tree, or search may fail</span>
<span class="cm">		 * (e.g., ?)</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BT_LEAF</span>:
			<span class="cm">/*</span>
<span class="cm">			 * compute the length of prefix for suffix compression</span>
<span class="cm">			 * between last entry of left page and first entry</span>
<span class="cm">			 * of right page</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span> <span class="o">&amp;&amp;</span> <span class="n">skip</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">skip</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* compute uppercase router prefix key */</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">ciGetLeafPrefixKey</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span>
							<span class="n">lp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
							<span class="n">rp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
							<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">lmp</span><span class="p">);</span>
					<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>
					<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">splitOut</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* next to leftmost entry of</span>
<span class="cm">				   lowest internal level */</span>

				<span class="cm">/* compute uppercase router key */</span>
				<span class="n">dtGetKey</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span><span class="p">);</span>
				<span class="n">key</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">key</span><span class="p">.</span><span class="n">namlen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">&amp;</span> <span class="n">JFS_OS2</span><span class="p">)</span> <span class="o">==</span> <span class="n">JFS_OS2</span><span class="p">)</span>
					<span class="n">ciToUpper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">n</span> <span class="o">=</span> <span class="n">NDTINTERNAL</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">namlen</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BT_INTERNAL</span>:
			<span class="n">dtGetKey</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">mntflag</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">NDTINTERNAL</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">namlen</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;dtSplitUp(): UFO!&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* unpin left child page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">lmp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * compute the data for the router entry</span>
<span class="cm">		 */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">xd</span> <span class="o">=</span> <span class="n">rpxd</span><span class="p">;</span>	<span class="cm">/* child page xd */</span>

		<span class="cm">/*</span>
<span class="cm">		 * parent page is full - split the parent page</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* init for parent page split */</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">smp</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">skip</span><span class="p">;</span>	<span class="cm">/* index at insert */</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">nslot</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">;</span>
			<span class="cm">/* split-&gt;data = data; */</span>

			<span class="cm">/* unpin right child page */</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>

			<span class="cm">/* The split routines insert the new entry,</span>
<span class="cm">			 * acquire txLock as appropriate.</span>
<span class="cm">			 * return &lt;rp&gt; pinned and its block number &lt;rbn&gt;.</span>
<span class="cm">			 */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">dtSplitRoot</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmp</span><span class="p">)</span> <span class="o">:</span>
			    <span class="n">dtSplitPage</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpxd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">splitOut</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* smp and rmp are pinned */</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * parent page is not full - insert router entry in parent page</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">smp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * acquire a transaction lock on the parent page</span>
<span class="cm">			 */</span>
			<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
			<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

			<span class="cm">/* linelock header */</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* linelock stbl of non-root parent page */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lv</span><span class="o">++</span><span class="p">;</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">skip</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
				<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
				<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span>
				    <span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">-</span>
				      <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dtInsertEntry</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="p">);</span>

			<span class="cm">/* exit propagate up */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* unpin current split and its right page */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">smp</span><span class="p">);</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * free remaining extents allocated for split</span>
<span class="cm">	 */</span>
      <span class="nl">splitOut:</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">pxdlist</span><span class="p">.</span><span class="n">npxd</span><span class="p">;</span>
	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="p">.</span><span class="n">pxd</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">pxdlist</span><span class="p">.</span><span class="n">maxnpxd</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">pxd</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dbFree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">),</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">));</span>

      <span class="nl">freeKeyName:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Rollback quota allocation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">quota_allocation</span><span class="p">)</span>
		<span class="n">dquot_free_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">quota_allocation</span><span class="p">);</span>

      <span class="nl">dtSplitUp_Exit:</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtSplitPage()</span>
<span class="cm"> *</span>
<span class="cm"> * function: Split a non-root page of a btree.</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return: 0 - success;</span>
<span class="cm"> *	   errno - failure;</span>
<span class="cm"> *	return split and new page pinned;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtSplitPage</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dtsplit</span> <span class="o">*</span> <span class="n">split</span><span class="p">,</span>
	    <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span> <span class="n">rmpp</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">**</span> <span class="n">rpp</span><span class="p">,</span> <span class="n">pxd_t</span> <span class="o">*</span> <span class="n">rpxdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">smp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">rmp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>		<span class="cm">/* new right page allocated */</span>
	<span class="n">s64</span> <span class="n">rbn</span><span class="p">;</span>		<span class="cm">/* new right page block number */</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nextbn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxdlist</span> <span class="o">*</span><span class="n">pxdlist</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip</span><span class="p">,</span> <span class="n">nextindex</span><span class="p">,</span> <span class="n">half</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">nxt</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">si</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">ldtentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="n">idtentry</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fsi</span><span class="p">,</span> <span class="n">stblsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">sdtlck</span><span class="p">,</span> <span class="o">*</span><span class="n">rdtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">slv</span><span class="p">,</span> <span class="o">*</span><span class="n">rlv</span><span class="p">,</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>

	<span class="cm">/* get split page */</span>
	<span class="n">smp</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">DT_PAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate the new right page for the split</span>
<span class="cm">	 */</span>
	<span class="n">pxdlist</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">pxdlist</span><span class="p">;</span>
	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">[</span><span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">npxd</span><span class="p">];</span>
	<span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">npxd</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rbn</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
	<span class="n">rmp</span> <span class="o">=</span> <span class="n">get_metapage</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">rbn</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Allocate blocks to quota. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dquot_alloc_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">,</span> <span class="n">rmp</span><span class="p">);</span>

	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">rmp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the new right page</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">rmp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckNEW</span><span class="p">);</span>
	<span class="n">rdtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="n">rp</span> <span class="o">=</span> <span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">rmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rpp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span> <span class="o">=</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">smp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the split page</span>
<span class="cm">	 *</span>
<span class="cm">	 * action:</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
	<span class="n">sdtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* linelock header of split page */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">slv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">slv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">slv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize/update sibling pointers between sp and rp</span>
<span class="cm">	 */</span>
	<span class="n">nextbn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nextbn</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">));</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">rbn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize new right page</span>
<span class="cm">	 */</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span><span class="p">;</span>

	<span class="cm">/* compute sorted entry table at start of extent data area */</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">PSIZE</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">stblsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>	<span class="cm">/* in unit of slot */</span>

	<span class="cm">/* init freelist */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">+</span> <span class="n">stblsize</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">-</span> <span class="n">fsi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	sequential append at tail: append without split</span>
<span class="cm">	 *</span>
<span class="cm">	 * If splitting the last page on a level because of appending</span>
<span class="cm">	 * a entry to it (skip is maxentry), it&#39;s likely that the access is</span>
<span class="cm">	 * sequential. Adding an empty page on the side of the level is less</span>
<span class="cm">	 * work and can push the fill factor much higher than normal.</span>
<span class="cm">	 * If we&#39;re wrong it&#39;s no big deal, we&#39;ll just do the split the right</span>
<span class="cm">	 * way next time.</span>
<span class="cm">	 * (It may look like it&#39;s equally easy to do a similar hack for</span>
<span class="cm">	 * reverse sorted data, that is, split the tree left,</span>
<span class="cm">	 * but it&#39;s not. Be my guest.)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nextbn</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* linelock header + stbl (first slot) of new page */</span>
		<span class="n">rlv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">rdtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">rdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">rlv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rlv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">rdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * initialize freelist of new right page</span>
<span class="cm">		 */</span>
		<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">fsi</span><span class="o">++</span><span class="p">;</span> <span class="n">fsi</span> <span class="o">&lt;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">,</span> <span class="n">fsi</span><span class="o">++</span><span class="p">)</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* insert entry at the first entry of the new right page */</span>
		<span class="n">dtInsertEntry</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdtlck</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	non-sequential insert (at possibly middle page)</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * update prev pointer of previous right sibling page;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nextbn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">nextbn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">discard_metapage</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * acquire a transaction lock on the next page</span>
<span class="cm">		 */</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckRELINK</span><span class="p">);</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p&quot;</span><span class="p">,</span>
			<span class="n">tlck</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

		<span class="cm">/* linelock header of previous right sibling page */</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">rbn</span><span class="p">);</span>

		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * split the data between the split and right pages.</span>
<span class="cm">	 */</span>
	<span class="n">skip</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">half</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSIZE</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* swag */</span>
	<span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	compute fill factor for split pages</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;nxt&gt; traces the next entry to move to rp</span>
<span class="cm">	 * &lt;off&gt; traces the next entry to stay in sp</span>
<span class="cm">	 */</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span><span class="p">];</span>
	<span class="n">nextindex</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">nxt</span> <span class="o">=</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nxt</span> <span class="o">&lt;</span> <span class="n">nextindex</span><span class="p">;</span> <span class="o">++</span><span class="n">off</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">==</span> <span class="n">skip</span><span class="p">)</span>
			<span class="cm">/* check for fill factor with new entry size */</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">nslot</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">si</span> <span class="o">=</span> <span class="n">stbl</span><span class="p">[</span><span class="n">nxt</span><span class="p">];</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_TYPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">BT_LEAF</span>:
				<span class="n">ldtentry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
					<span class="n">n</span> <span class="o">=</span> <span class="n">NDTLEAF</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">n</span> <span class="o">=</span> <span class="n">NDTLEAF_LEGACY</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span>
							   <span class="n">namlen</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">BT_INTERNAL</span>:
				<span class="n">idtentry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">NDTINTERNAL</span><span class="p">(</span><span class="n">idtentry</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="o">++</span><span class="n">nxt</span><span class="p">;</span>	<span class="cm">/* advance to next entry to move in sp */</span>
		<span class="p">}</span>

		<span class="n">left</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">half</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* &lt;nxt&gt; poins to the 1st entry to move */</span>

	<span class="cm">/*</span>
<span class="cm">	 *	move entries to right page</span>
<span class="cm">	 *</span>
<span class="cm">	 * dtMoveEntry() initializes rp and reserves entry for insertion</span>
<span class="cm">	 *</span>
<span class="cm">	 * split page moved out entries are linelocked;</span>
<span class="cm">	 * new/right page moved in entries are linelocked;</span>
<span class="cm">	 */</span>
	<span class="cm">/* linelock header + stbl of new right page */</span>
	<span class="n">rlv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">rdtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">rdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="n">rlv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rlv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">rdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="n">dtMoveEntry</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">nxt</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdtlck</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdtlck</span><span class="p">,</span> <span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * finalize freelist of new right page</span>
<span class="cm">	 */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fsi</span><span class="o">++</span><span class="p">;</span> <span class="n">fsi</span> <span class="o">&lt;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">,</span> <span class="n">fsi</span><span class="o">++</span><span class="p">)</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update directory index table for entries now in right page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">lblock</span><span class="p">;</span>

		<span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ldtentry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">n</span><span class="p">]];</span>
			<span class="n">modify_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
				     <span class="n">rbn</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lblock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * the skipped index was on the left page,</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skip</span> <span class="o">&lt;=</span> <span class="n">off</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* insert the new entry in the split page */</span>
		<span class="n">dtInsertEntry</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdtlck</span><span class="p">);</span>

		<span class="cm">/* linelock stbl of split page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
			<span class="n">sdtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">sdtlck</span><span class="p">);</span>
		<span class="n">slv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">skip</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
		<span class="n">slv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">slv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * the skipped index was on the right page,</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* adjust the skip index to reflect the new position */</span>
		<span class="n">skip</span> <span class="o">-=</span> <span class="n">nxt</span><span class="p">;</span>

		<span class="cm">/* insert the new entry in the right page */</span>
		<span class="n">dtInsertEntry</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdtlck</span><span class="p">);</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="o">*</span><span class="n">rmpp</span> <span class="o">=</span> <span class="n">rmp</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rpxdp</span> <span class="o">=</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtExtendPage()</span>
<span class="cm"> *</span>
<span class="cm"> * function: extend 1st/only directory leaf page</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return: 0 - success;</span>
<span class="cm"> *	   errno - failure;</span>
<span class="cm"> *	return extended page pinned;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtExtendPage</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dtsplit</span> <span class="o">*</span> <span class="n">split</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">smp</span><span class="p">,</span> <span class="o">*</span><span class="n">pmp</span><span class="p">,</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxdlist</span> <span class="o">*</span><span class="n">pxdlist</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">,</span> <span class="o">*</span><span class="n">tpxd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">xsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">newstblindex</span><span class="p">,</span> <span class="n">newstblsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oldstblindex</span><span class="p">,</span> <span class="n">oldstblsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fsi</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btframe</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">xaddr</span><span class="p">,</span> <span class="n">txaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">ldtentry</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>

	<span class="cm">/* get page to extend */</span>
	<span class="n">smp</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">DT_PAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">);</span>

	<span class="cm">/* get parent/root page */</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">BT_POP</span><span class="p">(</span><span class="n">btstack</span><span class="p">);</span>
	<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bn</span><span class="p">,</span> <span class="n">pmp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	extend the extent</span>
<span class="cm">	 */</span>
	<span class="n">pxdlist</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">pxdlist</span><span class="p">;</span>
	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">[</span><span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">npxd</span><span class="p">];</span>
	<span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">npxd</span><span class="o">++</span><span class="p">;</span>

	<span class="n">xaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
	<span class="n">tpxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">;</span>
	<span class="n">txaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">tpxd</span><span class="p">);</span>
	<span class="cm">/* in-place extension */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xaddr</span> <span class="o">==</span> <span class="n">txaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">tlckEXTEND</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* relocation */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">tlckNEW</span><span class="p">;</span>

		<span class="cm">/* save moved extent descriptor for later free */</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txMaplock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckRELOCATE</span><span class="p">);</span>
		<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEPXD</span><span class="p">;</span>
		<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">;</span>
		<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update directory index table to reflect new page address</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s64</span> <span class="n">lblock</span><span class="p">;</span>

			<span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ldtentry</span> <span class="o">=</span>
				    <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">n</span><span class="p">]];</span>
				<span class="n">modify_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span>
					     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
					     <span class="n">xaddr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lblock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	extend the page</span>
<span class="cm">	 */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span> <span class="o">=</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtExtendPage: ip:0x%p smp:0x%p sp:0x%p&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>

	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">smp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the extended/leaf page</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* update buffer extent descriptor of extended page */</span>
	<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
	<span class="n">xsize</span> <span class="o">=</span> <span class="n">xlen</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * copy old stbl to new stbl at start of extended area</span>
<span class="cm">	 */</span>
	<span class="n">oldstblindex</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span><span class="p">;</span>
	<span class="n">oldstblsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
	<span class="n">newstblindex</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">xsize</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
	<span class="n">newstblsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">newstblindex</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">oldstblindex</span><span class="p">],</span>
	       <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * in-line extension: linelock old area of extended page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">tlckEXTEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* linelock header */</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* linelock new stbl of extended page */</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">newstblindex</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">newstblsize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * relocation: linelock whole relocated area</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">+</span> <span class="n">newstblsize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">=</span> <span class="n">newstblindex</span><span class="p">;</span>
	<span class="cm">/* sp-&gt;header.nextindex remains the same */</span>

	<span class="cm">/*</span>
<span class="cm">	 * add old stbl region at head of freelist</span>
<span class="cm">	 */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">oldstblindex</span><span class="p">;</span>
	<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">oldstblsize</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">fsi</span><span class="o">++</span><span class="p">,</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">+=</span> <span class="n">oldstblsize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * append free region of newly extended area at tail of freelist</span>
<span class="cm">	 */</span>
	<span class="cm">/* init free region of newly extended area */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">n</span> <span class="o">=</span> <span class="n">newstblindex</span> <span class="o">+</span> <span class="n">newstblsize</span><span class="p">;</span>
	<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fsi</span><span class="o">++</span><span class="p">;</span> <span class="n">fsi</span> <span class="o">&lt;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">,</span> <span class="n">fsi</span><span class="o">++</span><span class="p">)</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* append new free region at tail of old freelist */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsi</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
			<span class="n">fsi</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">fsi</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">+=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * insert the new entry</span>
<span class="cm">	 */</span>
	<span class="n">dtInsertEntry</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="p">);</span>

	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">pmp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * linelock any freeslots residing in old extent</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">tlckEXTEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
			<span class="n">dtLinelockFreelist</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	update parent entry on the parent/root page</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the parent/root page</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">pmp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="cm">/* linelock parent entry - 1st slot */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* update the parent pxd for page extension */</span>
	<span class="n">tpxd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="o">*</span><span class="n">tpxd</span> <span class="o">=</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">pmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtSplitRoot()</span>
<span class="cm"> *</span>
<span class="cm"> * function:</span>
<span class="cm"> *	split the full root page into</span>
<span class="cm"> *	original/root/split page and new right page</span>
<span class="cm"> *	i.e., root remains fixed in tree anchor (inode) and</span>
<span class="cm"> *	the root is copied to a single new right child page</span>
<span class="cm"> *	since root page &lt;&lt; non-root page, and</span>
<span class="cm"> *	the split root page contains a single entry for the</span>
<span class="cm"> *	new right child page.</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return: 0 - success;</span>
<span class="cm"> *	   errno - failure;</span>
<span class="cm"> *	return new page pinned;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtSplitRoot</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span>
	    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dtsplit</span> <span class="o">*</span> <span class="n">split</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span> <span class="n">rmpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">smp</span><span class="p">;</span>
	<span class="n">dtroot_t</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">rmp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">rbn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fsi</span><span class="p">,</span> <span class="n">stblsize</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">ppxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxdlist</span> <span class="o">*</span><span class="n">pxdlist</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* get split root page */</span>
	<span class="n">smp</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_dtroot</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	allocate/initialize a single (right) child page</span>
<span class="cm">	 *</span>
<span class="cm">	 * N.B. at first split, a one (or two) block to fit new entry</span>
<span class="cm">	 * is allocated; at subsequent split, a full page is allocated;</span>
<span class="cm">	 */</span>
	<span class="n">pxdlist</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">pxdlist</span><span class="p">;</span>
	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">[</span><span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">npxd</span><span class="p">];</span>
	<span class="n">pxdlist</span><span class="o">-&gt;</span><span class="n">npxd</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rbn</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
	<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
	<span class="n">xsize</span> <span class="o">=</span> <span class="n">xlen</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>
	<span class="n">rmp</span> <span class="o">=</span> <span class="n">get_metapage</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">rbn</span><span class="p">,</span> <span class="n">xsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">rp</span> <span class="o">=</span> <span class="n">rmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Allocate blocks to quota. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dquot_alloc_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">rmp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the new right page</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">rmp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckNEW</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="o">?</span> <span class="n">BT_LEAF</span> <span class="o">:</span> <span class="n">BT_INTERNAL</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span> <span class="o">=</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>

	<span class="cm">/* initialize sibling pointers */</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	move in-line root page into new right page extent</span>
<span class="cm">	 */</span>
	<span class="cm">/* linelock header + copied entries + new stbl (1st slot) in new page */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>	<span class="cm">/* 1 + 8 + 1 */</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">xsize</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">stblsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>

	<span class="cm">/* copy old stbl to new stbl at start of extended area */</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">=</span> <span class="n">DTROOTMAXSLOT</span><span class="p">;</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">s8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">DTROOTMAXSLOT</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">stbl</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stbl</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">);</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span>

	<span class="cm">/* copy old data area to start of new data area */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">IDATASIZE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * append free region of newly extended area at tail of freelist</span>
<span class="cm">	 */</span>
	<span class="cm">/* init free region of newly extended area */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">n</span> <span class="o">=</span> <span class="n">DTROOTMAXSLOT</span> <span class="o">+</span> <span class="n">stblsize</span><span class="p">;</span>
	<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fsi</span><span class="o">++</span><span class="p">;</span> <span class="n">fsi</span> <span class="o">&lt;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">,</span> <span class="n">fsi</span><span class="o">++</span><span class="p">)</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* append new free region at tail of old freelist */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsi</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
			<span class="n">fsi</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">fsi</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">+</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update directory index table for entries now in right page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">lblock</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">ldtentry</span><span class="p">;</span>

		<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ldtentry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">n</span><span class="p">]];</span>
			<span class="n">modify_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
				     <span class="n">rbn</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lblock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * insert the new entry into the new right/child page</span>
<span class="cm">	 * (skip index in the new right page will not change)</span>
<span class="cm">	 */</span>
	<span class="n">dtInsertEntry</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	reset parent/root page</span>
<span class="cm">	 *</span>
<span class="cm">	 * set the 1st entry offset to 0, which force the left-most key</span>
<span class="cm">	 * at any level of the tree to be less than any search key.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The btree comparison code guarantees that the left-most key on any</span>
<span class="cm">	 * level of the tree is never used, so it doesn&#39;t need to be filled in.</span>
<span class="cm">	 */</span>
	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">smp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the root page (in-memory inode)</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">smp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckNEW</span> <span class="o">|</span> <span class="n">tlckBTROOT</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* linelock root */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">DTROOTMAXSLOT</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* update page header of root */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BT_LEAF</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">BT_INTERNAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* init the first entry */</span>
	<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">DTENTRYSTART</span><span class="p">];</span>
	<span class="n">ppxd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">s</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ppxd</span> <span class="o">=</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">stbl</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stbl</span><span class="p">;</span>
	<span class="n">stbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">DTENTRYSTART</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* init freelist */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">DTENTRYSTART</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>

	<span class="cm">/* init free region of remaining area */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fsi</span><span class="o">++</span><span class="p">;</span> <span class="n">fsi</span> <span class="o">&lt;</span> <span class="n">DTROOTMAXSLOT</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">,</span> <span class="n">fsi</span><span class="o">++</span><span class="p">)</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">DTENTRYSTART</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">=</span> <span class="n">DTROOTMAXSLOT</span> <span class="o">-</span> <span class="p">(</span><span class="n">DTENTRYSTART</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="o">*</span><span class="n">rmpp</span> <span class="o">=</span> <span class="n">rmp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtDelete()</span>
<span class="cm"> *</span>
<span class="cm"> * function: delete the entry(s) referenced by a key.</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return:</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dtDelete</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span>
	 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">ino_t</span> <span class="o">*</span> <span class="n">ino</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">imp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btstack</span> <span class="n">btstack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">ldtentry</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">table_index</span><span class="p">,</span> <span class="n">next_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">nmp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	search for the entry to delete:</span>
<span class="cm">	 *</span>
<span class="cm">	 * dtSearch() returns (leaf page pinned, index at which to delete).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtSearch</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">btstack</span><span class="p">,</span> <span class="n">flag</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* retrieve search result */</span>
	<span class="n">DT_GETSEARCH</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">btstack</span><span class="p">.</span><span class="n">top</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to find put the index of the next entry into the</span>
<span class="cm">	 * directory index table in order to resume a readdir from this</span>
<span class="cm">	 * entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">ldtentry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">]];</span>
		<span class="n">table_index</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Last entry in this leaf page</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">next_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Read next leaf page */</span>
				<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">),</span>
					   <span class="n">nmp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
					<span class="n">next_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
					<span class="n">ldtentry</span> <span class="o">=</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">-&gt;</span>
					    <span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
					<span class="n">next_index</span> <span class="o">=</span>
					    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
					<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">nmp</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ldtentry</span> <span class="o">=</span>
			    <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]];</span>
			<span class="n">next_index</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">free_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">table_index</span><span class="p">,</span> <span class="n">next_index</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * the leaf page becomes empty, delete the page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* delete empty page */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dtDeleteUp</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">btstack</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * the leaf page has other entries remaining:</span>
<span class="cm">	 *</span>
<span class="cm">	 * delete the entry from the leaf page.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * acquire a transaction lock on the leaf page</span>
<span class="cm">		 */</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do not assume that dtlck-&gt;index will be zero.  During a</span>
<span class="cm">		 * rename within a directory, this transaction may have</span>
<span class="cm">		 * modified this page already when adding the new entry.</span>
<span class="cm">		 */</span>

		<span class="cm">/* linelock header */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
			<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* linelock stbl of non-root leaf page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
				<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
			<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">)</span> <span class="o">-</span>
			    <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* free the leaf entry */</span>
		<span class="n">dtDeleteEntry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update directory index table for entries moved in stbl</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s64</span> <span class="n">lblock</span><span class="p">;</span>

			<span class="n">imp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ldtentry</span> <span class="o">=</span>
				    <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
				<span class="n">modify_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span>
					     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldtentry</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
					     <span class="n">bn</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lblock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">imp</span><span class="p">)</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">imp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtDeleteUp()</span>
<span class="cm"> *</span>
<span class="cm"> * function:</span>
<span class="cm"> *	free empty pages as propagating deletion up the tree</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtDeleteUp</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	   <span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span> <span class="n">fmp</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">nextindex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btframe</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	keep the root leaf page which has become empty</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BT_IS_ROOT</span><span class="p">(</span><span class="n">fmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * reset the root</span>
<span class="cm">		 *</span>
<span class="cm">		 * dtInitRoot() acquires txlock on the root</span>
<span class="cm">		 */</span>
		<span class="n">dtInitRoot</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">PARENT</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>

		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">fmp</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	free the non-root leaf page</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the page</span>
<span class="cm">	 *</span>
<span class="cm">	 * write FREEXTENT|NOREDOPAGE log record</span>
<span class="cm">	 * N.B. linelock is overlaid as freed extent descriptor, and</span>
<span class="cm">	 * the buffer page is freed;</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txMaplock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckFREE</span><span class="p">);</span>
	<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEPXD</span><span class="p">;</span>
	<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">;</span>
	<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* update sibling pointers */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtRelink</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">fp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">BT_PUTPAGE</span><span class="p">(</span><span class="n">fmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Free quota allocation. */</span>
	<span class="n">dquot_free_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>

	<span class="cm">/* free/invalidate its buffer page */</span>
	<span class="n">discard_metapage</span><span class="p">(</span><span class="n">fmp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	propagate page deletion up the directory tree</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the delete from the parent page makes it empty,</span>
<span class="cm">	 * continue all the way up the tree.</span>
<span class="cm">	 * stop if the root page is reached (which is never deleted) or</span>
<span class="cm">	 * if the entry deletion does not empty the page.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">parent</span> <span class="o">=</span> <span class="n">BT_POP</span><span class="p">(</span><span class="n">btstack</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pin the parent page &lt;sp&gt; */</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * free the extent of the child page deleted</span>
<span class="cm">		 */</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * delete the entry for the child page from parent</span>
<span class="cm">		 */</span>
		<span class="n">nextindex</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * the parent has the single entry being deleted:</span>
<span class="cm">		 *</span>
<span class="cm">		 * free the parent page which has become empty.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nextindex</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * keep the root internal page which has become empty</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * reset the root</span>
<span class="cm">				 *</span>
<span class="cm">				 * dtInitRoot() acquires txlock on the root</span>
<span class="cm">				 */</span>
				<span class="n">dtInitRoot</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">PARENT</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>

				<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * free the parent page</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * acquire a transaction lock on the page</span>
<span class="cm">				 *</span>
<span class="cm">				 * write FREEXTENT|NOREDOPAGE log record</span>
<span class="cm">				 */</span>
				<span class="n">tlck</span> <span class="o">=</span>
				    <span class="n">txMaplock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span>
					      <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckFREE</span><span class="p">);</span>
				<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
				<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEPXD</span><span class="p">;</span>
				<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">;</span>
				<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

				<span class="cm">/* update sibling pointers */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtRelink</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">);</span>

				<span class="cm">/* Free quota allocation */</span>
				<span class="n">dquot_free_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>

				<span class="cm">/* free/invalidate its buffer page */</span>
				<span class="n">discard_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

				<span class="cm">/* propagate up */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * the parent has other entries remaining:</span>
<span class="cm">		 *</span>
<span class="cm">		 * delete the router entry from the parent page.</span>
<span class="cm">		 */</span>
		<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * acquire a transaction lock on the page</span>
<span class="cm">		 *</span>
<span class="cm">		 * action: router entry deletion</span>
<span class="cm">		 */</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

		<span class="cm">/* linelock header */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
			<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* linelock stbl of non-root leaf page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
				<span class="n">lv</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
				<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">;</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">)</span> <span class="o">-</span>
			    <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* free the router entry */</span>
		<span class="n">dtDeleteEntry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="p">);</span>

		<span class="cm">/* reset key of new leftmost entry of level (for consistency) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">dtTruncateEntry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="p">);</span>

		<span class="cm">/* unpin the parent page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="cm">/* exit propagation up */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">PSIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef _NOTYET</span>
<span class="cm">/*</span>
<span class="cm"> * NAME:	dtRelocate()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	relocate dtpage (internal or leaf) of directory;</span>
<span class="cm"> *		This function is mainly used by defragfs utility.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dtRelocate</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">lmxaddr</span><span class="p">,</span> <span class="n">pxd_t</span> <span class="o">*</span> <span class="n">opxd</span><span class="p">,</span>
	       <span class="n">s64</span> <span class="n">nxaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">pmp</span><span class="p">,</span> <span class="o">*</span><span class="n">lmp</span><span class="p">,</span> <span class="o">*</span><span class="n">rmp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">lp</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btstack</span> <span class="n">btstack</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">oxaddr</span><span class="p">,</span> <span class="n">nextbn</span><span class="p">,</span> <span class="n">prevbn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">xsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>

	<span class="n">oxaddr</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">opxd</span><span class="p">);</span>
	<span class="n">xlen</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">opxd</span><span class="p">);</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtRelocate: lmxaddr:%Ld xaddr:%Ld:%Ld xlen:%d&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lmxaddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">oxaddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">nxaddr</span><span class="p">,</span>
		   <span class="n">xlen</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	1. get the internal parent dtpage covering</span>
<span class="cm">	 *	router entry for the tartget page to be relocated;</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dtSearchNode</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lmxaddr</span><span class="p">,</span> <span class="n">opxd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">btstack</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* retrieve search result */</span>
	<span class="n">DT_GETSEARCH</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">btstack</span><span class="p">.</span><span class="n">top</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">pmp</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtRelocate: parent router entry validated.&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	2. relocate the target dtpage</span>
<span class="cm">	 */</span>
	<span class="cm">/* read in the target page from src extent */</span>
	<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">oxaddr</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* release the pinned parent page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">pmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * read in sibling pages if any to update sibling pointers;</span>
<span class="cm">	 */</span>
	<span class="n">rmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nextbn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">nextbn</span><span class="p">,</span> <span class="n">rmp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">pmp</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prevbn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">prevbn</span><span class="p">,</span> <span class="n">lmp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">pmp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmp</span><span class="p">)</span>
				<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* at this point, all xtpages to be updated are in memory */</span>

	<span class="cm">/*</span>
<span class="cm">	 * update sibling pointers of sibling dtpages if any;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">lmp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckRELINK</span><span class="p">);</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="cm">/* linelock header */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nxaddr</span><span class="p">);</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">lmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">rmp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckRELINK</span><span class="p">);</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
		<span class="cm">/* linelock header */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nxaddr</span><span class="p">);</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">rmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * update the target dtpage to be relocated</span>
<span class="cm">	 *</span>
<span class="cm">	 * write LOG_REDOPAGE of LOG_NEW type for dst page</span>
<span class="cm">	 * for the whole target page (logredo() will apply</span>
<span class="cm">	 * after image and update bmap for allocation of the</span>
<span class="cm">	 * dst extent), and update bmap for allocation of</span>
<span class="cm">	 * the dst extent;</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckNEW</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="cm">/* linelock header */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* update the self address in the dtpage header */</span>
	<span class="n">pxd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">;</span>
	<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">nxaddr</span><span class="p">);</span>

	<span class="cm">/* the dst page is the same as the src page, i.e.,</span>
<span class="cm">	 * linelock for afterimage of the whole page;</span>
<span class="cm">	 */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">maxslot</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* update the buffer extent descriptor of the dtpage */</span>
	<span class="n">xsize</span> <span class="o">=</span> <span class="n">xlen</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>

	<span class="cm">/* unpin the relocated page */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtRelocate: target dtpage relocated.&quot;</span><span class="p">);</span>

	<span class="cm">/* the moved extent is dtpage, then a LOG_NOREDOPAGE log rec</span>
<span class="cm">	 * needs to be written (in logredo(), the LOG_NOREDOPAGE log rec</span>
<span class="cm">	 * will also force a bmap update ).</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 *	3. acquire maplock for the source extent to be freed;</span>
<span class="cm">	 */</span>
	<span class="cm">/* for dtpage relocation, write a LOG_NOREDOPAGE record</span>
<span class="cm">	 * for the source dtpage (logredo() will init NoRedoPage</span>
<span class="cm">	 * filter and will also update bmap for free of the source</span>
<span class="cm">	 * dtpage), and upadte bmap for free of the source dtpage;</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txMaplock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckFREE</span><span class="p">);</span>
	<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEPXD</span><span class="p">;</span>
	<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">,</span> <span class="n">oxaddr</span><span class="p">);</span>
	<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
	<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	4. update the parent router entry for relocation;</span>
<span class="cm">	 *</span>
<span class="cm">	 * acquire tlck for the parent entry covering the target dtpage;</span>
<span class="cm">	 * write LOG_REDOPAGE to apply after image only;</span>
<span class="cm">	 */</span>
	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtRelocate: update parent router entry.&quot;</span><span class="p">);</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">pmp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="cm">/* update the PXD with the new address */</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">pp</span><span class="p">);</span>
	<span class="n">pxd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">]];</span>
	<span class="n">PXDaddress</span><span class="p">(</span><span class="n">pxd</span><span class="p">,</span> <span class="n">nxaddr</span><span class="p">);</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* unpin the parent dtpage */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">pmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	dtSearchNode()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Search for an dtpage containing a specified address</span>
<span class="cm"> *		This function is mainly used by defragfs utility.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:	Search result on stack, the found page is pinned at exit.</span>
<span class="cm"> *		The result page must be an internal dtpage.</span>
<span class="cm"> *		lmxaddr give the address of the left most page of the</span>
<span class="cm"> *		dtree level, in which the required dtpage resides.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtSearchNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">s64</span> <span class="n">lmxaddr</span><span class="p">,</span> <span class="n">pxd_t</span> <span class="o">*</span> <span class="n">kpxd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">psize</span> <span class="o">=</span> <span class="mi">288</span><span class="p">;</span>	<span class="cm">/* initial in-line directory */</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">pxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btframe</span> <span class="o">*</span><span class="n">btsp</span><span class="p">;</span>

	<span class="n">BT_CLR</span><span class="p">(</span><span class="n">btstack</span><span class="p">);</span>	<span class="cm">/* reset stack */</span>

	<span class="cm">/*</span>
<span class="cm">	 *	descend tree to the level with specified leftmost page</span>
<span class="cm">	 *</span>
<span class="cm">	 *  by convention, root bn = 0.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;)</span> <span class="p">{</span>
		<span class="cm">/* get/pin the page to search */</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/* does the xaddr of leftmost page of the levevl</span>
<span class="cm">		 * matches levevl search key ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lmxaddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">lmxaddr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * descend down to leftmost child page</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* get the leftmost entry */</span>
		<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">pxd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>

		<span class="cm">/* get the child page block address */</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">);</span>
		<span class="n">psize</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>
		<span class="cm">/* unpin the parent page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	search each page at the current levevl</span>
<span class="cm">	 */</span>
      <span class="nl">loop:</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pxd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>

		<span class="cm">/* found the specified router entry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addressPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">)</span> <span class="o">==</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">kpxd</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">lengthPXD</span><span class="p">(</span><span class="n">pxd</span><span class="p">)</span> <span class="o">==</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">kpxd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">btsp</span> <span class="o">=</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* get the right sibling page if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* unpin current page */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/* get the right sibling page */</span>
	<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* _NOTYET */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	dtRelink()</span>
<span class="cm"> *</span>
<span class="cm"> * function:</span>
<span class="cm"> *	link around a freed page.</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *	fp:	page to be freed</span>
<span class="cm"> *</span>
<span class="cm"> * return:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtRelink</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nextbn</span><span class="p">,</span> <span class="n">prevbn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>

	<span class="n">nextbn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="n">prevbn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>

	<span class="cm">/* update prev pointer of the next page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nextbn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">nextbn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * acquire a transaction lock on the next page</span>
<span class="cm">		 *</span>
<span class="cm">		 * action: update prev pointer;</span>
<span class="cm">		 */</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckRELINK</span><span class="p">);</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p&quot;</span><span class="p">,</span>
			<span class="n">tlck</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

		<span class="cm">/* linelock header */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
			<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">prevbn</span><span class="p">);</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* update next pointer of the previous page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prevbn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">prevbn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * acquire a transaction lock on the prev page</span>
<span class="cm">		 *</span>
<span class="cm">		 * action: update next pointer;</span>
<span class="cm">		 */</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckRELINK</span><span class="p">);</span>
		<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p&quot;</span><span class="p">,</span>
			<span class="n">tlck</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

		<span class="cm">/* linelock header */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
			<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nextbn</span><span class="p">);</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtInitRoot()</span>
<span class="cm"> *</span>
<span class="cm"> * initialize directory root (inline in inode)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dtInitRoot</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">idotdot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">dtroot_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">xflag_save</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this was previously an non-empty directory, we need to remove</span>
<span class="cm">	 * the old directory table.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jfs_dirtable_inline</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">tblk</span> <span class="o">=</span> <span class="n">tid_to_tblock</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * We&#39;re playing games with the tid&#39;s xflag.  If</span>
<span class="cm">			 * we&#39;re removing a regular file, the file&#39;s xtree</span>
<span class="cm">			 * is committed with COMMIT_PMAP, but we always</span>
<span class="cm">			 * commit the directories xtree with COMMIT_PWMAP.</span>
<span class="cm">			 */</span>
			<span class="n">xflag_save</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span><span class="p">;</span>
			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * xtTruncate isn&#39;t guaranteed to fully truncate</span>
<span class="cm">			 * the xtree.  The caller needs to check i_size</span>
<span class="cm">			 * after committing the transaction to see if</span>
<span class="cm">			 * additional truncation is needed.  The</span>
<span class="cm">			 * COMMIT_Stale flag tells caller that we</span>
<span class="cm">			 * initiated the truncation.</span>
<span class="cm">			 */</span>
			<span class="n">xtTruncate</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">COMMIT_PWMAP</span><span class="p">);</span>
			<span class="n">set_cflag</span><span class="p">(</span><span class="n">COMMIT_Stale</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

			<span class="n">tblk</span><span class="o">-&gt;</span><span class="n">xflag</span> <span class="o">=</span> <span class="n">xflag_save</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">IDATASIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the root</span>
<span class="cm">	 *</span>
<span class="cm">	 * action: directory initialization;</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">bxflag</span><span class="p">,</span>
		      <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span> <span class="o">|</span> <span class="n">tlckBTROOT</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* linelock root */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">DTROOTMAXSLOT</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dtroot</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">DXD_INDEX</span> <span class="o">|</span> <span class="n">BT_ROOT</span> <span class="o">|</span> <span class="n">BT_LEAF</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* init freelist */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>

	<span class="cm">/* init data area of root */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fsi</span><span class="o">++</span><span class="p">;</span> <span class="n">fsi</span> <span class="o">&lt;</span> <span class="n">DTROOTMAXSLOT</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">,</span> <span class="n">fsi</span><span class="o">++</span><span class="p">)</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="cm">/* init &#39;..&#39; entry */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">idotdot</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">idotdot</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	add_missing_indices()</span>
<span class="cm"> *</span>
<span class="cm"> * function: Fix dtree page in which one or more entries has an invalid index.</span>
<span class="cm"> *	     fsck.jfs should really fix this, but it currently does not.</span>
<span class="cm"> *	     Called from jfs_readdir when bad index is detected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_missing_indices</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">s64</span> <span class="n">bn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>

	<span class="n">tid</span> <span class="o">=</span> <span class="n">txBegin</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DT_GETPAGE failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">);</span>

	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BT_IS_ROOT</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">tlckBTROOT</span><span class="p">;</span>

	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">add_index</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
				<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
			<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">stbl</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">txCommit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">end:</span>
	<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Buffer to hold directory entry info while traversing a dtree page</span>
<span class="cm"> * before being fed to the filldir function</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">jfs_dirent</span> <span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">position</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * function to determine next variable-sized jfs_dirent in buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">jfs_dirent</span> <span class="o">*</span><span class="nf">next_jfs_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_dirent</span> <span class="o">*</span><span class="n">dirent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_dirent</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dirent</span> <span class="o">+</span>
		 <span class="p">((</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_dirent</span><span class="p">)</span> <span class="o">+</span> <span class="n">dirent</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
		   <span class="k">sizeof</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
		  <span class="o">~</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	jfs_readdir()</span>
<span class="cm"> *</span>
<span class="cm"> * function: read directory entries sequentially</span>
<span class="cm"> *	from the specified entry offset</span>
<span class="cm"> *</span>
<span class="cm"> * parameter:</span>
<span class="cm"> *</span>
<span class="cm"> * return: offset = (pn, index) of start entry</span>
<span class="cm"> *	of next jfs_readdir()/dtRead()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jfs_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">codepage</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nls_tab</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">dtpos</span><span class="p">;</span>	<span class="cm">/* legacy OS/2 style position */</span>
	<span class="k">struct</span> <span class="n">dtoffset</span> <span class="p">{</span>
		<span class="n">s16</span> <span class="n">pn</span><span class="p">;</span>
		<span class="n">s16</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">unused</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">dtoffset</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dtoffset</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">dtpos</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btstack</span> <span class="n">btstack</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">d_namleft</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">outlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirent_buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dir_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">loop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_dirent</span> <span class="o">*</span><span class="n">jfs_dirent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jfs_dirents</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">overflow</span><span class="p">,</span> <span class="n">fix_page</span><span class="p">,</span> <span class="n">page_fixed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">unique_pos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* If we can&#39;t fix broken index */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">==</span> <span class="n">DIREND</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DO_INDEX</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * persistent index is stored in directory entries.</span>
<span class="cm">		 * Special cases:	 0 = .</span>
<span class="cm">		 *			 1 = ..</span>
<span class="cm">		 *			-1 = End of directory</span>
<span class="cm">		 */</span>
		<span class="n">do_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">dir_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dir_index</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="n">dirtab_slot</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dtEmpty</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">dir_index</span> <span class="o">&gt;=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Stale position.  Directory has shrunk */</span>
				<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		      <span class="nl">repeat:</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">read_index</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dir_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirtab_slot</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dirtab_slot</span><span class="p">.</span><span class="n">flag</span> <span class="o">==</span> <span class="n">DIR_INDEX_FREE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">loop_count</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;jfs_readdir detected &quot;</span>
						   <span class="s">&quot;infinite loop!&quot;</span><span class="p">);</span>
					<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">dir_index</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dirtab_slot</span><span class="p">.</span><span class="n">addr2</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dir_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bn</span> <span class="o">=</span> <span class="n">addressDTS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirtab_slot</span><span class="p">);</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">dirtab_slot</span><span class="p">.</span><span class="n">slot</span><span class="p">;</span>
			<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_INTERNAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;jfs_readdir: bad index table&quot;</span><span class="p">);</span>
				<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
				<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dir_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * self &quot;.&quot;</span>
<span class="cm">				 */</span>
				<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					    <span class="n">DT_DIR</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * parent &quot;..&quot;</span>
<span class="cm">			 */</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PARENT</span><span class="p">(</span><span class="n">ip</span><span class="p">),</span> <span class="n">DT_DIR</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Find first entry of left-most leaf</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtEmpty</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtReadFirst</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">btstack</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

			<span class="n">DT_GETSEARCH</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">btstack</span><span class="p">.</span><span class="n">top</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Legacy filesystem - OS/2 &amp; Linux JFS &lt; 0.3.6</span>
<span class="cm">		 *</span>
<span class="cm">		 * pn = index = 0:	First entry &quot;.&quot;</span>
<span class="cm">		 * pn = 0; index = 1:	Second entry &quot;..&quot;</span>
<span class="cm">		 * pn &gt; 0:		Real entries, pn=1 -&gt; leftmost page</span>
<span class="cm">		 * pn = index = -1:	No more entries</span>
<span class="cm">		 */</span>
		<span class="n">dtpos</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dtpos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* build &quot;.&quot; entry */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
				    <span class="n">DT_DIR</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">dtpos</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">pn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* build &quot;..&quot; entry */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span>
					    <span class="n">PARENT</span><span class="p">(</span><span class="n">ip</span><span class="p">),</span> <span class="n">DT_DIR</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;jfs_readdir called with &quot;</span>
					<span class="s">&quot;invalid offset!&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">pn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">dtpos</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dtEmpty</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtReadNext</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">btstack</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;jfs_readdir: unexpected rc = %d &quot;</span>
				<span class="s">&quot;from dtReadNext&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* get start leaf page and index */</span>
		<span class="n">DT_GETSEARCH</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">btstack</span><span class="p">.</span><span class="n">top</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

		<span class="cm">/* offset beyond directory eof ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dirent_buf</span> <span class="o">=</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirent_buf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">jfs_warn</span><span class="p">(</span><span class="s">&quot;jfs_readdir: __get_free_page failed!&quot;</span><span class="p">);</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_dirent</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_dirent</span> <span class="o">*</span><span class="p">)</span> <span class="n">dirent_buf</span><span class="p">;</span>
		<span class="n">jfs_dirents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">overflow</span> <span class="o">=</span> <span class="n">fix_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>

			<span class="k">if</span> <span class="p">(((</span><span class="kt">long</span><span class="p">)</span> <span class="n">jfs_dirent</span> <span class="o">+</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span>
			    <span class="p">(</span><span class="n">dirent_buf</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* DBCS codepages could overrun dirent_buf */</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">overflow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">d_namleft</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>
			<span class="n">name_ptr</span> <span class="o">=</span> <span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
			<span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">do_index</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">d_namleft</span><span class="p">,</span> <span class="n">DTLHDRDATALEN</span><span class="p">);</span>
				<span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * d-&gt;index should always be valid, but it</span>
<span class="cm">				 * isn&#39;t.  fsck.jfs doesn&#39;t create the</span>
<span class="cm">				 * directory index for the lost+found</span>
<span class="cm">				 * directory.  Rather than let it go,</span>
<span class="cm">				 * we can try to fix it.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">&gt;=</span>
				     <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_fixed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isReadOnly</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">fix_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="cm">/*</span>
<span class="cm">						 * setting overflow and setting</span>
<span class="cm">						 * index to i will cause the</span>
<span class="cm">						 * same page to be processed</span>
<span class="cm">						 * again starting here</span>
<span class="cm">						 */</span>
						<span class="n">overflow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">=</span> <span class="n">unique_pos</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">=</span> <span class="n">dtpos</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">d_namleft</span><span class="p">,</span> <span class="n">DTLHDRDATALEN_LEGACY</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* copy the name of head/only segment */</span>
			<span class="n">outlen</span> <span class="o">=</span> <span class="n">jfs_strfromUCS_le</span><span class="p">(</span><span class="n">name_ptr</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						   <span class="n">codepage</span><span class="p">);</span>
			<span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">outlen</span><span class="p">;</span>

			<span class="cm">/* copy name in the additional segment(s) */</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
				<span class="n">name_ptr</span> <span class="o">+=</span> <span class="n">outlen</span><span class="p">;</span>
				<span class="n">d_namleft</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
				<span class="cm">/* Sanity Check */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">d_namleft</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
						  <span class="s">&quot;JFS:Dtree error: ino = &quot;</span>
						  <span class="s">&quot;%ld, bn=%Ld, index = %d&quot;</span><span class="p">,</span>
						  <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
						  <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bn</span><span class="p">,</span>
						  <span class="n">i</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">skip_one</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">d_namleft</span><span class="p">,</span> <span class="n">DTSLOTDATALEN</span><span class="p">);</span>
				<span class="n">outlen</span> <span class="o">=</span> <span class="n">jfs_strfromUCS_le</span><span class="p">(</span><span class="n">name_ptr</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
							   <span class="n">len</span><span class="p">,</span> <span class="n">codepage</span><span class="p">);</span>
				<span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">+=</span> <span class="n">outlen</span><span class="p">;</span>

				<span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">jfs_dirents</span><span class="o">++</span><span class="p">;</span>
			<span class="n">jfs_dirent</span> <span class="o">=</span> <span class="n">next_jfs_dirent</span><span class="p">(</span><span class="n">jfs_dirent</span><span class="p">);</span>
<span class="nl">skip_one:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_index</span><span class="p">)</span>
				<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overflow</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Point to next leaf page */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span>
				<span class="n">bn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">bn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
				<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/* update offset (pn:index) for new page */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_index</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">pn</span><span class="o">++</span><span class="p">;</span>
					<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">page_fixed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* unpin previous leaf page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="n">jfs_dirent</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_dirent</span> <span class="o">*</span><span class="p">)</span> <span class="n">dirent_buf</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">jfs_dirents</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				    <span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span>
				    <span class="n">jfs_dirent</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">DT_UNKNOWN</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">jfs_dirent</span> <span class="o">=</span> <span class="n">next_jfs_dirent</span><span class="p">(</span><span class="n">jfs_dirent</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fix_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">add_missing_indices</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">);</span>
			<span class="n">page_fixed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overflow</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">DIREND</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_page</span><span class="p">(</span><span class="n">dirent_buf</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="n">free_page</span><span class="p">(</span><span class="n">dirent_buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtReadFirst()</span>
<span class="cm"> *</span>
<span class="cm"> * function: get the leftmost page of the directory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtReadFirst</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">psize</span> <span class="o">=</span> <span class="mi">288</span><span class="p">;</span>	<span class="cm">/* initial in-line directory */</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btframe</span> <span class="o">*</span><span class="n">btsp</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">xd</span><span class="p">;</span>

	<span class="n">BT_CLR</span><span class="p">(</span><span class="n">btstack</span><span class="p">);</span>	<span class="cm">/* reset stack */</span>

	<span class="cm">/*</span>
<span class="cm">	 *	descend leftmost path of the tree</span>
<span class="cm">	 *</span>
<span class="cm">	 * by convention, root bn = 0.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;)</span> <span class="p">{</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * leftmost leaf page</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* return leftmost entry */</span>
			<span class="n">btsp</span> <span class="o">=</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * descend down to leftmost child page</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BT_STACK_FULL</span><span class="p">(</span><span class="n">btstack</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;dtReadFirst: btstack overrun&quot;</span><span class="p">);</span>
			<span class="n">BT_STACK_DUMP</span><span class="p">(</span><span class="n">btstack</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* push (bn, index) of the parent page/entry */</span>
		<span class="n">BT_PUSH</span><span class="p">(</span><span class="n">btstack</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* get the leftmost entry */</span>
		<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">xd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>

		<span class="cm">/* get the child page block address */</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">xd</span><span class="p">);</span>
		<span class="n">psize</span> <span class="o">=</span> <span class="n">lengthPXD</span><span class="p">(</span><span class="n">xd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2bsize</span><span class="p">;</span>

		<span class="cm">/* unpin the parent page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtReadNext()</span>
<span class="cm"> *</span>
<span class="cm"> * function: get the page of the specified offset (pn:index)</span>
<span class="cm"> *</span>
<span class="cm"> * return: if (offset &gt; eof), bn = -1;</span>
<span class="cm"> *</span>
<span class="cm"> * note: if index &gt; nextindex of the target leaf page,</span>
<span class="cm"> * start with 1st entry of next leaf page;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtReadNext</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">btstack</span> <span class="o">*</span> <span class="n">btstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtoffset</span> <span class="p">{</span>
		<span class="n">s16</span> <span class="n">pn</span><span class="p">;</span>
		<span class="n">s16</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">s32</span> <span class="n">unused</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">dtoffset</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dtoffset</span> <span class="o">*</span><span class="p">)</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pn</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btframe</span> <span class="o">*</span><span class="n">btsp</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">xd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * get leftmost leaf page pinned</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtReadFirst</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">btstack</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* get leaf page */</span>
	<span class="n">DT_GETSEARCH</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/* get the start offset (pn:index) */</span>
	<span class="n">pn</span> <span class="o">=</span> <span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">pn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Now pn = 0 represents leftmost leaf */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

	<span class="cm">/* start at leftmost page ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* offset beyond eof ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* start with 1st entry of next leaf page */</span>
		<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">pn</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">a</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* start at non-leftmost page: scan parent pages for large pn */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* start after next leaf page ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pn</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">b</span><span class="p">;</span>

	<span class="cm">/* get leaf page pn = 1 */</span>
      <span class="nl">a:</span>
	<span class="n">bn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

	<span class="cm">/* unpin leaf page */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/* offset beyond eof ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">c</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * scan last internal page level to get target leaf page</span>
<span class="cm">	 */</span>
      <span class="nl">b:</span>
	<span class="cm">/* unpin leftmost leaf page */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/* get left most parent page */</span>
	<span class="n">btsp</span> <span class="o">=</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">btsp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bn</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bn</span><span class="p">;</span>
	<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* scan parent pages at last internal page level */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pn</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pn</span> <span class="o">-=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span>

		<span class="cm">/* get next parent page address */</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

		<span class="cm">/* unpin current parent page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="cm">/* offset beyond eof ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* get next parent page */</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/* update parent page stack frame */</span>
		<span class="n">parent</span><span class="o">-&gt;</span><span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get leaf page address */</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">xd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">pn</span><span class="p">]];</span>
	<span class="n">bn</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="n">xd</span><span class="p">);</span>

	<span class="cm">/* unpin parent page */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * get target leaf page</span>
<span class="cm">	 */</span>
      <span class="nl">c:</span>
	<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * leaf page has been completed:</span>
<span class="cm">	 * start with 1st entry of next leaf page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bn</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

		<span class="cm">/* unpin leaf page */</span>
		<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="cm">/* offset beyond eof ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* get next leaf page */</span>
		<span class="n">DT_GETPAGE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/* start with 1st entry of next leaf page */</span>
		<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">pn</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="cm">/* return target leaf page pinned */</span>
	<span class="n">btsp</span> <span class="o">=</span> <span class="n">btstack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
	<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="p">;</span>
	<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">dtoffset</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">btsp</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtCompare()</span>
<span class="cm"> *</span>
<span class="cm"> * function: compare search key with an internal entry</span>
<span class="cm"> *</span>
<span class="cm"> * return:</span>
<span class="cm"> *	&lt; 0 if k is &lt; record</span>
<span class="cm"> *	= 0 if k is = record</span>
<span class="cm"> *	&gt; 0 if k is &gt; record</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dtCompare</span><span class="p">(</span><span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span>	<span class="cm">/* search key */</span>
		     <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span>	<span class="cm">/* directory page */</span>
		     <span class="kt">int</span> <span class="n">si</span><span class="p">)</span>
<span class="p">{</span>				<span class="cm">/* entry slot index */</span>
	<span class="kt">wchar_t</span> <span class="o">*</span><span class="n">kname</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">klen</span><span class="p">,</span> <span class="n">namlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * force the left-most key on internal pages, at any level of</span>
<span class="cm">	 * the tree, to be less than any search key.</span>
<span class="cm">	 * this obviates having to update the leftmost key on an internal</span>
<span class="cm">	 * page when the user inserts a new key in the tree smaller than</span>
<span class="cm">	 * anything that has been stored.</span>
<span class="cm">	 *</span>
<span class="cm">	 * (? if/when dtSearch() narrows down to 1st entry (index = 0),</span>
<span class="cm">	 * at any internal page at any level of the tree,</span>
<span class="cm">	 * it descends to child of the entry anyway -</span>
<span class="cm">	 * ? make the entry as min size dummy entry)</span>
<span class="cm">	 *</span>
<span class="cm">	 * if (e-&gt;index == 0 &amp;&amp; h-&gt;prevpg == P_INVALID &amp;&amp; !(h-&gt;flags &amp; BT_LEAF))</span>
<span class="cm">	 * return (1);</span>
<span class="cm">	 */</span>

	<span class="n">kname</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">klen</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>

	<span class="n">ih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
	<span class="n">si</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namlen</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTIHDRDATALEN</span><span class="p">);</span>

	<span class="cm">/* compare with head/only segment */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">UniStrncmp_le</span><span class="p">(</span><span class="n">kname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">klen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">namlen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* compare with additional segment(s) */</span>
	<span class="n">kname</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">klen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">namlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* compare with next name segment */</span>
		<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTSLOTDATALEN</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">UniStrncmp_le</span><span class="p">(</span><span class="n">kname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">klen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">namlen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">kname</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">klen</span> <span class="o">-</span> <span class="n">namlen</span><span class="p">);</span>
<span class="p">}</span>




<span class="cm">/*</span>
<span class="cm"> *	ciCompare()</span>
<span class="cm"> *</span>
<span class="cm"> * function: compare search key with an (leaf/internal) entry</span>
<span class="cm"> *</span>
<span class="cm"> * return:</span>
<span class="cm"> *	&lt; 0 if k is &lt; record</span>
<span class="cm"> *	= 0 if k is = record</span>
<span class="cm"> *	&gt; 0 if k is &gt; record</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ciCompare</span><span class="p">(</span><span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span>	<span class="cm">/* search key */</span>
		     <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span>	<span class="cm">/* directory page */</span>
		     <span class="kt">int</span> <span class="n">si</span><span class="p">,</span>	<span class="cm">/* entry slot index */</span>
		     <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">wchar_t</span> <span class="o">*</span><span class="n">kname</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">klen</span><span class="p">,</span> <span class="n">namlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * force the left-most key on internal pages, at any level of</span>
<span class="cm">	 * the tree, to be less than any search key.</span>
<span class="cm">	 * this obviates having to update the leftmost key on an internal</span>
<span class="cm">	 * page when the user inserts a new key in the tree smaller than</span>
<span class="cm">	 * anything that has been stored.</span>
<span class="cm">	 *</span>
<span class="cm">	 * (? if/when dtSearch() narrows down to 1st entry (index = 0),</span>
<span class="cm">	 * at any internal page at any level of the tree,</span>
<span class="cm">	 * it descends to child of the entry anyway -</span>
<span class="cm">	 * ? make the entry as min size dummy entry)</span>
<span class="cm">	 *</span>
<span class="cm">	 * if (e-&gt;index == 0 &amp;&amp; h-&gt;prevpg == P_INVALID &amp;&amp; !(h-&gt;flags &amp; BT_LEAF))</span>
<span class="cm">	 * return (1);</span>
<span class="cm">	 */</span>

	<span class="n">kname</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">klen</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * leaf page entry</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">lh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">lh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">namlen</span> <span class="o">=</span> <span class="n">lh</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">JFS_DIR_INDEX</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTLHDRDATALEN</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTLHDRDATALEN_LEGACY</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * internal page entry</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">namlen</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTIHDRDATALEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* compare with head/only segment */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">kname</span><span class="o">++</span><span class="p">,</span> <span class="n">name</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* only uppercase if case-insensitive support is on */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">JFS_OS2</span><span class="p">)</span> <span class="o">==</span> <span class="n">JFS_OS2</span><span class="p">)</span>
			<span class="n">x</span> <span class="o">=</span> <span class="n">UniToupper</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">x</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="o">*</span><span class="n">kname</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">klen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">namlen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* compare with additional segment(s) */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">klen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">namlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* compare with next name segment */</span>
		<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTSLOTDATALEN</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">kname</span><span class="o">++</span><span class="p">,</span> <span class="n">name</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* only uppercase if case-insensitive support is on */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">JFS_OS2</span><span class="p">)</span> <span class="o">==</span> <span class="n">JFS_OS2</span><span class="p">)</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">UniToupper</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="o">*</span><span class="n">kname</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">klen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">namlen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">klen</span> <span class="o">-</span> <span class="n">namlen</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	ciGetLeafPrefixKey()</span>
<span class="cm"> *</span>
<span class="cm"> * function: compute prefix of suffix compression</span>
<span class="cm"> *	     from two adjacent leaf entries</span>
<span class="cm"> *	     across page boundary</span>
<span class="cm"> *</span>
<span class="cm"> * return: non-zero on error</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ciGetLeafPrefixKey</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">lp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">li</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">rp</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">ri</span><span class="p">,</span> <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">klen</span><span class="p">,</span> <span class="n">namlen</span><span class="p">;</span>
	<span class="kt">wchar_t</span> <span class="o">*</span><span class="n">pl</span><span class="p">,</span> <span class="o">*</span><span class="n">pr</span><span class="p">,</span> <span class="o">*</span><span class="n">kname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">component_name</span> <span class="n">lkey</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">component_name</span> <span class="n">rkey</span><span class="p">;</span>

	<span class="n">lkey</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="n">JFS_NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">wchar_t</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkey</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">rkey</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">((</span><span class="n">JFS_NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">wchar_t</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rkey</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lkey</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get left and right key */</span>
	<span class="n">dtGetKey</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">li</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lkey</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">lkey</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">lkey</span><span class="p">.</span><span class="n">namlen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">JFS_OS2</span><span class="p">)</span> <span class="o">==</span> <span class="n">JFS_OS2</span><span class="p">)</span>
		<span class="n">ciToUpper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lkey</span><span class="p">);</span>

	<span class="n">dtGetKey</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">ri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rkey</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">rkey</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">rkey</span><span class="p">.</span><span class="n">namlen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">JFS_OS2</span><span class="p">)</span> <span class="o">==</span> <span class="n">JFS_OS2</span><span class="p">)</span>
		<span class="n">ciToUpper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rkey</span><span class="p">);</span>

	<span class="cm">/* compute prefix */</span>
	<span class="n">klen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kname</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">lkey</span><span class="p">.</span><span class="n">namlen</span><span class="p">,</span> <span class="n">rkey</span><span class="p">.</span><span class="n">namlen</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pl</span> <span class="o">=</span> <span class="n">lkey</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">rkey</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	     <span class="n">namlen</span><span class="p">;</span> <span class="n">pl</span><span class="o">++</span><span class="p">,</span> <span class="n">pr</span><span class="o">++</span><span class="p">,</span> <span class="n">namlen</span><span class="o">--</span><span class="p">,</span> <span class="n">klen</span><span class="o">++</span><span class="p">,</span> <span class="n">kname</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">kname</span> <span class="o">=</span> <span class="o">*</span><span class="n">pr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pl</span> <span class="o">!=</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="n">klen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_names</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* l-&gt;namlen &lt;= r-&gt;namlen since l &lt;= r */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lkey</span><span class="p">.</span><span class="n">namlen</span> <span class="o">&lt;</span> <span class="n">rkey</span><span class="p">.</span><span class="n">namlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">kname</span> <span class="o">=</span> <span class="o">*</span><span class="n">pr</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="n">klen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>			<span class="cm">/* l-&gt;namelen == r-&gt;namelen */</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="n">klen</span><span class="p">;</span>

<span class="nl">free_names:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lkey</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rkey</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> *	dtGetKey()</span>
<span class="cm"> *</span>
<span class="cm"> * function: get key of the entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtGetKey</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>	<span class="cm">/* entry index */</span>
		     <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">si</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="n">ih</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namlen</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">wchar_t</span> <span class="o">*</span><span class="n">kname</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* get entry */</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">si</span> <span class="o">=</span> <span class="n">stbl</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">lh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">namlen</span> <span class="o">=</span> <span class="n">lh</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">lh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">JFS_DIR_INDEX</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTLHDRDATALEN</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTLHDRDATALEN_LEGACY</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">namlen</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTIHDRDATALEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">key</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="n">namlen</span><span class="p">;</span>
	<span class="n">kname</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * move head/only segment</span>
<span class="cm">	 */</span>
	<span class="n">UniStrncpy_from_le</span><span class="p">(</span><span class="n">kname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * move additional segment(s)</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">si</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get next segment */</span>
		<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">kname</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">namlen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">namlen</span><span class="p">,</span> <span class="n">DTSLOTDATALEN</span><span class="p">);</span>
		<span class="n">UniStrncpy_from_le</span><span class="p">(</span><span class="n">kname</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">si</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtInsertEntry()</span>
<span class="cm"> *</span>
<span class="cm"> * function: allocate free slot(s) and</span>
<span class="cm"> *	     write a leaf/internal entry</span>
<span class="cm"> *</span>
<span class="cm"> * return: entry slot index</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtInsertEntry</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span>
			  <span class="n">ddata_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">dtlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">lh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="n">ih</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hsi</span><span class="p">,</span> <span class="n">fsi</span><span class="p">,</span> <span class="n">klen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">nextindex</span><span class="p">;</span>
	<span class="kt">wchar_t</span> <span class="o">*</span><span class="n">kname</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="o">*</span><span class="n">xd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span> <span class="o">=</span> <span class="o">*</span><span class="n">dtlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xsi</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">klen</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>
	<span class="n">kname</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* allocate a free slot */</span>
	<span class="n">hsi</span> <span class="o">=</span> <span class="n">fsi</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="o">--</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span><span class="p">;</span>

	<span class="cm">/* open new linelock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>

	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">;</span>

	<span class="cm">/* write head/only segment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">h</span><span class="p">;</span>
		<span class="n">lh</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">lh</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">.</span><span class="n">ino</span><span class="p">);</span>
		<span class="n">lh</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="n">klen</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">lh</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">.</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">DTLHDRDATALEN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_ROOT</span><span class="p">))</span>
				<span class="n">bn</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">self</span><span class="p">);</span>
			<span class="n">lh</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">add_index</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">.</span><span class="n">tid</span><span class="p">,</span>
							  <span class="n">data</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">.</span><span class="n">ip</span><span class="p">,</span>
							  <span class="n">bn</span><span class="p">,</span> <span class="n">index</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">DTLHDRDATALEN_LEGACY</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">h</span><span class="p">;</span>
		<span class="n">ih</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">xd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxd_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ih</span><span class="p">;</span>
		<span class="o">*</span><span class="n">xd</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">xd</span><span class="p">;</span>
		<span class="n">ih</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="n">klen</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">ih</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">DTIHDRDATALEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">UniStrncpy_to_le</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">kname</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">;</span>

	<span class="cm">/* write additional segment(s) */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
	<span class="n">klen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">klen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get free slot */</span>
		<span class="n">fsi</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="o">--</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span><span class="p">;</span>

		<span class="cm">/* is next slot contiguous ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsi</span> <span class="o">!=</span> <span class="n">xsi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* close current linelock */</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* open new linelock */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
				<span class="n">lv</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
				<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kname</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">DTSLOTDATALEN</span><span class="p">);</span>
		<span class="n">UniStrncpy_to_le</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">kname</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xsi</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
		<span class="n">klen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* close current linelock */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dtlock</span> <span class="o">=</span> <span class="n">dtlck</span><span class="p">;</span>

	<span class="cm">/* terminate last/only segment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* single segment entry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span>
			<span class="n">lh</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ih</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* multi-segment entry */</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* if insert into middle, shift right succeeding entries in stbl */</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">nextindex</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">nextindex</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">stbl</span> <span class="o">+</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stbl</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="n">nextindex</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">.</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s64</span> <span class="n">lblock</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Need to update slot number for entries that moved</span>
<span class="cm">			 * in the stbl</span>
<span class="cm">			 */</span>
			<span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">nextindex</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">stbl</span><span class="p">[</span><span class="n">n</span><span class="p">]]);</span>
				<span class="n">modify_index</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">.</span><span class="n">tid</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">.</span><span class="n">ip</span><span class="p">,</span>
					     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lh</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span> <span class="n">bn</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lblock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">;</span>

	<span class="cm">/* advance next available entry index of stbl */</span>
	<span class="o">++</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtMoveEntry()</span>
<span class="cm"> *</span>
<span class="cm"> * function: move entries from split/left page to new/right page</span>
<span class="cm"> *</span>
<span class="cm"> *	nextindex of dst page and freelist/freecnt of both pages</span>
<span class="cm"> *	are updated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtMoveEntry</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">si</span><span class="p">,</span> <span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">dp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">sdtlock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">ddtlock</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">do_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ssi</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>		<span class="cm">/* src slot index */</span>
	<span class="kt">int</span> <span class="n">di</span><span class="p">;</span>			<span class="cm">/* dst entry index */</span>
	<span class="kt">int</span> <span class="n">dsi</span><span class="p">;</span>		<span class="cm">/* dst slot index */</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">sstbl</span><span class="p">,</span> <span class="o">*</span><span class="n">dstbl</span><span class="p">;</span>	<span class="cm">/* sorted entry table */</span>
	<span class="kt">int</span> <span class="n">snamlen</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">slh</span><span class="p">,</span> <span class="o">*</span><span class="n">dlh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="n">sih</span><span class="p">,</span> <span class="o">*</span><span class="n">dih</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">sdtlck</span> <span class="o">=</span> <span class="o">*</span><span class="n">sdtlock</span><span class="p">,</span> <span class="o">*</span><span class="n">ddtlck</span> <span class="o">=</span> <span class="o">*</span><span class="n">ddtlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">slv</span><span class="p">,</span> <span class="o">*</span><span class="n">dlv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xssi</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">nd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sfsi</span><span class="p">;</span>

	<span class="n">sstbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">s8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span><span class="p">];</span>
	<span class="n">dstbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">s8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">stblindex</span><span class="p">];</span>

	<span class="n">dsi</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>	<span class="cm">/* first (whole page) free slot */</span>
	<span class="n">sfsi</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>

	<span class="cm">/* linelock destination entry slot */</span>
	<span class="n">dlv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">ddtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">ddtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="n">dlv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">dsi</span><span class="p">;</span>

	<span class="cm">/* linelock source entry slot */</span>
	<span class="n">slv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="n">slv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sstbl</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
	<span class="n">xssi</span> <span class="o">=</span> <span class="n">slv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * move entries</span>
<span class="cm">	 */</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">nd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">di</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">si</span> <span class="o">&lt;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span> <span class="n">si</span><span class="o">++</span><span class="p">,</span> <span class="n">di</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ssi</span> <span class="o">=</span> <span class="n">sstbl</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">dstbl</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="n">dsi</span><span class="p">;</span>

		<span class="cm">/* is next slot contiguous ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ssi</span> <span class="o">!=</span> <span class="n">xssi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* close current linelock */</span>
			<span class="n">slv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
			<span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* open new linelock */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
				<span class="n">slv</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">sdtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">sdtlck</span><span class="p">);</span>
				<span class="n">slv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="n">slv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ssi</span><span class="p">;</span>
			<span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * move head/only segment of an entry</span>
<span class="cm">		 */</span>
		<span class="cm">/* get dst slot */</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">dsi</span><span class="p">];</span>

		<span class="cm">/* get src slot and move */</span>
		<span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">ssi</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* get source entry */</span>
			<span class="n">slh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">s</span><span class="p">;</span>
			<span class="n">dlh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">h</span><span class="p">;</span>
			<span class="n">snamlen</span> <span class="o">=</span> <span class="n">slh</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">do_index</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">snamlen</span><span class="p">,</span> <span class="n">DTLHDRDATALEN</span><span class="p">);</span>
				<span class="n">dlh</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">slh</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span> <span class="cm">/* little-endian */</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">snamlen</span><span class="p">,</span> <span class="n">DTLHDRDATALEN_LEGACY</span><span class="p">);</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">dlh</span><span class="p">,</span> <span class="n">slh</span><span class="p">,</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

			<span class="n">next</span> <span class="o">=</span> <span class="n">slh</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="cm">/* update dst head/only segment next field */</span>
			<span class="n">dsi</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dlh</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dsi</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">s</span><span class="p">;</span>
			<span class="n">snamlen</span> <span class="o">=</span> <span class="n">sih</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">snamlen</span><span class="p">,</span> <span class="n">DTIHDRDATALEN</span><span class="p">);</span>
			<span class="n">dih</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">h</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dih</span><span class="p">,</span> <span class="n">sih</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">sih</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="n">dsi</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dih</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dsi</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* free src head/only segment */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">sfsi</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sfsi</span> <span class="o">=</span> <span class="n">ssi</span><span class="p">;</span>

		<span class="n">ns</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nd</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xssi</span> <span class="o">=</span> <span class="n">ssi</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * move additional segment(s) of the entry</span>
<span class="cm">		 */</span>
		<span class="n">snamlen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">ssi</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* is next slot contiguous ? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ssi</span> <span class="o">!=</span> <span class="n">xssi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* close current linelock */</span>
				<span class="n">slv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
				<span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/* open new linelock */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
					<span class="n">slv</span><span class="o">++</span><span class="p">;</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">sdtlck</span> <span class="o">=</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span>
					    <span class="n">txLinelock</span><span class="p">(</span><span class="n">sdtlck</span><span class="p">);</span>
					<span class="n">slv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="p">}</span>

				<span class="n">slv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ssi</span><span class="p">;</span>
				<span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* get next source segment */</span>
			<span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">ssi</span><span class="p">];</span>

			<span class="cm">/* get next destination free slot */</span>
			<span class="n">d</span><span class="o">++</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">snamlen</span><span class="p">,</span> <span class="n">DTSLOTDATALEN</span><span class="p">);</span>
			<span class="n">UniStrncpy_le</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">ns</span><span class="o">++</span><span class="p">;</span>
			<span class="n">nd</span><span class="o">++</span><span class="p">;</span>
			<span class="n">xssi</span> <span class="o">=</span> <span class="n">ssi</span><span class="p">;</span>

			<span class="n">dsi</span><span class="o">++</span><span class="p">;</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dsi</span><span class="p">;</span>

			<span class="cm">/* free source segment */</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">sfsi</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sfsi</span> <span class="o">=</span> <span class="n">ssi</span><span class="p">;</span>

			<span class="n">snamlen</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>		<span class="cm">/* end while */</span>

		<span class="cm">/* terminate dst last/only segment */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* single segment entry */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span>
				<span class="n">dlh</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dih</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* multi-segment entry */</span>
			<span class="n">d</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>			<span class="cm">/* end for */</span>

	<span class="cm">/* close current linelock */</span>
	<span class="n">slv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
	<span class="n">sdtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="o">*</span><span class="n">sdtlock</span> <span class="o">=</span> <span class="n">sdtlck</span><span class="p">;</span>

	<span class="n">dlv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">nd</span><span class="p">;</span>
	<span class="n">ddtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ddtlock</span> <span class="o">=</span> <span class="n">ddtlck</span><span class="p">;</span>

	<span class="cm">/* update source header */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">sfsi</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">+=</span> <span class="n">nd</span><span class="p">;</span>

	<span class="cm">/* update destination header */</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span> <span class="o">=</span> <span class="n">di</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">dsi</span><span class="p">;</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">-=</span> <span class="n">nd</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtDeleteEntry()</span>
<span class="cm"> *</span>
<span class="cm"> * function: free a (leaf/internal) entry</span>
<span class="cm"> *</span>
<span class="cm"> * log freelist header, stbl, and each segment slot of entry</span>
<span class="cm"> * (even though last/only segment next field is modified,</span>
<span class="cm"> * physical image logging requires all segment slots of</span>
<span class="cm"> * the entry logged to avoid applying previous updates</span>
<span class="cm"> * to the same slots)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtDeleteEntry</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">dtlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fsi</span><span class="p">;</span>		<span class="cm">/* free entry slot index */</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">si</span><span class="p">,</span> <span class="n">freecnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span> <span class="o">=</span> <span class="o">*</span><span class="n">dtlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xsi</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* get free entry slot index */</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">stbl</span><span class="p">[</span><span class="n">fi</span><span class="p">];</span>

	<span class="cm">/* open new linelock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>

	<span class="cm">/* get the head/only segment */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_LEAF</span><span class="p">)</span>
		<span class="n">si</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">si</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">freecnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xsi</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>

	<span class="cm">/* find the last/only segment */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">si</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* is next slot contiguous ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">si</span> <span class="o">!=</span> <span class="n">xsi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* close current linelock */</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* open new linelock */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
				<span class="n">lv</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
				<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xsi</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
		<span class="n">freecnt</span><span class="o">++</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* close current linelock */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dtlock</span> <span class="o">=</span> <span class="n">dtlck</span><span class="p">;</span>

	<span class="cm">/* update freelist */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">+=</span> <span class="n">freecnt</span><span class="p">;</span>

	<span class="cm">/* if delete from middle,</span>
<span class="cm">	 * shift left the succedding entries in the stbl</span>
<span class="cm">	 */</span>
	<span class="n">si</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fi</span> <span class="o">&lt;</span> <span class="n">si</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stbl</span><span class="p">[</span><span class="n">fi</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">stbl</span><span class="p">[</span><span class="n">fi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">si</span> <span class="o">-</span> <span class="n">fi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtTruncateEntry()</span>
<span class="cm"> *</span>
<span class="cm"> * function: truncate a (leaf/internal) entry</span>
<span class="cm"> *</span>
<span class="cm"> * log freelist header, stbl, and each segment slot of entry</span>
<span class="cm"> * (even though last/only segment next field is modified,</span>
<span class="cm"> * physical image logging requires all segment slots of</span>
<span class="cm"> * the entry logged to avoid applying previous updates</span>
<span class="cm"> * to the same slots)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtTruncateEntry</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ti</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">dtlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tsi</span><span class="p">;</span>		<span class="cm">/* truncate entry slot index */</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">si</span><span class="p">,</span> <span class="n">freecnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span> <span class="o">=</span> <span class="o">*</span><span class="n">dtlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fsi</span><span class="p">,</span> <span class="n">xsi</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* get free entry slot index */</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">tsi</span> <span class="o">=</span> <span class="n">stbl</span><span class="p">[</span><span class="n">ti</span><span class="p">];</span>

	<span class="cm">/* open new linelock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">tsi</span><span class="p">;</span>

	<span class="cm">/* get the head/only segment */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">tsi</span><span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BT_INTERNAL</span><span class="p">);</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">si</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">idtentry</span> <span class="o">*</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">freecnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
	<span class="n">xsi</span> <span class="o">=</span> <span class="n">tsi</span><span class="p">;</span>

	<span class="cm">/* find the last/only segment */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">si</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* is next slot contiguous ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">si</span> <span class="o">!=</span> <span class="n">xsi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* close current linelock */</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* open new linelock */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
				<span class="n">lv</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
				<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xsi</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
		<span class="n">freecnt</span><span class="o">++</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* close current linelock */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dtlock</span> <span class="o">=</span> <span class="n">dtlck</span><span class="p">;</span>

	<span class="cm">/* update freelist */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freecnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freecnt</span> <span class="o">+=</span> <span class="n">freecnt</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	dtLinelockFreelist()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtLinelockFreelist</span><span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span>	<span class="cm">/* directory page */</span>
			       <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>	<span class="cm">/* max slot index */</span>
			       <span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">**</span> <span class="n">dtlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fsi</span><span class="p">;</span>		<span class="cm">/* free entry slot index */</span>
	<span class="k">struct</span> <span class="n">dtslot</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">si</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span> <span class="o">=</span> <span class="o">*</span><span class="n">dtlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xsi</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* get free entry slot index */</span>
	<span class="n">fsi</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>

	<span class="cm">/* open new linelock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
		<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xsi</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">fsi</span><span class="p">];</span>
	<span class="n">si</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* find the last/only segment */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">si</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">si</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* is next slot contiguous ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">si</span> <span class="o">!=</span> <span class="n">xsi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* close current linelock */</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* open new linelock */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">maxcnt</span><span class="p">)</span>
				<span class="n">lv</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="n">txLinelock</span><span class="p">(</span><span class="n">dtlck</span><span class="p">);</span>
				<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xsi</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* close current linelock */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dtlock</span> <span class="o">=</span> <span class="n">dtlck</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME: dtModify</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION: Modify the inode number part of a directory entry</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	tid	- Transaction id</span>
<span class="cm"> *	ip	- Inode of parent directory</span>
<span class="cm"> *	key	- Name of entry to be modified</span>
<span class="cm"> *	orig_ino	- Original inode number expected in entry</span>
<span class="cm"> *	new_ino	- New inode number to put into entry</span>
<span class="cm"> *	flag	- JFS_RENAME</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> *	-ESTALE	- If entry found does not match orig_ino passed in</span>
<span class="cm"> *	-ENOENT	- If no entry can be found to match key</span>
<span class="cm"> *	0	- If successfully modified entry</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dtModify</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	 <span class="k">struct</span> <span class="n">component_name</span> <span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">ino_t</span> <span class="o">*</span> <span class="n">orig_ino</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">new_ino</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btstack</span> <span class="n">btstack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="n">dtlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="n">s8</span> <span class="o">*</span><span class="n">stbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry_si</span><span class="p">;</span>		<span class="cm">/* entry slot index */</span>
	<span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	search for the entry to modify:</span>
<span class="cm">	 *</span>
<span class="cm">	 * dtSearch() returns (leaf page pinned, index at which to modify).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dtSearch</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">orig_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">btstack</span><span class="p">,</span> <span class="n">flag</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* retrieve search result */</span>
	<span class="n">DT_GETSEARCH</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">btstack</span><span class="p">.</span><span class="n">top</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">BT_MARK_DIRTY</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * acquire a transaction lock on the leaf page of named entry</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckDTREE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">);</span>
	<span class="n">dtlck</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dt_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* get slot index of the entry */</span>
	<span class="n">stbl</span> <span class="o">=</span> <span class="n">DT_GETSTBL</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">entry_si</span> <span class="o">=</span> <span class="n">stbl</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="cm">/* linelock entry */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">entry_si</span><span class="p">;</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dtlck</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* get the head/only segment */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ldtentry</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">entry_si</span><span class="p">];</span>

	<span class="cm">/* substitute the inode number of the entry */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_ino</span><span class="p">);</span>

	<span class="cm">/* unpin the leaf page */</span>
	<span class="n">DT_PUTPAGE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
