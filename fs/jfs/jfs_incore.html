<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jfs › jfs_incore.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jfs_incore.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   Copyright (C) International Business Machines Corp., 2000-2004</span>
<span class="cm"> *   Portions Copyright (C) Christoph Hellwig, 2001-2002</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program;  if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _H_JFS_INCORE</span>
<span class="cp">#define _H_JFS_INCORE</span>

<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &quot;jfs_types.h&quot;</span>
<span class="cp">#include &quot;jfs_xtree.h&quot;</span>
<span class="cp">#include &quot;jfs_dtree.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * JFS magic number</span>
<span class="cm"> */</span>
<span class="cp">#define JFS_SUPER_MAGIC 0x3153464a </span><span class="cm">/* &quot;JFS1&quot; */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * JFS-private inode information</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">fileset</span><span class="p">;</span>	<span class="cm">/* fileset number (always 16)*/</span>
	<span class="n">uint</span>	<span class="n">mode2</span><span class="p">;</span>		<span class="cm">/* jfs-specific mode		*/</span>
	<span class="n">uint</span>	<span class="n">saved_uid</span><span class="p">;</span>	<span class="cm">/* saved for uid mount option */</span>
	<span class="n">uint</span>	<span class="n">saved_gid</span><span class="p">;</span>	<span class="cm">/* saved for gid mount option */</span>
	<span class="n">pxd_t</span>	<span class="n">ixpxd</span><span class="p">;</span>		<span class="cm">/* inode extent descriptor	*/</span>
	<span class="n">dxd_t</span>	<span class="n">acl</span><span class="p">;</span>		<span class="cm">/* dxd describing acl	*/</span>
	<span class="n">dxd_t</span>	<span class="n">ea</span><span class="p">;</span>		<span class="cm">/* dxd describing ea	*/</span>
	<span class="kt">time_t</span>	<span class="n">otime</span><span class="p">;</span>		<span class="cm">/* time created	*/</span>
	<span class="n">uint</span>	<span class="n">next_index</span><span class="p">;</span>	<span class="cm">/* next available directory entry index */</span>
	<span class="kt">int</span>	<span class="n">acltype</span><span class="p">;</span>	<span class="cm">/* Type of ACL	*/</span>
	<span class="kt">short</span>	<span class="n">btorder</span><span class="p">;</span>	<span class="cm">/* access order	*/</span>
	<span class="kt">short</span>	<span class="n">btindex</span><span class="p">;</span>	<span class="cm">/* btpage entry index*/</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">;</span>	<span class="cm">/* inode map			*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cflag</span><span class="p">;</span>	<span class="cm">/* commit flags		*/</span>
	<span class="n">u64</span>	<span class="n">agstart</span><span class="p">;</span>	<span class="cm">/* agstart of the containing IAG */</span>
	<span class="n">u16</span>	<span class="n">bxflag</span><span class="p">;</span>		<span class="cm">/* xflag of pseudo buffer?	*/</span>
	<span class="n">unchar</span>	<span class="n">pad</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">char</span> <span class="n">active_ag</span><span class="p">;</span>	<span class="cm">/* ag currently allocating from	*/</span>
	<span class="n">lid_t</span>	<span class="n">blid</span><span class="p">;</span>		<span class="cm">/* lid of pseudo buffer?	*/</span>
	<span class="n">lid_t</span>	<span class="n">atlhead</span><span class="p">;</span>	<span class="cm">/* anonymous tlock list head	*/</span>
	<span class="n">lid_t</span>	<span class="n">atltail</span><span class="p">;</span>	<span class="cm">/* anonymous tlock list tail	*/</span>
	<span class="n">spinlock_t</span> <span class="n">ag_lock</span><span class="p">;</span>	<span class="cm">/* protects active_ag		*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">anon_inode_list</span><span class="p">;</span> <span class="cm">/* inodes having anonymous txns */</span>
	<span class="cm">/*</span>
<span class="cm">	 * rdwrlock serializes xtree between reads &amp; writes and synchronizes</span>
<span class="cm">	 * changes to special inodes.  It&#39;s use would be redundant on</span>
<span class="cm">	 * directories since the i_mutex taken in the VFS is sufficient.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">rdwrlock</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * commit_mutex serializes transaction processing on an inode.</span>
<span class="cm">	 * It must be taken after beginning a transaction (txBegin), since</span>
<span class="cm">	 * dirty inodes may be committed while a new transaction on the</span>
<span class="cm">	 * inode is blocked in txBegin or TxBeginAnon</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">commit_mutex</span><span class="p">;</span>
	<span class="cm">/* xattr_sem allows us to access the xattrs without taking i_mutex */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">xattr_sem</span><span class="p">;</span>
	<span class="n">lid_t</span>	<span class="n">xtlid</span><span class="p">;</span>		<span class="cm">/* lid of xtree lock on directory */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">xtpage_t</span> <span class="n">_xtroot</span><span class="p">;</span>	<span class="cm">/* 288: xtree root */</span>
			<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">_imap</span><span class="p">;</span>	<span class="cm">/* 4: inode map header	*/</span>
		<span class="p">}</span> <span class="n">file</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dir_table_slot</span> <span class="n">_table</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span> <span class="cm">/* 96: dir index */</span>
			<span class="n">dtroot_t</span> <span class="n">_dtroot</span><span class="p">;</span>	<span class="cm">/* 288: dtree root */</span>
		<span class="p">}</span> <span class="n">dir</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">unchar</span> <span class="n">_unused</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* 16: */</span>
			<span class="n">dxd_t</span> <span class="n">_dxd</span><span class="p">;</span>		<span class="cm">/* 16: */</span>
			<span class="n">unchar</span> <span class="kr">_inline</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>	<span class="cm">/* 128: inline symlink */</span>
			<span class="cm">/* _inline_ea may overlay the last part of</span>
<span class="cm">			 * file._xtroot if maxentry = XTROOTINITSLOT</span>
<span class="cm">			 */</span>
			<span class="n">unchar</span> <span class="n">_inline_ea</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>	<span class="cm">/* 128: inline extended attr */</span>
		<span class="p">}</span> <span class="n">link</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dev</span><span class="p">;</span>	<span class="cm">/* will die when we get wide dev_t */</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define i_xtroot u.file._xtroot</span>
<span class="cp">#define i_imap u.file._imap</span>
<span class="cp">#define i_dirtable u.dir._table</span>
<span class="cp">#define i_dtroot u.dir._dtroot</span>
<span class="cp">#define i_inline u.link._inline</span>
<span class="cp">#define i_inline_ea u.link._inline_ea</span>

<span class="cp">#define IREAD_LOCK(ip, subclass) \</span>
<span class="cp">	down_read_nested(&amp;JFS_IP(ip)-&gt;rdwrlock, subclass)</span>
<span class="cp">#define IREAD_UNLOCK(ip)	up_read(&amp;JFS_IP(ip)-&gt;rdwrlock)</span>
<span class="cp">#define IWRITE_LOCK(ip, subclass) \</span>
<span class="cp">	down_write_nested(&amp;JFS_IP(ip)-&gt;rdwrlock, subclass)</span>
<span class="cp">#define IWRITE_UNLOCK(ip)	up_write(&amp;JFS_IP(ip)-&gt;rdwrlock)</span>

<span class="cm">/*</span>
<span class="cm"> * cflag</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">cflags</span> <span class="p">{</span>
	<span class="n">COMMIT_Nolink</span><span class="p">,</span>		<span class="cm">/* inode committed with zero link count */</span>
	<span class="n">COMMIT_Inlineea</span><span class="p">,</span>	<span class="cm">/* commit inode inline EA */</span>
	<span class="n">COMMIT_Freewmap</span><span class="p">,</span>	<span class="cm">/* free WMAP at iClose() */</span>
	<span class="n">COMMIT_Dirty</span><span class="p">,</span>		<span class="cm">/* Inode is really dirty */</span>
	<span class="n">COMMIT_Dirtable</span><span class="p">,</span>	<span class="cm">/* commit changes to di_dirtable */</span>
	<span class="n">COMMIT_Stale</span><span class="p">,</span>		<span class="cm">/* data extent is no longer valid */</span>
	<span class="n">COMMIT_Synclist</span><span class="p">,</span>	<span class="cm">/* metadata pages on group commit synclist */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * commit_mutex nesting subclasses:</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">commit_mutex_class</span>
<span class="p">{</span>
	<span class="n">COMMIT_MUTEX_PARENT</span><span class="p">,</span>
	<span class="n">COMMIT_MUTEX_CHILD</span><span class="p">,</span>
	<span class="n">COMMIT_MUTEX_SECOND_PARENT</span><span class="p">,</span>	<span class="cm">/* Renaming */</span>
	<span class="n">COMMIT_MUTEX_VICTIM</span>		<span class="cm">/* Inode being unlinked due to rename */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * rdwrlock subclasses:</span>
<span class="cm"> * The dmap inode may be locked while a normal inode or the imap inode are</span>
<span class="cm"> * locked.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rdwrlock_class</span>
<span class="p">{</span>
	<span class="n">RDWRLOCK_NORMAL</span><span class="p">,</span>
	<span class="n">RDWRLOCK_IMAP</span><span class="p">,</span>
	<span class="n">RDWRLOCK_DMAP</span>
<span class="p">};</span>

<span class="cp">#define set_cflag(flag, ip)	set_bit(flag, &amp;(JFS_IP(ip)-&gt;cflag))</span>
<span class="cp">#define clear_cflag(flag, ip)	clear_bit(flag, &amp;(JFS_IP(ip)-&gt;cflag))</span>
<span class="cp">#define test_cflag(flag, ip)	test_bit(flag, &amp;(JFS_IP(ip)-&gt;cflag))</span>
<span class="cp">#define test_and_clear_cflag(flag, ip) \</span>
<span class="cp">	test_and_clear_bit(flag, &amp;(JFS_IP(ip)-&gt;cflag))</span>
<span class="cm">/*</span>
<span class="cm"> * JFS-private superblock information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>		<span class="cm">/* Point back to vfs super block */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">mntflag</span><span class="p">;</span>	<span class="cm">/* aggregate attributes	*/</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">ipbmap</span><span class="p">;</span>	<span class="cm">/* block map inode		*/</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">ipaimap</span><span class="p">;</span>	<span class="cm">/* aggregate inode map inode	*/</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">ipaimap2</span><span class="p">;</span>	<span class="cm">/* secondary aimap inode	*/</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">ipimap</span><span class="p">;</span>	<span class="cm">/* aggregate inode map inode	*/</span>
	<span class="k">struct</span> <span class="n">jfs_log</span>	<span class="o">*</span><span class="n">log</span><span class="p">;</span>		<span class="cm">/* log			*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">log_list</span><span class="p">;</span>	<span class="cm">/* volumes associated with a journal */</span>
	<span class="kt">short</span>		<span class="n">bsize</span><span class="p">;</span>		<span class="cm">/* logical block size	*/</span>
	<span class="kt">short</span>		<span class="n">l2bsize</span><span class="p">;</span>	<span class="cm">/* log2 logical block size	*/</span>
	<span class="kt">short</span>		<span class="n">nbperpage</span><span class="p">;</span>	<span class="cm">/* blocks per page		*/</span>
	<span class="kt">short</span>		<span class="n">l2nbperpage</span><span class="p">;</span>	<span class="cm">/* log2 blocks per page	*/</span>
	<span class="kt">short</span>		<span class="n">l2niperblk</span><span class="p">;</span>	<span class="cm">/* log2 inodes per page	*/</span>
	<span class="n">dev_t</span>		<span class="n">logdev</span><span class="p">;</span>		<span class="cm">/* external log device	*/</span>
	<span class="n">uint</span>		<span class="n">aggregate</span><span class="p">;</span>	<span class="cm">/* volume identifier in log record */</span>
	<span class="n">pxd_t</span>		<span class="n">logpxd</span><span class="p">;</span>		<span class="cm">/* pxd describing log	*/</span>
	<span class="n">pxd_t</span>		<span class="n">fsckpxd</span><span class="p">;</span>	<span class="cm">/* pxd describing fsck wkspc */</span>
	<span class="n">pxd_t</span>		<span class="n">ait2</span><span class="p">;</span>		<span class="cm">/* pxd describing AIT copy	*/</span>
	<span class="kt">char</span>		<span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* 128-bit uuid for volume	*/</span>
	<span class="kt">char</span>		<span class="n">loguuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* 128-bit uuid for log	*/</span>
	<span class="cm">/*</span>
<span class="cm">	 * commit_state is used for synchronization of the jfs_commit</span>
<span class="cm">	 * threads.  It is protected by LAZY_LOCK().</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>		<span class="n">commit_state</span><span class="p">;</span>	<span class="cm">/* commit state */</span>
	<span class="cm">/* Formerly in ipimap */</span>
	<span class="n">uint</span>		<span class="n">gengen</span><span class="p">;</span>		<span class="cm">/* inode generation generator*/</span>
	<span class="n">uint</span>		<span class="n">inostamp</span><span class="p">;</span>	<span class="cm">/* shows inode belongs to fileset*/</span>

	<span class="cm">/* Formerly in ipbmap */</span>
	<span class="k">struct</span> <span class="n">bmap</span>	<span class="o">*</span><span class="n">bmap</span><span class="p">;</span>		<span class="cm">/* incore bmap descriptor	*/</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">nls_tab</span><span class="p">;</span>	<span class="cm">/* current codepage		*/</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">direct_inode</span><span class="p">;</span>	<span class="cm">/* metadata inode */</span>
	<span class="n">uint</span>		<span class="n">state</span><span class="p">;</span>		<span class="cm">/* mount/recovery state	*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flag</span><span class="p">;</span>		<span class="cm">/* mount time flags */</span>
	<span class="n">uint</span>		<span class="n">p_state</span><span class="p">;</span>	<span class="cm">/* state prior to going no integrity */</span>
	<span class="n">uint</span>		<span class="n">uid</span><span class="p">;</span>		<span class="cm">/* uid to override on-disk uid */</span>
	<span class="n">uint</span>		<span class="n">gid</span><span class="p">;</span>		<span class="cm">/* gid to override on-disk gid */</span>
	<span class="n">uint</span>		<span class="n">umask</span><span class="p">;</span>		<span class="cm">/* umask to override on-disk umask */</span>
<span class="p">};</span>

<span class="cm">/* jfs_sb_info commit_state */</span>
<span class="cp">#define IN_LAZYCOMMIT 1</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="nf">JFS_IP</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jfs_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">jfs_dirtable_inline</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">MAX_INLINE_DIRTABLE_ENTRY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="nf">JFS_SBI</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">isReadOnly</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">JFS_SBI</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* _H_JFS_INCORE */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
